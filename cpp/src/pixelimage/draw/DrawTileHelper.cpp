// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_justPath_ILinePathContext
#include <justPath/ILinePathContext.h>
#endif
#ifndef INCLUDED_justPath_SvgLinePath
#include <justPath/SvgLinePath.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_draw_DrawTileHelper
#include <pixelimage/draw/DrawTileHelper.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fc768c01f79e9b96_11_new,"pixelimage.draw.DrawTileHelper","new",0x5f773f43,"pixelimage.draw.DrawTileHelper.new","pixelimage/draw/DrawTileHelper.hx",11,0x304a512d)
HX_LOCAL_STACK_FRAME(_hx_pos_fc768c01f79e9b96_41_lineSegmentTo,"pixelimage.draw.DrawTileHelper","lineSegmentTo",0xf799de1d,"pixelimage.draw.DrawTileHelper.lineSegmentTo","pixelimage/draw/DrawTileHelper.hx",41,0x304a512d)
HX_LOCAL_STACK_FRAME(_hx_pos_fc768c01f79e9b96_58_lineTo,"pixelimage.draw.DrawTileHelper","lineTo",0xb0e1078c,"pixelimage.draw.DrawTileHelper.lineTo","pixelimage/draw/DrawTileHelper.hx",58,0x304a512d)
HX_LOCAL_STACK_FRAME(_hx_pos_fc768c01f79e9b96_74_moveTo,"pixelimage.draw.DrawTileHelper","moveTo",0x90ed93e9,"pixelimage.draw.DrawTileHelper.moveTo","pixelimage/draw/DrawTileHelper.hx",74,0x304a512d)
HX_LOCAL_STACK_FRAME(_hx_pos_fc768c01f79e9b96_86_curveTo,"pixelimage.draw.DrawTileHelper","curveTo",0xc2f07c6d,"pixelimage.draw.DrawTileHelper.curveTo","pixelimage/draw/DrawTileHelper.hx",86,0x304a512d)
namespace pixelimage{
namespace draw{

void DrawTileHelper_obj::__construct(::pixelimage::ImageStruct pixelImage,Float strokeWidth,::pixelimage::ImageStruct tileImageStroke,::hx::Null< Float >  __o_translateX,::hx::Null< Float >  __o_translateY,::hx::Null< Float >  __o_scaleX,::hx::Null< Float >  __o_scaleY){
            		Float translateX = __o_translateX.Default(((Float)0.));
            		Float translateY = __o_translateY.Default(((Float)0.));
            		Float scaleX = __o_scaleX.Default(((Float)1.));
            		Float scaleY = __o_scaleY.Default(((Float)1.));
            	HX_GC_STACKFRAME(&_hx_pos_fc768c01f79e9b96_11_new)
HXLINE(  15)		this->toggleDraw = true;
HXLINE(  14)		this->y0 = ((Float)0.);
HXLINE(  13)		this->x0 = ((Float)0.);
HXLINE(  32)		this->pixelImage = pixelImage;
HXLINE(  33)		this->strokeWidth = strokeWidth;
HXLINE(  34)		this->translateX = translateX;
HXLINE(  35)		this->translateY = translateY;
HXLINE(  36)		this->scaleX = scaleX;
HXLINE(  37)		this->scaleY = scaleY;
HXLINE(  38)		this->svgLinePath = ::justPath::SvgLinePath_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this));
            	}

Dynamic DrawTileHelper_obj::__CreateEmpty() { return new DrawTileHelper_obj; }

void *DrawTileHelper_obj::_hx_vtable = 0;

Dynamic DrawTileHelper_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< DrawTileHelper_obj > _hx_result = new DrawTileHelper_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6]);
	return _hx_result;
}

bool DrawTileHelper_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x387fab99;
}

static ::justPath::ILinePathContext_obj _hx_pixelimage_draw_DrawTileHelper__hx_justPath_ILinePathContext= {
	( void (::hx::Object::*)(Float,Float))&::pixelimage::draw::DrawTileHelper_obj::moveTo,
	( void (::hx::Object::*)(Float,Float))&::pixelimage::draw::DrawTileHelper_obj::lineTo,
	( void (::hx::Object::*)(Float,Float))&::pixelimage::draw::DrawTileHelper_obj::lineSegmentTo,
};

void *DrawTileHelper_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x4fa789de: return &_hx_pixelimage_draw_DrawTileHelper__hx_justPath_ILinePathContext;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void DrawTileHelper_obj::lineSegmentTo(Float x2,Float y2){
            	HX_GC_STACKFRAME(&_hx_pos_fc768c01f79e9b96_41_lineSegmentTo)
HXLINE(  42)		if (this->toggleDraw) {
HXLINE(  43)			this->oldInfo = this->info;
HXLINE(  44)			::pixelimage::ImageStruct this1 = this->pixelImage;
HXDLIN(  44)			Float px = ((this->x0 * this->scaleX) + this->translateX);
HXDLIN(  44)			Float py = ((this->y0 * this->scaleY) + this->translateY);
HXDLIN(  44)			::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN(  44)			bool hasHit = false;
HXDLIN(  44)			Float o = (((y2 * this->scaleY) + this->translateY) - py);
HXDLIN(  44)			Float a = (((x2 * this->scaleX) + this->translateX) - px);
HXDLIN(  44)			Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  44)			Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  44)			 ::Dynamic debugCorners = false;
HXDLIN(  44)			if (::hx::IsNull( debugCorners )) {
HXLINE( 893)				debugCorners = false;
            			}
HXLINE(  44)			Float sin = ::Math_obj::sin(theta);
HXDLIN(  44)			Float cos = ::Math_obj::cos(theta);
HXDLIN(  44)			Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  44)			Float dx = ((Float)0.1);
HXDLIN(  44)			Float dy = radius;
HXDLIN(  44)			Float cx = h;
HXDLIN(  44)			Float cy = radius;
HXDLIN(  44)			Float bx = h;
HXDLIN(  44)			Float by = -(radius);
HXDLIN(  44)			Float ax = ((Float)0.1);
HXDLIN(  44)			Float ay = -(radius);
HXDLIN(  44)			Float temp = ((Float)0.);
HXLINE( 380)			temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 381)			ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 382)			ax = temp;
HXLINE( 384)			temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 385)			by = (py + ((by * cos) + (bx * sin)));
HXLINE( 386)			bx = temp;
HXLINE( 388)			temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 389)			cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 390)			cx = temp;
HXLINE( 392)			temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 393)			dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 394)			dx = temp;
HXLINE(  44)			if (( (bool)(debugCorners) )) {
HXLINE(  44)				{
HXLINE(  44)					Float x = (ax - ((Float)6.));
HXDLIN(  44)					Float y = (ay - ((Float)6.));
HXDLIN(  44)					int p = ::Std_obj::_hx_int(x);
HXDLIN(  44)					int xx = p;
HXDLIN(  44)					int q = ::Std_obj::_hx_int(y);
HXDLIN(  44)					int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  44)					int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  44)					while(true){
HXLINE(  44)						{
HXLINE(  44)							p = (p + 1);
HXDLIN(  44)							int x = (p - 1);
HXDLIN(  44)							int this2 = -65536;
HXDLIN(  44)							int c = this2;
HXDLIN(  44)							bool _hx_tmp;
HXDLIN(  44)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  44)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  44)								_hx_tmp = false;
            							}
HXDLIN(  44)							if (_hx_tmp) {
HXLINE(  44)								int location;
HXDLIN(  44)								if (this1->useVirtualPos) {
HXLINE(  44)									location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  44)									location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            								}
HXDLIN(  44)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  44)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)								int this4 = this3;
HXDLIN(  44)								int this5;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  44)									this5 = this4;
            								}
HXDLIN(  44)								Float a1;
HXDLIN(  44)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  44)								if ((this6 == 0)) {
HXLINE(  44)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r1;
HXDLIN(  44)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  44)								if ((this7 == 0)) {
HXLINE(  44)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g1;
HXDLIN(  44)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  44)								if ((this8 == 0)) {
HXLINE(  44)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b1;
HXDLIN(  44)								int this9 = (this5 & 255);
HXDLIN(  44)								if ((this9 == 0)) {
HXLINE(  44)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a2;
HXDLIN(  44)								int this10 = ((-65536 >> 24) & 255);
HXDLIN(  44)								if ((this10 == 0)) {
HXLINE(  44)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r2;
HXDLIN(  44)								int this11 = ((-65536 >> 16) & 255);
HXDLIN(  44)								if ((this11 == 0)) {
HXLINE(  44)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g2;
HXDLIN(  44)								int this12 = ((-65536 >> 8) & 255);
HXDLIN(  44)								if ((this12 == 0)) {
HXLINE(  44)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b2;
HXDLIN(  44)								int this13 = (-65536 & 255);
HXDLIN(  44)								if ((this13 == 0)) {
HXLINE(  44)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  44)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  44)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  44)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  44)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  44)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  44)								{
HXLINE(  44)									::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  44)									int value;
HXDLIN(  44)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  44)										value = blended;
            									}
HXDLIN(  44)									bool _hx_tmp;
HXDLIN(  44)									if ((location >= 0)) {
HXLINE(  44)										_hx_tmp = (location < (this14->byteLength >> 2));
            									}
            									else {
HXLINE(  44)										_hx_tmp = false;
            									}
HXDLIN(  44)									if (_hx_tmp) {
HXLINE(  44)										::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  44)										int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  44)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  44)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)								int index;
HXDLIN(  44)								if (this1->useVirtualPos) {
HXLINE(  44)									index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  44)									index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            								}
HXDLIN(  44)								int value;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  44)									value = c;
            								}
HXDLIN(  44)								bool _hx_tmp;
HXDLIN(  44)								if ((index >= 0)) {
HXLINE(  44)									_hx_tmp = (index < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  44)									_hx_tmp = false;
            								}
HXDLIN(  44)								if (_hx_tmp) {
HXLINE(  44)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  44)						if ((p > maxX)) {
HXLINE( 247)							p = xx;
HXLINE(  44)							q = (q + 1);
            						}
HXDLIN(  44)						if ((q > maxY)) {
HXLINE(  44)							goto _hx_goto_1;
            						}
            					}
            					_hx_goto_1:;
            				}
HXDLIN(  44)				{
HXLINE(  44)					Float x1 = (bx - ((Float)6.));
HXDLIN(  44)					Float y1 = (by - ((Float)6.));
HXDLIN(  44)					int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  44)					int xx1 = p1;
HXDLIN(  44)					int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  44)					int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  44)					int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  44)					while(true){
HXLINE(  44)						{
HXLINE(  44)							p1 = (p1 + 1);
HXDLIN(  44)							int x = (p1 - 1);
HXDLIN(  44)							int this2 = -16711936;
HXDLIN(  44)							int c = this2;
HXDLIN(  44)							bool _hx_tmp;
HXDLIN(  44)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  44)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  44)								_hx_tmp = false;
            							}
HXDLIN(  44)							if (_hx_tmp) {
HXLINE(  44)								int location;
HXDLIN(  44)								if (this1->useVirtualPos) {
HXLINE(  44)									location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  44)									location = ::Std_obj::_hx_int(( (Float)(((q1 * this1->width) + x)) ));
            								}
HXDLIN(  44)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  44)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)								int this4 = this3;
HXDLIN(  44)								int this5;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  44)									this5 = this4;
            								}
HXDLIN(  44)								Float a1;
HXDLIN(  44)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  44)								if ((this6 == 0)) {
HXLINE(  44)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r1;
HXDLIN(  44)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  44)								if ((this7 == 0)) {
HXLINE(  44)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g1;
HXDLIN(  44)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  44)								if ((this8 == 0)) {
HXLINE(  44)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b1;
HXDLIN(  44)								int this9 = (this5 & 255);
HXDLIN(  44)								if ((this9 == 0)) {
HXLINE(  44)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a2;
HXDLIN(  44)								int this10 = ((-16711936 >> 24) & 255);
HXDLIN(  44)								if ((this10 == 0)) {
HXLINE(  44)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r2;
HXDLIN(  44)								int this11 = ((-16711936 >> 16) & 255);
HXDLIN(  44)								if ((this11 == 0)) {
HXLINE(  44)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g2;
HXDLIN(  44)								int this12 = ((-16711936 >> 8) & 255);
HXDLIN(  44)								if ((this12 == 0)) {
HXLINE(  44)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b2;
HXDLIN(  44)								int this13 = (-16711936 & 255);
HXDLIN(  44)								if ((this13 == 0)) {
HXLINE(  44)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  44)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  44)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  44)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  44)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  44)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  44)								{
HXLINE(  44)									::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  44)									int value;
HXDLIN(  44)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  44)										value = blended;
            									}
HXDLIN(  44)									bool _hx_tmp;
HXDLIN(  44)									if ((location >= 0)) {
HXLINE(  44)										_hx_tmp = (location < (this14->byteLength >> 2));
            									}
            									else {
HXLINE(  44)										_hx_tmp = false;
            									}
HXDLIN(  44)									if (_hx_tmp) {
HXLINE(  44)										::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  44)										int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  44)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  44)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)								int index;
HXDLIN(  44)								if (this1->useVirtualPos) {
HXLINE(  44)									index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  44)									index = ::Std_obj::_hx_int(( (Float)(((q1 * this1->width) + x)) ));
            								}
HXDLIN(  44)								int value;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  44)									value = c;
            								}
HXDLIN(  44)								bool _hx_tmp;
HXDLIN(  44)								if ((index >= 0)) {
HXLINE(  44)									_hx_tmp = (index < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  44)									_hx_tmp = false;
            								}
HXDLIN(  44)								if (_hx_tmp) {
HXLINE(  44)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  44)						if ((p1 > maxX1)) {
HXLINE( 247)							p1 = xx1;
HXLINE(  44)							q1 = (q1 + 1);
            						}
HXDLIN(  44)						if ((q1 > maxY1)) {
HXLINE(  44)							goto _hx_goto_2;
            						}
            					}
            					_hx_goto_2:;
            				}
HXDLIN(  44)				{
HXLINE(  44)					Float x2 = (cx - ((Float)6.));
HXDLIN(  44)					Float y2 = (cy - ((Float)6.));
HXDLIN(  44)					int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  44)					int xx2 = p2;
HXDLIN(  44)					int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  44)					int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  44)					int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  44)					while(true){
HXLINE(  44)						{
HXLINE(  44)							p2 = (p2 + 1);
HXDLIN(  44)							int x = (p2 - 1);
HXDLIN(  44)							int this2 = -16776961;
HXDLIN(  44)							int c = this2;
HXDLIN(  44)							bool _hx_tmp;
HXDLIN(  44)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  44)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  44)								_hx_tmp = false;
            							}
HXDLIN(  44)							if (_hx_tmp) {
HXLINE(  44)								int location;
HXDLIN(  44)								if (this1->useVirtualPos) {
HXLINE(  44)									location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  44)									location = ::Std_obj::_hx_int(( (Float)(((q2 * this1->width) + x)) ));
            								}
HXDLIN(  44)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  44)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)								int this4 = this3;
HXDLIN(  44)								int this5;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  44)									this5 = this4;
            								}
HXDLIN(  44)								Float a1;
HXDLIN(  44)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  44)								if ((this6 == 0)) {
HXLINE(  44)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r1;
HXDLIN(  44)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  44)								if ((this7 == 0)) {
HXLINE(  44)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g1;
HXDLIN(  44)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  44)								if ((this8 == 0)) {
HXLINE(  44)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b1;
HXDLIN(  44)								int this9 = (this5 & 255);
HXDLIN(  44)								if ((this9 == 0)) {
HXLINE(  44)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a2;
HXDLIN(  44)								int this10 = ((-16776961 >> 24) & 255);
HXDLIN(  44)								if ((this10 == 0)) {
HXLINE(  44)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r2;
HXDLIN(  44)								int this11 = ((-16776961 >> 16) & 255);
HXDLIN(  44)								if ((this11 == 0)) {
HXLINE(  44)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g2;
HXDLIN(  44)								int this12 = ((-16776961 >> 8) & 255);
HXDLIN(  44)								if ((this12 == 0)) {
HXLINE(  44)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b2;
HXDLIN(  44)								int this13 = (-16776961 & 255);
HXDLIN(  44)								if ((this13 == 0)) {
HXLINE(  44)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  44)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  44)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  44)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  44)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  44)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  44)								{
HXLINE(  44)									::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  44)									int value;
HXDLIN(  44)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  44)										value = blended;
            									}
HXDLIN(  44)									bool _hx_tmp;
HXDLIN(  44)									if ((location >= 0)) {
HXLINE(  44)										_hx_tmp = (location < (this14->byteLength >> 2));
            									}
            									else {
HXLINE(  44)										_hx_tmp = false;
            									}
HXDLIN(  44)									if (_hx_tmp) {
HXLINE(  44)										::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  44)										int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  44)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  44)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)								int index;
HXDLIN(  44)								if (this1->useVirtualPos) {
HXLINE(  44)									index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  44)									index = ::Std_obj::_hx_int(( (Float)(((q2 * this1->width) + x)) ));
            								}
HXDLIN(  44)								int value;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  44)									value = c;
            								}
HXDLIN(  44)								bool _hx_tmp;
HXDLIN(  44)								if ((index >= 0)) {
HXLINE(  44)									_hx_tmp = (index < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  44)									_hx_tmp = false;
            								}
HXDLIN(  44)								if (_hx_tmp) {
HXLINE(  44)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  44)						if ((p2 > maxX2)) {
HXLINE( 247)							p2 = xx2;
HXLINE(  44)							q2 = (q2 + 1);
            						}
HXDLIN(  44)						if ((q2 > maxY2)) {
HXLINE(  44)							goto _hx_goto_3;
            						}
            					}
            					_hx_goto_3:;
            				}
HXDLIN(  44)				{
HXLINE(  44)					Float x3 = (dx - ((Float)6.));
HXDLIN(  44)					Float y3 = (dy - ((Float)6.));
HXDLIN(  44)					int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  44)					int xx3 = p3;
HXDLIN(  44)					int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  44)					int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  44)					int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  44)					while(true){
HXLINE(  44)						{
HXLINE(  44)							p3 = (p3 + 1);
HXDLIN(  44)							int x = (p3 - 1);
HXDLIN(  44)							int this2 = -1048336;
HXDLIN(  44)							int c = this2;
HXDLIN(  44)							bool _hx_tmp;
HXDLIN(  44)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  44)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  44)								_hx_tmp = false;
            							}
HXDLIN(  44)							if (_hx_tmp) {
HXLINE(  44)								int location;
HXDLIN(  44)								if (this1->useVirtualPos) {
HXLINE(  44)									location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  44)									location = ::Std_obj::_hx_int(( (Float)(((q3 * this1->width) + x)) ));
            								}
HXDLIN(  44)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  44)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)								int this4 = this3;
HXDLIN(  44)								int this5;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  44)									this5 = this4;
            								}
HXDLIN(  44)								Float a1;
HXDLIN(  44)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  44)								if ((this6 == 0)) {
HXLINE(  44)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r1;
HXDLIN(  44)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  44)								if ((this7 == 0)) {
HXLINE(  44)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g1;
HXDLIN(  44)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  44)								if ((this8 == 0)) {
HXLINE(  44)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b1;
HXDLIN(  44)								int this9 = (this5 & 255);
HXDLIN(  44)								if ((this9 == 0)) {
HXLINE(  44)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a2;
HXDLIN(  44)								int this10 = ((-1048336 >> 24) & 255);
HXDLIN(  44)								if ((this10 == 0)) {
HXLINE(  44)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r2;
HXDLIN(  44)								int this11 = ((-1048336 >> 16) & 255);
HXDLIN(  44)								if ((this11 == 0)) {
HXLINE(  44)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g2;
HXDLIN(  44)								int this12 = ((-1048336 >> 8) & 255);
HXDLIN(  44)								if ((this12 == 0)) {
HXLINE(  44)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b2;
HXDLIN(  44)								int this13 = (-1048336 & 255);
HXDLIN(  44)								if ((this13 == 0)) {
HXLINE(  44)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  44)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  44)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  44)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  44)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  44)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  44)								{
HXLINE(  44)									::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  44)									int value;
HXDLIN(  44)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  44)										value = blended;
            									}
HXDLIN(  44)									bool _hx_tmp;
HXDLIN(  44)									if ((location >= 0)) {
HXLINE(  44)										_hx_tmp = (location < (this14->byteLength >> 2));
            									}
            									else {
HXLINE(  44)										_hx_tmp = false;
            									}
HXDLIN(  44)									if (_hx_tmp) {
HXLINE(  44)										::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  44)										int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  44)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  44)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)								int index;
HXDLIN(  44)								if (this1->useVirtualPos) {
HXLINE(  44)									index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  44)									index = ::Std_obj::_hx_int(( (Float)(((q3 * this1->width) + x)) ));
            								}
HXDLIN(  44)								int value;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  44)									value = c;
            								}
HXDLIN(  44)								bool _hx_tmp;
HXDLIN(  44)								if ((index >= 0)) {
HXLINE(  44)									_hx_tmp = (index < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  44)									_hx_tmp = false;
            								}
HXDLIN(  44)								if (_hx_tmp) {
HXLINE(  44)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  44)						if ((p3 > maxX3)) {
HXLINE( 247)							p3 = xx3;
HXLINE(  44)							q3 = (q3 + 1);
            						}
HXDLIN(  44)						if ((q3 > maxY3)) {
HXLINE(  44)							goto _hx_goto_4;
            						}
            					}
            					_hx_goto_4:;
            				}
            			}
HXDLIN(  44)			Float bx1 = bx;
HXDLIN(  44)			Float by1 = by;
HXDLIN(  44)			Float cx1 = dx;
HXDLIN(  44)			Float cy1 = dy;
HXDLIN(  44)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  44)			if (!(adjustWinding)) {
HXLINE(  44)				Float bx_ = bx1;
HXDLIN(  44)				Float by_ = by1;
HXLINE( 188)				bx1 = cx1;
HXLINE( 189)				by1 = cy1;
HXLINE( 190)				cx1 = bx_;
HXLINE( 191)				cy1 = by_;
            			}
HXLINE(  44)			bool hasUndo = false;
HXDLIN(  44)			Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  44)			Float sx = (cy1 - ay);
HXDLIN(  44)			Float sy = (ax - cx1);
HXDLIN(  44)			Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  44)			Float tx = (ay - by1);
HXDLIN(  44)			Float ty = (bx1 - ax);
HXDLIN(  44)			Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  44)			::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  44)			if ((ax > bx1)) {
HXLINE(  44)				if ((ax > cx1)) {
HXLINE(  44)					int min;
HXDLIN(  44)					if ((bx1 > cx1)) {
HXLINE(  44)						min = ::Math_obj::floor(cx1);
            					}
            					else {
HXLINE(  44)						min = ::Math_obj::floor(bx1);
            					}
HXDLIN(  44)					int ii_min = min;
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					xIter3 = this1;
            				}
            				else {
HXLINE(  44)					int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					xIter3 = this1;
            				}
            			}
            			else {
HXLINE(  44)				if ((bx1 > cx1)) {
HXLINE(  44)					int min;
HXDLIN(  44)					if ((ax > cx1)) {
HXLINE(  44)						min = ::Math_obj::floor(cx1);
            					}
            					else {
HXLINE(  44)						min = ::Math_obj::ceil(ax);
            					}
HXDLIN(  44)					int ii_min = min;
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					xIter3 = this1;
            				}
            				else {
HXLINE(  44)					int ii_min = ::Math_obj::floor(ax);
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					xIter3 = this1;
            				}
            			}
HXDLIN(  44)			::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  44)			if ((ay > by1)) {
HXLINE(  44)				if ((ay > cy1)) {
HXLINE(  44)					int min;
HXDLIN(  44)					if ((by1 > cy1)) {
HXLINE(  44)						min = ::Math_obj::floor(cy1);
            					}
            					else {
HXLINE(  44)						min = ::Math_obj::floor(by1);
            					}
HXDLIN(  44)					int ii_min = min;
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					yIter3 = this1;
            				}
            				else {
HXLINE(  44)					int ii_min = ::Math_obj::floor(by1);
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					yIter3 = this1;
            				}
            			}
            			else {
HXLINE(  44)				if ((by1 > cy1)) {
HXLINE(  44)					int min;
HXDLIN(  44)					if ((ay > cy1)) {
HXLINE(  44)						min = ::Math_obj::floor(cy1);
            					}
            					else {
HXLINE(  44)						min = ::Math_obj::ceil(ay);
            					}
HXDLIN(  44)					int ii_min = min;
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					yIter3 = this1;
            				}
            				else {
HXLINE(  44)					int ii_min = ::Math_obj::floor(ay);
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					yIter3 = this1;
            				}
            			}
HXDLIN(  44)			::pixelimage::ImageStruct undoImage = null();
HXDLIN(  44)			if (hasUndo) {
HXLINE(  44)				int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  44)				int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  44)				int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  44)				::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  44)				::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  44)				::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  44)				undoImage = this4;
HXDLIN(  44)				{
HXLINE(  44)					int rectLeft = xIter3->start;
HXDLIN(  44)					int rectTop = yIter3->start;
HXDLIN(  44)					int rectRight = xIter3->max;
HXDLIN(  44)					bool forceClear = false;
HXDLIN(  44)					{
HXLINE(  44)						int _g = rectTop;
HXDLIN(  44)						int _g1 = yIter3->max;
HXDLIN(  44)						while((_g < _g1)){
HXLINE(  44)							_g = (_g + 1);
HXDLIN(  44)							int dy = (_g - 1);
HXDLIN(  44)							{
HXLINE(  44)								int _g1 = rectLeft;
HXDLIN(  44)								int _g2 = rectRight;
HXDLIN(  44)								while((_g1 < _g2)){
HXLINE(  44)									_g1 = (_g1 + 1);
HXDLIN(  44)									int dx = (_g1 - 1);
HXDLIN(  44)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)									int index;
HXDLIN(  44)									if (this1->useVirtualPos) {
HXLINE(  44)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            									}
            									else {
HXLINE(  44)										index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            									}
HXDLIN(  44)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)									int col;
HXDLIN(  44)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  44)										col = c;
            									}
HXDLIN(  44)									bool _hx_tmp;
HXDLIN(  44)									if (this1->useMask) {
HXLINE(  44)										_hx_tmp = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  44)										_hx_tmp = false;
            									}
HXDLIN(  44)									if (_hx_tmp) {
HXLINE(  44)										::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  44)										::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  44)										int index;
HXDLIN(  44)										if (this2->useVirtualPos) {
HXLINE(  44)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            										}
            										else {
HXLINE(  44)											index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            										}
HXDLIN(  44)										::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  44)										int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  44)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)										int v;
HXDLIN(  44)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)											v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  44)											v = c;
            										}
HXDLIN(  44)										int this4 = v;
HXDLIN(  44)										int maskPixel = this4;
HXDLIN(  44)										int this5 = col;
HXDLIN(  44)										int this6 = this5;
HXDLIN(  44)										if ((maskPixel == 0)) {
HXLINE(  44)											int this1 = this6;
HXDLIN(  44)											col = this1;
            										}
            										else {
HXLINE(  44)											Float m0;
HXDLIN(  44)											int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  44)											if ((this1 == 0)) {
HXLINE(  44)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float m1;
HXDLIN(  44)											int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  44)											if ((this2 == 0)) {
HXLINE(  44)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float m2;
HXDLIN(  44)											int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  44)											if ((this3 == 0)) {
HXLINE(  44)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float m3;
HXDLIN(  44)											int this4 = (maskPixel & 255);
HXDLIN(  44)											if ((this4 == 0)) {
HXLINE(  44)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  44)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  44)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  44)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  44)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  44)									if ((col != 0)) {
HXLINE(  44)										int x = (dx - rectLeft);
HXDLIN(  44)										int y = (dy - rectTop);
HXDLIN(  44)										int this1 = col;
HXDLIN(  44)										int c = this1;
HXDLIN(  44)										bool _hx_tmp;
HXDLIN(  44)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  44)											_hx_tmp = undoImage->transparent;
            										}
            										else {
HXLINE(  44)											_hx_tmp = false;
            										}
HXDLIN(  44)										if (_hx_tmp) {
HXLINE(  44)											int location;
HXDLIN(  44)											if (undoImage->useVirtualPos) {
HXLINE(  44)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  44)												location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  44)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  44)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  44)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  44)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)											int this3 = this2;
HXDLIN(  44)											int this4;
HXDLIN(  44)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  44)												this4 = this3;
            											}
HXDLIN(  44)											Float a1;
HXDLIN(  44)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  44)											if ((this5 == 0)) {
HXLINE(  44)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float r1;
HXDLIN(  44)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  44)											if ((this6 == 0)) {
HXLINE(  44)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float g1;
HXDLIN(  44)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  44)											if ((this7 == 0)) {
HXLINE(  44)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float b1;
HXDLIN(  44)											int this8 = (this4 & 255);
HXDLIN(  44)											if ((this8 == 0)) {
HXLINE(  44)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float a2;
HXDLIN(  44)											int this9 = ((col >> 24) & 255);
HXDLIN(  44)											if ((this9 == 0)) {
HXLINE(  44)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float r2;
HXDLIN(  44)											int this10 = ((col >> 16) & 255);
HXDLIN(  44)											if ((this10 == 0)) {
HXLINE(  44)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float g2;
HXDLIN(  44)											int this11 = ((col >> 8) & 255);
HXDLIN(  44)											if ((this11 == 0)) {
HXLINE(  44)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float b2;
HXDLIN(  44)											int this12 = (col & 255);
HXDLIN(  44)											if ((this12 == 0)) {
HXLINE(  44)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  44)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  44)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  44)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  44)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  44)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  44)											{
HXLINE(  44)												::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  44)												int value;
HXDLIN(  44)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  44)													value = blended;
            												}
HXDLIN(  44)												bool _hx_tmp;
HXDLIN(  44)												if ((location >= 0)) {
HXLINE(  44)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  44)													_hx_tmp = false;
            												}
HXDLIN(  44)												if (_hx_tmp) {
HXLINE(  44)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  44)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  44)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  44)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  44)											int index;
HXDLIN(  44)											if (undoImage->useVirtualPos) {
HXLINE(  44)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  44)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  44)											int value;
HXDLIN(  44)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  44)												value = c;
            											}
HXDLIN(  44)											bool _hx_tmp;
HXDLIN(  44)											if ((index >= 0)) {
HXLINE(  44)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  44)												_hx_tmp = false;
            											}
HXDLIN(  44)											if (_hx_tmp) {
HXLINE(  44)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  44)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  44)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  44)										if (forceClear) {
HXLINE(  44)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  44)											int x = (dx - rectLeft);
HXDLIN(  44)											int y = (dy - rectTop);
HXDLIN(  44)											int index;
HXDLIN(  44)											if (undoImage->useVirtualPos) {
HXLINE(  44)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  44)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  44)											bool _hx_tmp;
HXDLIN(  44)											if ((index >= 0)) {
HXLINE(  44)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  44)												_hx_tmp = false;
            											}
HXDLIN(  44)											if (_hx_tmp) {
HXLINE(  44)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  44)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  44)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  44)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  44)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  44)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  44)			bool foundY = false;
HXDLIN(  44)			Float s = ((Float)0.);
HXDLIN(  44)			Float t = ((Float)0.);
HXDLIN(  44)			Float sxx = ((Float)0.);
HXDLIN(  44)			Float txx = ((Float)0.);
HXDLIN(  44)			int _g_min = xIter3->start;
HXDLIN(  44)			int _g_max = xIter3->max;
HXDLIN(  44)			while((_g_min < _g_max)){
HXLINE(  44)				_g_min = (_g_min + 1);
HXDLIN(  44)				int x = (_g_min - 1);
HXLINE( 223)				sxx = (sx * ( (Float)(x) ));
HXLINE( 224)				txx = (tx * ( (Float)(x) ));
HXLINE( 225)				foundY = false;
HXLINE(  44)				{
HXLINE(  44)					int _g_min1 = yIter3->start;
HXDLIN(  44)					int _g_max = yIter3->max;
HXDLIN(  44)					while((_g_min1 < _g_max)){
HXLINE(  44)						_g_min1 = (_g_min1 + 1);
HXDLIN(  44)						int y = (_g_min1 - 1);
HXLINE( 227)						s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)						t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  44)						bool _hx_tmp;
HXDLIN(  44)						if (!((s <= 0))) {
HXLINE(  44)							_hx_tmp = (t <= 0);
            						}
            						else {
HXLINE(  44)							_hx_tmp = true;
            						}
HXDLIN(  44)						if (_hx_tmp) {
HXLINE(  44)							if (foundY) {
HXLINE(  44)								goto _hx_goto_8;
            							}
            						}
            						else {
HXLINE(  44)							if (((s + t) < A)) {
HXLINE(  44)								int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  44)								int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  44)								::haxe::io::ArrayBufferViewImpl this2 = tileImage->image;
HXDLIN(  44)								int index;
HXDLIN(  44)								if (tileImage->useVirtualPos) {
HXLINE(  44)									index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            								}
            								else {
HXLINE(  44)									index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            								}
HXDLIN(  44)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)								int color;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  44)									color = c;
            								}
HXDLIN(  44)								{
HXLINE(  44)									int this3 = color;
HXDLIN(  44)									int c1 = this3;
HXDLIN(  44)									bool _hx_tmp;
HXDLIN(  44)									if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  44)										_hx_tmp = this1->transparent;
            									}
            									else {
HXLINE(  44)										_hx_tmp = false;
            									}
HXDLIN(  44)									if (_hx_tmp) {
HXLINE(  44)										int location;
HXDLIN(  44)										if (this1->useVirtualPos) {
HXLINE(  44)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            										}
            										else {
HXLINE(  44)											location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            										}
HXDLIN(  44)										::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)										int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  44)										int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)										int this4 = this3;
HXDLIN(  44)										int this5;
HXDLIN(  44)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)											this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            										}
            										else {
HXLINE(  44)											this5 = this4;
            										}
HXDLIN(  44)										Float a1;
HXDLIN(  44)										int this6 = ((this5 >> 24) & 255);
HXDLIN(  44)										if ((this6 == 0)) {
HXLINE(  44)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float r1;
HXDLIN(  44)										int this7 = ((this5 >> 16) & 255);
HXDLIN(  44)										if ((this7 == 0)) {
HXLINE(  44)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float g1;
HXDLIN(  44)										int this8 = ((this5 >> 8) & 255);
HXDLIN(  44)										if ((this8 == 0)) {
HXLINE(  44)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float b1;
HXDLIN(  44)										int this9 = (this5 & 255);
HXDLIN(  44)										if ((this9 == 0)) {
HXLINE(  44)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float a2;
HXDLIN(  44)										int this10 = ((color >> 24) & 255);
HXDLIN(  44)										if ((this10 == 0)) {
HXLINE(  44)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float r2;
HXDLIN(  44)										int this11 = ((color >> 16) & 255);
HXDLIN(  44)										if ((this11 == 0)) {
HXLINE(  44)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float g2;
HXDLIN(  44)										int this12 = ((color >> 8) & 255);
HXDLIN(  44)										if ((this12 == 0)) {
HXLINE(  44)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float b2;
HXDLIN(  44)										int this13 = (color & 255);
HXDLIN(  44)										if ((this13 == 0)) {
HXLINE(  44)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  44)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  44)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  44)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  44)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  44)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  44)										{
HXLINE(  44)											::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  44)											int value;
HXDLIN(  44)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  44)												value = blended;
            											}
HXDLIN(  44)											bool _hx_tmp;
HXDLIN(  44)											if ((location >= 0)) {
HXLINE(  44)												_hx_tmp = (location < (this14->byteLength >> 2));
            											}
            											else {
HXLINE(  44)												_hx_tmp = false;
            											}
HXDLIN(  44)											if (_hx_tmp) {
HXLINE(  44)												::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  44)												int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  44)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  44)										::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)										int index;
HXDLIN(  44)										if (this1->useVirtualPos) {
HXLINE(  44)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            										}
            										else {
HXLINE(  44)											index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            										}
HXDLIN(  44)										int value;
HXDLIN(  44)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)											value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE(  44)											value = c1;
            										}
HXDLIN(  44)										bool _hx_tmp;
HXDLIN(  44)										if ((index >= 0)) {
HXLINE(  44)											_hx_tmp = (index < (this2->byteLength >> 2));
            										}
            										else {
HXLINE(  44)											_hx_tmp = false;
            										}
HXDLIN(  44)										if (_hx_tmp) {
HXLINE(  44)											::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)											int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXLINE( 237)								foundY = true;
            							}
            							else {
HXLINE(  44)								if (foundY) {
HXLINE(  44)									goto _hx_goto_8;
            								}
            							}
            						}
            					}
            					_hx_goto_8:;
            				}
            			}
HXDLIN(  44)			if ((hasHit == false)) {
HXLINE(  44)				::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  44)				if (hasUndo) {
HXLINE(  44)					v->undoImage = undoImage;
HXDLIN(  44)					v->undoX = xIter3->start;
HXDLIN(  44)					v->undoY = yIter3->start;
            				}
            			}
HXDLIN(  44)			Float bx2 = cx;
HXDLIN(  44)			Float by2 = cy;
HXDLIN(  44)			Float cx2 = dx;
HXDLIN(  44)			Float cy2 = dy;
HXDLIN(  44)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  44)			if (!(adjustWinding1)) {
HXLINE(  44)				Float bx_ = bx2;
HXDLIN(  44)				Float by_ = by2;
HXLINE( 188)				bx2 = cx2;
HXLINE( 189)				by2 = cy2;
HXLINE( 190)				cx2 = bx_;
HXLINE( 191)				cy2 = by_;
            			}
HXLINE(  44)			bool hasUndo1 = false;
HXDLIN(  44)			Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  44)			Float sx1 = (cy2 - by);
HXDLIN(  44)			Float sy1 = (bx - cx2);
HXDLIN(  44)			Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  44)			Float tx1 = (by - by2);
HXDLIN(  44)			Float ty1 = (bx2 - bx);
HXDLIN(  44)			Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  44)			::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  44)			if ((bx > bx2)) {
HXLINE(  44)				if ((bx > cx2)) {
HXLINE(  44)					int min;
HXDLIN(  44)					if ((bx2 > cx2)) {
HXLINE(  44)						min = ::Math_obj::floor(cx2);
            					}
            					else {
HXLINE(  44)						min = ::Math_obj::floor(bx2);
            					}
HXDLIN(  44)					int ii_min = min;
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					xIter31 = this1;
            				}
            				else {
HXLINE(  44)					int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					xIter31 = this1;
            				}
            			}
            			else {
HXLINE(  44)				if ((bx2 > cx2)) {
HXLINE(  44)					int min;
HXDLIN(  44)					if ((bx > cx2)) {
HXLINE(  44)						min = ::Math_obj::floor(cx2);
            					}
            					else {
HXLINE(  44)						min = ::Math_obj::ceil(bx);
            					}
HXDLIN(  44)					int ii_min = min;
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					xIter31 = this1;
            				}
            				else {
HXLINE(  44)					int ii_min = ::Math_obj::floor(bx);
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					xIter31 = this1;
            				}
            			}
HXDLIN(  44)			::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  44)			if ((by > by2)) {
HXLINE(  44)				if ((by > cy2)) {
HXLINE(  44)					int min;
HXDLIN(  44)					if ((by2 > cy2)) {
HXLINE(  44)						min = ::Math_obj::floor(cy2);
            					}
            					else {
HXLINE(  44)						min = ::Math_obj::floor(by2);
            					}
HXDLIN(  44)					int ii_min = min;
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(by);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					yIter31 = this1;
            				}
            				else {
HXLINE(  44)					int ii_min = ::Math_obj::floor(by2);
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					yIter31 = this1;
            				}
            			}
            			else {
HXLINE(  44)				if ((by2 > cy2)) {
HXLINE(  44)					int min;
HXDLIN(  44)					if ((by > cy2)) {
HXLINE(  44)						min = ::Math_obj::floor(cy2);
            					}
            					else {
HXLINE(  44)						min = ::Math_obj::ceil(by);
            					}
HXDLIN(  44)					int ii_min = min;
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					yIter31 = this1;
            				}
            				else {
HXLINE(  44)					int ii_min = ::Math_obj::floor(by);
HXDLIN(  44)					int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  44)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  44)					yIter31 = this1;
            				}
            			}
HXDLIN(  44)			::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  44)			if (hasUndo1) {
HXLINE(  44)				int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  44)				int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  44)				int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  44)				::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  44)				::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  44)				::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  44)				undoImage1 = this4;
HXDLIN(  44)				{
HXLINE(  44)					int rectLeft = xIter31->start;
HXDLIN(  44)					int rectTop = yIter31->start;
HXDLIN(  44)					int rectRight = xIter31->max;
HXDLIN(  44)					bool forceClear = false;
HXDLIN(  44)					{
HXLINE(  44)						int _g = rectTop;
HXDLIN(  44)						int _g1 = yIter31->max;
HXDLIN(  44)						while((_g < _g1)){
HXLINE(  44)							_g = (_g + 1);
HXDLIN(  44)							int dy = (_g - 1);
HXDLIN(  44)							{
HXLINE(  44)								int _g1 = rectLeft;
HXDLIN(  44)								int _g2 = rectRight;
HXDLIN(  44)								while((_g1 < _g2)){
HXLINE(  44)									_g1 = (_g1 + 1);
HXDLIN(  44)									int dx = (_g1 - 1);
HXDLIN(  44)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)									int index;
HXDLIN(  44)									if (this1->useVirtualPos) {
HXLINE(  44)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            									}
            									else {
HXLINE(  44)										index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            									}
HXDLIN(  44)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)									int col;
HXDLIN(  44)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  44)										col = c;
            									}
HXDLIN(  44)									bool _hx_tmp;
HXDLIN(  44)									if (this1->useMask) {
HXLINE(  44)										_hx_tmp = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  44)										_hx_tmp = false;
            									}
HXDLIN(  44)									if (_hx_tmp) {
HXLINE(  44)										::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  44)										::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  44)										int index;
HXDLIN(  44)										if (this2->useVirtualPos) {
HXLINE(  44)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            										}
            										else {
HXLINE(  44)											index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            										}
HXDLIN(  44)										::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  44)										int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  44)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)										int v;
HXDLIN(  44)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)											v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  44)											v = c;
            										}
HXDLIN(  44)										int this4 = v;
HXDLIN(  44)										int maskPixel = this4;
HXDLIN(  44)										int this5 = col;
HXDLIN(  44)										int this6 = this5;
HXDLIN(  44)										if ((maskPixel == 0)) {
HXLINE(  44)											int this1 = this6;
HXDLIN(  44)											col = this1;
            										}
            										else {
HXLINE(  44)											Float m0;
HXDLIN(  44)											int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  44)											if ((this1 == 0)) {
HXLINE(  44)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float m1;
HXDLIN(  44)											int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  44)											if ((this2 == 0)) {
HXLINE(  44)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float m2;
HXDLIN(  44)											int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  44)											if ((this3 == 0)) {
HXLINE(  44)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float m3;
HXDLIN(  44)											int this4 = (maskPixel & 255);
HXDLIN(  44)											if ((this4 == 0)) {
HXLINE(  44)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  44)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  44)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  44)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  44)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  44)									if ((col != 0)) {
HXLINE(  44)										int x = (dx - rectLeft);
HXDLIN(  44)										int y = (dy - rectTop);
HXDLIN(  44)										int this1 = col;
HXDLIN(  44)										int c = this1;
HXDLIN(  44)										bool _hx_tmp;
HXDLIN(  44)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  44)											_hx_tmp = undoImage1->transparent;
            										}
            										else {
HXLINE(  44)											_hx_tmp = false;
            										}
HXDLIN(  44)										if (_hx_tmp) {
HXLINE(  44)											int location;
HXDLIN(  44)											if (undoImage1->useVirtualPos) {
HXLINE(  44)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  44)												location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  44)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  44)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  44)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  44)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)											int this3 = this2;
HXDLIN(  44)											int this4;
HXDLIN(  44)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  44)												this4 = this3;
            											}
HXDLIN(  44)											Float a1;
HXDLIN(  44)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  44)											if ((this5 == 0)) {
HXLINE(  44)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float r1;
HXDLIN(  44)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  44)											if ((this6 == 0)) {
HXLINE(  44)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float g1;
HXDLIN(  44)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  44)											if ((this7 == 0)) {
HXLINE(  44)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float b1;
HXDLIN(  44)											int this8 = (this4 & 255);
HXDLIN(  44)											if ((this8 == 0)) {
HXLINE(  44)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float a2;
HXDLIN(  44)											int this9 = ((col >> 24) & 255);
HXDLIN(  44)											if ((this9 == 0)) {
HXLINE(  44)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float r2;
HXDLIN(  44)											int this10 = ((col >> 16) & 255);
HXDLIN(  44)											if ((this10 == 0)) {
HXLINE(  44)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float g2;
HXDLIN(  44)											int this11 = ((col >> 8) & 255);
HXDLIN(  44)											if ((this11 == 0)) {
HXLINE(  44)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float b2;
HXDLIN(  44)											int this12 = (col & 255);
HXDLIN(  44)											if ((this12 == 0)) {
HXLINE(  44)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  44)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  44)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  44)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  44)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  44)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  44)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  44)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  44)											{
HXLINE(  44)												::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  44)												int value;
HXDLIN(  44)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  44)													value = blended;
            												}
HXDLIN(  44)												bool _hx_tmp;
HXDLIN(  44)												if ((location >= 0)) {
HXLINE(  44)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  44)													_hx_tmp = false;
            												}
HXDLIN(  44)												if (_hx_tmp) {
HXLINE(  44)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  44)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  44)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  44)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  44)											int index;
HXDLIN(  44)											if (undoImage1->useVirtualPos) {
HXLINE(  44)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  44)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  44)											int value;
HXDLIN(  44)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  44)												value = c;
            											}
HXDLIN(  44)											bool _hx_tmp;
HXDLIN(  44)											if ((index >= 0)) {
HXLINE(  44)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  44)												_hx_tmp = false;
            											}
HXDLIN(  44)											if (_hx_tmp) {
HXLINE(  44)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  44)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  44)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  44)										if (forceClear) {
HXLINE(  44)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  44)											int x = (dx - rectLeft);
HXDLIN(  44)											int y = (dy - rectTop);
HXDLIN(  44)											int index;
HXDLIN(  44)											if (undoImage1->useVirtualPos) {
HXLINE(  44)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  44)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  44)											bool _hx_tmp;
HXDLIN(  44)											if ((index >= 0)) {
HXLINE(  44)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  44)												_hx_tmp = false;
            											}
HXDLIN(  44)											if (_hx_tmp) {
HXLINE(  44)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  44)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  44)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  44)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  44)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  44)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  44)			bool foundY1 = false;
HXDLIN(  44)			Float s1 = ((Float)0.);
HXDLIN(  44)			Float t1 = ((Float)0.);
HXDLIN(  44)			Float sxx1 = ((Float)0.);
HXDLIN(  44)			Float txx1 = ((Float)0.);
HXDLIN(  44)			int _g_min1 = xIter31->start;
HXDLIN(  44)			int _g_max1 = xIter31->max;
HXDLIN(  44)			while((_g_min1 < _g_max1)){
HXLINE(  44)				_g_min1 = (_g_min1 + 1);
HXDLIN(  44)				int x = (_g_min1 - 1);
HXLINE( 223)				sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)				txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)				foundY1 = false;
HXLINE(  44)				{
HXLINE(  44)					int _g_min = yIter31->start;
HXDLIN(  44)					int _g_max = yIter31->max;
HXDLIN(  44)					while((_g_min < _g_max)){
HXLINE(  44)						_g_min = (_g_min + 1);
HXDLIN(  44)						int y = (_g_min - 1);
HXLINE( 227)						s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)						t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  44)						bool _hx_tmp;
HXDLIN(  44)						if (!((s1 <= 0))) {
HXLINE(  44)							_hx_tmp = (t1 <= 0);
            						}
            						else {
HXLINE(  44)							_hx_tmp = true;
            						}
HXDLIN(  44)						if (_hx_tmp) {
HXLINE(  44)							if (foundY1) {
HXLINE(  44)								goto _hx_goto_12;
            							}
            						}
            						else {
HXLINE(  44)							if (((s1 + t1) < A1)) {
HXLINE(  44)								int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  44)								int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  44)								::haxe::io::ArrayBufferViewImpl this2 = tileImage->image;
HXDLIN(  44)								int index;
HXDLIN(  44)								if (tileImage->useVirtualPos) {
HXLINE(  44)									index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            								}
            								else {
HXLINE(  44)									index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            								}
HXDLIN(  44)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)								int color;
HXDLIN(  44)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  44)									color = c;
            								}
HXDLIN(  44)								{
HXLINE(  44)									int this3 = color;
HXDLIN(  44)									int c1 = this3;
HXDLIN(  44)									bool _hx_tmp;
HXDLIN(  44)									if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  44)										_hx_tmp = this1->transparent;
            									}
            									else {
HXLINE(  44)										_hx_tmp = false;
            									}
HXDLIN(  44)									if (_hx_tmp) {
HXLINE(  44)										int location;
HXDLIN(  44)										if (this1->useVirtualPos) {
HXLINE(  44)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            										}
            										else {
HXLINE(  44)											location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            										}
HXDLIN(  44)										::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)										int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  44)										int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  44)										int this4 = this3;
HXDLIN(  44)										int this5;
HXDLIN(  44)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)											this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            										}
            										else {
HXLINE(  44)											this5 = this4;
            										}
HXDLIN(  44)										Float a1;
HXDLIN(  44)										int this6 = ((this5 >> 24) & 255);
HXDLIN(  44)										if ((this6 == 0)) {
HXLINE(  44)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float r1;
HXDLIN(  44)										int this7 = ((this5 >> 16) & 255);
HXDLIN(  44)										if ((this7 == 0)) {
HXLINE(  44)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float g1;
HXDLIN(  44)										int this8 = ((this5 >> 8) & 255);
HXDLIN(  44)										if ((this8 == 0)) {
HXLINE(  44)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float b1;
HXDLIN(  44)										int this9 = (this5 & 255);
HXDLIN(  44)										if ((this9 == 0)) {
HXLINE(  44)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float a2;
HXDLIN(  44)										int this10 = ((color >> 24) & 255);
HXDLIN(  44)										if ((this10 == 0)) {
HXLINE(  44)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float r2;
HXDLIN(  44)										int this11 = ((color >> 16) & 255);
HXDLIN(  44)										if ((this11 == 0)) {
HXLINE(  44)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float g2;
HXDLIN(  44)										int this12 = ((color >> 8) & 255);
HXDLIN(  44)										if ((this12 == 0)) {
HXLINE(  44)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float b2;
HXDLIN(  44)										int this13 = (color & 255);
HXDLIN(  44)										if ((this13 == 0)) {
HXLINE(  44)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  44)											b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN(  44)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  44)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  44)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  44)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  44)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  44)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  44)										{
HXLINE(  44)											::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  44)											int value;
HXDLIN(  44)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  44)												value = blended;
            											}
HXDLIN(  44)											bool _hx_tmp;
HXDLIN(  44)											if ((location >= 0)) {
HXLINE(  44)												_hx_tmp = (location < (this14->byteLength >> 2));
            											}
            											else {
HXLINE(  44)												_hx_tmp = false;
            											}
HXDLIN(  44)											if (_hx_tmp) {
HXLINE(  44)												::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  44)												int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  44)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  44)										::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  44)										int index;
HXDLIN(  44)										if (this1->useVirtualPos) {
HXLINE(  44)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            										}
            										else {
HXLINE(  44)											index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            										}
HXDLIN(  44)										int value;
HXDLIN(  44)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)											value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE(  44)											value = c1;
            										}
HXDLIN(  44)										bool _hx_tmp;
HXDLIN(  44)										if ((index >= 0)) {
HXLINE(  44)											_hx_tmp = (index < (this2->byteLength >> 2));
            										}
            										else {
HXLINE(  44)											_hx_tmp = false;
            										}
HXDLIN(  44)										if (_hx_tmp) {
HXLINE(  44)											::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  44)											int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  44)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  44)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  44)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  44)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXLINE( 237)								foundY1 = true;
            							}
            							else {
HXLINE(  44)								if (foundY1) {
HXLINE(  44)									goto _hx_goto_12;
            								}
            							}
            						}
            					}
            					_hx_goto_12:;
            				}
            			}
HXDLIN(  44)			if ((hasHit == false)) {
HXLINE(  44)				::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  44)				if (hasUndo1) {
HXLINE(  44)					v->undoImage = undoImage1;
HXDLIN(  44)					v->undoX = xIter31->start;
HXDLIN(  44)					v->undoY = yIter31->start;
            				}
            			}
HXDLIN(  44)			::pixelimage::algo::HitQuad _hx_tmp;
HXDLIN(  44)			if ((hasHit == true)) {
HXLINE(  44)				::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  44)				_hx_tmp = v;
            			}
            			else {
HXLINE(  44)				_hx_tmp = null();
            			}
HXDLIN(  44)			this->info = _hx_tmp;
HXLINE(  47)			bool _hx_tmp1;
HXDLIN(  47)			if (::hx::IsNotNull( this->info )) {
HXLINE(  47)				_hx_tmp1 = ::hx::IsNotNull( this->oldInfo );
            			}
            			else {
HXLINE(  47)				_hx_tmp1 = false;
            			}
HXDLIN(  47)			if (_hx_tmp1) {
HXLINE(  48)				::pixelimage::ImageStruct this1 = this->pixelImage;
HXDLIN(  48)				Float ax = ((this->oldInfo->bx * this->scaleX) + this->translateX);
HXDLIN(  48)				Float ay = ((this->oldInfo->by * this->scaleY) + this->translateY);
HXDLIN(  48)				Float bx = ((this->info->ax * this->scaleX) + this->translateX);
HXDLIN(  48)				Float by = ((this->info->ay * this->scaleY) + this->translateY);
HXDLIN(  48)				Float cx = ((this->info->dx * this->scaleX) + this->translateX);
HXDLIN(  48)				Float cy = ((this->info->dy * this->scaleY) + this->translateY);
HXDLIN(  48)				Float dx = ((this->oldInfo->cx * this->scaleX) + this->translateX);
HXDLIN(  48)				Float dy = ((this->oldInfo->cy * this->scaleY) + this->translateY);
HXDLIN(  48)				::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN(  48)				bool hasHit = false;
HXDLIN(  48)				{
HXLINE(  48)					{
HXLINE(  48)						Float bx1 = bx;
HXDLIN(  48)						Float by1 = by;
HXDLIN(  48)						Float cx1 = dx;
HXDLIN(  48)						Float cy1 = dy;
HXDLIN(  48)						bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  48)						if (!(adjustWinding)) {
HXLINE(  48)							Float bx_ = bx1;
HXDLIN(  48)							Float by_ = by1;
HXLINE( 188)							bx1 = cx1;
HXLINE( 189)							by1 = cy1;
HXLINE( 190)							cx1 = bx_;
HXLINE( 191)							cy1 = by_;
            						}
HXLINE(  48)						{
HXLINE(  48)							bool hasUndo = false;
HXDLIN(  48)							Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  48)							Float sx = (cy1 - ay);
HXDLIN(  48)							Float sy = (ax - cx1);
HXDLIN(  48)							Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  48)							Float tx = (ay - by1);
HXDLIN(  48)							Float ty = (bx1 - ax);
HXDLIN(  48)							Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  48)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  48)							if ((ax > bx1)) {
HXLINE(  48)								if ((ax > cx1)) {
HXLINE(  48)									int min;
HXDLIN(  48)									if ((bx1 > cx1)) {
HXLINE(  48)										min = ::Math_obj::floor(cx1);
            									}
            									else {
HXLINE(  48)										min = ::Math_obj::floor(bx1);
            									}
HXDLIN(  48)									int ii_min = min;
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									xIter3 = this1;
            								}
            								else {
HXLINE(  48)									int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  48)								if ((bx1 > cx1)) {
HXLINE(  48)									int min;
HXDLIN(  48)									if ((ax > cx1)) {
HXLINE(  48)										min = ::Math_obj::floor(cx1);
            									}
            									else {
HXLINE(  48)										min = ::Math_obj::ceil(ax);
            									}
HXDLIN(  48)									int ii_min = min;
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									xIter3 = this1;
            								}
            								else {
HXLINE(  48)									int ii_min = ::Math_obj::floor(ax);
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									xIter3 = this1;
            								}
            							}
HXDLIN(  48)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  48)							if ((ay > by1)) {
HXLINE(  48)								if ((ay > cy1)) {
HXLINE(  48)									int min;
HXDLIN(  48)									if ((by1 > cy1)) {
HXLINE(  48)										min = ::Math_obj::floor(cy1);
            									}
            									else {
HXLINE(  48)										min = ::Math_obj::floor(by1);
            									}
HXDLIN(  48)									int ii_min = min;
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									yIter3 = this1;
            								}
            								else {
HXLINE(  48)									int ii_min = ::Math_obj::floor(by1);
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  48)								if ((by1 > cy1)) {
HXLINE(  48)									int min;
HXDLIN(  48)									if ((ay > cy1)) {
HXLINE(  48)										min = ::Math_obj::floor(cy1);
            									}
            									else {
HXLINE(  48)										min = ::Math_obj::ceil(ay);
            									}
HXDLIN(  48)									int ii_min = min;
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									yIter3 = this1;
            								}
            								else {
HXLINE(  48)									int ii_min = ::Math_obj::floor(ay);
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									yIter3 = this1;
            								}
            							}
HXDLIN(  48)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  48)							if (hasUndo) {
HXLINE(  48)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  48)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  48)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  48)								::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  48)								::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  48)								::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  48)								undoImage = this4;
HXDLIN(  48)								{
HXLINE(  48)									int rectLeft = xIter3->start;
HXDLIN(  48)									int rectTop = yIter3->start;
HXDLIN(  48)									int rectRight = xIter3->max;
HXDLIN(  48)									bool forceClear = false;
HXDLIN(  48)									{
HXLINE(  48)										int _g = rectTop;
HXDLIN(  48)										int _g1 = yIter3->max;
HXDLIN(  48)										while((_g < _g1)){
HXLINE(  48)											_g = (_g + 1);
HXDLIN(  48)											int dy = (_g - 1);
HXDLIN(  48)											{
HXLINE(  48)												int _g1 = rectLeft;
HXDLIN(  48)												int _g2 = rectRight;
HXDLIN(  48)												while((_g1 < _g2)){
HXLINE(  48)													_g1 = (_g1 + 1);
HXDLIN(  48)													int dx = (_g1 - 1);
HXDLIN(  48)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  48)													int index;
HXDLIN(  48)													if (this1->useVirtualPos) {
HXLINE(  48)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  48)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  48)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  48)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  48)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)													int col;
HXDLIN(  48)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  48)														col = c;
            													}
HXDLIN(  48)													bool _hx_tmp;
HXDLIN(  48)													if (this1->useMask) {
HXLINE(  48)														_hx_tmp = ::hx::IsNotNull( this1->mask );
            													}
            													else {
HXLINE(  48)														_hx_tmp = false;
            													}
HXDLIN(  48)													if (_hx_tmp) {
HXLINE(  48)														::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  48)														::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  48)														int index;
HXDLIN(  48)														if (this2->useVirtualPos) {
HXLINE(  48)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXLINE(  48)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN(  48)														::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  48)														int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  48)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)														int v;
HXDLIN(  48)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  48)															v = c;
            														}
HXDLIN(  48)														int this4 = v;
HXDLIN(  48)														int maskPixel = this4;
HXDLIN(  48)														int this5 = col;
HXDLIN(  48)														int this6 = this5;
HXDLIN(  48)														if ((maskPixel == 0)) {
HXLINE(  48)															int this1 = this6;
HXDLIN(  48)															col = this1;
            														}
            														else {
HXLINE(  48)															Float m0;
HXDLIN(  48)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  48)															if ((this1 == 0)) {
HXLINE(  48)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float m1;
HXDLIN(  48)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  48)															if ((this2 == 0)) {
HXLINE(  48)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float m2;
HXDLIN(  48)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  48)															if ((this3 == 0)) {
HXLINE(  48)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float m3;
HXDLIN(  48)															int this4 = (maskPixel & 255);
HXDLIN(  48)															if ((this4 == 0)) {
HXLINE(  48)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  48)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  48)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  48)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  48)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  48)													if ((col != 0)) {
HXLINE(  48)														int x = (dx - rectLeft);
HXDLIN(  48)														int y = (dy - rectTop);
HXDLIN(  48)														int this1 = col;
HXDLIN(  48)														int c = this1;
HXDLIN(  48)														bool _hx_tmp;
HXDLIN(  48)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  48)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE(  48)															_hx_tmp = false;
            														}
HXDLIN(  48)														if (_hx_tmp) {
HXLINE(  48)															int location;
HXDLIN(  48)															if (undoImage->useVirtualPos) {
HXLINE(  48)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  48)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  48)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  48)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  48)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  48)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)															int this3 = this2;
HXDLIN(  48)															int this4;
HXDLIN(  48)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  48)																this4 = this3;
            															}
HXDLIN(  48)															Float a1;
HXDLIN(  48)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  48)															if ((this5 == 0)) {
HXLINE(  48)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float r1;
HXDLIN(  48)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  48)															if ((this6 == 0)) {
HXLINE(  48)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float g1;
HXDLIN(  48)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  48)															if ((this7 == 0)) {
HXLINE(  48)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float b1;
HXDLIN(  48)															int this8 = (this4 & 255);
HXDLIN(  48)															if ((this8 == 0)) {
HXLINE(  48)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float a2;
HXDLIN(  48)															int this9 = ((col >> 24) & 255);
HXDLIN(  48)															if ((this9 == 0)) {
HXLINE(  48)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float r2;
HXDLIN(  48)															int this10 = ((col >> 16) & 255);
HXDLIN(  48)															if ((this10 == 0)) {
HXLINE(  48)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float g2;
HXDLIN(  48)															int this11 = ((col >> 8) & 255);
HXDLIN(  48)															if ((this11 == 0)) {
HXLINE(  48)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float b2;
HXDLIN(  48)															int this12 = (col & 255);
HXDLIN(  48)															if ((this12 == 0)) {
HXLINE(  48)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  48)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  48)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  48)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  48)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  48)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  48)															{
HXLINE(  48)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  48)																int value;
HXDLIN(  48)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  48)																	value = blended;
            																}
HXDLIN(  48)																bool _hx_tmp;
HXDLIN(  48)																if ((location >= 0)) {
HXLINE(  48)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  48)																	_hx_tmp = false;
            																}
HXDLIN(  48)																if (_hx_tmp) {
HXLINE(  48)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  48)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  48)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  48)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  48)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  48)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  48)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  48)															int index;
HXDLIN(  48)															if (undoImage->useVirtualPos) {
HXLINE(  48)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  48)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  48)															int value;
HXDLIN(  48)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  48)																value = c;
            															}
HXDLIN(  48)															bool _hx_tmp;
HXDLIN(  48)															if ((index >= 0)) {
HXLINE(  48)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  48)																_hx_tmp = false;
            															}
HXDLIN(  48)															if (_hx_tmp) {
HXLINE(  48)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  48)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  48)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  48)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  48)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  48)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  48)														if (forceClear) {
HXLINE(  48)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  48)															int x = (dx - rectLeft);
HXDLIN(  48)															int y = (dy - rectTop);
HXDLIN(  48)															int index;
HXDLIN(  48)															if (undoImage->useVirtualPos) {
HXLINE(  48)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  48)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  48)															bool _hx_tmp;
HXDLIN(  48)															if ((index >= 0)) {
HXLINE(  48)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  48)																_hx_tmp = false;
            															}
HXDLIN(  48)															if (_hx_tmp) {
HXLINE(  48)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  48)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  48)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  48)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  48)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  48)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  48)							bool foundY = false;
HXDLIN(  48)							Float s = ((Float)0.);
HXDLIN(  48)							Float t = ((Float)0.);
HXDLIN(  48)							Float sxx = ((Float)0.);
HXDLIN(  48)							Float txx = ((Float)0.);
HXDLIN(  48)							{
HXLINE(  48)								int _g_min = xIter3->start;
HXDLIN(  48)								int _g_max = xIter3->max;
HXDLIN(  48)								while((_g_min < _g_max)){
HXLINE(  48)									_g_min = (_g_min + 1);
HXDLIN(  48)									int x = (_g_min - 1);
HXLINE( 223)									sxx = (sx * ( (Float)(x) ));
HXLINE( 224)									txx = (tx * ( (Float)(x) ));
HXLINE( 225)									foundY = false;
HXLINE(  48)									{
HXLINE(  48)										int _g_min1 = yIter3->start;
HXDLIN(  48)										int _g_max = yIter3->max;
HXDLIN(  48)										while((_g_min1 < _g_max)){
HXLINE(  48)											_g_min1 = (_g_min1 + 1);
HXDLIN(  48)											int y = (_g_min1 - 1);
HXLINE( 227)											s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)											t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  48)											bool _hx_tmp;
HXDLIN(  48)											if (!((s <= 0))) {
HXLINE(  48)												_hx_tmp = (t <= 0);
            											}
            											else {
HXLINE(  48)												_hx_tmp = true;
            											}
HXDLIN(  48)											if (_hx_tmp) {
HXLINE(  48)												if (foundY) {
HXLINE(  48)													goto _hx_goto_16;
            												}
            											}
            											else {
HXLINE(  48)												if (((s + t) < A)) {
HXLINE(  48)													int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  48)													int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  48)													::haxe::io::ArrayBufferViewImpl this2 = tileImage->image;
HXDLIN(  48)													int index;
HXDLIN(  48)													if (tileImage->useVirtualPos) {
HXLINE(  48)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            													}
            													else {
HXLINE(  48)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            													}
HXDLIN(  48)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  48)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  48)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)													int color;
HXDLIN(  48)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  48)														color = c;
            													}
HXDLIN(  48)													{
HXLINE(  48)														int this3 = color;
HXDLIN(  48)														int c1 = this3;
HXDLIN(  48)														bool _hx_tmp;
HXDLIN(  48)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  48)															_hx_tmp = this1->transparent;
            														}
            														else {
HXLINE(  48)															_hx_tmp = false;
            														}
HXDLIN(  48)														if (_hx_tmp) {
HXLINE(  48)															int location;
HXDLIN(  48)															if (this1->useVirtualPos) {
HXLINE(  48)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            															}
            															else {
HXLINE(  48)																location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            															}
HXDLIN(  48)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  48)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  48)															int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  48)															int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)															int this4 = this3;
HXDLIN(  48)															int this5;
HXDLIN(  48)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            															}
            															else {
HXLINE(  48)																this5 = this4;
            															}
HXDLIN(  48)															Float a1;
HXDLIN(  48)															int this6 = ((this5 >> 24) & 255);
HXDLIN(  48)															if ((this6 == 0)) {
HXLINE(  48)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float r1;
HXDLIN(  48)															int this7 = ((this5 >> 16) & 255);
HXDLIN(  48)															if ((this7 == 0)) {
HXLINE(  48)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float g1;
HXDLIN(  48)															int this8 = ((this5 >> 8) & 255);
HXDLIN(  48)															if ((this8 == 0)) {
HXLINE(  48)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float b1;
HXDLIN(  48)															int this9 = (this5 & 255);
HXDLIN(  48)															if ((this9 == 0)) {
HXLINE(  48)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float a2;
HXDLIN(  48)															int this10 = ((color >> 24) & 255);
HXDLIN(  48)															if ((this10 == 0)) {
HXLINE(  48)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float r2;
HXDLIN(  48)															int this11 = ((color >> 16) & 255);
HXDLIN(  48)															if ((this11 == 0)) {
HXLINE(  48)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float g2;
HXDLIN(  48)															int this12 = ((color >> 8) & 255);
HXDLIN(  48)															if ((this12 == 0)) {
HXLINE(  48)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float b2;
HXDLIN(  48)															int this13 = (color & 255);
HXDLIN(  48)															if ((this13 == 0)) {
HXLINE(  48)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  48)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  48)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  48)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  48)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  48)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  48)															{
HXLINE(  48)																::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  48)																int value;
HXDLIN(  48)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  48)																	value = blended;
            																}
HXDLIN(  48)																bool _hx_tmp;
HXDLIN(  48)																if ((location >= 0)) {
HXLINE(  48)																	_hx_tmp = (location < (this14->byteLength >> 2));
            																}
            																else {
HXLINE(  48)																	_hx_tmp = false;
            																}
HXDLIN(  48)																if (_hx_tmp) {
HXLINE(  48)																	::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  48)																	int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  48)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  48)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  48)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  48)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  48)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  48)															int index;
HXDLIN(  48)															if (this1->useVirtualPos) {
HXLINE(  48)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            															}
            															else {
HXLINE(  48)																index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            															}
HXDLIN(  48)															int value;
HXDLIN(  48)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  48)																value = c1;
            															}
HXDLIN(  48)															bool _hx_tmp;
HXDLIN(  48)															if ((index >= 0)) {
HXLINE(  48)																_hx_tmp = (index < (this2->byteLength >> 2));
            															}
            															else {
HXLINE(  48)																_hx_tmp = false;
            															}
HXDLIN(  48)															if (_hx_tmp) {
HXLINE(  48)																::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  48)																int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  48)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  48)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  48)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  48)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY = true;
            												}
            												else {
HXLINE(  48)													if (foundY) {
HXLINE(  48)														goto _hx_goto_16;
            													}
            												}
            											}
            										}
            										_hx_goto_16:;
            									}
            								}
            							}
HXDLIN(  48)							if ((hasHit == false)) {
HXLINE(  48)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  48)								if (hasUndo) {
HXLINE(  48)									v->undoImage = undoImage;
HXDLIN(  48)									v->undoX = xIter3->start;
HXDLIN(  48)									v->undoY = yIter3->start;
            								}
            							}
            						}
            					}
HXDLIN(  48)					{
HXLINE(  48)						Float bx2 = cx;
HXDLIN(  48)						Float by2 = cy;
HXDLIN(  48)						Float cx2 = dx;
HXDLIN(  48)						Float cy2 = dy;
HXDLIN(  48)						bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  48)						if (!(adjustWinding1)) {
HXLINE(  48)							Float bx_ = bx2;
HXDLIN(  48)							Float by_ = by2;
HXLINE( 188)							bx2 = cx2;
HXLINE( 189)							by2 = cy2;
HXLINE( 190)							cx2 = bx_;
HXLINE( 191)							cy2 = by_;
            						}
HXLINE(  48)						{
HXLINE(  48)							bool hasUndo1 = false;
HXDLIN(  48)							Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  48)							Float sx1 = (cy2 - by);
HXDLIN(  48)							Float sy1 = (bx - cx2);
HXDLIN(  48)							Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  48)							Float tx1 = (by - by2);
HXDLIN(  48)							Float ty1 = (bx2 - bx);
HXDLIN(  48)							Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  48)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  48)							if ((bx > bx2)) {
HXLINE(  48)								if ((bx > cx2)) {
HXLINE(  48)									int min;
HXDLIN(  48)									if ((bx2 > cx2)) {
HXLINE(  48)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  48)										min = ::Math_obj::floor(bx2);
            									}
HXDLIN(  48)									int ii_min = min;
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									xIter31 = this1;
            								}
            								else {
HXLINE(  48)									int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  48)								if ((bx2 > cx2)) {
HXLINE(  48)									int min;
HXDLIN(  48)									if ((bx > cx2)) {
HXLINE(  48)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  48)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  48)									int ii_min = min;
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									xIter31 = this1;
            								}
            								else {
HXLINE(  48)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									xIter31 = this1;
            								}
            							}
HXDLIN(  48)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  48)							if ((by > by2)) {
HXLINE(  48)								if ((by > cy2)) {
HXLINE(  48)									int min;
HXDLIN(  48)									if ((by2 > cy2)) {
HXLINE(  48)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  48)										min = ::Math_obj::floor(by2);
            									}
HXDLIN(  48)									int ii_min = min;
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									yIter31 = this1;
            								}
            								else {
HXLINE(  48)									int ii_min = ::Math_obj::floor(by2);
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  48)								if ((by2 > cy2)) {
HXLINE(  48)									int min;
HXDLIN(  48)									if ((by > cy2)) {
HXLINE(  48)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  48)										min = ::Math_obj::ceil(by);
            									}
HXDLIN(  48)									int ii_min = min;
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									yIter31 = this1;
            								}
            								else {
HXLINE(  48)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  48)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  48)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  48)									yIter31 = this1;
            								}
            							}
HXDLIN(  48)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  48)							if (hasUndo1) {
HXLINE(  48)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  48)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  48)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  48)								::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  48)								::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  48)								::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  48)								undoImage1 = this4;
HXDLIN(  48)								{
HXLINE(  48)									int rectLeft = xIter31->start;
HXDLIN(  48)									int rectTop = yIter31->start;
HXDLIN(  48)									int rectRight = xIter31->max;
HXDLIN(  48)									bool forceClear = false;
HXDLIN(  48)									{
HXLINE(  48)										int _g = rectTop;
HXDLIN(  48)										int _g1 = yIter31->max;
HXDLIN(  48)										while((_g < _g1)){
HXLINE(  48)											_g = (_g + 1);
HXDLIN(  48)											int dy = (_g - 1);
HXDLIN(  48)											{
HXLINE(  48)												int _g1 = rectLeft;
HXDLIN(  48)												int _g2 = rectRight;
HXDLIN(  48)												while((_g1 < _g2)){
HXLINE(  48)													_g1 = (_g1 + 1);
HXDLIN(  48)													int dx = (_g1 - 1);
HXDLIN(  48)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  48)													int index;
HXDLIN(  48)													if (this1->useVirtualPos) {
HXLINE(  48)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  48)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  48)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  48)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  48)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)													int col;
HXDLIN(  48)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  48)														col = c;
            													}
HXDLIN(  48)													bool _hx_tmp;
HXDLIN(  48)													if (this1->useMask) {
HXLINE(  48)														_hx_tmp = ::hx::IsNotNull( this1->mask );
            													}
            													else {
HXLINE(  48)														_hx_tmp = false;
            													}
HXDLIN(  48)													if (_hx_tmp) {
HXLINE(  48)														::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  48)														::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  48)														int index;
HXDLIN(  48)														if (this2->useVirtualPos) {
HXLINE(  48)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXLINE(  48)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN(  48)														::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  48)														int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  48)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)														int v;
HXDLIN(  48)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  48)															v = c;
            														}
HXDLIN(  48)														int this4 = v;
HXDLIN(  48)														int maskPixel = this4;
HXDLIN(  48)														int this5 = col;
HXDLIN(  48)														int this6 = this5;
HXDLIN(  48)														if ((maskPixel == 0)) {
HXLINE(  48)															int this1 = this6;
HXDLIN(  48)															col = this1;
            														}
            														else {
HXLINE(  48)															Float m0;
HXDLIN(  48)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  48)															if ((this1 == 0)) {
HXLINE(  48)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float m1;
HXDLIN(  48)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  48)															if ((this2 == 0)) {
HXLINE(  48)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float m2;
HXDLIN(  48)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  48)															if ((this3 == 0)) {
HXLINE(  48)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float m3;
HXDLIN(  48)															int this4 = (maskPixel & 255);
HXDLIN(  48)															if ((this4 == 0)) {
HXLINE(  48)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  48)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  48)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  48)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  48)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  48)													if ((col != 0)) {
HXLINE(  48)														int x = (dx - rectLeft);
HXDLIN(  48)														int y = (dy - rectTop);
HXDLIN(  48)														int this1 = col;
HXDLIN(  48)														int c = this1;
HXDLIN(  48)														bool _hx_tmp;
HXDLIN(  48)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  48)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE(  48)															_hx_tmp = false;
            														}
HXDLIN(  48)														if (_hx_tmp) {
HXLINE(  48)															int location;
HXDLIN(  48)															if (undoImage1->useVirtualPos) {
HXLINE(  48)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  48)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  48)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  48)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  48)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  48)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)															int this3 = this2;
HXDLIN(  48)															int this4;
HXDLIN(  48)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  48)																this4 = this3;
            															}
HXDLIN(  48)															Float a1;
HXDLIN(  48)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  48)															if ((this5 == 0)) {
HXLINE(  48)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float r1;
HXDLIN(  48)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  48)															if ((this6 == 0)) {
HXLINE(  48)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float g1;
HXDLIN(  48)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  48)															if ((this7 == 0)) {
HXLINE(  48)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float b1;
HXDLIN(  48)															int this8 = (this4 & 255);
HXDLIN(  48)															if ((this8 == 0)) {
HXLINE(  48)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float a2;
HXDLIN(  48)															int this9 = ((col >> 24) & 255);
HXDLIN(  48)															if ((this9 == 0)) {
HXLINE(  48)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float r2;
HXDLIN(  48)															int this10 = ((col >> 16) & 255);
HXDLIN(  48)															if ((this10 == 0)) {
HXLINE(  48)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float g2;
HXDLIN(  48)															int this11 = ((col >> 8) & 255);
HXDLIN(  48)															if ((this11 == 0)) {
HXLINE(  48)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float b2;
HXDLIN(  48)															int this12 = (col & 255);
HXDLIN(  48)															if ((this12 == 0)) {
HXLINE(  48)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  48)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  48)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  48)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  48)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  48)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  48)															{
HXLINE(  48)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  48)																int value;
HXDLIN(  48)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  48)																	value = blended;
            																}
HXDLIN(  48)																bool _hx_tmp;
HXDLIN(  48)																if ((location >= 0)) {
HXLINE(  48)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  48)																	_hx_tmp = false;
            																}
HXDLIN(  48)																if (_hx_tmp) {
HXLINE(  48)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  48)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  48)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  48)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  48)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  48)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  48)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  48)															int index;
HXDLIN(  48)															if (undoImage1->useVirtualPos) {
HXLINE(  48)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  48)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  48)															int value;
HXDLIN(  48)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  48)																value = c;
            															}
HXDLIN(  48)															bool _hx_tmp;
HXDLIN(  48)															if ((index >= 0)) {
HXLINE(  48)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  48)																_hx_tmp = false;
            															}
HXDLIN(  48)															if (_hx_tmp) {
HXLINE(  48)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  48)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  48)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  48)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  48)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  48)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  48)														if (forceClear) {
HXLINE(  48)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  48)															int x = (dx - rectLeft);
HXDLIN(  48)															int y = (dy - rectTop);
HXDLIN(  48)															int index;
HXDLIN(  48)															if (undoImage1->useVirtualPos) {
HXLINE(  48)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  48)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  48)															bool _hx_tmp;
HXDLIN(  48)															if ((index >= 0)) {
HXLINE(  48)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  48)																_hx_tmp = false;
            															}
HXDLIN(  48)															if (_hx_tmp) {
HXLINE(  48)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  48)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  48)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  48)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  48)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  48)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  48)							bool foundY1 = false;
HXDLIN(  48)							Float s1 = ((Float)0.);
HXDLIN(  48)							Float t1 = ((Float)0.);
HXDLIN(  48)							Float sxx1 = ((Float)0.);
HXDLIN(  48)							Float txx1 = ((Float)0.);
HXDLIN(  48)							{
HXLINE(  48)								int _g_min1 = xIter31->start;
HXDLIN(  48)								int _g_max1 = xIter31->max;
HXDLIN(  48)								while((_g_min1 < _g_max1)){
HXLINE(  48)									_g_min1 = (_g_min1 + 1);
HXDLIN(  48)									int x = (_g_min1 - 1);
HXLINE( 223)									sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)									txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)									foundY1 = false;
HXLINE(  48)									{
HXLINE(  48)										int _g_min = yIter31->start;
HXDLIN(  48)										int _g_max = yIter31->max;
HXDLIN(  48)										while((_g_min < _g_max)){
HXLINE(  48)											_g_min = (_g_min + 1);
HXDLIN(  48)											int y = (_g_min - 1);
HXLINE( 227)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  48)											bool _hx_tmp;
HXDLIN(  48)											if (!((s1 <= 0))) {
HXLINE(  48)												_hx_tmp = (t1 <= 0);
            											}
            											else {
HXLINE(  48)												_hx_tmp = true;
            											}
HXDLIN(  48)											if (_hx_tmp) {
HXLINE(  48)												if (foundY1) {
HXLINE(  48)													goto _hx_goto_20;
            												}
            											}
            											else {
HXLINE(  48)												if (((s1 + t1) < A1)) {
HXLINE(  48)													int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  48)													int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  48)													::haxe::io::ArrayBufferViewImpl this2 = tileImage->image;
HXDLIN(  48)													int index;
HXDLIN(  48)													if (tileImage->useVirtualPos) {
HXLINE(  48)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            													}
            													else {
HXLINE(  48)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            													}
HXDLIN(  48)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  48)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  48)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)													int color;
HXDLIN(  48)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  48)														color = c;
            													}
HXDLIN(  48)													{
HXLINE(  48)														int this3 = color;
HXDLIN(  48)														int c1 = this3;
HXDLIN(  48)														bool _hx_tmp;
HXDLIN(  48)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  48)															_hx_tmp = this1->transparent;
            														}
            														else {
HXLINE(  48)															_hx_tmp = false;
            														}
HXDLIN(  48)														if (_hx_tmp) {
HXLINE(  48)															int location;
HXDLIN(  48)															if (this1->useVirtualPos) {
HXLINE(  48)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            															}
            															else {
HXLINE(  48)																location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            															}
HXDLIN(  48)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  48)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  48)															int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  48)															int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)															int this4 = this3;
HXDLIN(  48)															int this5;
HXDLIN(  48)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            															}
            															else {
HXLINE(  48)																this5 = this4;
            															}
HXDLIN(  48)															Float a1;
HXDLIN(  48)															int this6 = ((this5 >> 24) & 255);
HXDLIN(  48)															if ((this6 == 0)) {
HXLINE(  48)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float r1;
HXDLIN(  48)															int this7 = ((this5 >> 16) & 255);
HXDLIN(  48)															if ((this7 == 0)) {
HXLINE(  48)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float g1;
HXDLIN(  48)															int this8 = ((this5 >> 8) & 255);
HXDLIN(  48)															if ((this8 == 0)) {
HXLINE(  48)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float b1;
HXDLIN(  48)															int this9 = (this5 & 255);
HXDLIN(  48)															if ((this9 == 0)) {
HXLINE(  48)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float a2;
HXDLIN(  48)															int this10 = ((color >> 24) & 255);
HXDLIN(  48)															if ((this10 == 0)) {
HXLINE(  48)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float r2;
HXDLIN(  48)															int this11 = ((color >> 16) & 255);
HXDLIN(  48)															if ((this11 == 0)) {
HXLINE(  48)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float g2;
HXDLIN(  48)															int this12 = ((color >> 8) & 255);
HXDLIN(  48)															if ((this12 == 0)) {
HXLINE(  48)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float b2;
HXDLIN(  48)															int this13 = (color & 255);
HXDLIN(  48)															if ((this13 == 0)) {
HXLINE(  48)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  48)																b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            															}
HXDLIN(  48)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  48)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  48)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  48)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  48)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  48)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  48)															{
HXLINE(  48)																::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  48)																int value;
HXDLIN(  48)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  48)																	value = blended;
            																}
HXDLIN(  48)																bool _hx_tmp;
HXDLIN(  48)																if ((location >= 0)) {
HXLINE(  48)																	_hx_tmp = (location < (this14->byteLength >> 2));
            																}
            																else {
HXLINE(  48)																	_hx_tmp = false;
            																}
HXDLIN(  48)																if (_hx_tmp) {
HXLINE(  48)																	::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  48)																	int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  48)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  48)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  48)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  48)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  48)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  48)															int index;
HXDLIN(  48)															if (this1->useVirtualPos) {
HXLINE(  48)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            															}
            															else {
HXLINE(  48)																index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            															}
HXDLIN(  48)															int value;
HXDLIN(  48)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  48)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  48)																value = c1;
            															}
HXDLIN(  48)															bool _hx_tmp;
HXDLIN(  48)															if ((index >= 0)) {
HXLINE(  48)																_hx_tmp = (index < (this2->byteLength >> 2));
            															}
            															else {
HXLINE(  48)																_hx_tmp = false;
            															}
HXDLIN(  48)															if (_hx_tmp) {
HXLINE(  48)																::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  48)																int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  48)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  48)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  48)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  48)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY1 = true;
            												}
            												else {
HXLINE(  48)													if (foundY1) {
HXLINE(  48)														goto _hx_goto_20;
            													}
            												}
            											}
            										}
            										_hx_goto_20:;
            									}
            								}
            							}
HXDLIN(  48)							if ((hasHit == false)) {
HXLINE(  48)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  48)								if (hasUndo1) {
HXLINE(  48)									v->undoImage = undoImage1;
HXDLIN(  48)									v->undoX = xIter31->start;
HXDLIN(  48)									v->undoY = yIter31->start;
            								}
            							}
            						}
            					}
HXDLIN(  48)					if ((hasHit == true)) {
HXLINE(  48)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            					}
            				}
            			}
            		}
HXLINE(  53)		this->toggleDraw = !(this->toggleDraw);
HXLINE(  54)		this->x0 = x2;
HXLINE(  55)		this->y0 = y2;
            	}


HX_DEFINE_DYNAMIC_FUNC2(DrawTileHelper_obj,lineSegmentTo,(void))

void DrawTileHelper_obj::lineTo(Float x2,Float y2){
            	HX_GC_STACKFRAME(&_hx_pos_fc768c01f79e9b96_58_lineTo)
HXLINE(  59)		this->oldInfo = this->info;
HXLINE(  60)		::pixelimage::ImageStruct this1 = this->pixelImage;
HXDLIN(  60)		Float px = ((this->x0 * this->scaleX) + this->translateX);
HXDLIN(  60)		Float py = ((this->y0 * this->scaleY) + this->translateY);
HXDLIN(  60)		::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN(  60)		Float o = (((y2 * this->scaleY) + this->translateY) - py);
HXDLIN(  60)		Float a = (((x2 * this->scaleX) + this->translateX) - px);
HXDLIN(  60)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  60)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  60)		 ::Dynamic debugCorners = false;
HXDLIN(  60)		if (::hx::IsNull( debugCorners )) {
HXLINE( 893)			debugCorners = false;
            		}
HXLINE(  60)		Float sin = ::Math_obj::sin(theta);
HXDLIN(  60)		Float cos = ::Math_obj::cos(theta);
HXDLIN(  60)		Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  60)		Float dx = ((Float)0.1);
HXDLIN(  60)		Float dy = radius;
HXDLIN(  60)		Float cx = h;
HXDLIN(  60)		Float cy = radius;
HXDLIN(  60)		Float bx = h;
HXDLIN(  60)		Float by = -(radius);
HXDLIN(  60)		Float ax = ((Float)0.1);
HXDLIN(  60)		Float ay = -(radius);
HXDLIN(  60)		Float temp = ((Float)0.);
HXLINE( 380)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 381)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 382)		ax = temp;
HXLINE( 384)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 385)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 386)		bx = temp;
HXLINE( 388)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 389)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 390)		cx = temp;
HXLINE( 392)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 393)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 394)		dx = temp;
HXLINE(  60)		if (( (bool)(debugCorners) )) {
HXLINE(  60)			{
HXLINE(  60)				Float x = (ax - ((Float)6.));
HXDLIN(  60)				Float y = (ay - ((Float)6.));
HXDLIN(  60)				int p = ::Std_obj::_hx_int(x);
HXDLIN(  60)				int xx = p;
HXDLIN(  60)				int q = ::Std_obj::_hx_int(y);
HXDLIN(  60)				int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  60)				int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  60)				while(true){
HXLINE(  60)					{
HXLINE(  60)						p = (p + 1);
HXDLIN(  60)						int x = (p - 1);
HXDLIN(  60)						int this2 = -65536;
HXDLIN(  60)						int c = this2;
HXDLIN(  60)						bool _hx_tmp;
HXDLIN(  60)						if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE(  60)							_hx_tmp = false;
            						}
HXDLIN(  60)						if (_hx_tmp) {
HXLINE(  60)							int location;
HXDLIN(  60)							if (this1->useVirtualPos) {
HXLINE(  60)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE(  60)								location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            							}
HXDLIN(  60)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  60)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)							int this4 = this3;
HXDLIN(  60)							int this5;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE(  60)								this5 = this4;
            							}
HXDLIN(  60)							Float a1;
HXDLIN(  60)							int this6 = ((this5 >> 24) & 255);
HXDLIN(  60)							if ((this6 == 0)) {
HXLINE(  60)								a1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float r1;
HXDLIN(  60)							int this7 = ((this5 >> 16) & 255);
HXDLIN(  60)							if ((this7 == 0)) {
HXLINE(  60)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float g1;
HXDLIN(  60)							int this8 = ((this5 >> 8) & 255);
HXDLIN(  60)							if ((this8 == 0)) {
HXLINE(  60)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float b1;
HXDLIN(  60)							int this9 = (this5 & 255);
HXDLIN(  60)							if ((this9 == 0)) {
HXLINE(  60)								b1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float a2;
HXDLIN(  60)							int this10 = ((-65536 >> 24) & 255);
HXDLIN(  60)							if ((this10 == 0)) {
HXLINE(  60)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float r2;
HXDLIN(  60)							int this11 = ((-65536 >> 16) & 255);
HXDLIN(  60)							if ((this11 == 0)) {
HXLINE(  60)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float g2;
HXDLIN(  60)							int this12 = ((-65536 >> 8) & 255);
HXDLIN(  60)							if ((this12 == 0)) {
HXLINE(  60)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float b2;
HXDLIN(  60)							int this13 = (-65536 & 255);
HXDLIN(  60)							if ((this13 == 0)) {
HXLINE(  60)								b2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)							{
HXLINE(  60)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  60)								int value;
HXDLIN(  60)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  60)									value = blended;
            								}
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((location >= 0)) {
HXLINE(  60)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  60)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE(  60)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)							int index;
HXDLIN(  60)							if (this1->useVirtualPos) {
HXLINE(  60)								index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE(  60)								index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            							}
HXDLIN(  60)							int value;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  60)								value = c;
            							}
HXDLIN(  60)							bool _hx_tmp;
HXDLIN(  60)							if ((index >= 0)) {
HXLINE(  60)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE(  60)								_hx_tmp = false;
            							}
HXDLIN(  60)							if (_hx_tmp) {
HXLINE(  60)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN(  60)					if ((p > maxX)) {
HXLINE( 247)						p = xx;
HXLINE(  60)						q = (q + 1);
            					}
HXDLIN(  60)					if ((q > maxY)) {
HXLINE(  60)						goto _hx_goto_22;
            					}
            				}
            				_hx_goto_22:;
            			}
HXDLIN(  60)			{
HXLINE(  60)				Float x1 = (bx - ((Float)6.));
HXDLIN(  60)				Float y1 = (by - ((Float)6.));
HXDLIN(  60)				int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  60)				int xx1 = p1;
HXDLIN(  60)				int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  60)				int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  60)				int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  60)				while(true){
HXLINE(  60)					{
HXLINE(  60)						p1 = (p1 + 1);
HXDLIN(  60)						int x = (p1 - 1);
HXDLIN(  60)						int this2 = -16711936;
HXDLIN(  60)						int c = this2;
HXDLIN(  60)						bool _hx_tmp;
HXDLIN(  60)						if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE(  60)							_hx_tmp = false;
            						}
HXDLIN(  60)						if (_hx_tmp) {
HXLINE(  60)							int location;
HXDLIN(  60)							if (this1->useVirtualPos) {
HXLINE(  60)								location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE(  60)								location = ::Std_obj::_hx_int(( (Float)(((q1 * this1->width) + x)) ));
            							}
HXDLIN(  60)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  60)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)							int this4 = this3;
HXDLIN(  60)							int this5;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE(  60)								this5 = this4;
            							}
HXDLIN(  60)							Float a1;
HXDLIN(  60)							int this6 = ((this5 >> 24) & 255);
HXDLIN(  60)							if ((this6 == 0)) {
HXLINE(  60)								a1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float r1;
HXDLIN(  60)							int this7 = ((this5 >> 16) & 255);
HXDLIN(  60)							if ((this7 == 0)) {
HXLINE(  60)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float g1;
HXDLIN(  60)							int this8 = ((this5 >> 8) & 255);
HXDLIN(  60)							if ((this8 == 0)) {
HXLINE(  60)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float b1;
HXDLIN(  60)							int this9 = (this5 & 255);
HXDLIN(  60)							if ((this9 == 0)) {
HXLINE(  60)								b1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float a2;
HXDLIN(  60)							int this10 = ((-16711936 >> 24) & 255);
HXDLIN(  60)							if ((this10 == 0)) {
HXLINE(  60)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float r2;
HXDLIN(  60)							int this11 = ((-16711936 >> 16) & 255);
HXDLIN(  60)							if ((this11 == 0)) {
HXLINE(  60)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float g2;
HXDLIN(  60)							int this12 = ((-16711936 >> 8) & 255);
HXDLIN(  60)							if ((this12 == 0)) {
HXLINE(  60)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float b2;
HXDLIN(  60)							int this13 = (-16711936 & 255);
HXDLIN(  60)							if ((this13 == 0)) {
HXLINE(  60)								b2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)							{
HXLINE(  60)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  60)								int value;
HXDLIN(  60)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  60)									value = blended;
            								}
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((location >= 0)) {
HXLINE(  60)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  60)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE(  60)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)							int index;
HXDLIN(  60)							if (this1->useVirtualPos) {
HXLINE(  60)								index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE(  60)								index = ::Std_obj::_hx_int(( (Float)(((q1 * this1->width) + x)) ));
            							}
HXDLIN(  60)							int value;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  60)								value = c;
            							}
HXDLIN(  60)							bool _hx_tmp;
HXDLIN(  60)							if ((index >= 0)) {
HXLINE(  60)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE(  60)								_hx_tmp = false;
            							}
HXDLIN(  60)							if (_hx_tmp) {
HXLINE(  60)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN(  60)					if ((p1 > maxX1)) {
HXLINE( 247)						p1 = xx1;
HXLINE(  60)						q1 = (q1 + 1);
            					}
HXDLIN(  60)					if ((q1 > maxY1)) {
HXLINE(  60)						goto _hx_goto_23;
            					}
            				}
            				_hx_goto_23:;
            			}
HXDLIN(  60)			{
HXLINE(  60)				Float x2 = (cx - ((Float)6.));
HXDLIN(  60)				Float y2 = (cy - ((Float)6.));
HXDLIN(  60)				int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  60)				int xx2 = p2;
HXDLIN(  60)				int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  60)				int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  60)				int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  60)				while(true){
HXLINE(  60)					{
HXLINE(  60)						p2 = (p2 + 1);
HXDLIN(  60)						int x = (p2 - 1);
HXDLIN(  60)						int this2 = -16776961;
HXDLIN(  60)						int c = this2;
HXDLIN(  60)						bool _hx_tmp;
HXDLIN(  60)						if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE(  60)							_hx_tmp = false;
            						}
HXDLIN(  60)						if (_hx_tmp) {
HXLINE(  60)							int location;
HXDLIN(  60)							if (this1->useVirtualPos) {
HXLINE(  60)								location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE(  60)								location = ::Std_obj::_hx_int(( (Float)(((q2 * this1->width) + x)) ));
            							}
HXDLIN(  60)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  60)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)							int this4 = this3;
HXDLIN(  60)							int this5;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE(  60)								this5 = this4;
            							}
HXDLIN(  60)							Float a1;
HXDLIN(  60)							int this6 = ((this5 >> 24) & 255);
HXDLIN(  60)							if ((this6 == 0)) {
HXLINE(  60)								a1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float r1;
HXDLIN(  60)							int this7 = ((this5 >> 16) & 255);
HXDLIN(  60)							if ((this7 == 0)) {
HXLINE(  60)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float g1;
HXDLIN(  60)							int this8 = ((this5 >> 8) & 255);
HXDLIN(  60)							if ((this8 == 0)) {
HXLINE(  60)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float b1;
HXDLIN(  60)							int this9 = (this5 & 255);
HXDLIN(  60)							if ((this9 == 0)) {
HXLINE(  60)								b1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float a2;
HXDLIN(  60)							int this10 = ((-16776961 >> 24) & 255);
HXDLIN(  60)							if ((this10 == 0)) {
HXLINE(  60)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float r2;
HXDLIN(  60)							int this11 = ((-16776961 >> 16) & 255);
HXDLIN(  60)							if ((this11 == 0)) {
HXLINE(  60)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float g2;
HXDLIN(  60)							int this12 = ((-16776961 >> 8) & 255);
HXDLIN(  60)							if ((this12 == 0)) {
HXLINE(  60)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float b2;
HXDLIN(  60)							int this13 = (-16776961 & 255);
HXDLIN(  60)							if ((this13 == 0)) {
HXLINE(  60)								b2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)							{
HXLINE(  60)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  60)								int value;
HXDLIN(  60)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  60)									value = blended;
            								}
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((location >= 0)) {
HXLINE(  60)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  60)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE(  60)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)							int index;
HXDLIN(  60)							if (this1->useVirtualPos) {
HXLINE(  60)								index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE(  60)								index = ::Std_obj::_hx_int(( (Float)(((q2 * this1->width) + x)) ));
            							}
HXDLIN(  60)							int value;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  60)								value = c;
            							}
HXDLIN(  60)							bool _hx_tmp;
HXDLIN(  60)							if ((index >= 0)) {
HXLINE(  60)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE(  60)								_hx_tmp = false;
            							}
HXDLIN(  60)							if (_hx_tmp) {
HXLINE(  60)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN(  60)					if ((p2 > maxX2)) {
HXLINE( 247)						p2 = xx2;
HXLINE(  60)						q2 = (q2 + 1);
            					}
HXDLIN(  60)					if ((q2 > maxY2)) {
HXLINE(  60)						goto _hx_goto_24;
            					}
            				}
            				_hx_goto_24:;
            			}
HXDLIN(  60)			{
HXLINE(  60)				Float x3 = (dx - ((Float)6.));
HXDLIN(  60)				Float y3 = (dy - ((Float)6.));
HXDLIN(  60)				int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  60)				int xx3 = p3;
HXDLIN(  60)				int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  60)				int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  60)				int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  60)				while(true){
HXLINE(  60)					{
HXLINE(  60)						p3 = (p3 + 1);
HXDLIN(  60)						int x = (p3 - 1);
HXDLIN(  60)						int this2 = -1048336;
HXDLIN(  60)						int c = this2;
HXDLIN(  60)						bool _hx_tmp;
HXDLIN(  60)						if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE(  60)							_hx_tmp = false;
            						}
HXDLIN(  60)						if (_hx_tmp) {
HXLINE(  60)							int location;
HXDLIN(  60)							if (this1->useVirtualPos) {
HXLINE(  60)								location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE(  60)								location = ::Std_obj::_hx_int(( (Float)(((q3 * this1->width) + x)) ));
            							}
HXDLIN(  60)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  60)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)							int this4 = this3;
HXDLIN(  60)							int this5;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE(  60)								this5 = this4;
            							}
HXDLIN(  60)							Float a1;
HXDLIN(  60)							int this6 = ((this5 >> 24) & 255);
HXDLIN(  60)							if ((this6 == 0)) {
HXLINE(  60)								a1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float r1;
HXDLIN(  60)							int this7 = ((this5 >> 16) & 255);
HXDLIN(  60)							if ((this7 == 0)) {
HXLINE(  60)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float g1;
HXDLIN(  60)							int this8 = ((this5 >> 8) & 255);
HXDLIN(  60)							if ((this8 == 0)) {
HXLINE(  60)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float b1;
HXDLIN(  60)							int this9 = (this5 & 255);
HXDLIN(  60)							if ((this9 == 0)) {
HXLINE(  60)								b1 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float a2;
HXDLIN(  60)							int this10 = ((-1048336 >> 24) & 255);
HXDLIN(  60)							if ((this10 == 0)) {
HXLINE(  60)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float r2;
HXDLIN(  60)							int this11 = ((-1048336 >> 16) & 255);
HXDLIN(  60)							if ((this11 == 0)) {
HXLINE(  60)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float g2;
HXDLIN(  60)							int this12 = ((-1048336 >> 8) & 255);
HXDLIN(  60)							if ((this12 == 0)) {
HXLINE(  60)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float b2;
HXDLIN(  60)							int this13 = (-1048336 & 255);
HXDLIN(  60)							if ((this13 == 0)) {
HXLINE(  60)								b2 = ((Float)0.);
            							}
            							else {
HXLINE(  60)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN(  60)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)							{
HXLINE(  60)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  60)								int value;
HXDLIN(  60)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  60)									value = blended;
            								}
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((location >= 0)) {
HXLINE(  60)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  60)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE(  60)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)							int index;
HXDLIN(  60)							if (this1->useVirtualPos) {
HXLINE(  60)								index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE(  60)								index = ::Std_obj::_hx_int(( (Float)(((q3 * this1->width) + x)) ));
            							}
HXDLIN(  60)							int value;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  60)								value = c;
            							}
HXDLIN(  60)							bool _hx_tmp;
HXDLIN(  60)							if ((index >= 0)) {
HXLINE(  60)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE(  60)								_hx_tmp = false;
            							}
HXDLIN(  60)							if (_hx_tmp) {
HXLINE(  60)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN(  60)					if ((p3 > maxX3)) {
HXLINE( 247)						p3 = xx3;
HXLINE(  60)						q3 = (q3 + 1);
            					}
HXDLIN(  60)					if ((q3 > maxY3)) {
HXLINE(  60)						goto _hx_goto_25;
            					}
            				}
            				_hx_goto_25:;
            			}
            		}
HXDLIN(  60)		Float bx1 = bx;
HXDLIN(  60)		Float by1 = by;
HXDLIN(  60)		Float cx1 = dx;
HXDLIN(  60)		Float cy1 = dy;
HXDLIN(  60)		bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  60)		if (!(adjustWinding)) {
HXLINE(  60)			Float bx_ = bx1;
HXDLIN(  60)			Float by_ = by1;
HXLINE( 188)			bx1 = cx1;
HXLINE( 189)			by1 = cy1;
HXLINE( 190)			cx1 = bx_;
HXLINE( 191)			cy1 = by_;
            		}
HXLINE(  60)		bool hasUndo = false;
HXDLIN(  60)		Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  60)		Float sx = (cy1 - ay);
HXDLIN(  60)		Float sy = (ax - cx1);
HXDLIN(  60)		Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  60)		Float tx = (ay - by1);
HXDLIN(  60)		Float ty = (bx1 - ax);
HXDLIN(  60)		Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  60)		::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  60)		if ((ax > bx1)) {
HXLINE(  60)			if ((ax > cx1)) {
HXLINE(  60)				int min;
HXDLIN(  60)				if ((bx1 > cx1)) {
HXLINE(  60)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXLINE(  60)					min = ::Math_obj::floor(bx1);
            				}
HXDLIN(  60)				int ii_min = min;
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				xIter3 = this1;
            			}
            			else {
HXLINE(  60)				int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				xIter3 = this1;
            			}
            		}
            		else {
HXLINE(  60)			if ((bx1 > cx1)) {
HXLINE(  60)				int min;
HXDLIN(  60)				if ((ax > cx1)) {
HXLINE(  60)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXLINE(  60)					min = ::Math_obj::ceil(ax);
            				}
HXDLIN(  60)				int ii_min = min;
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				xIter3 = this1;
            			}
            			else {
HXLINE(  60)				int ii_min = ::Math_obj::floor(ax);
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				xIter3 = this1;
            			}
            		}
HXDLIN(  60)		::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  60)		if ((ay > by1)) {
HXLINE(  60)			if ((ay > cy1)) {
HXLINE(  60)				int min;
HXDLIN(  60)				if ((by1 > cy1)) {
HXLINE(  60)					min = ::Math_obj::floor(cy1);
            				}
            				else {
HXLINE(  60)					min = ::Math_obj::floor(by1);
            				}
HXDLIN(  60)				int ii_min = min;
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				yIter3 = this1;
            			}
            			else {
HXLINE(  60)				int ii_min = ::Math_obj::floor(by1);
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				yIter3 = this1;
            			}
            		}
            		else {
HXLINE(  60)			if ((by1 > cy1)) {
HXLINE(  60)				int min;
HXDLIN(  60)				if ((ay > cy1)) {
HXLINE(  60)					min = ::Math_obj::floor(cy1);
            				}
            				else {
HXLINE(  60)					min = ::Math_obj::ceil(ay);
            				}
HXDLIN(  60)				int ii_min = min;
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				yIter3 = this1;
            			}
            			else {
HXLINE(  60)				int ii_min = ::Math_obj::floor(ay);
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				yIter3 = this1;
            			}
            		}
HXDLIN(  60)		::pixelimage::ImageStruct undoImage = null();
HXDLIN(  60)		if (hasUndo) {
HXLINE(  60)			int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  60)			int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  60)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  60)			::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  60)			::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  60)			::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  60)			undoImage = this4;
HXDLIN(  60)			{
HXLINE(  60)				int rectLeft = xIter3->start;
HXDLIN(  60)				int rectTop = yIter3->start;
HXDLIN(  60)				int rectRight = xIter3->max;
HXDLIN(  60)				bool forceClear = false;
HXDLIN(  60)				{
HXLINE(  60)					int _g = rectTop;
HXDLIN(  60)					int _g1 = yIter3->max;
HXDLIN(  60)					while((_g < _g1)){
HXLINE(  60)						_g = (_g + 1);
HXDLIN(  60)						int dy = (_g - 1);
HXDLIN(  60)						{
HXLINE(  60)							int _g1 = rectLeft;
HXDLIN(  60)							int _g2 = rectRight;
HXDLIN(  60)							while((_g1 < _g2)){
HXLINE(  60)								_g1 = (_g1 + 1);
HXDLIN(  60)								int dx = (_g1 - 1);
HXDLIN(  60)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)								int index;
HXDLIN(  60)								if (this1->useVirtualPos) {
HXLINE(  60)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  60)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  60)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)								int col;
HXDLIN(  60)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  60)									col = c;
            								}
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if (this1->useMask) {
HXLINE(  60)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  60)									::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  60)									int index;
HXDLIN(  60)									if (this2->useVirtualPos) {
HXLINE(  60)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            									}
            									else {
HXLINE(  60)										index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            									}
HXDLIN(  60)									::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  60)									int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  60)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)									int v;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  60)										v = c;
            									}
HXDLIN(  60)									int this4 = v;
HXDLIN(  60)									int maskPixel = this4;
HXDLIN(  60)									int this5 = col;
HXDLIN(  60)									int this6 = this5;
HXDLIN(  60)									if ((maskPixel == 0)) {
HXLINE(  60)										int this1 = this6;
HXDLIN(  60)										col = this1;
            									}
            									else {
HXLINE(  60)										Float m0;
HXDLIN(  60)										int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  60)										if ((this1 == 0)) {
HXLINE(  60)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float m1;
HXDLIN(  60)										int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  60)										if ((this2 == 0)) {
HXLINE(  60)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float m2;
HXDLIN(  60)										int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  60)										if ((this3 == 0)) {
HXLINE(  60)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float m3;
HXDLIN(  60)										int this4 = (maskPixel & 255);
HXDLIN(  60)										if ((this4 == 0)) {
HXLINE(  60)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  60)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  60)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  60)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  60)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  60)								if ((col != 0)) {
HXLINE(  60)									int x = (dx - rectLeft);
HXDLIN(  60)									int y = (dy - rectTop);
HXDLIN(  60)									int this1 = col;
HXDLIN(  60)									int c = this1;
HXDLIN(  60)									bool _hx_tmp;
HXDLIN(  60)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)										_hx_tmp = undoImage->transparent;
            									}
            									else {
HXLINE(  60)										_hx_tmp = false;
            									}
HXDLIN(  60)									if (_hx_tmp) {
HXLINE(  60)										int location;
HXDLIN(  60)										if (undoImage->useVirtualPos) {
HXLINE(  60)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            										}
            										else {
HXLINE(  60)											location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            										}
HXDLIN(  60)										::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  60)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)										int this3 = this2;
HXDLIN(  60)										int this4;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											this4 = this3;
            										}
HXDLIN(  60)										Float a1;
HXDLIN(  60)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)										if ((this5 == 0)) {
HXLINE(  60)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r1;
HXDLIN(  60)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)										if ((this6 == 0)) {
HXLINE(  60)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g1;
HXDLIN(  60)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)										if ((this7 == 0)) {
HXLINE(  60)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b1;
HXDLIN(  60)										int this8 = (this4 & 255);
HXDLIN(  60)										if ((this8 == 0)) {
HXLINE(  60)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a2;
HXDLIN(  60)										int this9 = ((col >> 24) & 255);
HXDLIN(  60)										if ((this9 == 0)) {
HXLINE(  60)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r2;
HXDLIN(  60)										int this10 = ((col >> 16) & 255);
HXDLIN(  60)										if ((this10 == 0)) {
HXLINE(  60)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g2;
HXDLIN(  60)										int this11 = ((col >> 8) & 255);
HXDLIN(  60)										if ((this11 == 0)) {
HXLINE(  60)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b2;
HXDLIN(  60)										int this12 = (col & 255);
HXDLIN(  60)										if ((this12 == 0)) {
HXLINE(  60)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)										{
HXLINE(  60)											::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  60)											int value;
HXDLIN(  60)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  60)												value = blended;
            											}
HXDLIN(  60)											bool _hx_tmp;
HXDLIN(  60)											if ((location >= 0)) {
HXLINE(  60)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE(  60)												_hx_tmp = false;
            											}
HXDLIN(  60)											if (_hx_tmp) {
HXLINE(  60)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  60)										int index;
HXDLIN(  60)										if (undoImage->useVirtualPos) {
HXLINE(  60)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            										}
            										else {
HXLINE(  60)											index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            										}
HXDLIN(  60)										int value;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  60)											value = c;
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((index >= 0)) {
HXLINE(  60)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  60)									if (forceClear) {
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  60)										int x = (dx - rectLeft);
HXDLIN(  60)										int y = (dy - rectTop);
HXDLIN(  60)										int index;
HXDLIN(  60)										if (undoImage->useVirtualPos) {
HXLINE(  60)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            										}
            										else {
HXLINE(  60)											index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((index >= 0)) {
HXLINE(  60)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  60)		bool foundY = false;
HXDLIN(  60)		Float s = ((Float)0.);
HXDLIN(  60)		Float t = ((Float)0.);
HXDLIN(  60)		Float sxx = ((Float)0.);
HXDLIN(  60)		Float txx = ((Float)0.);
HXDLIN(  60)		int _g_min = xIter3->start;
HXDLIN(  60)		int _g_max = xIter3->max;
HXDLIN(  60)		while((_g_min < _g_max)){
HXLINE(  60)			_g_min = (_g_min + 1);
HXDLIN(  60)			int x = (_g_min - 1);
HXLINE( 223)			sxx = (sx * ( (Float)(x) ));
HXLINE( 224)			txx = (tx * ( (Float)(x) ));
HXLINE( 225)			foundY = false;
HXLINE(  60)			{
HXLINE(  60)				int _g_min1 = yIter3->start;
HXDLIN(  60)				int _g_max = yIter3->max;
HXDLIN(  60)				while((_g_min1 < _g_max)){
HXLINE(  60)					_g_min1 = (_g_min1 + 1);
HXDLIN(  60)					int y = (_g_min1 - 1);
HXLINE( 227)					s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)					t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  60)					bool _hx_tmp;
HXDLIN(  60)					if (!((s <= 0))) {
HXLINE(  60)						_hx_tmp = (t <= 0);
            					}
            					else {
HXLINE(  60)						_hx_tmp = true;
            					}
HXDLIN(  60)					if (_hx_tmp) {
HXLINE(  60)						if (foundY) {
HXLINE(  60)							goto _hx_goto_29;
            						}
            					}
            					else {
HXLINE(  60)						if (((s + t) < A)) {
HXLINE(  60)							int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  60)							int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  60)							::haxe::io::ArrayBufferViewImpl this2 = tileImage->image;
HXDLIN(  60)							int index;
HXDLIN(  60)							if (tileImage->useVirtualPos) {
HXLINE(  60)								index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            							}
            							else {
HXLINE(  60)								index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            							}
HXDLIN(  60)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)							int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)							int color;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  60)								color = c;
            							}
HXDLIN(  60)							{
HXLINE(  60)								int this3 = color;
HXDLIN(  60)								int c1 = this3;
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  60)									_hx_tmp = this1->transparent;
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									int location;
HXDLIN(  60)									if (this1->useVirtualPos) {
HXLINE(  60)										location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            									}
            									else {
HXLINE(  60)										location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            									}
HXDLIN(  60)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  60)									int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)									int this4 = this3;
HXDLIN(  60)									int this5;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            									}
            									else {
HXLINE(  60)										this5 = this4;
            									}
HXDLIN(  60)									Float a1;
HXDLIN(  60)									int this6 = ((this5 >> 24) & 255);
HXDLIN(  60)									if ((this6 == 0)) {
HXLINE(  60)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r1;
HXDLIN(  60)									int this7 = ((this5 >> 16) & 255);
HXDLIN(  60)									if ((this7 == 0)) {
HXLINE(  60)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g1;
HXDLIN(  60)									int this8 = ((this5 >> 8) & 255);
HXDLIN(  60)									if ((this8 == 0)) {
HXLINE(  60)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b1;
HXDLIN(  60)									int this9 = (this5 & 255);
HXDLIN(  60)									if ((this9 == 0)) {
HXLINE(  60)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a2;
HXDLIN(  60)									int this10 = ((color >> 24) & 255);
HXDLIN(  60)									if ((this10 == 0)) {
HXLINE(  60)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r2;
HXDLIN(  60)									int this11 = ((color >> 16) & 255);
HXDLIN(  60)									if ((this11 == 0)) {
HXLINE(  60)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g2;
HXDLIN(  60)									int this12 = ((color >> 8) & 255);
HXDLIN(  60)									if ((this12 == 0)) {
HXLINE(  60)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b2;
HXDLIN(  60)									int this13 = (color & 255);
HXDLIN(  60)									if ((this13 == 0)) {
HXLINE(  60)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)									{
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  60)										int value;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  60)											value = blended;
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((location >= 0)) {
HXLINE(  60)											_hx_tmp = (location < (this14->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  60)											int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  60)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)									int index;
HXDLIN(  60)									if (this1->useVirtualPos) {
HXLINE(  60)										index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            									}
            									else {
HXLINE(  60)										index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            									}
HXDLIN(  60)									int value;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE(  60)										value = c1;
            									}
HXDLIN(  60)									bool _hx_tmp;
HXDLIN(  60)									if ((index >= 0)) {
HXLINE(  60)										_hx_tmp = (index < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  60)										_hx_tmp = false;
            									}
HXDLIN(  60)									if (_hx_tmp) {
HXLINE(  60)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)										int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXLINE( 237)							foundY = true;
            						}
            						else {
HXLINE(  60)							if (foundY) {
HXLINE(  60)								goto _hx_goto_29;
            							}
            						}
            					}
            				}
            				_hx_goto_29:;
            			}
            		}
HXDLIN(  60)		Float bx2 = cx;
HXDLIN(  60)		Float by2 = cy;
HXDLIN(  60)		Float cx2 = dx;
HXDLIN(  60)		Float cy2 = dy;
HXDLIN(  60)		bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  60)		if (!(adjustWinding1)) {
HXLINE(  60)			Float bx_ = bx2;
HXDLIN(  60)			Float by_ = by2;
HXLINE( 188)			bx2 = cx2;
HXLINE( 189)			by2 = cy2;
HXLINE( 190)			cx2 = bx_;
HXLINE( 191)			cy2 = by_;
            		}
HXLINE(  60)		bool hasUndo1 = false;
HXDLIN(  60)		Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  60)		Float sx1 = (cy2 - by);
HXDLIN(  60)		Float sy1 = (bx - cx2);
HXDLIN(  60)		Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  60)		Float tx1 = (by - by2);
HXDLIN(  60)		Float ty1 = (bx2 - bx);
HXDLIN(  60)		Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  60)		::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  60)		if ((bx > bx2)) {
HXLINE(  60)			if ((bx > cx2)) {
HXLINE(  60)				int min;
HXDLIN(  60)				if ((bx2 > cx2)) {
HXLINE(  60)					min = ::Math_obj::floor(cx2);
            				}
            				else {
HXLINE(  60)					min = ::Math_obj::floor(bx2);
            				}
HXDLIN(  60)				int ii_min = min;
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				xIter31 = this1;
            			}
            			else {
HXLINE(  60)				int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				xIter31 = this1;
            			}
            		}
            		else {
HXLINE(  60)			if ((bx2 > cx2)) {
HXLINE(  60)				int min;
HXDLIN(  60)				if ((bx > cx2)) {
HXLINE(  60)					min = ::Math_obj::floor(cx2);
            				}
            				else {
HXLINE(  60)					min = ::Math_obj::ceil(bx);
            				}
HXDLIN(  60)				int ii_min = min;
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				xIter31 = this1;
            			}
            			else {
HXLINE(  60)				int ii_min = ::Math_obj::floor(bx);
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				xIter31 = this1;
            			}
            		}
HXDLIN(  60)		::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  60)		if ((by > by2)) {
HXLINE(  60)			if ((by > cy2)) {
HXLINE(  60)				int min;
HXDLIN(  60)				if ((by2 > cy2)) {
HXLINE(  60)					min = ::Math_obj::floor(cy2);
            				}
            				else {
HXLINE(  60)					min = ::Math_obj::floor(by2);
            				}
HXDLIN(  60)				int ii_min = min;
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(by);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				yIter31 = this1;
            			}
            			else {
HXLINE(  60)				int ii_min = ::Math_obj::floor(by2);
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				yIter31 = this1;
            			}
            		}
            		else {
HXLINE(  60)			if ((by2 > cy2)) {
HXLINE(  60)				int min;
HXDLIN(  60)				if ((by > cy2)) {
HXLINE(  60)					min = ::Math_obj::floor(cy2);
            				}
            				else {
HXLINE(  60)					min = ::Math_obj::ceil(by);
            				}
HXDLIN(  60)				int ii_min = min;
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				yIter31 = this1;
            			}
            			else {
HXLINE(  60)				int ii_min = ::Math_obj::floor(by);
HXDLIN(  60)				int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  60)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)				yIter31 = this1;
            			}
            		}
HXDLIN(  60)		::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  60)		if (hasUndo1) {
HXLINE(  60)			int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  60)			int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  60)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  60)			::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  60)			::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  60)			::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  60)			undoImage1 = this4;
HXDLIN(  60)			{
HXLINE(  60)				int rectLeft = xIter31->start;
HXDLIN(  60)				int rectTop = yIter31->start;
HXDLIN(  60)				int rectRight = xIter31->max;
HXDLIN(  60)				bool forceClear = false;
HXDLIN(  60)				{
HXLINE(  60)					int _g = rectTop;
HXDLIN(  60)					int _g1 = yIter31->max;
HXDLIN(  60)					while((_g < _g1)){
HXLINE(  60)						_g = (_g + 1);
HXDLIN(  60)						int dy = (_g - 1);
HXDLIN(  60)						{
HXLINE(  60)							int _g1 = rectLeft;
HXDLIN(  60)							int _g2 = rectRight;
HXDLIN(  60)							while((_g1 < _g2)){
HXLINE(  60)								_g1 = (_g1 + 1);
HXDLIN(  60)								int dx = (_g1 - 1);
HXDLIN(  60)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)								int index;
HXDLIN(  60)								if (this1->useVirtualPos) {
HXLINE(  60)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  60)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  60)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)								int col;
HXDLIN(  60)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  60)									col = c;
            								}
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if (this1->useMask) {
HXLINE(  60)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  60)									::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  60)									int index;
HXDLIN(  60)									if (this2->useVirtualPos) {
HXLINE(  60)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            									}
            									else {
HXLINE(  60)										index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            									}
HXDLIN(  60)									::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  60)									int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  60)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)									int v;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  60)										v = c;
            									}
HXDLIN(  60)									int this4 = v;
HXDLIN(  60)									int maskPixel = this4;
HXDLIN(  60)									int this5 = col;
HXDLIN(  60)									int this6 = this5;
HXDLIN(  60)									if ((maskPixel == 0)) {
HXLINE(  60)										int this1 = this6;
HXDLIN(  60)										col = this1;
            									}
            									else {
HXLINE(  60)										Float m0;
HXDLIN(  60)										int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  60)										if ((this1 == 0)) {
HXLINE(  60)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float m1;
HXDLIN(  60)										int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  60)										if ((this2 == 0)) {
HXLINE(  60)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float m2;
HXDLIN(  60)										int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  60)										if ((this3 == 0)) {
HXLINE(  60)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float m3;
HXDLIN(  60)										int this4 = (maskPixel & 255);
HXDLIN(  60)										if ((this4 == 0)) {
HXLINE(  60)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  60)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  60)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  60)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  60)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  60)								if ((col != 0)) {
HXLINE(  60)									int x = (dx - rectLeft);
HXDLIN(  60)									int y = (dy - rectTop);
HXDLIN(  60)									int this1 = col;
HXDLIN(  60)									int c = this1;
HXDLIN(  60)									bool _hx_tmp;
HXDLIN(  60)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)										_hx_tmp = undoImage1->transparent;
            									}
            									else {
HXLINE(  60)										_hx_tmp = false;
            									}
HXDLIN(  60)									if (_hx_tmp) {
HXLINE(  60)										int location;
HXDLIN(  60)										if (undoImage1->useVirtualPos) {
HXLINE(  60)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            										}
            										else {
HXLINE(  60)											location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            										}
HXDLIN(  60)										::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  60)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)										int this3 = this2;
HXDLIN(  60)										int this4;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											this4 = this3;
            										}
HXDLIN(  60)										Float a1;
HXDLIN(  60)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)										if ((this5 == 0)) {
HXLINE(  60)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r1;
HXDLIN(  60)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)										if ((this6 == 0)) {
HXLINE(  60)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g1;
HXDLIN(  60)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)										if ((this7 == 0)) {
HXLINE(  60)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b1;
HXDLIN(  60)										int this8 = (this4 & 255);
HXDLIN(  60)										if ((this8 == 0)) {
HXLINE(  60)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a2;
HXDLIN(  60)										int this9 = ((col >> 24) & 255);
HXDLIN(  60)										if ((this9 == 0)) {
HXLINE(  60)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r2;
HXDLIN(  60)										int this10 = ((col >> 16) & 255);
HXDLIN(  60)										if ((this10 == 0)) {
HXLINE(  60)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g2;
HXDLIN(  60)										int this11 = ((col >> 8) & 255);
HXDLIN(  60)										if ((this11 == 0)) {
HXLINE(  60)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b2;
HXDLIN(  60)										int this12 = (col & 255);
HXDLIN(  60)										if ((this12 == 0)) {
HXLINE(  60)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)										{
HXLINE(  60)											::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  60)											int value;
HXDLIN(  60)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  60)												value = blended;
            											}
HXDLIN(  60)											bool _hx_tmp;
HXDLIN(  60)											if ((location >= 0)) {
HXLINE(  60)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE(  60)												_hx_tmp = false;
            											}
HXDLIN(  60)											if (_hx_tmp) {
HXLINE(  60)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  60)										int index;
HXDLIN(  60)										if (undoImage1->useVirtualPos) {
HXLINE(  60)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            										}
            										else {
HXLINE(  60)											index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            										}
HXDLIN(  60)										int value;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  60)											value = c;
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((index >= 0)) {
HXLINE(  60)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  60)									if (forceClear) {
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  60)										int x = (dx - rectLeft);
HXDLIN(  60)										int y = (dy - rectTop);
HXDLIN(  60)										int index;
HXDLIN(  60)										if (undoImage1->useVirtualPos) {
HXLINE(  60)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            										}
            										else {
HXLINE(  60)											index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((index >= 0)) {
HXLINE(  60)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  60)		bool foundY1 = false;
HXDLIN(  60)		Float s1 = ((Float)0.);
HXDLIN(  60)		Float t1 = ((Float)0.);
HXDLIN(  60)		Float sxx1 = ((Float)0.);
HXDLIN(  60)		Float txx1 = ((Float)0.);
HXDLIN(  60)		int _g_min1 = xIter31->start;
HXDLIN(  60)		int _g_max1 = xIter31->max;
HXDLIN(  60)		while((_g_min1 < _g_max1)){
HXLINE(  60)			_g_min1 = (_g_min1 + 1);
HXDLIN(  60)			int x = (_g_min1 - 1);
HXLINE( 223)			sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)			txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)			foundY1 = false;
HXLINE(  60)			{
HXLINE(  60)				int _g_min = yIter31->start;
HXDLIN(  60)				int _g_max = yIter31->max;
HXDLIN(  60)				while((_g_min < _g_max)){
HXLINE(  60)					_g_min = (_g_min + 1);
HXDLIN(  60)					int y = (_g_min - 1);
HXLINE( 227)					s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)					t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  60)					bool _hx_tmp;
HXDLIN(  60)					if (!((s1 <= 0))) {
HXLINE(  60)						_hx_tmp = (t1 <= 0);
            					}
            					else {
HXLINE(  60)						_hx_tmp = true;
            					}
HXDLIN(  60)					if (_hx_tmp) {
HXLINE(  60)						if (foundY1) {
HXLINE(  60)							goto _hx_goto_33;
            						}
            					}
            					else {
HXLINE(  60)						if (((s1 + t1) < A1)) {
HXLINE(  60)							int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  60)							int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  60)							::haxe::io::ArrayBufferViewImpl this2 = tileImage->image;
HXDLIN(  60)							int index;
HXDLIN(  60)							if (tileImage->useVirtualPos) {
HXLINE(  60)								index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            							}
            							else {
HXLINE(  60)								index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            							}
HXDLIN(  60)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)							int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)							int color;
HXDLIN(  60)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)								color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  60)								color = c;
            							}
HXDLIN(  60)							{
HXLINE(  60)								int this3 = color;
HXDLIN(  60)								int c1 = this3;
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  60)									_hx_tmp = this1->transparent;
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									int location;
HXDLIN(  60)									if (this1->useVirtualPos) {
HXLINE(  60)										location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            									}
            									else {
HXLINE(  60)										location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            									}
HXDLIN(  60)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  60)									int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)									int this4 = this3;
HXDLIN(  60)									int this5;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            									}
            									else {
HXLINE(  60)										this5 = this4;
            									}
HXDLIN(  60)									Float a1;
HXDLIN(  60)									int this6 = ((this5 >> 24) & 255);
HXDLIN(  60)									if ((this6 == 0)) {
HXLINE(  60)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r1;
HXDLIN(  60)									int this7 = ((this5 >> 16) & 255);
HXDLIN(  60)									if ((this7 == 0)) {
HXLINE(  60)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g1;
HXDLIN(  60)									int this8 = ((this5 >> 8) & 255);
HXDLIN(  60)									if ((this8 == 0)) {
HXLINE(  60)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b1;
HXDLIN(  60)									int this9 = (this5 & 255);
HXDLIN(  60)									if ((this9 == 0)) {
HXLINE(  60)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a2;
HXDLIN(  60)									int this10 = ((color >> 24) & 255);
HXDLIN(  60)									if ((this10 == 0)) {
HXLINE(  60)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r2;
HXDLIN(  60)									int this11 = ((color >> 16) & 255);
HXDLIN(  60)									if ((this11 == 0)) {
HXLINE(  60)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g2;
HXDLIN(  60)									int this12 = ((color >> 8) & 255);
HXDLIN(  60)									if ((this12 == 0)) {
HXLINE(  60)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b2;
HXDLIN(  60)									int this13 = (color & 255);
HXDLIN(  60)									if ((this13 == 0)) {
HXLINE(  60)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)									{
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  60)										int value;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  60)											value = blended;
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((location >= 0)) {
HXLINE(  60)											_hx_tmp = (location < (this14->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  60)											int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  60)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)									int index;
HXDLIN(  60)									if (this1->useVirtualPos) {
HXLINE(  60)										index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            									}
            									else {
HXLINE(  60)										index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            									}
HXDLIN(  60)									int value;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE(  60)										value = c1;
            									}
HXDLIN(  60)									bool _hx_tmp;
HXDLIN(  60)									if ((index >= 0)) {
HXLINE(  60)										_hx_tmp = (index < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  60)										_hx_tmp = false;
            									}
HXDLIN(  60)									if (_hx_tmp) {
HXLINE(  60)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)										int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXLINE( 237)							foundY1 = true;
            						}
            						else {
HXLINE(  60)							if (foundY1) {
HXLINE(  60)								goto _hx_goto_33;
            							}
            						}
            					}
            				}
            				_hx_goto_33:;
            			}
            		}
HXDLIN(  60)		::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  60)		this->info = v;
HXLINE(  63)		bool _hx_tmp;
HXDLIN(  63)		if (::hx::IsNotNull( this->info )) {
HXLINE(  63)			_hx_tmp = ::hx::IsNotNull( this->oldInfo );
            		}
            		else {
HXLINE(  63)			_hx_tmp = false;
            		}
HXDLIN(  63)		if (_hx_tmp) {
HXLINE(  64)			::pixelimage::ImageStruct this1 = this->pixelImage;
HXDLIN(  64)			Float ax = ((this->oldInfo->bx * this->scaleX) + this->translateX);
HXDLIN(  64)			Float ay = ((this->oldInfo->by * this->scaleY) + this->translateY);
HXDLIN(  64)			Float bx = ((this->info->ax * this->scaleX) + this->translateX);
HXDLIN(  64)			Float by = ((this->info->ay * this->scaleY) + this->translateY);
HXDLIN(  64)			Float cx = ((this->info->dx * this->scaleX) + this->translateX);
HXDLIN(  64)			Float cy = ((this->info->dy * this->scaleY) + this->translateY);
HXDLIN(  64)			Float dx = ((this->oldInfo->cx * this->scaleX) + this->translateX);
HXDLIN(  64)			Float dy = ((this->oldInfo->cy * this->scaleY) + this->translateY);
HXDLIN(  64)			::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN(  64)			{
HXLINE(  64)				{
HXLINE(  64)					Float bx1 = bx;
HXDLIN(  64)					Float by1 = by;
HXDLIN(  64)					Float cx1 = dx;
HXDLIN(  64)					Float cy1 = dy;
HXDLIN(  64)					bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  64)					if (!(adjustWinding)) {
HXLINE(  64)						Float bx_ = bx1;
HXDLIN(  64)						Float by_ = by1;
HXLINE( 188)						bx1 = cx1;
HXLINE( 189)						by1 = cy1;
HXLINE( 190)						cx1 = bx_;
HXLINE( 191)						cy1 = by_;
            					}
HXLINE(  64)					{
HXLINE(  64)						bool hasUndo = false;
HXDLIN(  64)						Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  64)						Float sx = (cy1 - ay);
HXDLIN(  64)						Float sy = (ax - cx1);
HXDLIN(  64)						Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  64)						Float tx = (ay - by1);
HXDLIN(  64)						Float ty = (bx1 - ax);
HXDLIN(  64)						Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  64)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  64)						if ((ax > bx1)) {
HXLINE(  64)							if ((ax > cx1)) {
HXLINE(  64)								int min;
HXDLIN(  64)								if ((bx1 > cx1)) {
HXLINE(  64)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  64)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN(  64)								int ii_min = min;
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								xIter3 = this1;
            							}
            							else {
HXLINE(  64)								int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  64)							if ((bx1 > cx1)) {
HXLINE(  64)								int min;
HXDLIN(  64)								if ((ax > cx1)) {
HXLINE(  64)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  64)									min = ::Math_obj::ceil(ax);
            								}
HXDLIN(  64)								int ii_min = min;
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								xIter3 = this1;
            							}
            							else {
HXLINE(  64)								int ii_min = ::Math_obj::floor(ax);
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								xIter3 = this1;
            							}
            						}
HXDLIN(  64)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  64)						if ((ay > by1)) {
HXLINE(  64)							if ((ay > cy1)) {
HXLINE(  64)								int min;
HXDLIN(  64)								if ((by1 > cy1)) {
HXLINE(  64)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  64)									min = ::Math_obj::floor(by1);
            								}
HXDLIN(  64)								int ii_min = min;
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								yIter3 = this1;
            							}
            							else {
HXLINE(  64)								int ii_min = ::Math_obj::floor(by1);
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  64)							if ((by1 > cy1)) {
HXLINE(  64)								int min;
HXDLIN(  64)								if ((ay > cy1)) {
HXLINE(  64)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  64)									min = ::Math_obj::ceil(ay);
            								}
HXDLIN(  64)								int ii_min = min;
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								yIter3 = this1;
            							}
            							else {
HXLINE(  64)								int ii_min = ::Math_obj::floor(ay);
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								yIter3 = this1;
            							}
            						}
HXDLIN(  64)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  64)						if (hasUndo) {
HXLINE(  64)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  64)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  64)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  64)							::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  64)							::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  64)							::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  64)							undoImage = this4;
HXDLIN(  64)							{
HXLINE(  64)								int rectLeft = xIter3->start;
HXDLIN(  64)								int rectTop = yIter3->start;
HXDLIN(  64)								int rectRight = xIter3->max;
HXDLIN(  64)								bool forceClear = false;
HXDLIN(  64)								{
HXLINE(  64)									int _g = rectTop;
HXDLIN(  64)									int _g1 = yIter3->max;
HXDLIN(  64)									while((_g < _g1)){
HXLINE(  64)										_g = (_g + 1);
HXDLIN(  64)										int dy = (_g - 1);
HXDLIN(  64)										{
HXLINE(  64)											int _g1 = rectLeft;
HXDLIN(  64)											int _g2 = rectRight;
HXDLIN(  64)											while((_g1 < _g2)){
HXLINE(  64)												_g1 = (_g1 + 1);
HXDLIN(  64)												int dx = (_g1 - 1);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)												int index;
HXDLIN(  64)												if (this1->useVirtualPos) {
HXLINE(  64)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  64)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  64)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)												int col;
HXDLIN(  64)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  64)													col = c;
            												}
HXDLIN(  64)												bool _hx_tmp;
HXDLIN(  64)												if (this1->useMask) {
HXLINE(  64)													_hx_tmp = ::hx::IsNotNull( this1->mask );
            												}
            												else {
HXLINE(  64)													_hx_tmp = false;
            												}
HXDLIN(  64)												if (_hx_tmp) {
HXLINE(  64)													::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  64)													::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  64)													int index;
HXDLIN(  64)													if (this2->useVirtualPos) {
HXLINE(  64)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            													}
            													else {
HXLINE(  64)														index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            													}
HXDLIN(  64)													::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  64)													int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  64)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)													int v;
HXDLIN(  64)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  64)														v = c;
            													}
HXDLIN(  64)													int this4 = v;
HXDLIN(  64)													int maskPixel = this4;
HXDLIN(  64)													int this5 = col;
HXDLIN(  64)													int this6 = this5;
HXDLIN(  64)													if ((maskPixel == 0)) {
HXLINE(  64)														int this1 = this6;
HXDLIN(  64)														col = this1;
            													}
            													else {
HXLINE(  64)														Float m0;
HXDLIN(  64)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  64)														if ((this1 == 0)) {
HXLINE(  64)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m1;
HXDLIN(  64)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  64)														if ((this2 == 0)) {
HXLINE(  64)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m2;
HXDLIN(  64)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  64)														if ((this3 == 0)) {
HXLINE(  64)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m3;
HXDLIN(  64)														int this4 = (maskPixel & 255);
HXDLIN(  64)														if ((this4 == 0)) {
HXLINE(  64)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  64)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  64)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  64)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  64)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  64)												if ((col != 0)) {
HXLINE(  64)													int x = (dx - rectLeft);
HXDLIN(  64)													int y = (dy - rectTop);
HXDLIN(  64)													int this1 = col;
HXDLIN(  64)													int c = this1;
HXDLIN(  64)													bool _hx_tmp;
HXDLIN(  64)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  64)														_hx_tmp = false;
            													}
HXDLIN(  64)													if (_hx_tmp) {
HXLINE(  64)														int location;
HXDLIN(  64)														if (undoImage->useVirtualPos) {
HXLINE(  64)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  64)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  64)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)														int this3 = this2;
HXDLIN(  64)														int this4;
HXDLIN(  64)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															this4 = this3;
            														}
HXDLIN(  64)														Float a1;
HXDLIN(  64)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)														if ((this5 == 0)) {
HXLINE(  64)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r1;
HXDLIN(  64)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)														if ((this6 == 0)) {
HXLINE(  64)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g1;
HXDLIN(  64)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)														if ((this7 == 0)) {
HXLINE(  64)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b1;
HXDLIN(  64)														int this8 = (this4 & 255);
HXDLIN(  64)														if ((this8 == 0)) {
HXLINE(  64)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a2;
HXDLIN(  64)														int this9 = ((col >> 24) & 255);
HXDLIN(  64)														if ((this9 == 0)) {
HXLINE(  64)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r2;
HXDLIN(  64)														int this10 = ((col >> 16) & 255);
HXDLIN(  64)														if ((this10 == 0)) {
HXLINE(  64)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g2;
HXDLIN(  64)														int this11 = ((col >> 8) & 255);
HXDLIN(  64)														if ((this11 == 0)) {
HXLINE(  64)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b2;
HXDLIN(  64)														int this12 = (col & 255);
HXDLIN(  64)														if ((this12 == 0)) {
HXLINE(  64)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)														{
HXLINE(  64)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  64)															int value;
HXDLIN(  64)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  64)																value = blended;
            															}
HXDLIN(  64)															bool _hx_tmp;
HXDLIN(  64)															if ((location >= 0)) {
HXLINE(  64)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  64)																_hx_tmp = false;
            															}
HXDLIN(  64)															if (_hx_tmp) {
HXLINE(  64)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  64)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)														int index;
HXDLIN(  64)														if (undoImage->useVirtualPos) {
HXLINE(  64)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  64)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  64)														int value;
HXDLIN(  64)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  64)															value = c;
            														}
HXDLIN(  64)														bool _hx_tmp;
HXDLIN(  64)														if ((index >= 0)) {
HXLINE(  64)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  64)															_hx_tmp = false;
            														}
HXDLIN(  64)														if (_hx_tmp) {
HXLINE(  64)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  64)													if (forceClear) {
HXLINE(  64)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)														int x = (dx - rectLeft);
HXDLIN(  64)														int y = (dy - rectTop);
HXDLIN(  64)														int index;
HXDLIN(  64)														if (undoImage->useVirtualPos) {
HXLINE(  64)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  64)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  64)														bool _hx_tmp;
HXDLIN(  64)														if ((index >= 0)) {
HXLINE(  64)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  64)															_hx_tmp = false;
            														}
HXDLIN(  64)														if (_hx_tmp) {
HXLINE(  64)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  64)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						bool foundY = false;
HXDLIN(  64)						Float s = ((Float)0.);
HXDLIN(  64)						Float t = ((Float)0.);
HXDLIN(  64)						Float sxx = ((Float)0.);
HXDLIN(  64)						Float txx = ((Float)0.);
HXDLIN(  64)						{
HXLINE(  64)							int _g_min = xIter3->start;
HXDLIN(  64)							int _g_max = xIter3->max;
HXDLIN(  64)							while((_g_min < _g_max)){
HXLINE(  64)								_g_min = (_g_min + 1);
HXDLIN(  64)								int x = (_g_min - 1);
HXLINE( 223)								sxx = (sx * ( (Float)(x) ));
HXLINE( 224)								txx = (tx * ( (Float)(x) ));
HXLINE( 225)								foundY = false;
HXLINE(  64)								{
HXLINE(  64)									int _g_min1 = yIter3->start;
HXDLIN(  64)									int _g_max = yIter3->max;
HXDLIN(  64)									while((_g_min1 < _g_max)){
HXLINE(  64)										_g_min1 = (_g_min1 + 1);
HXDLIN(  64)										int y = (_g_min1 - 1);
HXLINE( 227)										s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)										t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  64)										bool _hx_tmp;
HXDLIN(  64)										if (!((s <= 0))) {
HXLINE(  64)											_hx_tmp = (t <= 0);
            										}
            										else {
HXLINE(  64)											_hx_tmp = true;
            										}
HXDLIN(  64)										if (_hx_tmp) {
HXLINE(  64)											if (foundY) {
HXLINE(  64)												goto _hx_goto_37;
            											}
            										}
            										else {
HXLINE(  64)											if (((s + t) < A)) {
HXLINE(  64)												int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  64)												int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this2 = tileImage->image;
HXDLIN(  64)												int index;
HXDLIN(  64)												if (tileImage->useVirtualPos) {
HXLINE(  64)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            												}
            												else {
HXLINE(  64)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            												}
HXDLIN(  64)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)												int color;
HXDLIN(  64)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  64)													color = c;
            												}
HXDLIN(  64)												{
HXLINE(  64)													int this3 = color;
HXDLIN(  64)													int c1 = this3;
HXDLIN(  64)													bool _hx_tmp;
HXDLIN(  64)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  64)														_hx_tmp = this1->transparent;
            													}
            													else {
HXLINE(  64)														_hx_tmp = false;
            													}
HXDLIN(  64)													if (_hx_tmp) {
HXLINE(  64)														int location;
HXDLIN(  64)														if (this1->useVirtualPos) {
HXLINE(  64)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            														}
            														else {
HXLINE(  64)															location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            														}
HXDLIN(  64)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)														int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  64)														int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)														int this4 = this3;
HXDLIN(  64)														int this5;
HXDLIN(  64)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															this5 = this4;
            														}
HXDLIN(  64)														Float a1;
HXDLIN(  64)														int this6 = ((this5 >> 24) & 255);
HXDLIN(  64)														if ((this6 == 0)) {
HXLINE(  64)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r1;
HXDLIN(  64)														int this7 = ((this5 >> 16) & 255);
HXDLIN(  64)														if ((this7 == 0)) {
HXLINE(  64)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g1;
HXDLIN(  64)														int this8 = ((this5 >> 8) & 255);
HXDLIN(  64)														if ((this8 == 0)) {
HXLINE(  64)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b1;
HXDLIN(  64)														int this9 = (this5 & 255);
HXDLIN(  64)														if ((this9 == 0)) {
HXLINE(  64)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a2;
HXDLIN(  64)														int this10 = ((color >> 24) & 255);
HXDLIN(  64)														if ((this10 == 0)) {
HXLINE(  64)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r2;
HXDLIN(  64)														int this11 = ((color >> 16) & 255);
HXDLIN(  64)														if ((this11 == 0)) {
HXLINE(  64)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g2;
HXDLIN(  64)														int this12 = ((color >> 8) & 255);
HXDLIN(  64)														if ((this12 == 0)) {
HXLINE(  64)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b2;
HXDLIN(  64)														int this13 = (color & 255);
HXDLIN(  64)														if ((this13 == 0)) {
HXLINE(  64)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)														{
HXLINE(  64)															::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  64)															int value;
HXDLIN(  64)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  64)																value = blended;
            															}
HXDLIN(  64)															bool _hx_tmp;
HXDLIN(  64)															if ((location >= 0)) {
HXLINE(  64)																_hx_tmp = (location < (this14->byteLength >> 2));
            															}
            															else {
HXLINE(  64)																_hx_tmp = false;
            															}
HXDLIN(  64)															if (_hx_tmp) {
HXLINE(  64)																::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  64)																int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  64)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  64)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)														int index;
HXDLIN(  64)														if (this1->useVirtualPos) {
HXLINE(  64)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            														}
            														else {
HXLINE(  64)															index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            														}
HXDLIN(  64)														int value;
HXDLIN(  64)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															value = c1;
            														}
HXDLIN(  64)														bool _hx_tmp;
HXDLIN(  64)														if ((index >= 0)) {
HXLINE(  64)															_hx_tmp = (index < (this2->byteLength >> 2));
            														}
            														else {
HXLINE(  64)															_hx_tmp = false;
            														}
HXDLIN(  64)														if (_hx_tmp) {
HXLINE(  64)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY = true;
            											}
            											else {
HXLINE(  64)												if (foundY) {
HXLINE(  64)													goto _hx_goto_37;
            												}
            											}
            										}
            									}
            									_hx_goto_37:;
            								}
            							}
            						}
            					}
            				}
HXDLIN(  64)				{
HXLINE(  64)					Float bx2 = cx;
HXDLIN(  64)					Float by2 = cy;
HXDLIN(  64)					Float cx2 = dx;
HXDLIN(  64)					Float cy2 = dy;
HXDLIN(  64)					bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  64)					if (!(adjustWinding1)) {
HXLINE(  64)						Float bx_ = bx2;
HXDLIN(  64)						Float by_ = by2;
HXLINE( 188)						bx2 = cx2;
HXLINE( 189)						by2 = cy2;
HXLINE( 190)						cx2 = bx_;
HXLINE( 191)						cy2 = by_;
            					}
HXLINE(  64)					{
HXLINE(  64)						bool hasUndo1 = false;
HXDLIN(  64)						Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  64)						Float sx1 = (cy2 - by);
HXDLIN(  64)						Float sy1 = (bx - cx2);
HXDLIN(  64)						Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  64)						Float tx1 = (by - by2);
HXDLIN(  64)						Float ty1 = (bx2 - bx);
HXDLIN(  64)						Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  64)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  64)						if ((bx > bx2)) {
HXLINE(  64)							if ((bx > cx2)) {
HXLINE(  64)								int min;
HXDLIN(  64)								if ((bx2 > cx2)) {
HXLINE(  64)									min = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE(  64)									min = ::Math_obj::floor(bx2);
            								}
HXDLIN(  64)								int ii_min = min;
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								xIter31 = this1;
            							}
            							else {
HXLINE(  64)								int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE(  64)							if ((bx2 > cx2)) {
HXLINE(  64)								int min;
HXDLIN(  64)								if ((bx > cx2)) {
HXLINE(  64)									min = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE(  64)									min = ::Math_obj::ceil(bx);
            								}
HXDLIN(  64)								int ii_min = min;
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								xIter31 = this1;
            							}
            							else {
HXLINE(  64)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								xIter31 = this1;
            							}
            						}
HXDLIN(  64)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  64)						if ((by > by2)) {
HXLINE(  64)							if ((by > cy2)) {
HXLINE(  64)								int min;
HXDLIN(  64)								if ((by2 > cy2)) {
HXLINE(  64)									min = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE(  64)									min = ::Math_obj::floor(by2);
            								}
HXDLIN(  64)								int ii_min = min;
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								yIter31 = this1;
            							}
            							else {
HXLINE(  64)								int ii_min = ::Math_obj::floor(by2);
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE(  64)							if ((by2 > cy2)) {
HXLINE(  64)								int min;
HXDLIN(  64)								if ((by > cy2)) {
HXLINE(  64)									min = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE(  64)									min = ::Math_obj::ceil(by);
            								}
HXDLIN(  64)								int ii_min = min;
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								yIter31 = this1;
            							}
            							else {
HXLINE(  64)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  64)								int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  64)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)								yIter31 = this1;
            							}
            						}
HXDLIN(  64)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  64)						if (hasUndo1) {
HXLINE(  64)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  64)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  64)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  64)							::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  64)							::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  64)							::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  64)							undoImage1 = this4;
HXDLIN(  64)							{
HXLINE(  64)								int rectLeft = xIter31->start;
HXDLIN(  64)								int rectTop = yIter31->start;
HXDLIN(  64)								int rectRight = xIter31->max;
HXDLIN(  64)								bool forceClear = false;
HXDLIN(  64)								{
HXLINE(  64)									int _g = rectTop;
HXDLIN(  64)									int _g1 = yIter31->max;
HXDLIN(  64)									while((_g < _g1)){
HXLINE(  64)										_g = (_g + 1);
HXDLIN(  64)										int dy = (_g - 1);
HXDLIN(  64)										{
HXLINE(  64)											int _g1 = rectLeft;
HXDLIN(  64)											int _g2 = rectRight;
HXDLIN(  64)											while((_g1 < _g2)){
HXLINE(  64)												_g1 = (_g1 + 1);
HXDLIN(  64)												int dx = (_g1 - 1);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)												int index;
HXDLIN(  64)												if (this1->useVirtualPos) {
HXLINE(  64)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  64)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  64)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)												int col;
HXDLIN(  64)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  64)													col = c;
            												}
HXDLIN(  64)												bool _hx_tmp;
HXDLIN(  64)												if (this1->useMask) {
HXLINE(  64)													_hx_tmp = ::hx::IsNotNull( this1->mask );
            												}
            												else {
HXLINE(  64)													_hx_tmp = false;
            												}
HXDLIN(  64)												if (_hx_tmp) {
HXLINE(  64)													::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  64)													::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  64)													int index;
HXDLIN(  64)													if (this2->useVirtualPos) {
HXLINE(  64)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            													}
            													else {
HXLINE(  64)														index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            													}
HXDLIN(  64)													::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  64)													int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  64)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)													int v;
HXDLIN(  64)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  64)														v = c;
            													}
HXDLIN(  64)													int this4 = v;
HXDLIN(  64)													int maskPixel = this4;
HXDLIN(  64)													int this5 = col;
HXDLIN(  64)													int this6 = this5;
HXDLIN(  64)													if ((maskPixel == 0)) {
HXLINE(  64)														int this1 = this6;
HXDLIN(  64)														col = this1;
            													}
            													else {
HXLINE(  64)														Float m0;
HXDLIN(  64)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  64)														if ((this1 == 0)) {
HXLINE(  64)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m1;
HXDLIN(  64)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  64)														if ((this2 == 0)) {
HXLINE(  64)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m2;
HXDLIN(  64)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  64)														if ((this3 == 0)) {
HXLINE(  64)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float m3;
HXDLIN(  64)														int this4 = (maskPixel & 255);
HXDLIN(  64)														if ((this4 == 0)) {
HXLINE(  64)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  64)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  64)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  64)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  64)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  64)												if ((col != 0)) {
HXLINE(  64)													int x = (dx - rectLeft);
HXDLIN(  64)													int y = (dy - rectTop);
HXDLIN(  64)													int this1 = col;
HXDLIN(  64)													int c = this1;
HXDLIN(  64)													bool _hx_tmp;
HXDLIN(  64)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE(  64)														_hx_tmp = false;
            													}
HXDLIN(  64)													if (_hx_tmp) {
HXLINE(  64)														int location;
HXDLIN(  64)														if (undoImage1->useVirtualPos) {
HXLINE(  64)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  64)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  64)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  64)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)														int this3 = this2;
HXDLIN(  64)														int this4;
HXDLIN(  64)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															this4 = this3;
            														}
HXDLIN(  64)														Float a1;
HXDLIN(  64)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)														if ((this5 == 0)) {
HXLINE(  64)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r1;
HXDLIN(  64)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)														if ((this6 == 0)) {
HXLINE(  64)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g1;
HXDLIN(  64)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)														if ((this7 == 0)) {
HXLINE(  64)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b1;
HXDLIN(  64)														int this8 = (this4 & 255);
HXDLIN(  64)														if ((this8 == 0)) {
HXLINE(  64)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a2;
HXDLIN(  64)														int this9 = ((col >> 24) & 255);
HXDLIN(  64)														if ((this9 == 0)) {
HXLINE(  64)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r2;
HXDLIN(  64)														int this10 = ((col >> 16) & 255);
HXDLIN(  64)														if ((this10 == 0)) {
HXLINE(  64)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g2;
HXDLIN(  64)														int this11 = ((col >> 8) & 255);
HXDLIN(  64)														if ((this11 == 0)) {
HXLINE(  64)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b2;
HXDLIN(  64)														int this12 = (col & 255);
HXDLIN(  64)														if ((this12 == 0)) {
HXLINE(  64)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)														{
HXLINE(  64)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  64)															int value;
HXDLIN(  64)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  64)																value = blended;
            															}
HXDLIN(  64)															bool _hx_tmp;
HXDLIN(  64)															if ((location >= 0)) {
HXLINE(  64)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  64)																_hx_tmp = false;
            															}
HXDLIN(  64)															if (_hx_tmp) {
HXLINE(  64)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  64)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  64)														int index;
HXDLIN(  64)														if (undoImage1->useVirtualPos) {
HXLINE(  64)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  64)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  64)														int value;
HXDLIN(  64)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  64)															value = c;
            														}
HXDLIN(  64)														bool _hx_tmp;
HXDLIN(  64)														if ((index >= 0)) {
HXLINE(  64)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  64)															_hx_tmp = false;
            														}
HXDLIN(  64)														if (_hx_tmp) {
HXLINE(  64)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  64)													if (forceClear) {
HXLINE(  64)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  64)														int x = (dx - rectLeft);
HXDLIN(  64)														int y = (dy - rectTop);
HXDLIN(  64)														int index;
HXDLIN(  64)														if (undoImage1->useVirtualPos) {
HXLINE(  64)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  64)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  64)														bool _hx_tmp;
HXDLIN(  64)														if ((index >= 0)) {
HXLINE(  64)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  64)															_hx_tmp = false;
            														}
HXDLIN(  64)														if (_hx_tmp) {
HXLINE(  64)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  64)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  64)						bool foundY1 = false;
HXDLIN(  64)						Float s1 = ((Float)0.);
HXDLIN(  64)						Float t1 = ((Float)0.);
HXDLIN(  64)						Float sxx1 = ((Float)0.);
HXDLIN(  64)						Float txx1 = ((Float)0.);
HXDLIN(  64)						{
HXLINE(  64)							int _g_min1 = xIter31->start;
HXDLIN(  64)							int _g_max1 = xIter31->max;
HXDLIN(  64)							while((_g_min1 < _g_max1)){
HXLINE(  64)								_g_min1 = (_g_min1 + 1);
HXDLIN(  64)								int x = (_g_min1 - 1);
HXLINE( 223)								sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)								txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)								foundY1 = false;
HXLINE(  64)								{
HXLINE(  64)									int _g_min = yIter31->start;
HXDLIN(  64)									int _g_max = yIter31->max;
HXDLIN(  64)									while((_g_min < _g_max)){
HXLINE(  64)										_g_min = (_g_min + 1);
HXDLIN(  64)										int y = (_g_min - 1);
HXLINE( 227)										s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)										t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  64)										bool _hx_tmp;
HXDLIN(  64)										if (!((s1 <= 0))) {
HXLINE(  64)											_hx_tmp = (t1 <= 0);
            										}
            										else {
HXLINE(  64)											_hx_tmp = true;
            										}
HXDLIN(  64)										if (_hx_tmp) {
HXLINE(  64)											if (foundY1) {
HXLINE(  64)												goto _hx_goto_41;
            											}
            										}
            										else {
HXLINE(  64)											if (((s1 + t1) < A1)) {
HXLINE(  64)												int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  64)												int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this2 = tileImage->image;
HXDLIN(  64)												int index;
HXDLIN(  64)												if (tileImage->useVirtualPos) {
HXLINE(  64)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            												}
            												else {
HXLINE(  64)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            												}
HXDLIN(  64)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)												int color;
HXDLIN(  64)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  64)													color = c;
            												}
HXDLIN(  64)												{
HXLINE(  64)													int this3 = color;
HXDLIN(  64)													int c1 = this3;
HXDLIN(  64)													bool _hx_tmp;
HXDLIN(  64)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  64)														_hx_tmp = this1->transparent;
            													}
            													else {
HXLINE(  64)														_hx_tmp = false;
            													}
HXDLIN(  64)													if (_hx_tmp) {
HXLINE(  64)														int location;
HXDLIN(  64)														if (this1->useVirtualPos) {
HXLINE(  64)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            														}
            														else {
HXLINE(  64)															location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            														}
HXDLIN(  64)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)														int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  64)														int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)														int this4 = this3;
HXDLIN(  64)														int this5;
HXDLIN(  64)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															this5 = this4;
            														}
HXDLIN(  64)														Float a1;
HXDLIN(  64)														int this6 = ((this5 >> 24) & 255);
HXDLIN(  64)														if ((this6 == 0)) {
HXLINE(  64)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r1;
HXDLIN(  64)														int this7 = ((this5 >> 16) & 255);
HXDLIN(  64)														if ((this7 == 0)) {
HXLINE(  64)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g1;
HXDLIN(  64)														int this8 = ((this5 >> 8) & 255);
HXDLIN(  64)														if ((this8 == 0)) {
HXLINE(  64)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b1;
HXDLIN(  64)														int this9 = (this5 & 255);
HXDLIN(  64)														if ((this9 == 0)) {
HXLINE(  64)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a2;
HXDLIN(  64)														int this10 = ((color >> 24) & 255);
HXDLIN(  64)														if ((this10 == 0)) {
HXLINE(  64)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float r2;
HXDLIN(  64)														int this11 = ((color >> 16) & 255);
HXDLIN(  64)														if ((this11 == 0)) {
HXLINE(  64)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float g2;
HXDLIN(  64)														int this12 = ((color >> 8) & 255);
HXDLIN(  64)														if ((this12 == 0)) {
HXLINE(  64)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float b2;
HXDLIN(  64)														int this13 = (color & 255);
HXDLIN(  64)														if ((this13 == 0)) {
HXLINE(  64)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  64)															b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            														}
HXDLIN(  64)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)														{
HXLINE(  64)															::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  64)															int value;
HXDLIN(  64)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  64)																value = blended;
            															}
HXDLIN(  64)															bool _hx_tmp;
HXDLIN(  64)															if ((location >= 0)) {
HXLINE(  64)																_hx_tmp = (location < (this14->byteLength >> 2));
            															}
            															else {
HXLINE(  64)																_hx_tmp = false;
            															}
HXDLIN(  64)															if (_hx_tmp) {
HXLINE(  64)																::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  64)																int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  64)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  64)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)														int index;
HXDLIN(  64)														if (this1->useVirtualPos) {
HXLINE(  64)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            														}
            														else {
HXLINE(  64)															index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            														}
HXDLIN(  64)														int value;
HXDLIN(  64)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE(  64)															value = c1;
            														}
HXDLIN(  64)														bool _hx_tmp;
HXDLIN(  64)														if ((index >= 0)) {
HXLINE(  64)															_hx_tmp = (index < (this2->byteLength >> 2));
            														}
            														else {
HXLINE(  64)															_hx_tmp = false;
            														}
HXDLIN(  64)														if (_hx_tmp) {
HXLINE(  64)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY1 = true;
            											}
            											else {
HXLINE(  64)												if (foundY1) {
HXLINE(  64)													goto _hx_goto_41;
            												}
            											}
            										}
            									}
            									_hx_goto_41:;
            								}
            							}
            						}
            					}
            				}
HXDLIN(  64)				::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            			}
            		}
HXLINE(  69)		this->x0 = x2;
HXLINE(  70)		this->y0 = y2;
HXLINE(  71)		this->toggleDraw = true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(DrawTileHelper_obj,lineTo,(void))

void DrawTileHelper_obj::moveTo(Float x1,Float y1){
            	HX_STACKFRAME(&_hx_pos_fc768c01f79e9b96_74_moveTo)
HXLINE(  75)		this->x0 = x1;
HXLINE(  76)		this->y0 = y1;
HXLINE(  77)		this->info = null();
HXLINE(  78)		this->toggleDraw = true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(DrawTileHelper_obj,moveTo,(void))

void DrawTileHelper_obj::curveTo(Float x2,Float y2,Float x3,Float y3,Float x4,Float y4){
            	HX_STACKFRAME(&_hx_pos_fc768c01f79e9b96_86_curveTo)
HXDLIN(  86)		::justPath::SvgLinePath _this = this->svgLinePath;
HXDLIN(  86)		::Array< Float > tempArr = ::Array_obj< Float >::__new(0);
HXDLIN(  86)		{
HXDLIN(  86)			Float ax = _this->px;
HXDLIN(  86)			Float ay = _this->py;
HXDLIN(  86)			Float x = (ax - x2);
HXDLIN(  86)			Float y = (ay - y2);
HXDLIN(  86)			Float x1 = (x2 - x3);
HXDLIN(  86)			Float y1 = (y2 - y3);
HXDLIN(  86)			Float x5 = (x3 - x4);
HXDLIN(  86)			Float y5 = (y3 - y4);
HXDLIN(  86)			Float approxDistance = ((::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x1 * x1) + (y1 * y1)))) + ::Math_obj::sqrt(((x5 * x5) + (y5 * y5))));
HXDLIN(  86)			if ((approxDistance == 0)) {
HXDLIN(  86)				approxDistance = ((Float)0.000001);
            			}
HXDLIN(  86)			Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),((Float)0.03));
HXDLIN(  86)			int l = tempArr->length;
HXDLIN(  86)			l = (l + 1);
HXDLIN(  86)			tempArr[(l - 1)] = ax;
HXDLIN(  86)			l = (l + 1);
HXDLIN(  86)			tempArr[(l - 1)] = ay;
HXDLIN(  86)			Float t = step;
HXDLIN(  86)			while((t < ((Float)1.))){
HXDLIN(  86)				l = (l + 1);
HXDLIN(  86)				Float u = (( (Float)(1) ) - t);
HXDLIN(  86)				tempArr[(l - 1)] = ((((::Math_obj::pow(u,( (Float)(3) )) * ax) + (((( (Float)(3) ) * ::Math_obj::pow(u,( (Float)(2) ))) * t) * x2)) + (((( (Float)(3) ) * u) * ::Math_obj::pow(t,( (Float)(2) ))) * x3)) + (::Math_obj::pow(t,( (Float)(3) )) * x4));
HXDLIN(  86)				l = (l + 1);
HXDLIN(  86)				Float u1 = (( (Float)(1) ) - t);
HXDLIN(  86)				tempArr[(l - 1)] = ((((::Math_obj::pow(u1,( (Float)(3) )) * ay) + (((( (Float)(3) ) * ::Math_obj::pow(u1,( (Float)(2) ))) * t) * y2)) + (((( (Float)(3) ) * u1) * ::Math_obj::pow(t,( (Float)(2) ))) * y3)) + (::Math_obj::pow(t,( (Float)(3) )) * y4));
HXDLIN(  86)				t = (t + step);
            			}
HXDLIN(  86)			l = (l + 1);
HXDLIN(  86)			tempArr[(l - 1)] = x4;
HXDLIN(  86)			l = (l + 1);
HXDLIN(  86)			tempArr[(l - 1)] = y4;
            		}
HXDLIN(  86)		::haxe::Log_obj::trace(tempArr,::hx::SourceInfo(HX_("justPath/SvgLinePath.hx",5f,c6,70,0f),512,HX_("justPath.SvgLinePath",20,f0,4a,08),HX_("curveTo",0a,60,88,ce)));
HXDLIN(  86)		{
HXDLIN(  86)			 ::Dynamic withMove = false;
HXDLIN(  86)			if (::hx::IsNull( withMove )) {
HXDLIN(  86)				withMove = true;
            			}
HXDLIN(  86)			int l1 = tempArr->length;
HXDLIN(  86)			int i = 2;
HXDLIN(  86)			if (( (bool)(withMove) )) {
HXDLIN(  86)				::justPath::ILinePathContext_obj::moveTo(_this->pathContext,tempArr->__get(0),tempArr->__get(1));
            			}
            			else {
HXDLIN(  86)				::justPath::ILinePathContext_obj::lineSegmentTo(_this->pathContext,tempArr->__get(0),tempArr->__get(1));
            			}
HXDLIN(  86)			while((i < l1)){
HXDLIN(  86)				::justPath::ILinePathContext_obj::lineSegmentTo(_this->pathContext,tempArr->__get(i),tempArr->__get((i + 1)));
HXDLIN(  86)				i = (i + 2);
            			}
            		}
HXDLIN(  86)		tempArr = ::Array_obj< Float >::__new(0);
HXDLIN(  86)		_this->px = x4;
HXDLIN(  86)		_this->py = y4;
            	}


HX_DEFINE_DYNAMIC_FUNC6(DrawTileHelper_obj,curveTo,(void))


::hx::ObjectPtr< DrawTileHelper_obj > DrawTileHelper_obj::__new(::pixelimage::ImageStruct pixelImage,Float strokeWidth,::pixelimage::ImageStruct tileImageStroke,::hx::Null< Float >  __o_translateX,::hx::Null< Float >  __o_translateY,::hx::Null< Float >  __o_scaleX,::hx::Null< Float >  __o_scaleY) {
	::hx::ObjectPtr< DrawTileHelper_obj > __this = new DrawTileHelper_obj();
	__this->__construct(pixelImage,strokeWidth,tileImageStroke,__o_translateX,__o_translateY,__o_scaleX,__o_scaleY);
	return __this;
}

::hx::ObjectPtr< DrawTileHelper_obj > DrawTileHelper_obj::__alloc(::hx::Ctx *_hx_ctx,::pixelimage::ImageStruct pixelImage,Float strokeWidth,::pixelimage::ImageStruct tileImageStroke,::hx::Null< Float >  __o_translateX,::hx::Null< Float >  __o_translateY,::hx::Null< Float >  __o_scaleX,::hx::Null< Float >  __o_scaleY) {
	DrawTileHelper_obj *__this = (DrawTileHelper_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(DrawTileHelper_obj), true, "pixelimage.draw.DrawTileHelper"));
	*(void **)__this = DrawTileHelper_obj::_hx_vtable;
	__this->__construct(pixelImage,strokeWidth,tileImageStroke,__o_translateX,__o_translateY,__o_scaleX,__o_scaleY);
	return __this;
}

DrawTileHelper_obj::DrawTileHelper_obj()
{
}

void DrawTileHelper_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(DrawTileHelper);
	HX_MARK_MEMBER_NAME(svgLinePath,"svgLinePath");
	HX_MARK_MEMBER_NAME(x0,"x0");
	HX_MARK_MEMBER_NAME(y0,"y0");
	HX_MARK_MEMBER_NAME(toggleDraw,"toggleDraw");
	HX_MARK_MEMBER_NAME(strokeWidth,"strokeWidth");
	HX_MARK_MEMBER_NAME(tileImageStroke,"tileImageStroke");
	HX_MARK_MEMBER_NAME(translateX,"translateX");
	HX_MARK_MEMBER_NAME(translateY,"translateY");
	HX_MARK_MEMBER_NAME(scaleX,"scaleX");
	HX_MARK_MEMBER_NAME(scaleY,"scaleY");
	HX_MARK_MEMBER_NAME(pixelImage,"pixelImage");
	HX_MARK_MEMBER_NAME(info,"info");
	HX_MARK_MEMBER_NAME(oldInfo,"oldInfo");
	HX_MARK_END_CLASS();
}

void DrawTileHelper_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(svgLinePath,"svgLinePath");
	HX_VISIT_MEMBER_NAME(x0,"x0");
	HX_VISIT_MEMBER_NAME(y0,"y0");
	HX_VISIT_MEMBER_NAME(toggleDraw,"toggleDraw");
	HX_VISIT_MEMBER_NAME(strokeWidth,"strokeWidth");
	HX_VISIT_MEMBER_NAME(tileImageStroke,"tileImageStroke");
	HX_VISIT_MEMBER_NAME(translateX,"translateX");
	HX_VISIT_MEMBER_NAME(translateY,"translateY");
	HX_VISIT_MEMBER_NAME(scaleX,"scaleX");
	HX_VISIT_MEMBER_NAME(scaleY,"scaleY");
	HX_VISIT_MEMBER_NAME(pixelImage,"pixelImage");
	HX_VISIT_MEMBER_NAME(info,"info");
	HX_VISIT_MEMBER_NAME(oldInfo,"oldInfo");
}

::hx::Val DrawTileHelper_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x0") ) { return ::hx::Val( x0 ); }
		if (HX_FIELD_EQ(inName,"y0") ) { return ::hx::Val( y0 ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"info") ) { return ::hx::Val( info ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"scaleX") ) { return ::hx::Val( scaleX ); }
		if (HX_FIELD_EQ(inName,"scaleY") ) { return ::hx::Val( scaleY ); }
		if (HX_FIELD_EQ(inName,"lineTo") ) { return ::hx::Val( lineTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"oldInfo") ) { return ::hx::Val( oldInfo ); }
		if (HX_FIELD_EQ(inName,"curveTo") ) { return ::hx::Val( curveTo_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"toggleDraw") ) { return ::hx::Val( toggleDraw ); }
		if (HX_FIELD_EQ(inName,"translateX") ) { return ::hx::Val( translateX ); }
		if (HX_FIELD_EQ(inName,"translateY") ) { return ::hx::Val( translateY ); }
		if (HX_FIELD_EQ(inName,"pixelImage") ) { return ::hx::Val( pixelImage ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"svgLinePath") ) { return ::hx::Val( svgLinePath ); }
		if (HX_FIELD_EQ(inName,"strokeWidth") ) { return ::hx::Val( strokeWidth ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"lineSegmentTo") ) { return ::hx::Val( lineSegmentTo_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"tileImageStroke") ) { return ::hx::Val( tileImageStroke ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val DrawTileHelper_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x0") ) { x0=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y0") ) { y0=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"info") ) { info=inValue.Cast< ::pixelimage::algo::HitQuad >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"scaleX") ) { scaleX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scaleY") ) { scaleY=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"oldInfo") ) { oldInfo=inValue.Cast< ::pixelimage::algo::HitQuad >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"toggleDraw") ) { toggleDraw=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"translateX") ) { translateX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"translateY") ) { translateY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pixelImage") ) { pixelImage=inValue.Cast< ::pixelimage::ImageStruct >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"svgLinePath") ) { svgLinePath=inValue.Cast< ::justPath::SvgLinePath >(); return inValue; }
		if (HX_FIELD_EQ(inName,"strokeWidth") ) { strokeWidth=inValue.Cast< Float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"tileImageStroke") ) { tileImageStroke=inValue.Cast< ::pixelimage::ImageStruct >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void DrawTileHelper_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("svgLinePath",3d,9e,8b,c6));
	outFields->push(HX_("x0",b8,68,00,00));
	outFields->push(HX_("y0",97,69,00,00));
	outFields->push(HX_("toggleDraw",b8,71,26,da));
	outFields->push(HX_("strokeWidth",2e,f7,1c,e3));
	outFields->push(HX_("tileImageStroke",e5,1c,7e,f6));
	outFields->push(HX_("translateX",4a,8d,5c,06));
	outFields->push(HX_("translateY",4b,8d,5c,06));
	outFields->push(HX_("scaleX",8e,ea,25,3c));
	outFields->push(HX_("scaleY",8f,ea,25,3c));
	outFields->push(HX_("pixelImage",f5,62,57,5c));
	outFields->push(HX_("info",6e,38,bb,45));
	outFields->push(HX_("oldInfo",b5,dc,ff,fa));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo DrawTileHelper_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::justPath::SvgLinePath */ ,(int)offsetof(DrawTileHelper_obj,svgLinePath),HX_("svgLinePath",3d,9e,8b,c6)},
	{::hx::fsFloat,(int)offsetof(DrawTileHelper_obj,x0),HX_("x0",b8,68,00,00)},
	{::hx::fsFloat,(int)offsetof(DrawTileHelper_obj,y0),HX_("y0",97,69,00,00)},
	{::hx::fsBool,(int)offsetof(DrawTileHelper_obj,toggleDraw),HX_("toggleDraw",b8,71,26,da)},
	{::hx::fsFloat,(int)offsetof(DrawTileHelper_obj,strokeWidth),HX_("strokeWidth",2e,f7,1c,e3)},
	{::hx::fsObject /* ::pixelimage::ImageStruct */ ,(int)offsetof(DrawTileHelper_obj,tileImageStroke),HX_("tileImageStroke",e5,1c,7e,f6)},
	{::hx::fsFloat,(int)offsetof(DrawTileHelper_obj,translateX),HX_("translateX",4a,8d,5c,06)},
	{::hx::fsFloat,(int)offsetof(DrawTileHelper_obj,translateY),HX_("translateY",4b,8d,5c,06)},
	{::hx::fsFloat,(int)offsetof(DrawTileHelper_obj,scaleX),HX_("scaleX",8e,ea,25,3c)},
	{::hx::fsFloat,(int)offsetof(DrawTileHelper_obj,scaleY),HX_("scaleY",8f,ea,25,3c)},
	{::hx::fsObject /* ::pixelimage::ImageStruct */ ,(int)offsetof(DrawTileHelper_obj,pixelImage),HX_("pixelImage",f5,62,57,5c)},
	{::hx::fsObject /* ::pixelimage::algo::HitQuad */ ,(int)offsetof(DrawTileHelper_obj,info),HX_("info",6e,38,bb,45)},
	{::hx::fsObject /* ::pixelimage::algo::HitQuad */ ,(int)offsetof(DrawTileHelper_obj,oldInfo),HX_("oldInfo",b5,dc,ff,fa)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *DrawTileHelper_obj_sStaticStorageInfo = 0;
#endif

static ::String DrawTileHelper_obj_sMemberFields[] = {
	HX_("svgLinePath",3d,9e,8b,c6),
	HX_("x0",b8,68,00,00),
	HX_("y0",97,69,00,00),
	HX_("toggleDraw",b8,71,26,da),
	HX_("strokeWidth",2e,f7,1c,e3),
	HX_("tileImageStroke",e5,1c,7e,f6),
	HX_("translateX",4a,8d,5c,06),
	HX_("translateY",4b,8d,5c,06),
	HX_("scaleX",8e,ea,25,3c),
	HX_("scaleY",8f,ea,25,3c),
	HX_("pixelImage",f5,62,57,5c),
	HX_("info",6e,38,bb,45),
	HX_("oldInfo",b5,dc,ff,fa),
	HX_("lineSegmentTo",7a,d5,67,57),
	HX_("lineTo",8f,46,a0,ec),
	HX_("moveTo",ec,d2,ac,cc),
	HX_("curveTo",0a,60,88,ce),
	::String(null()) };

::hx::Class DrawTileHelper_obj::__mClass;

void DrawTileHelper_obj::__register()
{
	DrawTileHelper_obj _hx_dummy;
	DrawTileHelper_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.draw.DrawTileHelper",d1,e1,f7,f9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(DrawTileHelper_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< DrawTileHelper_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = DrawTileHelper_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = DrawTileHelper_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace draw
