// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage__Pixelimage_Pixelimage_Impl_
#include <pixelimage/_Pixelimage/Pixelimage_Impl_.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_PatternShape
#include <pixelimage/triangleGML/coreShape/PatternShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_092dcf6cc6f48a2d_51_new,"pixelimage.triangleGML.coreShape.PatternShape","new",0x5e7b89f8,"pixelimage.triangleGML.coreShape.PatternShape.new","pixelimage/triangleGML/coreShape/PatternShape.hx",51,0xfe23a3d5)
static const bool _hx_array_data_ff096e06_1[] = {
	1,1,0,0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_092dcf6cc6f48a2d_78_setParameter,"pixelimage.triangleGML.coreShape.PatternShape","setParameter",0x8ed0490f,"pixelimage.triangleGML.coreShape.PatternShape.setParameter","pixelimage/triangleGML/coreShape/PatternShape.hx",78,0xfe23a3d5)
HX_LOCAL_STACK_FRAME(_hx_pos_092dcf6cc6f48a2d_124_render,"pixelimage.triangleGML.coreShape.PatternShape","render",0x6653c0be,"pixelimage.triangleGML.coreShape.PatternShape.render","pixelimage/triangleGML/coreShape/PatternShape.hx",124,0xfe23a3d5)
HX_LOCAL_STACK_FRAME(_hx_pos_092dcf6cc6f48a2d_129_buildPatternTemplates,"pixelimage.triangleGML.coreShape.PatternShape","buildPatternTemplates",0x5edd4d6f,"pixelimage.triangleGML.coreShape.PatternShape.buildPatternTemplates","pixelimage/triangleGML/coreShape/PatternShape.hx",129,0xfe23a3d5)
namespace pixelimage{
namespace triangleGML{
namespace coreShape{

void PatternShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int strokeColor0 = __o_strokeColor0.Default(0);
            		int strokeColor1 = __o_strokeColor1.Default(0);
            		int fillColor0 = __o_fillColor0.Default(0);
            		int fillColor1 = __o_fillColor1.Default(0);
            		bool strokePatternAcross = __o_strokePatternAcross.Default(true);
            		int strokePatternScale = __o_strokePatternScale.Default(1);
            		int fillPatternWidth = __o_fillPatternWidth.Default(16);
            		int fillPatternHeight = __o_fillPatternHeight.Default(16);
            		bool fillPatternAcross = __o_fillPatternAcross.Default(true);
            		int fillPatternScale = __o_fillPatternScale.Default(1);
            	HX_STACKFRAME(&_hx_pos_092dcf6cc6f48a2d_51_new)
HXLINE(  52)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
HXLINE(  53)		this->strokeColor0 = strokeColor0;
HXLINE(  54)		this->strokeColor1 = strokeColor1;
HXLINE(  55)		this->fillColor0 = fillColor0;
HXLINE(  56)		this->fillColor1 = fillColor1;
HXLINE(  59)		this->strokePatternFill = strokePatternFill;
HXLINE(  60)		this->strokePatternWidth = ( (int)(strokePatternWidth) );
HXLINE(  61)		this->strokePatternHeight = ( (int)(strokePatternHeight) );
HXLINE(  62)		this->strokePatternAcross = strokePatternAcross;
HXLINE(  63)		this->strokePatternScale = strokePatternScale;
HXLINE(  65)		if (::hx::IsNull( fillPatternFill )) {
HXLINE(  67)			this->fillPatternFill = ::Array_obj< bool >::fromData( _hx_array_data_ff096e06_1,4);
            		}
            		else {
HXLINE(  69)			this->fillPatternFill = fillPatternFill;
            		}
HXLINE(  72)		this->fillPatternWidth = fillPatternWidth;
HXLINE(  73)		this->fillPatternHeight = fillPatternHeight;
HXLINE(  74)		this->fillPatternAcross = fillPatternAcross;
HXLINE(  75)		this->fillPatternScale = fillPatternScale;
            	}

Dynamic PatternShape_obj::__CreateEmpty() { return new PatternShape_obj; }

void *PatternShape_obj::_hx_vtable = 0;

Dynamic PatternShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PatternShape_obj > _hx_result = new PatternShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14],inArgs[15],inArgs[16],inArgs[17],inArgs[18]);
	return _hx_result;
}

bool PatternShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x6e596dee;
	}
}

void PatternShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_092dcf6cc6f48a2d_78_setParameter)
HXDLIN(  78)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("fillColor0",50,4c,21,ca)) ){
HXLINE(  84)			this->fillColor0 = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  84)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("fillColor1",51,4c,21,ca)) ){
HXLINE(  86)			this->fillColor1 = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  86)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("fillPatternAcross",6c,e1,de,f0)) ){
HXLINE( 111)			::String bools = ::StringTools_obj::trim(value).toLowerCase();
HXLINE( 112)			bool _hx_tmp;
HXDLIN( 112)			bool _hx_tmp1;
HXDLIN( 112)			if ((bools != HX_("true",4e,a7,03,4d))) {
HXLINE( 112)				_hx_tmp1 = (bools == HX_("1",31,00,00,00));
            			}
            			else {
HXLINE( 112)				_hx_tmp1 = true;
            			}
HXDLIN( 112)			if (_hx_tmp1) {
HXLINE( 112)				_hx_tmp = true;
            			}
            			else {
HXLINE( 112)				_hx_tmp = false;
            			}
HXDLIN( 112)			this->fillPatternAcross = _hx_tmp;
HXLINE( 110)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("fillPatternFill",30,0b,98,82)) ){
HXLINE( 105)			value = value.split(HX_("[",5b,00,00,00))->__get(1).split(HX_("]",5d,00,00,00))->__get(0);
HXLINE( 106)			::Array< bool > _g = ::Array_obj< bool >::__new(0);
HXDLIN( 106)			{
HXLINE( 106)				int _g1 = 0;
HXDLIN( 106)				::Array< ::String > _g2 = value.split(HX_(",",2c,00,00,00));
HXDLIN( 106)				while((_g1 < _g2->length)){
HXLINE( 106)					::String v = _g2->__get(_g1);
HXDLIN( 106)					_g1 = (_g1 + 1);
HXLINE( 107)					::String bools = ::StringTools_obj::trim(v).toLowerCase();
HXLINE( 108)					bool _hx_tmp;
HXDLIN( 108)					bool _hx_tmp1;
HXDLIN( 108)					if ((bools != HX_("true",4e,a7,03,4d))) {
HXLINE( 108)						_hx_tmp1 = (bools == HX_("1",31,00,00,00));
            					}
            					else {
HXLINE( 108)						_hx_tmp1 = true;
            					}
HXDLIN( 108)					if (_hx_tmp1) {
HXLINE( 108)						_hx_tmp = true;
            					}
            					else {
HXLINE( 108)						_hx_tmp = false;
            					}
HXDLIN( 108)					_g->push(_hx_tmp);
            				}
            			}
HXLINE( 106)			this->fillPatternFill = _g;
HXLINE( 104)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("fillPatternHeight",d4,89,32,de)) ){
HXLINE( 116)			this->fillPatternHeight = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN( 116)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("fillPatternScale",3d,a9,a7,3a)) ){
HXLINE( 118)			this->fillPatternScale = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN( 118)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("fillPatternWidth",b9,90,3b,8c)) ){
HXLINE( 114)			this->fillPatternWidth = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN( 114)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("strokeColor0",45,87,c5,50)) ){
HXLINE(  80)			this->strokeColor0 = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  80)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("strokeColor1",46,87,c5,50)) ){
HXLINE(  82)			this->strokeColor1 = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  82)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("strokePatternAcross",17,1f,dd,71)) ){
HXLINE(  95)			::String bools = ::StringTools_obj::trim(value).toLowerCase();
HXLINE(  96)			bool _hx_tmp;
HXDLIN(  96)			bool _hx_tmp1;
HXDLIN(  96)			if ((bools != HX_("true",4e,a7,03,4d))) {
HXLINE(  96)				_hx_tmp1 = (bools == HX_("1",31,00,00,00));
            			}
            			else {
HXLINE(  96)				_hx_tmp1 = true;
            			}
HXDLIN(  96)			if (_hx_tmp1) {
HXLINE(  96)				_hx_tmp = true;
            			}
            			else {
HXLINE(  96)				_hx_tmp = false;
            			}
HXDLIN(  96)			this->strokePatternAcross = _hx_tmp;
HXLINE(  94)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("strokePatternFill",1b,f8,d0,11)) ){
HXLINE(  89)			value = value.split(HX_("[",5b,00,00,00))->__get(1).split(HX_("]",5d,00,00,00))->__get(0);
HXLINE(  90)			::Array< bool > _g = ::Array_obj< bool >::__new(0);
HXDLIN(  90)			{
HXLINE(  90)				int _g1 = 0;
HXDLIN(  90)				::Array< ::String > _g2 = value.split(HX_(",",2c,00,00,00));
HXDLIN(  90)				while((_g1 < _g2->length)){
HXLINE(  90)					::String v = _g2->__get(_g1);
HXDLIN(  90)					_g1 = (_g1 + 1);
HXLINE(  91)					::String bools = ::StringTools_obj::trim(v).toLowerCase();
HXLINE(  92)					bool _hx_tmp;
HXDLIN(  92)					bool _hx_tmp1;
HXDLIN(  92)					if ((bools != HX_("true",4e,a7,03,4d))) {
HXLINE(  92)						_hx_tmp1 = (bools == HX_("1",31,00,00,00));
            					}
            					else {
HXLINE(  92)						_hx_tmp1 = true;
            					}
HXDLIN(  92)					if (_hx_tmp1) {
HXLINE(  92)						_hx_tmp = true;
            					}
            					else {
HXLINE(  92)						_hx_tmp = false;
            					}
HXDLIN(  92)					_g->push(_hx_tmp);
            				}
            			}
HXLINE(  90)			this->strokePatternFill = _g;
HXLINE(  88)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("strokePatternHeight",7f,c7,30,5f)) ){
HXLINE( 100)			this->strokePatternHeight = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN( 100)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("strokePatternScale",f2,09,3e,fd)) ){
HXLINE( 102)			this->strokePatternScale = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN( 102)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("strokePatternWidth",6e,f1,d1,4e)) ){
HXLINE(  98)			this->strokePatternWidth = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  98)			goto _hx_goto_2;
            		}
            		/* default */{
HXLINE( 121)			this->super::setParameter(name,value);
            		}
            		_hx_goto_2:;
            	}


::pixelimage::ImageStruct PatternShape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_STACKFRAME(&_hx_pos_092dcf6cc6f48a2d_124_render)
HXLINE( 125)		this->tileImageStroke = null();
HXLINE( 126)		this->tileImageFill = null();
HXLINE( 127)		return this->super::render(pixelShape);
            	}


void PatternShape_obj::buildPatternTemplates(){
            	HX_GC_STACKFRAME(&_hx_pos_092dcf6cc6f48a2d_129_buildPatternTemplates)
HXLINE( 130)		this->tileImageStroke = null();
HXLINE( 131)		this->tiledBorder = ::hx::IsNotNull( this->strokePatternFill );
HXLINE( 132)		if (this->tiledBorder) {
HXLINE( 133)			int w = this->strokePatternWidth;
HXDLIN( 133)			int h = this->strokePatternHeight;
HXDLIN( 133)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 133)			::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 133)			::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 133)			::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 133)			::pixelimage::ImageStruct this4 = this3;
HXDLIN( 133)			this->tileImageStroke = this4;
HXLINE( 134)			this->tileImageStroke->transparent = false;
HXLINE( 136)			if (this->strokePatternAcross) {
HXLINE( 138)				::pixelimage::ImageStruct this1 = this->tileImageStroke;
HXDLIN( 138)				Float h = ( (Float)(this->strokePatternHeight) );
HXDLIN( 138)				int foreColor = this->strokeColor0;
HXDLIN( 138)				int backColor = this->strokeColor1;
HXDLIN( 138)				::Array< bool > patternFill = this->strokePatternFill;
HXDLIN( 138)				int p = 0;
HXDLIN( 138)				int xx = p;
HXDLIN( 138)				int q = 0;
HXDLIN( 138)				int maxX = ::Std_obj::_hx_int(( (Float)(this->strokePatternWidth) ));
HXDLIN( 138)				int maxY = ::Std_obj::_hx_int(h);
HXDLIN( 138)				int count = 0;
HXDLIN( 138)				bool useFore = true;
HXDLIN( 138)				while(true){
HXLINE( 138)					if ((count < patternFill->length)) {
HXLINE( 138)						useFore = patternFill->__get(count);
HXDLIN( 138)						count = (count + 1);
            					}
            					else {
HXLINE( 138)						count = 0;
HXDLIN( 138)						useFore = patternFill->__get(count);
HXDLIN( 138)						count = (count + 1);
            					}
HXDLIN( 138)					int color;
HXDLIN( 138)					if (useFore) {
HXLINE( 138)						color = foreColor;
            					}
            					else {
HXLINE( 138)						color = backColor;
            					}
HXDLIN( 138)					{
HXLINE( 138)						p = (p + 1);
HXDLIN( 138)						int x = (p - 1);
HXDLIN( 138)						int this2 = color;
HXDLIN( 138)						int c = this2;
HXDLIN( 138)						bool _hx_tmp;
HXDLIN( 138)						if ((((c >> 24) & 255) < 254)) {
HXLINE( 138)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE( 138)							_hx_tmp = false;
            						}
HXDLIN( 138)						if (_hx_tmp) {
HXLINE( 138)							int location;
HXDLIN( 138)							if (this1->useVirtualPos) {
HXLINE( 138)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 138)								location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            							}
HXDLIN( 138)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 138)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 138)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 138)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)							int this4 = this3;
HXDLIN( 138)							int this5;
HXDLIN( 138)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE( 138)								this5 = this4;
            							}
HXDLIN( 138)							Float a1;
HXDLIN( 138)							int this6 = ((this5 >> 24) & 255);
HXDLIN( 138)							if ((this6 == 0)) {
HXLINE( 138)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 138)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 138)							Float r1;
HXDLIN( 138)							int this7 = ((this5 >> 16) & 255);
HXDLIN( 138)							if ((this7 == 0)) {
HXLINE( 138)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 138)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 138)							Float g1;
HXDLIN( 138)							int this8 = ((this5 >> 8) & 255);
HXDLIN( 138)							if ((this8 == 0)) {
HXLINE( 138)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 138)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 138)							Float b1;
HXDLIN( 138)							int this9 = (this5 & 255);
HXDLIN( 138)							if ((this9 == 0)) {
HXLINE( 138)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 138)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 138)							Float a2;
HXDLIN( 138)							int this10 = ((color >> 24) & 255);
HXDLIN( 138)							if ((this10 == 0)) {
HXLINE( 138)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 138)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 138)							Float r2;
HXDLIN( 138)							int this11 = ((color >> 16) & 255);
HXDLIN( 138)							if ((this11 == 0)) {
HXLINE( 138)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 138)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 138)							Float g2;
HXDLIN( 138)							int this12 = ((color >> 8) & 255);
HXDLIN( 138)							if ((this12 == 0)) {
HXLINE( 138)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 138)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 138)							Float b2;
HXDLIN( 138)							int this13 = (color & 255);
HXDLIN( 138)							if ((this13 == 0)) {
HXLINE( 138)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 138)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 138)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)							{
HXLINE( 138)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN( 138)								int value;
HXDLIN( 138)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 138)									value = blended;
            								}
HXDLIN( 138)								bool _hx_tmp;
HXDLIN( 138)								if ((location >= 0)) {
HXLINE( 138)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE( 138)									_hx_tmp = false;
            								}
HXDLIN( 138)								if (_hx_tmp) {
HXLINE( 138)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN( 138)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN( 138)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE( 138)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 138)							int index;
HXDLIN( 138)							if (this1->useVirtualPos) {
HXLINE( 138)								index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 138)								index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            							}
HXDLIN( 138)							int value;
HXDLIN( 138)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 138)								value = c;
            							}
HXDLIN( 138)							bool _hx_tmp;
HXDLIN( 138)							if ((index >= 0)) {
HXLINE( 138)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE( 138)								_hx_tmp = false;
            							}
HXDLIN( 138)							if (_hx_tmp) {
HXLINE( 138)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 138)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 138)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN( 138)					if ((p > maxX)) {
HXLINE( 138)						p = xx;
HXDLIN( 138)						q = (q + 1);
            					}
HXDLIN( 138)					if ((q > maxY)) {
HXLINE( 138)						goto _hx_goto_7;
            					}
            				}
            				_hx_goto_7:;
            			}
            			else {
HXLINE( 141)				::pixelimage::ImageStruct this1 = this->tileImageStroke;
HXDLIN( 141)				Float h = ( (Float)(this->strokePatternHeight) );
HXDLIN( 141)				int foreColor = this->strokeColor0;
HXDLIN( 141)				int backColor = this->strokeColor1;
HXDLIN( 141)				::Array< bool > patternFill = this->strokePatternFill;
HXDLIN( 141)				int p = 0;
HXDLIN( 141)				int xx = p;
HXDLIN( 141)				int q = 0;
HXDLIN( 141)				int maxX = ::Std_obj::_hx_int(( (Float)(this->strokePatternWidth) ));
HXDLIN( 141)				int maxY = ::Std_obj::_hx_int(h);
HXDLIN( 141)				int count = 0;
HXDLIN( 141)				bool useFore = true;
HXDLIN( 141)				while(true){
HXLINE( 141)					if ((count < patternFill->length)) {
HXLINE( 141)						useFore = patternFill->__get(count);
HXDLIN( 141)						count = (count + 1);
            					}
            					else {
HXLINE( 141)						count = 0;
HXDLIN( 141)						useFore = patternFill->__get(count);
HXDLIN( 141)						count = (count + 1);
            					}
HXDLIN( 141)					int color;
HXDLIN( 141)					if (useFore) {
HXLINE( 141)						color = foreColor;
            					}
            					else {
HXLINE( 141)						color = backColor;
            					}
HXDLIN( 141)					{
HXLINE( 141)						p = (p + 1);
HXDLIN( 141)						int x = (p - 1);
HXDLIN( 141)						int this2 = color;
HXDLIN( 141)						int c = this2;
HXDLIN( 141)						bool _hx_tmp;
HXDLIN( 141)						if ((((c >> 24) & 255) < 254)) {
HXLINE( 141)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE( 141)							_hx_tmp = false;
            						}
HXDLIN( 141)						if (_hx_tmp) {
HXLINE( 141)							int location;
HXDLIN( 141)							if (this1->useVirtualPos) {
HXLINE( 141)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 141)								location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            							}
HXDLIN( 141)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 141)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 141)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 141)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 141)							int this4 = this3;
HXDLIN( 141)							int this5;
HXDLIN( 141)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE( 141)								this5 = this4;
            							}
HXDLIN( 141)							Float a1;
HXDLIN( 141)							int this6 = ((this5 >> 24) & 255);
HXDLIN( 141)							if ((this6 == 0)) {
HXLINE( 141)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 141)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 141)							Float r1;
HXDLIN( 141)							int this7 = ((this5 >> 16) & 255);
HXDLIN( 141)							if ((this7 == 0)) {
HXLINE( 141)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 141)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 141)							Float g1;
HXDLIN( 141)							int this8 = ((this5 >> 8) & 255);
HXDLIN( 141)							if ((this8 == 0)) {
HXLINE( 141)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 141)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 141)							Float b1;
HXDLIN( 141)							int this9 = (this5 & 255);
HXDLIN( 141)							if ((this9 == 0)) {
HXLINE( 141)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 141)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 141)							Float a2;
HXDLIN( 141)							int this10 = ((color >> 24) & 255);
HXDLIN( 141)							if ((this10 == 0)) {
HXLINE( 141)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 141)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 141)							Float r2;
HXDLIN( 141)							int this11 = ((color >> 16) & 255);
HXDLIN( 141)							if ((this11 == 0)) {
HXLINE( 141)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 141)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 141)							Float g2;
HXDLIN( 141)							int this12 = ((color >> 8) & 255);
HXDLIN( 141)							if ((this12 == 0)) {
HXLINE( 141)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 141)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 141)							Float b2;
HXDLIN( 141)							int this13 = (color & 255);
HXDLIN( 141)							if ((this13 == 0)) {
HXLINE( 141)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 141)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 141)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 141)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 141)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 141)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 141)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 141)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 141)							{
HXLINE( 141)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN( 141)								int value;
HXDLIN( 141)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 141)									value = blended;
            								}
HXDLIN( 141)								bool _hx_tmp;
HXDLIN( 141)								if ((location >= 0)) {
HXLINE( 141)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE( 141)									_hx_tmp = false;
            								}
HXDLIN( 141)								if (_hx_tmp) {
HXLINE( 141)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN( 141)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN( 141)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 141)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 141)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 141)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE( 141)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 141)							int index;
HXDLIN( 141)							if (this1->useVirtualPos) {
HXLINE( 141)								index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 141)								index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            							}
HXDLIN( 141)							int value;
HXDLIN( 141)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 141)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 141)								value = c;
            							}
HXDLIN( 141)							bool _hx_tmp;
HXDLIN( 141)							if ((index >= 0)) {
HXLINE( 141)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE( 141)								_hx_tmp = false;
            							}
HXDLIN( 141)							if (_hx_tmp) {
HXLINE( 141)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 141)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 141)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 141)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 141)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 141)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN( 141)					if ((p > maxX)) {
HXLINE( 141)						p = xx;
HXDLIN( 141)						q = (q + 1);
            					}
HXDLIN( 141)					if ((q > maxY)) {
HXLINE( 141)						goto _hx_goto_8;
            					}
            				}
            				_hx_goto_8:;
            			}
HXLINE( 143)			if ((this->strokePatternScale > 1)) {
HXLINE( 143)				::pixelimage::ImageStruct this1 = this->tileImageStroke;
HXDLIN( 143)				int scaleW = this->strokePatternScale;
HXDLIN( 143)				int scaleH = this->strokePatternScale;
HXDLIN( 143)				bool includeMask = false;
HXDLIN( 143)				int p = 0;
HXDLIN( 143)				int xx = p;
HXDLIN( 143)				int q = 0;
HXDLIN( 143)				int wNew = ::Std_obj::_hx_int(( (Float)((this1->width * scaleW)) ));
HXDLIN( 143)				int hNew = ::Std_obj::_hx_int(( (Float)((this1->height * scaleH)) ));
HXDLIN( 143)				int size = (::Std_obj::_hx_int(( (Float)((wNew * hNew)) )) * 4);
HXDLIN( 143)				::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 143)				::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN( 143)				::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,wNew,hNew,this3);
HXDLIN( 143)				::pixelimage::ImageStruct pixelImage = this4;
HXDLIN( 143)				int maxX = wNew;
HXDLIN( 143)				int maxY = hNew;
HXDLIN( 143)				while(true){
HXLINE( 143)					int x = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN( 143)					int y = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN( 143)					::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 143)					int index;
HXDLIN( 143)					if (this1->useVirtualPos) {
HXLINE( 143)						index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            					}
            					else {
HXLINE( 143)						index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            					}
HXDLIN( 143)					::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 143)					int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 143)					int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 143)					int color;
HXDLIN( 143)					if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 143)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE( 143)						color = c;
            					}
HXDLIN( 143)					{
HXLINE( 143)						p = (p + 1);
HXDLIN( 143)						int x1 = (p - 1);
HXDLIN( 143)						int this3 = color;
HXDLIN( 143)						int c1 = this3;
HXDLIN( 143)						bool _hx_tmp;
HXDLIN( 143)						if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 143)							_hx_tmp = pixelImage->transparent;
            						}
            						else {
HXLINE( 143)							_hx_tmp = false;
            						}
HXDLIN( 143)						if (_hx_tmp) {
HXLINE( 143)							int location;
HXDLIN( 143)							if (pixelImage->useVirtualPos) {
HXLINE( 143)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x1) - pixelImage->virtualX));
            							}
            							else {
HXLINE( 143)								location = ::Std_obj::_hx_int(( (Float)(((q * pixelImage->width) + x1)) ));
            							}
HXDLIN( 143)							::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 143)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 143)							int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 143)							int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 143)							int this3 = this2;
HXDLIN( 143)							int this4;
HXDLIN( 143)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 143)								this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            							}
            							else {
HXLINE( 143)								this4 = this3;
            							}
HXDLIN( 143)							Float a1;
HXDLIN( 143)							int this5 = ((this4 >> 24) & 255);
HXDLIN( 143)							if ((this5 == 0)) {
HXLINE( 143)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 143)								a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            							}
HXDLIN( 143)							Float r1;
HXDLIN( 143)							int this6 = ((this4 >> 16) & 255);
HXDLIN( 143)							if ((this6 == 0)) {
HXLINE( 143)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 143)								r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 143)							Float g1;
HXDLIN( 143)							int this7 = ((this4 >> 8) & 255);
HXDLIN( 143)							if ((this7 == 0)) {
HXLINE( 143)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 143)								g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 143)							Float b1;
HXDLIN( 143)							int this8 = (this4 & 255);
HXDLIN( 143)							if ((this8 == 0)) {
HXLINE( 143)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 143)								b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 143)							Float a2;
HXDLIN( 143)							int this9 = ((color >> 24) & 255);
HXDLIN( 143)							if ((this9 == 0)) {
HXLINE( 143)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 143)								a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 143)							Float r2;
HXDLIN( 143)							int this10 = ((color >> 16) & 255);
HXDLIN( 143)							if ((this10 == 0)) {
HXLINE( 143)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 143)								r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 143)							Float g2;
HXDLIN( 143)							int this11 = ((color >> 8) & 255);
HXDLIN( 143)							if ((this11 == 0)) {
HXLINE( 143)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 143)								g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 143)							Float b2;
HXDLIN( 143)							int this12 = (color & 255);
HXDLIN( 143)							if ((this12 == 0)) {
HXLINE( 143)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 143)								b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 143)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 143)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 143)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 143)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 143)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 143)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 143)							{
HXLINE( 143)								::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 143)								int value;
HXDLIN( 143)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 143)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 143)									value = blended;
            								}
HXDLIN( 143)								bool _hx_tmp;
HXDLIN( 143)								if ((location >= 0)) {
HXLINE( 143)									_hx_tmp = (location < (this13->byteLength >> 2));
            								}
            								else {
HXLINE( 143)									_hx_tmp = false;
            								}
HXDLIN( 143)								if (_hx_tmp) {
HXLINE( 143)									::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 143)									int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 143)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 143)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 143)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 143)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE( 143)							::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 143)							int index;
HXDLIN( 143)							if (pixelImage->useVirtualPos) {
HXLINE( 143)								index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x1) - pixelImage->virtualX));
            							}
            							else {
HXLINE( 143)								index = ::Std_obj::_hx_int(( (Float)(((q * pixelImage->width) + x1)) ));
            							}
HXDLIN( 143)							int value;
HXDLIN( 143)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 143)								value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            							}
            							else {
HXLINE( 143)								value = c1;
            							}
HXDLIN( 143)							bool _hx_tmp;
HXDLIN( 143)							if ((index >= 0)) {
HXLINE( 143)								_hx_tmp = (index < (this1->byteLength >> 2));
            							}
            							else {
HXLINE( 143)								_hx_tmp = false;
            							}
HXDLIN( 143)							if (_hx_tmp) {
HXLINE( 143)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 143)								int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 143)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 143)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 143)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 143)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN( 143)					if ((p > maxX)) {
HXLINE( 143)						p = xx;
HXDLIN( 143)						q = (q + 1);
            					}
HXDLIN( 143)					if ((q > maxY)) {
HXLINE( 143)						goto _hx_goto_9;
            					}
            				}
            				_hx_goto_9:;
HXDLIN( 143)				bool _hx_tmp;
HXDLIN( 143)				if (::hx::IsNotNull( this1->mask )) {
HXLINE( 143)					_hx_tmp = includeMask;
            				}
            				else {
HXLINE( 143)					_hx_tmp = false;
            				}
HXDLIN( 143)				if (_hx_tmp) {
HXLINE( 143)					::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN( 143)					bool transparent = this1->mask->transparent;
HXDLIN( 143)					int p = 0;
HXDLIN( 143)					int xx = p;
HXDLIN( 143)					int q = 0;
HXDLIN( 143)					int wNew = ::Std_obj::_hx_int(( (Float)((this2->width * scaleW)) ));
HXDLIN( 143)					int hNew = ::Std_obj::_hx_int(( (Float)((this2->height * scaleH)) ));
HXDLIN( 143)					int size = (::Std_obj::_hx_int(( (Float)((wNew * hNew)) )) * 4);
HXDLIN( 143)					::haxe::io::ArrayBufferViewImpl this3 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 143)					::haxe::io::ArrayBufferViewImpl this4 = this3;
HXDLIN( 143)					::pixelimage::ImageStruct this5 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,wNew,hNew,this4);
HXDLIN( 143)					::pixelimage::ImageStruct pixelImage1 = this5;
HXDLIN( 143)					int maxX = wNew;
HXDLIN( 143)					int maxY = hNew;
HXDLIN( 143)					while(true){
HXLINE( 143)						int x = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN( 143)						int y = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN( 143)						::haxe::io::ArrayBufferViewImpl this1 = this2->image;
HXDLIN( 143)						int index;
HXDLIN( 143)						if (this2->useVirtualPos) {
HXLINE( 143)							index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            						}
            						else {
HXLINE( 143)							index = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            						}
HXDLIN( 143)						::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 143)						int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 143)						int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 143)						int color;
HXDLIN( 143)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 143)							color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            						}
            						else {
HXLINE( 143)							color = c;
            						}
HXDLIN( 143)						{
HXLINE( 143)							p = (p + 1);
HXDLIN( 143)							int x1 = (p - 1);
HXDLIN( 143)							int this3 = color;
HXDLIN( 143)							int c1 = this3;
HXDLIN( 143)							bool _hx_tmp;
HXDLIN( 143)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 143)								_hx_tmp = pixelImage1->transparent;
            							}
            							else {
HXLINE( 143)								_hx_tmp = false;
            							}
HXDLIN( 143)							if (_hx_tmp) {
HXLINE( 143)								int location;
HXDLIN( 143)								if (pixelImage1->useVirtualPos) {
HXLINE( 143)									location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelImage1->virtualY) * ( (Float)(pixelImage1->width) )) + x1) - pixelImage1->virtualX));
            								}
            								else {
HXLINE( 143)									location = ::Std_obj::_hx_int(( (Float)(((q * pixelImage1->width) + x1)) ));
            								}
HXDLIN( 143)								::haxe::io::ArrayBufferViewImpl this1 = pixelImage1->image;
HXDLIN( 143)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 143)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 143)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 143)								int this3 = this2;
HXDLIN( 143)								int this4;
HXDLIN( 143)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 143)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE( 143)									this4 = this3;
            								}
HXDLIN( 143)								Float a1;
HXDLIN( 143)								int this5 = ((this4 >> 24) & 255);
HXDLIN( 143)								if ((this5 == 0)) {
HXLINE( 143)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 143)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 143)								Float r1;
HXDLIN( 143)								int this6 = ((this4 >> 16) & 255);
HXDLIN( 143)								if ((this6 == 0)) {
HXLINE( 143)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 143)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 143)								Float g1;
HXDLIN( 143)								int this7 = ((this4 >> 8) & 255);
HXDLIN( 143)								if ((this7 == 0)) {
HXLINE( 143)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 143)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 143)								Float b1;
HXDLIN( 143)								int this8 = (this4 & 255);
HXDLIN( 143)								if ((this8 == 0)) {
HXLINE( 143)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 143)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 143)								Float a2;
HXDLIN( 143)								int this9 = ((color >> 24) & 255);
HXDLIN( 143)								if ((this9 == 0)) {
HXLINE( 143)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 143)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 143)								Float r2;
HXDLIN( 143)								int this10 = ((color >> 16) & 255);
HXDLIN( 143)								if ((this10 == 0)) {
HXLINE( 143)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 143)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 143)								Float g2;
HXDLIN( 143)								int this11 = ((color >> 8) & 255);
HXDLIN( 143)								if ((this11 == 0)) {
HXLINE( 143)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 143)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 143)								Float b2;
HXDLIN( 143)								int this12 = (color & 255);
HXDLIN( 143)								if ((this12 == 0)) {
HXLINE( 143)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 143)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN( 143)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 143)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 143)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 143)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 143)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 143)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 143)								{
HXLINE( 143)									::haxe::io::ArrayBufferViewImpl this13 = pixelImage1->image;
HXDLIN( 143)									int value;
HXDLIN( 143)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 143)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 143)										value = blended;
            									}
HXDLIN( 143)									bool _hx_tmp;
HXDLIN( 143)									if ((location >= 0)) {
HXLINE( 143)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE( 143)										_hx_tmp = false;
            									}
HXDLIN( 143)									if (_hx_tmp) {
HXLINE( 143)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 143)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 143)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 143)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 143)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 143)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE( 143)								::haxe::io::ArrayBufferViewImpl this1 = pixelImage1->image;
HXDLIN( 143)								int index;
HXDLIN( 143)								if (pixelImage1->useVirtualPos) {
HXLINE( 143)									index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelImage1->virtualY) * ( (Float)(pixelImage1->width) )) + x1) - pixelImage1->virtualX));
            								}
            								else {
HXLINE( 143)									index = ::Std_obj::_hx_int(( (Float)(((q * pixelImage1->width) + x1)) ));
            								}
HXDLIN( 143)								int value;
HXDLIN( 143)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 143)									value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 143)									value = c1;
            								}
HXDLIN( 143)								bool _hx_tmp;
HXDLIN( 143)								if ((index >= 0)) {
HXLINE( 143)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE( 143)									_hx_tmp = false;
            								}
HXDLIN( 143)								if (_hx_tmp) {
HXLINE( 143)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 143)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 143)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 143)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 143)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 143)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN( 143)						if ((p > maxX)) {
HXLINE( 143)							p = xx;
HXDLIN( 143)							q = (q + 1);
            						}
HXDLIN( 143)						if ((q > maxY)) {
HXLINE( 143)							goto _hx_goto_10;
            						}
            					}
            					_hx_goto_10:;
HXDLIN( 143)					bool _hx_tmp;
HXDLIN( 143)					if (::hx::IsNotNull( this2->mask )) {
HXLINE( 143)						_hx_tmp = includeMask;
            					}
            					else {
HXLINE( 143)						_hx_tmp = false;
            					}
HXDLIN( 143)					if (_hx_tmp) {
HXLINE( 143)						::pixelimage::ImageStruct v = ::pixelimage::_Pixelimage::Pixelimage_Impl__obj::scaleUpInt(this2->mask,scaleW,scaleH,this2->mask->transparent,includeMask);
HXDLIN( 143)						pixelImage1->useMask = true;
HXDLIN( 143)						pixelImage1->mask = v;
            					}
HXDLIN( 143)					::pixelimage::ImageStruct v = pixelImage1;
HXDLIN( 143)					pixelImage->useMask = true;
HXDLIN( 143)					pixelImage->mask = v;
            				}
HXDLIN( 143)				this->tileImageStroke = pixelImage;
            			}
            		}
HXLINE( 146)		int w = this->fillPatternWidth;
HXDLIN( 146)		int h = this->fillPatternHeight;
HXDLIN( 146)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 146)		::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 146)		::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 146)		::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 146)		::pixelimage::ImageStruct this4 = this3;
HXDLIN( 146)		this->tileImageFill = this4;
HXLINE( 147)		this->tileImageFill->transparent = false;
HXLINE( 149)		if (this->fillPatternAcross) {
HXLINE( 151)			::pixelimage::ImageStruct this1 = this->tileImageFill;
HXDLIN( 151)			Float h = ( (Float)(this->fillPatternHeight) );
HXDLIN( 151)			int foreColor = this->fillColor0;
HXDLIN( 151)			int backColor = this->fillColor1;
HXDLIN( 151)			::Array< bool > patternFill = this->fillPatternFill;
HXDLIN( 151)			int p = 0;
HXDLIN( 151)			int xx = p;
HXDLIN( 151)			int q = 0;
HXDLIN( 151)			int maxX = ::Std_obj::_hx_int(( (Float)(this->fillPatternWidth) ));
HXDLIN( 151)			int maxY = ::Std_obj::_hx_int(h);
HXDLIN( 151)			int count = 0;
HXDLIN( 151)			bool useFore = true;
HXDLIN( 151)			while(true){
HXLINE( 151)				if ((count < patternFill->length)) {
HXLINE( 151)					useFore = patternFill->__get(count);
HXDLIN( 151)					count = (count + 1);
            				}
            				else {
HXLINE( 151)					count = 0;
HXDLIN( 151)					useFore = patternFill->__get(count);
HXDLIN( 151)					count = (count + 1);
            				}
HXDLIN( 151)				int color;
HXDLIN( 151)				if (useFore) {
HXLINE( 151)					color = foreColor;
            				}
            				else {
HXLINE( 151)					color = backColor;
            				}
HXDLIN( 151)				{
HXLINE( 151)					p = (p + 1);
HXDLIN( 151)					int x = (p - 1);
HXDLIN( 151)					int this2 = color;
HXDLIN( 151)					int c = this2;
HXDLIN( 151)					bool _hx_tmp;
HXDLIN( 151)					if ((((c >> 24) & 255) < 254)) {
HXLINE( 151)						_hx_tmp = this1->transparent;
            					}
            					else {
HXLINE( 151)						_hx_tmp = false;
            					}
HXDLIN( 151)					if (_hx_tmp) {
HXLINE( 151)						int location;
HXDLIN( 151)						if (this1->useVirtualPos) {
HXLINE( 151)							location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            						}
            						else {
HXLINE( 151)							location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            						}
HXDLIN( 151)						::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 151)						::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 151)						int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 151)						int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 151)						int this4 = this3;
HXDLIN( 151)						int this5;
HXDLIN( 151)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 151)							this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            						}
            						else {
HXLINE( 151)							this5 = this4;
            						}
HXDLIN( 151)						Float a1;
HXDLIN( 151)						int this6 = ((this5 >> 24) & 255);
HXDLIN( 151)						if ((this6 == 0)) {
HXLINE( 151)							a1 = ((Float)0.);
            						}
            						else {
HXLINE( 151)							a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN( 151)						Float r1;
HXDLIN( 151)						int this7 = ((this5 >> 16) & 255);
HXDLIN( 151)						if ((this7 == 0)) {
HXLINE( 151)							r1 = ((Float)0.);
            						}
            						else {
HXLINE( 151)							r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN( 151)						Float g1;
HXDLIN( 151)						int this8 = ((this5 >> 8) & 255);
HXDLIN( 151)						if ((this8 == 0)) {
HXLINE( 151)							g1 = ((Float)0.);
            						}
            						else {
HXLINE( 151)							g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN( 151)						Float b1;
HXDLIN( 151)						int this9 = (this5 & 255);
HXDLIN( 151)						if ((this9 == 0)) {
HXLINE( 151)							b1 = ((Float)0.);
            						}
            						else {
HXLINE( 151)							b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN( 151)						Float a2;
HXDLIN( 151)						int this10 = ((color >> 24) & 255);
HXDLIN( 151)						if ((this10 == 0)) {
HXLINE( 151)							a2 = ((Float)0.);
            						}
            						else {
HXLINE( 151)							a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN( 151)						Float r2;
HXDLIN( 151)						int this11 = ((color >> 16) & 255);
HXDLIN( 151)						if ((this11 == 0)) {
HXLINE( 151)							r2 = ((Float)0.);
            						}
            						else {
HXLINE( 151)							r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN( 151)						Float g2;
HXDLIN( 151)						int this12 = ((color >> 8) & 255);
HXDLIN( 151)						if ((this12 == 0)) {
HXLINE( 151)							g2 = ((Float)0.);
            						}
            						else {
HXLINE( 151)							g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN( 151)						Float b2;
HXDLIN( 151)						int this13 = (color & 255);
HXDLIN( 151)						if ((this13 == 0)) {
HXLINE( 151)							b2 = ((Float)0.);
            						}
            						else {
HXLINE( 151)							b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN( 151)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 151)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 151)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 151)						int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 151)						int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 151)						int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 151)						{
HXLINE( 151)							::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN( 151)							int value;
HXDLIN( 151)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 151)								value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE( 151)								value = blended;
            							}
HXDLIN( 151)							bool _hx_tmp;
HXDLIN( 151)							if ((location >= 0)) {
HXLINE( 151)								_hx_tmp = (location < (this14->byteLength >> 2));
            							}
            							else {
HXLINE( 151)								_hx_tmp = false;
            							}
HXDLIN( 151)							if (_hx_tmp) {
HXLINE( 151)								::haxe::io::Bytes _this = this14->bytes;
HXDLIN( 151)								int pos = ((location << 2) + this14->byteOffset);
HXDLIN( 151)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 151)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 151)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 151)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
            					else {
HXLINE( 151)						::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 151)						int index;
HXDLIN( 151)						if (this1->useVirtualPos) {
HXLINE( 151)							index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            						}
            						else {
HXLINE( 151)							index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            						}
HXDLIN( 151)						int value;
HXDLIN( 151)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 151)							value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            						}
            						else {
HXLINE( 151)							value = c;
            						}
HXDLIN( 151)						bool _hx_tmp;
HXDLIN( 151)						if ((index >= 0)) {
HXLINE( 151)							_hx_tmp = (index < (this2->byteLength >> 2));
            						}
            						else {
HXLINE( 151)							_hx_tmp = false;
            						}
HXDLIN( 151)						if (_hx_tmp) {
HXLINE( 151)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 151)							int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 151)							_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 151)							_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 151)							_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 151)							_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            						}
            					}
            				}
HXDLIN( 151)				if ((p > maxX)) {
HXLINE( 151)					p = xx;
HXDLIN( 151)					q = (q + 1);
            				}
HXDLIN( 151)				if ((q > maxY)) {
HXLINE( 151)					goto _hx_goto_11;
            				}
            			}
            			_hx_goto_11:;
            		}
            		else {
HXLINE( 154)			::pixelimage::ImageStruct this1 = this->tileImageFill;
HXDLIN( 154)			Float h = ( (Float)(this->fillPatternHeight) );
HXDLIN( 154)			int foreColor = this->fillColor0;
HXDLIN( 154)			int backColor = this->fillColor1;
HXDLIN( 154)			::Array< bool > patternFill = this->fillPatternFill;
HXDLIN( 154)			int p = 0;
HXDLIN( 154)			int q = 0;
HXDLIN( 154)			int yy = q;
HXDLIN( 154)			int maxX = ::Std_obj::_hx_int(( (Float)(this->fillPatternWidth) ));
HXDLIN( 154)			int maxY = ::Std_obj::_hx_int(h);
HXDLIN( 154)			int count = 0;
HXDLIN( 154)			bool useFore = true;
HXDLIN( 154)			while(true){
HXLINE( 154)				if ((count < patternFill->length)) {
HXLINE( 154)					useFore = patternFill->__get(count);
HXDLIN( 154)					count = (count + 1);
            				}
            				else {
HXLINE( 154)					count = 0;
HXDLIN( 154)					useFore = patternFill->__get(count);
HXDLIN( 154)					count = (count + 1);
            				}
HXDLIN( 154)				int color;
HXDLIN( 154)				if (useFore) {
HXLINE( 154)					color = foreColor;
            				}
            				else {
HXLINE( 154)					color = backColor;
            				}
HXDLIN( 154)				{
HXLINE( 154)					q = (q + 1);
HXDLIN( 154)					int y = (q - 1);
HXDLIN( 154)					int this2 = color;
HXDLIN( 154)					int c = this2;
HXDLIN( 154)					bool _hx_tmp;
HXDLIN( 154)					if ((((c >> 24) & 255) < 254)) {
HXLINE( 154)						_hx_tmp = this1->transparent;
            					}
            					else {
HXLINE( 154)						_hx_tmp = false;
            					}
HXDLIN( 154)					if (_hx_tmp) {
HXLINE( 154)						int location;
HXDLIN( 154)						if (this1->useVirtualPos) {
HXLINE( 154)							location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + p) - this1->virtualX));
            						}
            						else {
HXLINE( 154)							location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + p)) ));
            						}
HXDLIN( 154)						::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 154)						::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 154)						int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 154)						int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 154)						int this4 = this3;
HXDLIN( 154)						int this5;
HXDLIN( 154)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 154)							this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            						}
            						else {
HXLINE( 154)							this5 = this4;
            						}
HXDLIN( 154)						Float a1;
HXDLIN( 154)						int this6 = ((this5 >> 24) & 255);
HXDLIN( 154)						if ((this6 == 0)) {
HXLINE( 154)							a1 = ((Float)0.);
            						}
            						else {
HXLINE( 154)							a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN( 154)						Float r1;
HXDLIN( 154)						int this7 = ((this5 >> 16) & 255);
HXDLIN( 154)						if ((this7 == 0)) {
HXLINE( 154)							r1 = ((Float)0.);
            						}
            						else {
HXLINE( 154)							r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN( 154)						Float g1;
HXDLIN( 154)						int this8 = ((this5 >> 8) & 255);
HXDLIN( 154)						if ((this8 == 0)) {
HXLINE( 154)							g1 = ((Float)0.);
            						}
            						else {
HXLINE( 154)							g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN( 154)						Float b1;
HXDLIN( 154)						int this9 = (this5 & 255);
HXDLIN( 154)						if ((this9 == 0)) {
HXLINE( 154)							b1 = ((Float)0.);
            						}
            						else {
HXLINE( 154)							b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN( 154)						Float a2;
HXDLIN( 154)						int this10 = ((color >> 24) & 255);
HXDLIN( 154)						if ((this10 == 0)) {
HXLINE( 154)							a2 = ((Float)0.);
            						}
            						else {
HXLINE( 154)							a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN( 154)						Float r2;
HXDLIN( 154)						int this11 = ((color >> 16) & 255);
HXDLIN( 154)						if ((this11 == 0)) {
HXLINE( 154)							r2 = ((Float)0.);
            						}
            						else {
HXLINE( 154)							r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN( 154)						Float g2;
HXDLIN( 154)						int this12 = ((color >> 8) & 255);
HXDLIN( 154)						if ((this12 == 0)) {
HXLINE( 154)							g2 = ((Float)0.);
            						}
            						else {
HXLINE( 154)							g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN( 154)						Float b2;
HXDLIN( 154)						int this13 = (color & 255);
HXDLIN( 154)						if ((this13 == 0)) {
HXLINE( 154)							b2 = ((Float)0.);
            						}
            						else {
HXLINE( 154)							b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN( 154)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 154)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 154)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 154)						int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 154)						int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 154)						int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 154)						{
HXLINE( 154)							::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN( 154)							int value;
HXDLIN( 154)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 154)								value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE( 154)								value = blended;
            							}
HXDLIN( 154)							bool _hx_tmp;
HXDLIN( 154)							if ((location >= 0)) {
HXLINE( 154)								_hx_tmp = (location < (this14->byteLength >> 2));
            							}
            							else {
HXLINE( 154)								_hx_tmp = false;
            							}
HXDLIN( 154)							if (_hx_tmp) {
HXLINE( 154)								::haxe::io::Bytes _this = this14->bytes;
HXDLIN( 154)								int pos = ((location << 2) + this14->byteOffset);
HXDLIN( 154)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 154)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 154)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 154)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
            					else {
HXLINE( 154)						::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 154)						int index;
HXDLIN( 154)						if (this1->useVirtualPos) {
HXLINE( 154)							index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + p) - this1->virtualX));
            						}
            						else {
HXLINE( 154)							index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + p)) ));
            						}
HXDLIN( 154)						int value;
HXDLIN( 154)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 154)							value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            						}
            						else {
HXLINE( 154)							value = c;
            						}
HXDLIN( 154)						bool _hx_tmp;
HXDLIN( 154)						if ((index >= 0)) {
HXLINE( 154)							_hx_tmp = (index < (this2->byteLength >> 2));
            						}
            						else {
HXLINE( 154)							_hx_tmp = false;
            						}
HXDLIN( 154)						if (_hx_tmp) {
HXLINE( 154)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 154)							int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 154)							_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 154)							_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 154)							_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 154)							_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            						}
            					}
            				}
HXDLIN( 154)				if ((q > maxY)) {
HXLINE( 154)					q = yy;
HXDLIN( 154)					q = (q + 1);
            				}
HXDLIN( 154)				if ((p > maxX)) {
HXLINE( 154)					goto _hx_goto_12;
            				}
            			}
            			_hx_goto_12:;
            		}
HXLINE( 156)		if ((this->fillPatternScale > 1)) {
HXLINE( 156)			::pixelimage::ImageStruct this1 = this->tileImageFill;
HXDLIN( 156)			int scaleW = this->fillPatternScale;
HXDLIN( 156)			int scaleH = this->fillPatternScale;
HXDLIN( 156)			bool includeMask = false;
HXDLIN( 156)			int p = 0;
HXDLIN( 156)			int xx = p;
HXDLIN( 156)			int q = 0;
HXDLIN( 156)			int wNew = ::Std_obj::_hx_int(( (Float)((this1->width * scaleW)) ));
HXDLIN( 156)			int hNew = ::Std_obj::_hx_int(( (Float)((this1->height * scaleH)) ));
HXDLIN( 156)			int size = (::Std_obj::_hx_int(( (Float)((wNew * hNew)) )) * 4);
HXDLIN( 156)			::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 156)			::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN( 156)			::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,wNew,hNew,this3);
HXDLIN( 156)			::pixelimage::ImageStruct pixelImage = this4;
HXDLIN( 156)			int maxX = wNew;
HXDLIN( 156)			int maxY = hNew;
HXDLIN( 156)			while(true){
HXLINE( 156)				int x = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN( 156)				int y = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN( 156)				::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 156)				int index;
HXDLIN( 156)				if (this1->useVirtualPos) {
HXLINE( 156)					index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            				}
            				else {
HXLINE( 156)					index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            				}
HXDLIN( 156)				::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 156)				int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 156)				int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 156)				int color;
HXDLIN( 156)				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXLINE( 156)					color = c;
            				}
HXDLIN( 156)				{
HXLINE( 156)					p = (p + 1);
HXDLIN( 156)					int x1 = (p - 1);
HXDLIN( 156)					int this3 = color;
HXDLIN( 156)					int c1 = this3;
HXDLIN( 156)					bool _hx_tmp;
HXDLIN( 156)					if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 156)						_hx_tmp = pixelImage->transparent;
            					}
            					else {
HXLINE( 156)						_hx_tmp = false;
            					}
HXDLIN( 156)					if (_hx_tmp) {
HXLINE( 156)						int location;
HXDLIN( 156)						if (pixelImage->useVirtualPos) {
HXLINE( 156)							location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x1) - pixelImage->virtualX));
            						}
            						else {
HXLINE( 156)							location = ::Std_obj::_hx_int(( (Float)(((q * pixelImage->width) + x1)) ));
            						}
HXDLIN( 156)						::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 156)						::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 156)						int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 156)						int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 156)						int this3 = this2;
HXDLIN( 156)						int this4;
HXDLIN( 156)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)							this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            						}
            						else {
HXLINE( 156)							this4 = this3;
            						}
HXDLIN( 156)						Float a1;
HXDLIN( 156)						int this5 = ((this4 >> 24) & 255);
HXDLIN( 156)						if ((this5 == 0)) {
HXLINE( 156)							a1 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float r1;
HXDLIN( 156)						int this6 = ((this4 >> 16) & 255);
HXDLIN( 156)						if ((this6 == 0)) {
HXLINE( 156)							r1 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float g1;
HXDLIN( 156)						int this7 = ((this4 >> 8) & 255);
HXDLIN( 156)						if ((this7 == 0)) {
HXLINE( 156)							g1 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float b1;
HXDLIN( 156)						int this8 = (this4 & 255);
HXDLIN( 156)						if ((this8 == 0)) {
HXLINE( 156)							b1 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float a2;
HXDLIN( 156)						int this9 = ((color >> 24) & 255);
HXDLIN( 156)						if ((this9 == 0)) {
HXLINE( 156)							a2 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float r2;
HXDLIN( 156)						int this10 = ((color >> 16) & 255);
HXDLIN( 156)						if ((this10 == 0)) {
HXLINE( 156)							r2 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float g2;
HXDLIN( 156)						int this11 = ((color >> 8) & 255);
HXDLIN( 156)						if ((this11 == 0)) {
HXLINE( 156)							g2 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float b2;
HXDLIN( 156)						int this12 = (color & 255);
HXDLIN( 156)						if ((this12 == 0)) {
HXLINE( 156)							b2 = ((Float)0.);
            						}
            						else {
HXLINE( 156)							b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN( 156)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 156)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 156)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 156)						int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 156)						int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 156)						int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 156)						{
HXLINE( 156)							::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 156)							int value;
HXDLIN( 156)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)								value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE( 156)								value = blended;
            							}
HXDLIN( 156)							bool _hx_tmp;
HXDLIN( 156)							if ((location >= 0)) {
HXLINE( 156)								_hx_tmp = (location < (this13->byteLength >> 2));
            							}
            							else {
HXLINE( 156)								_hx_tmp = false;
            							}
HXDLIN( 156)							if (_hx_tmp) {
HXLINE( 156)								::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 156)								int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 156)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 156)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 156)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 156)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
            					else {
HXLINE( 156)						::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 156)						int index;
HXDLIN( 156)						if (pixelImage->useVirtualPos) {
HXLINE( 156)							index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x1) - pixelImage->virtualX));
            						}
            						else {
HXLINE( 156)							index = ::Std_obj::_hx_int(( (Float)(((q * pixelImage->width) + x1)) ));
            						}
HXDLIN( 156)						int value;
HXDLIN( 156)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)							value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXLINE( 156)							value = c1;
            						}
HXDLIN( 156)						bool _hx_tmp;
HXDLIN( 156)						if ((index >= 0)) {
HXLINE( 156)							_hx_tmp = (index < (this1->byteLength >> 2));
            						}
            						else {
HXLINE( 156)							_hx_tmp = false;
            						}
HXDLIN( 156)						if (_hx_tmp) {
HXLINE( 156)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 156)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 156)							_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 156)							_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 156)							_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 156)							_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            						}
            					}
            				}
HXDLIN( 156)				if ((p > maxX)) {
HXLINE( 156)					p = xx;
HXDLIN( 156)					q = (q + 1);
            				}
HXDLIN( 156)				if ((q > maxY)) {
HXLINE( 156)					goto _hx_goto_13;
            				}
            			}
            			_hx_goto_13:;
HXDLIN( 156)			bool _hx_tmp;
HXDLIN( 156)			if (::hx::IsNotNull( this1->mask )) {
HXLINE( 156)				_hx_tmp = includeMask;
            			}
            			else {
HXLINE( 156)				_hx_tmp = false;
            			}
HXDLIN( 156)			if (_hx_tmp) {
HXLINE( 156)				::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN( 156)				bool transparent = this1->mask->transparent;
HXDLIN( 156)				int p = 0;
HXDLIN( 156)				int xx = p;
HXDLIN( 156)				int q = 0;
HXDLIN( 156)				int wNew = ::Std_obj::_hx_int(( (Float)((this2->width * scaleW)) ));
HXDLIN( 156)				int hNew = ::Std_obj::_hx_int(( (Float)((this2->height * scaleH)) ));
HXDLIN( 156)				int size = (::Std_obj::_hx_int(( (Float)((wNew * hNew)) )) * 4);
HXDLIN( 156)				::haxe::io::ArrayBufferViewImpl this3 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 156)				::haxe::io::ArrayBufferViewImpl this4 = this3;
HXDLIN( 156)				::pixelimage::ImageStruct this5 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,wNew,hNew,this4);
HXDLIN( 156)				::pixelimage::ImageStruct pixelImage1 = this5;
HXDLIN( 156)				int maxX = wNew;
HXDLIN( 156)				int maxY = hNew;
HXDLIN( 156)				while(true){
HXLINE( 156)					int x = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN( 156)					int y = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN( 156)					::haxe::io::ArrayBufferViewImpl this1 = this2->image;
HXDLIN( 156)					int index;
HXDLIN( 156)					if (this2->useVirtualPos) {
HXLINE( 156)						index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            					}
            					else {
HXLINE( 156)						index = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            					}
HXDLIN( 156)					::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 156)					int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 156)					int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 156)					int color;
HXDLIN( 156)					if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE( 156)						color = c;
            					}
HXDLIN( 156)					{
HXLINE( 156)						p = (p + 1);
HXDLIN( 156)						int x1 = (p - 1);
HXDLIN( 156)						int this3 = color;
HXDLIN( 156)						int c1 = this3;
HXDLIN( 156)						bool _hx_tmp;
HXDLIN( 156)						if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 156)							_hx_tmp = pixelImage1->transparent;
            						}
            						else {
HXLINE( 156)							_hx_tmp = false;
            						}
HXDLIN( 156)						if (_hx_tmp) {
HXLINE( 156)							int location;
HXDLIN( 156)							if (pixelImage1->useVirtualPos) {
HXLINE( 156)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelImage1->virtualY) * ( (Float)(pixelImage1->width) )) + x1) - pixelImage1->virtualX));
            							}
            							else {
HXLINE( 156)								location = ::Std_obj::_hx_int(( (Float)(((q * pixelImage1->width) + x1)) ));
            							}
HXDLIN( 156)							::haxe::io::ArrayBufferViewImpl this1 = pixelImage1->image;
HXDLIN( 156)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 156)							int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 156)							int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 156)							int this3 = this2;
HXDLIN( 156)							int this4;
HXDLIN( 156)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)								this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            							}
            							else {
HXLINE( 156)								this4 = this3;
            							}
HXDLIN( 156)							Float a1;
HXDLIN( 156)							int this5 = ((this4 >> 24) & 255);
HXDLIN( 156)							if ((this5 == 0)) {
HXLINE( 156)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 156)								a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            							}
HXDLIN( 156)							Float r1;
HXDLIN( 156)							int this6 = ((this4 >> 16) & 255);
HXDLIN( 156)							if ((this6 == 0)) {
HXLINE( 156)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 156)								r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 156)							Float g1;
HXDLIN( 156)							int this7 = ((this4 >> 8) & 255);
HXDLIN( 156)							if ((this7 == 0)) {
HXLINE( 156)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 156)								g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 156)							Float b1;
HXDLIN( 156)							int this8 = (this4 & 255);
HXDLIN( 156)							if ((this8 == 0)) {
HXLINE( 156)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 156)								b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 156)							Float a2;
HXDLIN( 156)							int this9 = ((color >> 24) & 255);
HXDLIN( 156)							if ((this9 == 0)) {
HXLINE( 156)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 156)								a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 156)							Float r2;
HXDLIN( 156)							int this10 = ((color >> 16) & 255);
HXDLIN( 156)							if ((this10 == 0)) {
HXLINE( 156)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 156)								r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 156)							Float g2;
HXDLIN( 156)							int this11 = ((color >> 8) & 255);
HXDLIN( 156)							if ((this11 == 0)) {
HXLINE( 156)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 156)								g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 156)							Float b2;
HXDLIN( 156)							int this12 = (color & 255);
HXDLIN( 156)							if ((this12 == 0)) {
HXLINE( 156)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 156)								b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 156)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 156)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 156)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 156)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 156)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 156)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 156)							{
HXLINE( 156)								::haxe::io::ArrayBufferViewImpl this13 = pixelImage1->image;
HXDLIN( 156)								int value;
HXDLIN( 156)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 156)									value = blended;
            								}
HXDLIN( 156)								bool _hx_tmp;
HXDLIN( 156)								if ((location >= 0)) {
HXLINE( 156)									_hx_tmp = (location < (this13->byteLength >> 2));
            								}
            								else {
HXLINE( 156)									_hx_tmp = false;
            								}
HXDLIN( 156)								if (_hx_tmp) {
HXLINE( 156)									::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 156)									int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 156)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 156)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 156)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 156)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE( 156)							::haxe::io::ArrayBufferViewImpl this1 = pixelImage1->image;
HXDLIN( 156)							int index;
HXDLIN( 156)							if (pixelImage1->useVirtualPos) {
HXLINE( 156)								index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelImage1->virtualY) * ( (Float)(pixelImage1->width) )) + x1) - pixelImage1->virtualX));
            							}
            							else {
HXLINE( 156)								index = ::Std_obj::_hx_int(( (Float)(((q * pixelImage1->width) + x1)) ));
            							}
HXDLIN( 156)							int value;
HXDLIN( 156)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 156)								value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            							}
            							else {
HXLINE( 156)								value = c1;
            							}
HXDLIN( 156)							bool _hx_tmp;
HXDLIN( 156)							if ((index >= 0)) {
HXLINE( 156)								_hx_tmp = (index < (this1->byteLength >> 2));
            							}
            							else {
HXLINE( 156)								_hx_tmp = false;
            							}
HXDLIN( 156)							if (_hx_tmp) {
HXLINE( 156)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 156)								int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 156)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 156)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 156)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 156)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN( 156)					if ((p > maxX)) {
HXLINE( 156)						p = xx;
HXDLIN( 156)						q = (q + 1);
            					}
HXDLIN( 156)					if ((q > maxY)) {
HXLINE( 156)						goto _hx_goto_14;
            					}
            				}
            				_hx_goto_14:;
HXDLIN( 156)				bool _hx_tmp;
HXDLIN( 156)				if (::hx::IsNotNull( this2->mask )) {
HXLINE( 156)					_hx_tmp = includeMask;
            				}
            				else {
HXLINE( 156)					_hx_tmp = false;
            				}
HXDLIN( 156)				if (_hx_tmp) {
HXLINE( 156)					::pixelimage::ImageStruct v = ::pixelimage::_Pixelimage::Pixelimage_Impl__obj::scaleUpInt(this2->mask,scaleW,scaleH,this2->mask->transparent,includeMask);
HXDLIN( 156)					pixelImage1->useMask = true;
HXDLIN( 156)					pixelImage1->mask = v;
            				}
HXDLIN( 156)				::pixelimage::ImageStruct v = pixelImage1;
HXDLIN( 156)				pixelImage->useMask = true;
HXDLIN( 156)				pixelImage->mask = v;
            			}
HXDLIN( 156)			this->tileImageFill = pixelImage;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(PatternShape_obj,buildPatternTemplates,(void))


::hx::ObjectPtr< PatternShape_obj > PatternShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale) {
	::hx::ObjectPtr< PatternShape_obj > __this = new PatternShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale);
	return __this;
}

::hx::ObjectPtr< PatternShape_obj > PatternShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale) {
	PatternShape_obj *__this = (PatternShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PatternShape_obj), true, "pixelimage.triangleGML.coreShape.PatternShape"));
	*(void **)__this = PatternShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale);
	return __this;
}

PatternShape_obj::PatternShape_obj()
{
}

void PatternShape_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PatternShape);
	HX_MARK_MEMBER_NAME(strokeColor0,"strokeColor0");
	HX_MARK_MEMBER_NAME(strokeColor1,"strokeColor1");
	HX_MARK_MEMBER_NAME(fillColor0,"fillColor0");
	HX_MARK_MEMBER_NAME(fillColor1,"fillColor1");
	HX_MARK_MEMBER_NAME(strokePatternFill,"strokePatternFill");
	HX_MARK_MEMBER_NAME(strokePatternWidth,"strokePatternWidth");
	HX_MARK_MEMBER_NAME(strokePatternHeight,"strokePatternHeight");
	HX_MARK_MEMBER_NAME(strokePatternAcross,"strokePatternAcross");
	HX_MARK_MEMBER_NAME(strokePatternScale,"strokePatternScale");
	HX_MARK_MEMBER_NAME(fillPatternFill,"fillPatternFill");
	HX_MARK_MEMBER_NAME(fillPatternWidth,"fillPatternWidth");
	HX_MARK_MEMBER_NAME(fillPatternHeight,"fillPatternHeight");
	HX_MARK_MEMBER_NAME(fillPatternAcross,"fillPatternAcross");
	HX_MARK_MEMBER_NAME(fillPatternScale,"fillPatternScale");
	HX_MARK_MEMBER_NAME(tiledBorder,"tiledBorder");
	HX_MARK_MEMBER_NAME(tileImageStroke,"tileImageStroke");
	HX_MARK_MEMBER_NAME(tileImageFill,"tileImageFill");
	::pixelimage::triangleGML::coreShape::BasicShape_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PatternShape_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(strokeColor0,"strokeColor0");
	HX_VISIT_MEMBER_NAME(strokeColor1,"strokeColor1");
	HX_VISIT_MEMBER_NAME(fillColor0,"fillColor0");
	HX_VISIT_MEMBER_NAME(fillColor1,"fillColor1");
	HX_VISIT_MEMBER_NAME(strokePatternFill,"strokePatternFill");
	HX_VISIT_MEMBER_NAME(strokePatternWidth,"strokePatternWidth");
	HX_VISIT_MEMBER_NAME(strokePatternHeight,"strokePatternHeight");
	HX_VISIT_MEMBER_NAME(strokePatternAcross,"strokePatternAcross");
	HX_VISIT_MEMBER_NAME(strokePatternScale,"strokePatternScale");
	HX_VISIT_MEMBER_NAME(fillPatternFill,"fillPatternFill");
	HX_VISIT_MEMBER_NAME(fillPatternWidth,"fillPatternWidth");
	HX_VISIT_MEMBER_NAME(fillPatternHeight,"fillPatternHeight");
	HX_VISIT_MEMBER_NAME(fillPatternAcross,"fillPatternAcross");
	HX_VISIT_MEMBER_NAME(fillPatternScale,"fillPatternScale");
	HX_VISIT_MEMBER_NAME(tiledBorder,"tiledBorder");
	HX_VISIT_MEMBER_NAME(tileImageStroke,"tileImageStroke");
	HX_VISIT_MEMBER_NAME(tileImageFill,"tileImageFill");
	::pixelimage::triangleGML::coreShape::BasicShape_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val PatternShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fillColor0") ) { return ::hx::Val( fillColor0 ); }
		if (HX_FIELD_EQ(inName,"fillColor1") ) { return ::hx::Val( fillColor1 ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"tiledBorder") ) { return ::hx::Val( tiledBorder ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"strokeColor0") ) { return ::hx::Val( strokeColor0 ); }
		if (HX_FIELD_EQ(inName,"strokeColor1") ) { return ::hx::Val( strokeColor1 ); }
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"tileImageFill") ) { return ::hx::Val( tileImageFill ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fillPatternFill") ) { return ::hx::Val( fillPatternFill ); }
		if (HX_FIELD_EQ(inName,"tileImageStroke") ) { return ::hx::Val( tileImageStroke ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fillPatternWidth") ) { return ::hx::Val( fillPatternWidth ); }
		if (HX_FIELD_EQ(inName,"fillPatternScale") ) { return ::hx::Val( fillPatternScale ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"strokePatternFill") ) { return ::hx::Val( strokePatternFill ); }
		if (HX_FIELD_EQ(inName,"fillPatternHeight") ) { return ::hx::Val( fillPatternHeight ); }
		if (HX_FIELD_EQ(inName,"fillPatternAcross") ) { return ::hx::Val( fillPatternAcross ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"strokePatternWidth") ) { return ::hx::Val( strokePatternWidth ); }
		if (HX_FIELD_EQ(inName,"strokePatternScale") ) { return ::hx::Val( strokePatternScale ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"strokePatternHeight") ) { return ::hx::Val( strokePatternHeight ); }
		if (HX_FIELD_EQ(inName,"strokePatternAcross") ) { return ::hx::Val( strokePatternAcross ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"buildPatternTemplates") ) { return ::hx::Val( buildPatternTemplates_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val PatternShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"fillColor0") ) { fillColor0=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fillColor1") ) { fillColor1=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"tiledBorder") ) { tiledBorder=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"strokeColor0") ) { strokeColor0=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"strokeColor1") ) { strokeColor1=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"tileImageFill") ) { tileImageFill=inValue.Cast< ::pixelimage::ImageStruct >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fillPatternFill") ) { fillPatternFill=inValue.Cast< ::Array< bool > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tileImageStroke") ) { tileImageStroke=inValue.Cast< ::pixelimage::ImageStruct >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fillPatternWidth") ) { fillPatternWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fillPatternScale") ) { fillPatternScale=inValue.Cast< int >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"strokePatternFill") ) { strokePatternFill=inValue.Cast< ::Array< bool > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fillPatternHeight") ) { fillPatternHeight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fillPatternAcross") ) { fillPatternAcross=inValue.Cast< bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"strokePatternWidth") ) { strokePatternWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"strokePatternScale") ) { strokePatternScale=inValue.Cast< int >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"strokePatternHeight") ) { strokePatternHeight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"strokePatternAcross") ) { strokePatternAcross=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PatternShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("strokeColor0",45,87,c5,50));
	outFields->push(HX_("strokeColor1",46,87,c5,50));
	outFields->push(HX_("fillColor0",50,4c,21,ca));
	outFields->push(HX_("fillColor1",51,4c,21,ca));
	outFields->push(HX_("strokePatternFill",1b,f8,d0,11));
	outFields->push(HX_("strokePatternWidth",6e,f1,d1,4e));
	outFields->push(HX_("strokePatternHeight",7f,c7,30,5f));
	outFields->push(HX_("strokePatternAcross",17,1f,dd,71));
	outFields->push(HX_("strokePatternScale",f2,09,3e,fd));
	outFields->push(HX_("fillPatternFill",30,0b,98,82));
	outFields->push(HX_("fillPatternWidth",b9,90,3b,8c));
	outFields->push(HX_("fillPatternHeight",d4,89,32,de));
	outFields->push(HX_("fillPatternAcross",6c,e1,de,f0));
	outFields->push(HX_("fillPatternScale",3d,a9,a7,3a));
	outFields->push(HX_("tiledBorder",02,3b,24,a9));
	outFields->push(HX_("tileImageStroke",e5,1c,7e,f6));
	outFields->push(HX_("tileImageFill",70,a2,b6,95));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PatternShape_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(PatternShape_obj,strokeColor0),HX_("strokeColor0",45,87,c5,50)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,strokeColor1),HX_("strokeColor1",46,87,c5,50)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,fillColor0),HX_("fillColor0",50,4c,21,ca)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,fillColor1),HX_("fillColor1",51,4c,21,ca)},
	{::hx::fsObject /* ::Array< bool > */ ,(int)offsetof(PatternShape_obj,strokePatternFill),HX_("strokePatternFill",1b,f8,d0,11)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,strokePatternWidth),HX_("strokePatternWidth",6e,f1,d1,4e)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,strokePatternHeight),HX_("strokePatternHeight",7f,c7,30,5f)},
	{::hx::fsBool,(int)offsetof(PatternShape_obj,strokePatternAcross),HX_("strokePatternAcross",17,1f,dd,71)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,strokePatternScale),HX_("strokePatternScale",f2,09,3e,fd)},
	{::hx::fsObject /* ::Array< bool > */ ,(int)offsetof(PatternShape_obj,fillPatternFill),HX_("fillPatternFill",30,0b,98,82)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,fillPatternWidth),HX_("fillPatternWidth",b9,90,3b,8c)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,fillPatternHeight),HX_("fillPatternHeight",d4,89,32,de)},
	{::hx::fsBool,(int)offsetof(PatternShape_obj,fillPatternAcross),HX_("fillPatternAcross",6c,e1,de,f0)},
	{::hx::fsInt,(int)offsetof(PatternShape_obj,fillPatternScale),HX_("fillPatternScale",3d,a9,a7,3a)},
	{::hx::fsBool,(int)offsetof(PatternShape_obj,tiledBorder),HX_("tiledBorder",02,3b,24,a9)},
	{::hx::fsObject /* ::pixelimage::ImageStruct */ ,(int)offsetof(PatternShape_obj,tileImageStroke),HX_("tileImageStroke",e5,1c,7e,f6)},
	{::hx::fsObject /* ::pixelimage::ImageStruct */ ,(int)offsetof(PatternShape_obj,tileImageFill),HX_("tileImageFill",70,a2,b6,95)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *PatternShape_obj_sStaticStorageInfo = 0;
#endif

static ::String PatternShape_obj_sMemberFields[] = {
	HX_("strokeColor0",45,87,c5,50),
	HX_("strokeColor1",46,87,c5,50),
	HX_("fillColor0",50,4c,21,ca),
	HX_("fillColor1",51,4c,21,ca),
	HX_("strokePatternFill",1b,f8,d0,11),
	HX_("strokePatternWidth",6e,f1,d1,4e),
	HX_("strokePatternHeight",7f,c7,30,5f),
	HX_("strokePatternAcross",17,1f,dd,71),
	HX_("strokePatternScale",f2,09,3e,fd),
	HX_("fillPatternFill",30,0b,98,82),
	HX_("fillPatternWidth",b9,90,3b,8c),
	HX_("fillPatternHeight",d4,89,32,de),
	HX_("fillPatternAcross",6c,e1,de,f0),
	HX_("fillPatternScale",3d,a9,a7,3a),
	HX_("tiledBorder",02,3b,24,a9),
	HX_("tileImageStroke",e5,1c,7e,f6),
	HX_("tileImageFill",70,a2,b6,95),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	HX_("buildPatternTemplates",d7,4d,8f,f7),
	::String(null()) };

::hx::Class PatternShape_obj::__mClass;

void PatternShape_obj::__register()
{
	PatternShape_obj _hx_dummy;
	PatternShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.coreShape.PatternShape",06,6e,09,ff);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PatternShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PatternShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PatternShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PatternShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace coreShape
