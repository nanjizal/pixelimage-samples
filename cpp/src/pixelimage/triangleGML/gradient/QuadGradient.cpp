// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicGradient
#include <pixelimage/triangleGML/coreShape/BasicGradient.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_gradient_QuadGradient
#include <pixelimage/triangleGML/gradient/QuadGradient.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_55708f0b035799ea_35_new,"pixelimage.triangleGML.gradient.QuadGradient","new",0x0d8e89be,"pixelimage.triangleGML.gradient.QuadGradient.new","pixelimage/triangleGML/gradient/QuadGradient.hx",35,0xd78a1413)
HX_LOCAL_STACK_FRAME(_hx_pos_55708f0b035799ea_47_setParameter,"pixelimage.triangleGML.gradient.QuadGradient","setParameter",0x547e2089,"pixelimage.triangleGML.gradient.QuadGradient.setParameter","pixelimage/triangleGML/gradient/QuadGradient.hx",47,0xd78a1413)
HX_LOCAL_STACK_FRAME(_hx_pos_55708f0b035799ea_76_render,"pixelimage.triangleGML.gradient.QuadGradient","render",0xfeca60b8,"pixelimage.triangleGML.gradient.QuadGradient.render","pixelimage/triangleGML/gradient/QuadGradient.hx",76,0xd78a1413)
namespace pixelimage{
namespace triangleGML{
namespace gradient{

void QuadGradient_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< int >  __o_color1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< int >  __o_color2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3,::hx::Null< int >  __o_color3,::hx::Null< Float >  __o_x4,::hx::Null< Float >  __o_y4,::hx::Null< int >  __o_color4){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		Float x1 = __o_x1.Default(((Float)0.));
            		Float y1 = __o_y1.Default(((Float)0.));
            		int color1 = __o_color1.Default(-2490624);
            		Float x2 = __o_x2.Default(((Float)0.));
            		Float y2 = __o_y2.Default(((Float)0.));
            		int color2 = __o_color2.Default(-65285);
            		Float x3 = __o_x3.Default(((Float)0.));
            		Float y3 = __o_y3.Default(((Float)0.));
            		int color3 = __o_color3.Default(-16711745);
            		Float x4 = __o_x4.Default(((Float)0.));
            		Float y4 = __o_y4.Default(((Float)0.));
            		int color4 = __o_color4.Default(-27392);
            	HX_STACKFRAME(&_hx_pos_55708f0b035799ea_35_new)
HXLINE(  36)		super::__construct(opacity,visibility,::Array_obj< int >::__new(4)->init(0,color1)->init(1,color2)->init(2,color3)->init(3,color4));
HXLINE(  37)		this->x1 = x1;
HXLINE(  38)		this->y1 = y1;
HXLINE(  39)		this->x2 = x2;
HXLINE(  40)		this->y2 = y2;
HXLINE(  41)		this->x3 = x3;
HXLINE(  42)		this->y3 = y3;
HXLINE(  43)		this->x4 = x4;
HXLINE(  44)		this->y4 = y4;
            	}

Dynamic QuadGradient_obj::__CreateEmpty() { return new QuadGradient_obj; }

void *QuadGradient_obj::_hx_vtable = 0;

Dynamic QuadGradient_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< QuadGradient_obj > _hx_result = new QuadGradient_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13]);
	return _hx_result;
}

bool QuadGradient_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5d356050) {
		if (inClassId<=(int)0x24e92cfb) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x24e92cfb;
		} else {
			return inClassId==(int)0x5d356050;
		}
	} else {
		return inClassId==(int)0x68e012c5;
	}
}

void QuadGradient_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_55708f0b035799ea_47_setParameter)
HXDLIN(  47)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("color1",6e,c5,86,c6)) ){
HXLINE(  65)			this->cornerColors[0] = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  65)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("color2",6f,c5,86,c6)) ){
HXLINE(  67)			this->cornerColors[1] = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  67)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("color3",70,c5,86,c6)) ){
HXLINE(  69)			this->cornerColors[2] = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  69)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("color4",71,c5,86,c6)) ){
HXLINE(  71)			this->cornerColors[3] = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  71)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x1",b9,68,00,00)) ){
HXLINE(  49)			this->x1 = ::Std_obj::parseFloat(value);
HXDLIN(  49)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x2",ba,68,00,00)) ){
HXLINE(  53)			this->x2 = ::Std_obj::parseFloat(value);
HXDLIN(  53)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x3",bb,68,00,00)) ){
HXLINE(  57)			this->x3 = ::Std_obj::parseFloat(value);
HXDLIN(  57)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x4",bc,68,00,00)) ){
HXLINE(  61)			this->x4 = ::Std_obj::parseFloat(value);
HXDLIN(  61)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y1",98,69,00,00)) ){
HXLINE(  51)			this->y1 = ::Std_obj::parseFloat(value);
HXDLIN(  51)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y2",99,69,00,00)) ){
HXLINE(  55)			this->y2 = ::Std_obj::parseFloat(value);
HXDLIN(  55)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y3",9a,69,00,00)) ){
HXLINE(  59)			this->y3 = ::Std_obj::parseFloat(value);
HXDLIN(  59)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y4",9b,69,00,00)) ){
HXLINE(  63)			this->y4 = ::Std_obj::parseFloat(value);
HXDLIN(  63)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  73)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct QuadGradient_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_55708f0b035799ea_76_render)
HXLINE(  77)		Float x1_ = (this->x1 + this->offX);
HXLINE(  78)		Float x2_ = (this->x2 + this->offX);
HXLINE(  79)		Float x3_ = (this->x3 + this->offX);
HXLINE(  80)		Float x4_ = (this->x4 + this->offX);
HXLINE(  81)		Float y1_ = (this->y1 + this->offY);
HXLINE(  82)		Float y2_ = (this->y2 + this->offY);
HXLINE(  83)		Float y3_ = (this->y3 + this->offY);
HXLINE(  84)		Float y4_ = (this->y4 + this->offY);
HXLINE(  85)		int min = ::Math_obj::floor(x1_);
HXDLIN(  85)		int max = ::Math_obj::ceil(x1_);
HXDLIN(  85)		if ((x2_ < min)) {
HXLINE(  31)			min = ::Math_obj::floor(x2_);
            		}
            		else {
HXLINE(  85)			if ((x2_ > max)) {
HXLINE(  33)				max = ::Math_obj::ceil(x2_);
            			}
            		}
HXLINE(  85)		if ((x3_ < min)) {
HXLINE(  36)			min = ::Math_obj::floor(x3_);
            		}
            		else {
HXLINE(  85)			if ((x3_ > max)) {
HXLINE(  38)				max = ::Math_obj::ceil(x3_);
            			}
            		}
HXLINE(  85)		if ((x4_ < min)) {
HXLINE(  41)			min = ::Math_obj::floor(x4_);
            		}
            		else {
HXLINE(  85)			if ((x4_ > max)) {
HXLINE(  43)				max = ::Math_obj::ceil(x4_);
            			}
            		}
HXLINE(  85)		int ii_min = min;
HXDLIN(  85)		int ii_max = max;
HXDLIN(  85)		::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)		::pixelimage::iter::IntIterStart iterX = this1;
HXLINE(  86)		int min1 = ::Math_obj::floor(y1_);
HXDLIN(  86)		int max1 = ::Math_obj::ceil(y1_);
HXDLIN(  86)		if ((y2_ < min1)) {
HXLINE(  31)			min1 = ::Math_obj::floor(y2_);
            		}
            		else {
HXLINE(  86)			if ((y2_ > max1)) {
HXLINE(  33)				max1 = ::Math_obj::ceil(y2_);
            			}
            		}
HXLINE(  86)		if ((y3_ < min1)) {
HXLINE(  36)			min1 = ::Math_obj::floor(y3_);
            		}
            		else {
HXLINE(  86)			if ((y3_ > max1)) {
HXLINE(  38)				max1 = ::Math_obj::ceil(y3_);
            			}
            		}
HXLINE(  86)		if ((y4_ < min1)) {
HXLINE(  41)			min1 = ::Math_obj::floor(y4_);
            		}
            		else {
HXLINE(  86)			if ((y4_ > max1)) {
HXLINE(  43)				max1 = ::Math_obj::ceil(y4_);
            			}
            		}
HXLINE(  86)		int ii_min1 = min1;
HXDLIN(  86)		int ii_max1 = max1;
HXDLIN(  86)		::pixelimage::iter::IntIterStart this2 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
HXDLIN(  86)		::pixelimage::iter::IntIterStart iterY = this2;
HXLINE(  87)		int left = iterX->start;
HXLINE(  88)		int top = iterY->start;
HXLINE(  89)		int width = (iterX->max - left);
HXLINE(  90)		int height = (iterY->max - top);
HXLINE(  91)		int w = ::Math_obj::ceil(( (Float)(width) ));
HXDLIN(  91)		int h = ::Math_obj::ceil(( (Float)(height) ));
HXDLIN(  91)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  91)		::haxe::io::ArrayBufferViewImpl this3 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  91)		::haxe::io::ArrayBufferViewImpl this4 = this3;
HXDLIN(  91)		::pixelimage::ImageStruct this5 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this4);
HXDLIN(  91)		::pixelimage::ImageStruct this6 = this5;
HXDLIN(  91)		::pixelimage::ImageStruct temp = this6;
HXLINE(  92)		temp->transparent = false;
HXLINE(  93)		{
HXLINE(  93)			int colorA = this->cornerColors->__get(0);
HXDLIN(  93)			int colorB = this->cornerColors->__get(1);
HXDLIN(  93)			int colorC = this->cornerColors->__get(2);
HXDLIN(  93)			int colorD = this->cornerColors->__get(3);
HXDLIN(  93)			bool hasHit = true;
HXDLIN(  93)			{
HXLINE(  93)				{
HXLINE(  93)					bool hasUndo = false;
HXDLIN(  93)					int aA = ((colorB >> 24) & 255);
HXDLIN(  93)					int rA = ((colorB >> 16) & 255);
HXDLIN(  93)					int gA = ((colorB >> 8) & 255);
HXDLIN(  93)					int bA = (colorB & 255);
HXDLIN(  93)					int aB = ((colorA >> 24) & 255);
HXDLIN(  93)					int rB = ((colorA >> 16) & 255);
HXDLIN(  93)					int gB = ((colorA >> 8) & 255);
HXDLIN(  93)					int bB = (colorA & 255);
HXDLIN(  93)					int aC = ((colorD >> 24) & 255);
HXDLIN(  93)					int rC = ((colorD >> 16) & 255);
HXDLIN(  93)					int gC = ((colorD >> 8) & 255);
HXDLIN(  93)					int bC = (colorD & 255);
HXDLIN(  93)					Float bcx = (x2_ - x4_);
HXDLIN(  93)					Float bcy = (y2_ - y4_);
HXDLIN(  93)					Float acx = (x1_ - x4_);
HXDLIN(  93)					Float acy = (y1_ - y4_);
HXDLIN(  93)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  93)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  93)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  93)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  93)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  93)					if ((x1_ > x2_)) {
HXLINE(  93)						if ((x1_ > x4_)) {
HXLINE(  93)							int min;
HXDLIN(  93)							if ((x2_ > x4_)) {
HXLINE(  93)								min = ::Math_obj::floor(x4_);
            							}
            							else {
HXLINE(  93)								min = ::Math_obj::floor(x2_);
            							}
HXDLIN(  93)							int ii_min = min;
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(x1_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							xIter3 = this1;
            						}
            						else {
HXLINE(  93)							int ii_min = ::Math_obj::floor(x2_);
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(x4_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE(  93)						if ((x2_ > x4_)) {
HXLINE(  93)							int min;
HXDLIN(  93)							if ((x1_ > x4_)) {
HXLINE(  93)								min = ::Math_obj::floor(x4_);
            							}
            							else {
HXLINE(  93)								min = ::Math_obj::ceil(x1_);
            							}
HXDLIN(  93)							int ii_min = min;
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(x2_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							xIter3 = this1;
            						}
            						else {
HXLINE(  93)							int ii_min = ::Math_obj::floor(x1_);
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(x4_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							xIter3 = this1;
            						}
            					}
HXDLIN(  93)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  93)					if ((y1_ > y2_)) {
HXLINE(  93)						if ((y1_ > y4_)) {
HXLINE(  93)							int min;
HXDLIN(  93)							if ((y2_ > y4_)) {
HXLINE(  93)								min = ::Math_obj::floor(y4_);
            							}
            							else {
HXLINE(  93)								min = ::Math_obj::floor(y2_);
            							}
HXDLIN(  93)							int ii_min = min;
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(y1_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							yIter3 = this1;
            						}
            						else {
HXLINE(  93)							int ii_min = ::Math_obj::floor(y2_);
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(y4_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE(  93)						if ((y2_ > y4_)) {
HXLINE(  93)							int min;
HXDLIN(  93)							if ((y1_ > y4_)) {
HXLINE(  93)								min = ::Math_obj::floor(y4_);
            							}
            							else {
HXLINE(  93)								min = ::Math_obj::ceil(y1_);
            							}
HXDLIN(  93)							int ii_min = min;
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(y2_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							yIter3 = this1;
            						}
            						else {
HXLINE(  93)							int ii_min = ::Math_obj::floor(y1_);
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(y4_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							yIter3 = this1;
            						}
            					}
HXDLIN(  93)					::pixelimage::ImageStruct undoImage = null();
HXDLIN(  93)					if (hasUndo) {
HXLINE(  93)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  93)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  93)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)						undoImage = this3;
HXDLIN(  93)						{
HXLINE(  93)							int rectLeft = xIter3->start;
HXDLIN(  93)							int rectTop = yIter3->start;
HXDLIN(  93)							int rectRight = xIter3->max;
HXDLIN(  93)							bool forceClear = false;
HXDLIN(  93)							{
HXLINE(  93)								int _g = rectTop;
HXDLIN(  93)								int _g1 = yIter3->max;
HXDLIN(  93)								while((_g < _g1)){
HXLINE(  93)									_g = (_g + 1);
HXDLIN(  93)									int dy = (_g - 1);
HXDLIN(  93)									{
HXLINE(  93)										int _g1 = rectLeft;
HXDLIN(  93)										int _g2 = rectRight;
HXDLIN(  93)										while((_g1 < _g2)){
HXLINE(  93)											_g1 = (_g1 + 1);
HXDLIN(  93)											int dx = (_g1 - 1);
HXDLIN(  93)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  93)											int index;
HXDLIN(  93)											if (temp->useVirtualPos) {
HXLINE(  93)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            											}
            											else {
HXLINE(  93)												index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            											}
HXDLIN(  93)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)											int col;
HXDLIN(  93)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  93)												col = c;
            											}
HXDLIN(  93)											bool _hx_tmp;
HXDLIN(  93)											if (temp->useMask) {
HXLINE(  93)												_hx_tmp = ::hx::IsNotNull( temp->mask );
            											}
            											else {
HXLINE(  93)												_hx_tmp = false;
            											}
HXDLIN(  93)											if (_hx_tmp) {
HXLINE(  93)												::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  93)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)												int index;
HXDLIN(  93)												if (this1->useVirtualPos) {
HXLINE(  93)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  93)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  93)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)												int v;
HXDLIN(  93)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  93)													v = c;
            												}
HXDLIN(  93)												int this3 = v;
HXDLIN(  93)												int maskPixel = this3;
HXDLIN(  93)												int this4 = col;
HXDLIN(  93)												int this5 = this4;
HXDLIN(  93)												if ((maskPixel == 0)) {
HXLINE(  93)													int this1 = this5;
HXDLIN(  93)													col = this1;
            												}
            												else {
HXLINE(  93)													Float m0;
HXDLIN(  93)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)													if ((this1 == 0)) {
HXLINE(  93)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float m1;
HXDLIN(  93)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)													if ((this2 == 0)) {
HXLINE(  93)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float m2;
HXDLIN(  93)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)													if ((this3 == 0)) {
HXLINE(  93)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float m3;
HXDLIN(  93)													int this4 = (maskPixel & 255);
HXDLIN(  93)													if ((this4 == 0)) {
HXLINE(  93)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  93)											if ((col != 0)) {
HXLINE(  93)												int x = (dx - rectLeft);
HXDLIN(  93)												int y = (dy - rectTop);
HXDLIN(  93)												int this1 = col;
HXDLIN(  93)												int c = this1;
HXDLIN(  93)												bool _hx_tmp;
HXDLIN(  93)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE(  93)													_hx_tmp = false;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													int location;
HXDLIN(  93)													if (undoImage->useVirtualPos) {
HXLINE(  93)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  93)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  93)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)													int this3 = this2;
HXDLIN(  93)													int this4;
HXDLIN(  93)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  93)														this4 = this3;
            													}
HXDLIN(  93)													Float a1;
HXDLIN(  93)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)													if ((this5 == 0)) {
HXLINE(  93)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float r1;
HXDLIN(  93)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)													if ((this6 == 0)) {
HXLINE(  93)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float g1;
HXDLIN(  93)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)													if ((this7 == 0)) {
HXLINE(  93)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float b1;
HXDLIN(  93)													int this8 = (this4 & 255);
HXDLIN(  93)													if ((this8 == 0)) {
HXLINE(  93)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float a2;
HXDLIN(  93)													int this9 = ((col >> 24) & 255);
HXDLIN(  93)													if ((this9 == 0)) {
HXLINE(  93)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float r2;
HXDLIN(  93)													int this10 = ((col >> 16) & 255);
HXDLIN(  93)													if ((this10 == 0)) {
HXLINE(  93)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float g2;
HXDLIN(  93)													int this11 = ((col >> 8) & 255);
HXDLIN(  93)													if ((this11 == 0)) {
HXLINE(  93)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float b2;
HXDLIN(  93)													int this12 = (col & 255);
HXDLIN(  93)													if ((this12 == 0)) {
HXLINE(  93)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)													{
HXLINE(  93)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  93)														int value;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  93)															value = blended;
            														}
HXDLIN(  93)														bool _hx_tmp;
HXDLIN(  93)														if ((location >= 0)) {
HXLINE(  93)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  93)															_hx_tmp = false;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  93)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)													int index;
HXDLIN(  93)													if (undoImage->useVirtualPos) {
HXLINE(  93)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  93)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  93)													int value;
HXDLIN(  93)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  93)														value = c;
            													}
HXDLIN(  93)													bool _hx_tmp;
HXDLIN(  93)													if ((index >= 0)) {
HXLINE(  93)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  93)														_hx_tmp = false;
            													}
HXDLIN(  93)													if (_hx_tmp) {
HXLINE(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  93)												if (forceClear) {
HXLINE(  93)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)													int x = (dx - rectLeft);
HXDLIN(  93)													int y = (dy - rectTop);
HXDLIN(  93)													int index;
HXDLIN(  93)													if (undoImage->useVirtualPos) {
HXLINE(  93)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  93)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  93)													bool _hx_tmp;
HXDLIN(  93)													if ((index >= 0)) {
HXLINE(  93)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  93)														_hx_tmp = false;
            													}
HXDLIN(  93)													if (_hx_tmp) {
HXLINE(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  93)					{
HXLINE(  93)						int _g_min = xIter3->start;
HXDLIN(  93)						int _g_max = xIter3->max;
HXDLIN(  93)						while((_g_min < _g_max)){
HXLINE(  93)							_g_min = (_g_min + 1);
HXDLIN(  93)							int px = (_g_min - 1);
HXDLIN(  93)							Float pcx = (( (Float)(px) ) - x4_);
HXDLIN(  93)							{
HXLINE(  93)								int _g_min1 = yIter3->start;
HXDLIN(  93)								int _g_max = yIter3->max;
HXDLIN(  93)								while((_g_min1 < _g_max)){
HXLINE(  93)									_g_min1 = (_g_min1 + 1);
HXDLIN(  93)									int py = (_g_min1 - 1);
HXDLIN(  93)									Float pcy = (( (Float)(py) ) - y4_);
HXDLIN(  93)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  93)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  93)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  93)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  93)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  93)									bool _hx_tmp;
HXDLIN(  93)									bool _hx_tmp1;
HXDLIN(  93)									if ((ratioA >= 0)) {
HXLINE(  93)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  93)										_hx_tmp1 = false;
            									}
HXDLIN(  93)									if (_hx_tmp1) {
HXLINE(  93)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  93)										_hx_tmp = false;
            									}
HXDLIN(  93)									if (_hx_tmp) {
HXLINE(  93)										int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  93)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  93)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  93)										int this1 = i;
HXDLIN(  93)										int a = this1;
HXDLIN(  93)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  93)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  93)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  93)										int this2 = i1;
HXDLIN(  93)										int r = this2;
HXDLIN(  93)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  93)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  93)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  93)										int this3 = i2;
HXDLIN(  93)										int g = this3;
HXDLIN(  93)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  93)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  93)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  93)										int this4 = i3;
HXDLIN(  93)										int b = this4;
HXDLIN(  93)										{
HXLINE(  93)											int location;
HXDLIN(  93)											if (temp->useVirtualPos) {
HXLINE(  93)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - temp->virtualY) * ( (Float)(temp->width) )) + px) - temp->virtualX));
            											}
            											else {
HXLINE(  93)												location = ::Std_obj::_hx_int(( (Float)(((py * temp->width) + px)) ));
            											}
HXDLIN(  93)											bool _hx_tmp;
HXDLIN(  93)											if (temp->transparent) {
HXLINE(  93)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  93)												_hx_tmp = false;
            											}
HXDLIN(  93)											if (_hx_tmp) {
HXLINE(  93)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  93)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)												int this3 = this2;
HXDLIN(  93)												int old;
HXDLIN(  93)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  93)													old = this3;
            												}
HXDLIN(  93)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)												Float a1;
HXDLIN(  93)												int this4 = ((old >> 24) & 255);
HXDLIN(  93)												if ((this4 == 0)) {
HXLINE(  93)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float r1;
HXDLIN(  93)												int this5 = ((old >> 16) & 255);
HXDLIN(  93)												if ((this5 == 0)) {
HXLINE(  93)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float g1;
HXDLIN(  93)												int this6 = ((old >> 8) & 255);
HXDLIN(  93)												if ((this6 == 0)) {
HXLINE(  93)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float b1;
HXDLIN(  93)												int this7 = (old & 255);
HXDLIN(  93)												if ((this7 == 0)) {
HXLINE(  93)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float a2;
HXDLIN(  93)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  93)												if ((this8 == 0)) {
HXLINE(  93)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float r2;
HXDLIN(  93)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  93)												if ((this9 == 0)) {
HXLINE(  93)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float g2;
HXDLIN(  93)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  93)												if ((this10 == 0)) {
HXLINE(  93)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float b2;
HXDLIN(  93)												int this11 = (rhs & 255);
HXDLIN(  93)												if ((this11 == 0)) {
HXLINE(  93)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  93)												{
HXLINE(  93)													::haxe::io::ArrayBufferViewImpl this12 = temp->image;
HXDLIN(  93)													int value;
HXDLIN(  93)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  93)														value = blended;
            													}
HXDLIN(  93)													bool _hx_tmp;
HXDLIN(  93)													if ((location >= 0)) {
HXLINE(  93)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  93)														_hx_tmp = false;
            													}
HXDLIN(  93)													if (_hx_tmp) {
HXLINE(  93)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  93)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  93)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  93)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  93)												int value;
HXDLIN(  93)												if (temp->isLittle) {
HXLINE(  93)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  93)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  93)												bool _hx_tmp;
HXDLIN(  93)												if ((location >= 0)) {
HXLINE(  93)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  93)													_hx_tmp = false;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  93)					if ((hasHit == false)) {
HXLINE(  93)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x1_,y1_,x2_,y2_,x4_,y4_,true);
HXDLIN(  93)						if (hasUndo) {
HXLINE(  93)							v->undoImage = undoImage;
HXDLIN(  93)							v->undoX = xIter3->start;
HXDLIN(  93)							v->undoY = yIter3->start;
            						}
            					}
            				}
HXDLIN(  93)				{
HXLINE(  93)					bool hasHit1 = false;
HXDLIN(  93)					bool hasUndo1 = false;
HXDLIN(  93)					int aA1 = ((colorC >> 24) & 255);
HXDLIN(  93)					int rA1 = ((colorC >> 16) & 255);
HXDLIN(  93)					int gA1 = ((colorC >> 8) & 255);
HXDLIN(  93)					int bA1 = (colorC & 255);
HXDLIN(  93)					int aB1 = ((colorB >> 24) & 255);
HXDLIN(  93)					int rB1 = ((colorB >> 16) & 255);
HXDLIN(  93)					int gB1 = ((colorB >> 8) & 255);
HXDLIN(  93)					int bB1 = (colorB & 255);
HXDLIN(  93)					int aC1 = ((colorD >> 24) & 255);
HXDLIN(  93)					int rC1 = ((colorD >> 16) & 255);
HXDLIN(  93)					int gC1 = ((colorD >> 8) & 255);
HXDLIN(  93)					int bC1 = (colorD & 255);
HXDLIN(  93)					Float bcx1 = (x3_ - x4_);
HXDLIN(  93)					Float bcy1 = (y3_ - y4_);
HXDLIN(  93)					Float acx1 = (x2_ - x4_);
HXDLIN(  93)					Float acy1 = (y2_ - y4_);
HXDLIN(  93)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  93)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  93)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  93)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  93)					::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  93)					if ((x2_ > x3_)) {
HXLINE(  93)						if ((x2_ > x4_)) {
HXLINE(  93)							int min;
HXDLIN(  93)							if ((x3_ > x4_)) {
HXLINE(  93)								min = ::Math_obj::floor(x4_);
            							}
            							else {
HXLINE(  93)								min = ::Math_obj::floor(x3_);
            							}
HXDLIN(  93)							int ii_min = min;
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(x2_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							xIter31 = this1;
            						}
            						else {
HXLINE(  93)							int ii_min = ::Math_obj::floor(x3_);
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(x4_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							xIter31 = this1;
            						}
            					}
            					else {
HXLINE(  93)						if ((x3_ > x4_)) {
HXLINE(  93)							int min;
HXDLIN(  93)							if ((x2_ > x4_)) {
HXLINE(  93)								min = ::Math_obj::floor(x4_);
            							}
            							else {
HXLINE(  93)								min = ::Math_obj::ceil(x2_);
            							}
HXDLIN(  93)							int ii_min = min;
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(x3_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							xIter31 = this1;
            						}
            						else {
HXLINE(  93)							int ii_min = ::Math_obj::floor(x2_);
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(x4_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							xIter31 = this1;
            						}
            					}
HXDLIN(  93)					::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  93)					if ((y2_ > y3_)) {
HXLINE(  93)						if ((y2_ > y4_)) {
HXLINE(  93)							int min;
HXDLIN(  93)							if ((y3_ > y4_)) {
HXLINE(  93)								min = ::Math_obj::floor(y4_);
            							}
            							else {
HXLINE(  93)								min = ::Math_obj::floor(y3_);
            							}
HXDLIN(  93)							int ii_min = min;
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(y2_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							yIter31 = this1;
            						}
            						else {
HXLINE(  93)							int ii_min = ::Math_obj::floor(y3_);
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(y4_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							yIter31 = this1;
            						}
            					}
            					else {
HXLINE(  93)						if ((y3_ > y4_)) {
HXLINE(  93)							int min;
HXDLIN(  93)							if ((y2_ > y4_)) {
HXLINE(  93)								min = ::Math_obj::floor(y4_);
            							}
            							else {
HXLINE(  93)								min = ::Math_obj::ceil(y2_);
            							}
HXDLIN(  93)							int ii_min = min;
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(y3_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							yIter31 = this1;
            						}
            						else {
HXLINE(  93)							int ii_min = ::Math_obj::floor(y2_);
HXDLIN(  93)							int ii_max = ::Math_obj::ceil(y4_);
HXDLIN(  93)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)							yIter31 = this1;
            						}
            					}
HXDLIN(  93)					::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  93)					if (hasUndo1) {
HXLINE(  93)						int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  93)						int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  93)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)						undoImage1 = this3;
HXDLIN(  93)						{
HXLINE(  93)							int rectLeft = xIter31->start;
HXDLIN(  93)							int rectTop = yIter31->start;
HXDLIN(  93)							int rectRight = xIter31->max;
HXDLIN(  93)							bool forceClear = false;
HXDLIN(  93)							{
HXLINE(  93)								int _g = rectTop;
HXDLIN(  93)								int _g1 = yIter31->max;
HXDLIN(  93)								while((_g < _g1)){
HXLINE(  93)									_g = (_g + 1);
HXDLIN(  93)									int dy = (_g - 1);
HXDLIN(  93)									{
HXLINE(  93)										int _g1 = rectLeft;
HXDLIN(  93)										int _g2 = rectRight;
HXDLIN(  93)										while((_g1 < _g2)){
HXLINE(  93)											_g1 = (_g1 + 1);
HXDLIN(  93)											int dx = (_g1 - 1);
HXDLIN(  93)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  93)											int index;
HXDLIN(  93)											if (temp->useVirtualPos) {
HXLINE(  93)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            											}
            											else {
HXLINE(  93)												index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            											}
HXDLIN(  93)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)											int col;
HXDLIN(  93)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  93)												col = c;
            											}
HXDLIN(  93)											bool _hx_tmp;
HXDLIN(  93)											if (temp->useMask) {
HXLINE(  93)												_hx_tmp = ::hx::IsNotNull( temp->mask );
            											}
            											else {
HXLINE(  93)												_hx_tmp = false;
            											}
HXDLIN(  93)											if (_hx_tmp) {
HXLINE(  93)												::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  93)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)												int index;
HXDLIN(  93)												if (this1->useVirtualPos) {
HXLINE(  93)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  93)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  93)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)												int v;
HXDLIN(  93)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  93)													v = c;
            												}
HXDLIN(  93)												int this3 = v;
HXDLIN(  93)												int maskPixel = this3;
HXDLIN(  93)												int this4 = col;
HXDLIN(  93)												int this5 = this4;
HXDLIN(  93)												if ((maskPixel == 0)) {
HXLINE(  93)													int this1 = this5;
HXDLIN(  93)													col = this1;
            												}
            												else {
HXLINE(  93)													Float m0;
HXDLIN(  93)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)													if ((this1 == 0)) {
HXLINE(  93)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float m1;
HXDLIN(  93)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)													if ((this2 == 0)) {
HXLINE(  93)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float m2;
HXDLIN(  93)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)													if ((this3 == 0)) {
HXLINE(  93)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float m3;
HXDLIN(  93)													int this4 = (maskPixel & 255);
HXDLIN(  93)													if ((this4 == 0)) {
HXLINE(  93)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  93)											if ((col != 0)) {
HXLINE(  93)												int x = (dx - rectLeft);
HXDLIN(  93)												int y = (dy - rectTop);
HXDLIN(  93)												int this1 = col;
HXDLIN(  93)												int c = this1;
HXDLIN(  93)												bool _hx_tmp;
HXDLIN(  93)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)													_hx_tmp = undoImage1->transparent;
            												}
            												else {
HXLINE(  93)													_hx_tmp = false;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													int location;
HXDLIN(  93)													if (undoImage1->useVirtualPos) {
HXLINE(  93)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  93)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  93)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  93)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)													int this3 = this2;
HXDLIN(  93)													int this4;
HXDLIN(  93)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  93)														this4 = this3;
            													}
HXDLIN(  93)													Float a1;
HXDLIN(  93)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)													if ((this5 == 0)) {
HXLINE(  93)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float r1;
HXDLIN(  93)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)													if ((this6 == 0)) {
HXLINE(  93)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float g1;
HXDLIN(  93)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)													if ((this7 == 0)) {
HXLINE(  93)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float b1;
HXDLIN(  93)													int this8 = (this4 & 255);
HXDLIN(  93)													if ((this8 == 0)) {
HXLINE(  93)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float a2;
HXDLIN(  93)													int this9 = ((col >> 24) & 255);
HXDLIN(  93)													if ((this9 == 0)) {
HXLINE(  93)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float r2;
HXDLIN(  93)													int this10 = ((col >> 16) & 255);
HXDLIN(  93)													if ((this10 == 0)) {
HXLINE(  93)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float g2;
HXDLIN(  93)													int this11 = ((col >> 8) & 255);
HXDLIN(  93)													if ((this11 == 0)) {
HXLINE(  93)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float b2;
HXDLIN(  93)													int this12 = (col & 255);
HXDLIN(  93)													if ((this12 == 0)) {
HXLINE(  93)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  93)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)													{
HXLINE(  93)														::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  93)														int value;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  93)															value = blended;
            														}
HXDLIN(  93)														bool _hx_tmp;
HXDLIN(  93)														if ((location >= 0)) {
HXLINE(  93)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  93)															_hx_tmp = false;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  93)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  93)													int index;
HXDLIN(  93)													if (undoImage1->useVirtualPos) {
HXLINE(  93)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  93)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  93)													int value;
HXDLIN(  93)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  93)														value = c;
            													}
HXDLIN(  93)													bool _hx_tmp;
HXDLIN(  93)													if ((index >= 0)) {
HXLINE(  93)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  93)														_hx_tmp = false;
            													}
HXDLIN(  93)													if (_hx_tmp) {
HXLINE(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  93)												if (forceClear) {
HXLINE(  93)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  93)													int x = (dx - rectLeft);
HXDLIN(  93)													int y = (dy - rectTop);
HXDLIN(  93)													int index;
HXDLIN(  93)													if (undoImage1->useVirtualPos) {
HXLINE(  93)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  93)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  93)													bool _hx_tmp;
HXDLIN(  93)													if ((index >= 0)) {
HXLINE(  93)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  93)														_hx_tmp = false;
            													}
HXDLIN(  93)													if (_hx_tmp) {
HXLINE(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  93)					{
HXLINE(  93)						int _g_min1 = xIter31->start;
HXDLIN(  93)						int _g_max1 = xIter31->max;
HXDLIN(  93)						while((_g_min1 < _g_max1)){
HXLINE(  93)							_g_min1 = (_g_min1 + 1);
HXDLIN(  93)							int px = (_g_min1 - 1);
HXDLIN(  93)							Float pcx = (( (Float)(px) ) - x4_);
HXDLIN(  93)							{
HXLINE(  93)								int _g_min = yIter31->start;
HXDLIN(  93)								int _g_max = yIter31->max;
HXDLIN(  93)								while((_g_min < _g_max)){
HXLINE(  93)									_g_min = (_g_min + 1);
HXDLIN(  93)									int py = (_g_min - 1);
HXDLIN(  93)									Float pcy = (( (Float)(py) ) - y4_);
HXDLIN(  93)									Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  93)									Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  93)									Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  93)									Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  93)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  93)									bool _hx_tmp;
HXDLIN(  93)									bool _hx_tmp1;
HXDLIN(  93)									if ((ratioA >= 0)) {
HXLINE(  93)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  93)										_hx_tmp1 = false;
            									}
HXDLIN(  93)									if (_hx_tmp1) {
HXLINE(  93)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  93)										_hx_tmp = false;
            									}
HXDLIN(  93)									if (_hx_tmp) {
HXLINE(  93)										int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  93)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  93)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  93)										int this1 = i;
HXDLIN(  93)										int a = this1;
HXDLIN(  93)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  93)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  93)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  93)										int this2 = i1;
HXDLIN(  93)										int r = this2;
HXDLIN(  93)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  93)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  93)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  93)										int this3 = i2;
HXDLIN(  93)										int g = this3;
HXDLIN(  93)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  93)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  93)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  93)										int this4 = i3;
HXDLIN(  93)										int b = this4;
HXDLIN(  93)										{
HXLINE(  93)											int location;
HXDLIN(  93)											if (temp->useVirtualPos) {
HXLINE(  93)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - temp->virtualY) * ( (Float)(temp->width) )) + px) - temp->virtualX));
            											}
            											else {
HXLINE(  93)												location = ::Std_obj::_hx_int(( (Float)(((py * temp->width) + px)) ));
            											}
HXDLIN(  93)											bool _hx_tmp;
HXDLIN(  93)											if (temp->transparent) {
HXLINE(  93)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  93)												_hx_tmp = false;
            											}
HXDLIN(  93)											if (_hx_tmp) {
HXLINE(  93)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  93)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)												int this3 = this2;
HXDLIN(  93)												int old;
HXDLIN(  93)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  93)													old = this3;
            												}
HXDLIN(  93)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)												Float a1;
HXDLIN(  93)												int this4 = ((old >> 24) & 255);
HXDLIN(  93)												if ((this4 == 0)) {
HXLINE(  93)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float r1;
HXDLIN(  93)												int this5 = ((old >> 16) & 255);
HXDLIN(  93)												if ((this5 == 0)) {
HXLINE(  93)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float g1;
HXDLIN(  93)												int this6 = ((old >> 8) & 255);
HXDLIN(  93)												if ((this6 == 0)) {
HXLINE(  93)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float b1;
HXDLIN(  93)												int this7 = (old & 255);
HXDLIN(  93)												if ((this7 == 0)) {
HXLINE(  93)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float a2;
HXDLIN(  93)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  93)												if ((this8 == 0)) {
HXLINE(  93)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float r2;
HXDLIN(  93)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  93)												if ((this9 == 0)) {
HXLINE(  93)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float g2;
HXDLIN(  93)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  93)												if ((this10 == 0)) {
HXLINE(  93)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float b2;
HXDLIN(  93)												int this11 = (rhs & 255);
HXDLIN(  93)												if ((this11 == 0)) {
HXLINE(  93)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  93)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  93)												{
HXLINE(  93)													::haxe::io::ArrayBufferViewImpl this12 = temp->image;
HXDLIN(  93)													int value;
HXDLIN(  93)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  93)														value = blended;
            													}
HXDLIN(  93)													bool _hx_tmp;
HXDLIN(  93)													if ((location >= 0)) {
HXLINE(  93)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  93)														_hx_tmp = false;
            													}
HXDLIN(  93)													if (_hx_tmp) {
HXLINE(  93)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  93)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  93)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  93)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  93)												int value;
HXDLIN(  93)												if (temp->isLittle) {
HXLINE(  93)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  93)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  93)												bool _hx_tmp;
HXDLIN(  93)												if ((location >= 0)) {
HXLINE(  93)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  93)													_hx_tmp = false;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  93)					if ((hasHit1 == false)) {
HXLINE(  93)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x2_,y2_,x3_,y3_,x4_,y4_,true);
HXDLIN(  93)						if (hasUndo1) {
HXLINE(  93)							v->undoImage = undoImage1;
HXDLIN(  93)							v->undoX = xIter31->start;
HXDLIN(  93)							v->undoY = yIter31->start;
            						}
            					}
            				}
HXDLIN(  93)				if ((hasHit == true)) {
HXLINE(  93)					::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x1_,y1_,x2_,y2_,x3_,y3_,x4_,y4_,true);
            				}
            			}
            		}
HXLINE(  97)		{
HXLINE(  97)			bool forceClear = false;
HXDLIN(  97)			{
HXLINE(  97)				int _g = 0;
HXDLIN(  97)				int _g1 = temp->height;
HXDLIN(  97)				while((_g < _g1)){
HXLINE(  97)					_g = (_g + 1);
HXDLIN(  97)					int dy = (_g - 1);
HXDLIN(  97)					{
HXLINE(  97)						int _g1 = 0;
HXDLIN(  97)						int _g2 = temp->width;
HXDLIN(  97)						while((_g1 < _g2)){
HXLINE(  97)							_g1 = (_g1 + 1);
HXDLIN(  97)							int dx = (_g1 - 1);
HXDLIN(  97)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  97)							int index;
HXDLIN(  97)							if (temp->useVirtualPos) {
HXLINE(  97)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  97)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  97)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)							int col;
HXDLIN(  97)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  97)								col = c;
            							}
HXDLIN(  97)							bool _hx_tmp;
HXDLIN(  97)							if (temp->useMask) {
HXLINE(  97)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  97)								_hx_tmp = false;
            							}
HXDLIN(  97)							if (_hx_tmp) {
HXLINE(  97)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  97)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)								int index;
HXDLIN(  97)								if (this1->useVirtualPos) {
HXLINE(  97)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  97)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  97)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)								int v;
HXDLIN(  97)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  97)									v = c;
            								}
HXDLIN(  97)								int this3 = v;
HXDLIN(  97)								int maskPixel = this3;
HXDLIN(  97)								int this4 = col;
HXDLIN(  97)								int this5 = this4;
HXDLIN(  97)								if ((maskPixel == 0)) {
HXLINE(  97)									int this1 = this5;
HXDLIN(  97)									col = this1;
            								}
            								else {
HXLINE(  97)									Float m0;
HXDLIN(  97)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)									if ((this1 == 0)) {
HXLINE(  97)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float m1;
HXDLIN(  97)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)									if ((this2 == 0)) {
HXLINE(  97)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float m2;
HXDLIN(  97)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)									if ((this3 == 0)) {
HXLINE(  97)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float m3;
HXDLIN(  97)									int this4 = (maskPixel & 255);
HXDLIN(  97)									if ((this4 == 0)) {
HXLINE(  97)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  97)							if ((col != 0)) {
HXLINE(  97)								int x = (left + dx);
HXDLIN(  97)								int y = (top + dy);
HXDLIN(  97)								int this1 = col;
HXDLIN(  97)								int c = this1;
HXDLIN(  97)								bool _hx_tmp;
HXDLIN(  97)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  97)									_hx_tmp = false;
            								}
HXDLIN(  97)								if (_hx_tmp) {
HXLINE(  97)									int location;
HXDLIN(  97)									if (pixelShape->useVirtualPos) {
HXLINE(  97)										location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  97)										location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            									}
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  97)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)									int this3 = this2;
HXDLIN(  97)									int this4;
HXDLIN(  97)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  97)										this4 = this3;
            									}
HXDLIN(  97)									Float a1;
HXDLIN(  97)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)									if ((this5 == 0)) {
HXLINE(  97)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float r1;
HXDLIN(  97)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)									if ((this6 == 0)) {
HXLINE(  97)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float g1;
HXDLIN(  97)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)									if ((this7 == 0)) {
HXLINE(  97)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float b1;
HXDLIN(  97)									int this8 = (this4 & 255);
HXDLIN(  97)									if ((this8 == 0)) {
HXLINE(  97)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float a2;
HXDLIN(  97)									int this9 = ((col >> 24) & 255);
HXDLIN(  97)									if ((this9 == 0)) {
HXLINE(  97)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float r2;
HXDLIN(  97)									int this10 = ((col >> 16) & 255);
HXDLIN(  97)									if ((this10 == 0)) {
HXLINE(  97)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float g2;
HXDLIN(  97)									int this11 = ((col >> 8) & 255);
HXDLIN(  97)									if ((this11 == 0)) {
HXLINE(  97)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float b2;
HXDLIN(  97)									int this12 = (col & 255);
HXDLIN(  97)									if ((this12 == 0)) {
HXLINE(  97)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)									{
HXLINE(  97)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  97)										int value;
HXDLIN(  97)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  97)											value = blended;
            										}
HXDLIN(  97)										bool _hx_tmp;
HXDLIN(  97)										if ((location >= 0)) {
HXLINE(  97)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  97)											_hx_tmp = false;
            										}
HXDLIN(  97)										if (_hx_tmp) {
HXLINE(  97)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  97)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  97)									int index;
HXDLIN(  97)									if (pixelShape->useVirtualPos) {
HXLINE(  97)										index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  97)										index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            									}
HXDLIN(  97)									int value;
HXDLIN(  97)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  97)										value = c;
            									}
HXDLIN(  97)									bool _hx_tmp;
HXDLIN(  97)									if ((index >= 0)) {
HXLINE(  97)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  97)										_hx_tmp = false;
            									}
HXDLIN(  97)									if (_hx_tmp) {
HXLINE(  97)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  97)								if (forceClear) {
HXLINE(  97)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  97)									int x = (left + dx);
HXDLIN(  97)									int y = (top + dy);
HXDLIN(  97)									int index;
HXDLIN(  97)									if (pixelShape->useVirtualPos) {
HXLINE(  97)										index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  97)										index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            									}
HXDLIN(  97)									bool _hx_tmp;
HXDLIN(  97)									if ((index >= 0)) {
HXLINE(  97)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  97)										_hx_tmp = false;
            									}
HXDLIN(  97)									if (_hx_tmp) {
HXLINE(  97)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  98)		temp = null();
HXLINE(  99)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< QuadGradient_obj > QuadGradient_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< int >  __o_color1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< int >  __o_color2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3,::hx::Null< int >  __o_color3,::hx::Null< Float >  __o_x4,::hx::Null< Float >  __o_y4,::hx::Null< int >  __o_color4) {
	::hx::ObjectPtr< QuadGradient_obj > __this = new QuadGradient_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_x1,__o_y1,__o_color1,__o_x2,__o_y2,__o_color2,__o_x3,__o_y3,__o_color3,__o_x4,__o_y4,__o_color4);
	return __this;
}

::hx::ObjectPtr< QuadGradient_obj > QuadGradient_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< int >  __o_color1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< int >  __o_color2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3,::hx::Null< int >  __o_color3,::hx::Null< Float >  __o_x4,::hx::Null< Float >  __o_y4,::hx::Null< int >  __o_color4) {
	QuadGradient_obj *__this = (QuadGradient_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(QuadGradient_obj), true, "pixelimage.triangleGML.gradient.QuadGradient"));
	*(void **)__this = QuadGradient_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_x1,__o_y1,__o_color1,__o_x2,__o_y2,__o_color2,__o_x3,__o_y3,__o_color3,__o_x4,__o_y4,__o_color4);
	return __this;
}

QuadGradient_obj::QuadGradient_obj()
{
}

::hx::Val QuadGradient_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { return ::hx::Val( x1 ); }
		if (HX_FIELD_EQ(inName,"y1") ) { return ::hx::Val( y1 ); }
		if (HX_FIELD_EQ(inName,"x2") ) { return ::hx::Val( x2 ); }
		if (HX_FIELD_EQ(inName,"y2") ) { return ::hx::Val( y2 ); }
		if (HX_FIELD_EQ(inName,"x3") ) { return ::hx::Val( x3 ); }
		if (HX_FIELD_EQ(inName,"y3") ) { return ::hx::Val( y3 ); }
		if (HX_FIELD_EQ(inName,"x4") ) { return ::hx::Val( x4 ); }
		if (HX_FIELD_EQ(inName,"y4") ) { return ::hx::Val( y4 ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val QuadGradient_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { x1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y1") ) { y1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x2") ) { x2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y2") ) { y2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x3") ) { x3=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y3") ) { y3=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x4") ) { x4=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y4") ) { y4=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void QuadGradient_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x1",b9,68,00,00));
	outFields->push(HX_("y1",98,69,00,00));
	outFields->push(HX_("x2",ba,68,00,00));
	outFields->push(HX_("y2",99,69,00,00));
	outFields->push(HX_("x3",bb,68,00,00));
	outFields->push(HX_("y3",9a,69,00,00));
	outFields->push(HX_("x4",bc,68,00,00));
	outFields->push(HX_("y4",9b,69,00,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo QuadGradient_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(QuadGradient_obj,x1),HX_("x1",b9,68,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadGradient_obj,y1),HX_("y1",98,69,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadGradient_obj,x2),HX_("x2",ba,68,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadGradient_obj,y2),HX_("y2",99,69,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadGradient_obj,x3),HX_("x3",bb,68,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadGradient_obj,y3),HX_("y3",9a,69,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadGradient_obj,x4),HX_("x4",bc,68,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadGradient_obj,y4),HX_("y4",9b,69,00,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *QuadGradient_obj_sStaticStorageInfo = 0;
#endif

static ::String QuadGradient_obj_sMemberFields[] = {
	HX_("x1",b9,68,00,00),
	HX_("y1",98,69,00,00),
	HX_("x2",ba,68,00,00),
	HX_("y2",99,69,00,00),
	HX_("x3",bb,68,00,00),
	HX_("y3",9a,69,00,00),
	HX_("x4",bc,68,00,00),
	HX_("y4",9b,69,00,00),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class QuadGradient_obj::__mClass;

void QuadGradient_obj::__register()
{
	QuadGradient_obj _hx_dummy;
	QuadGradient_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.gradient.QuadGradient",cc,92,e3,4a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(QuadGradient_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< QuadGradient_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = QuadGradient_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = QuadGradient_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace gradient
