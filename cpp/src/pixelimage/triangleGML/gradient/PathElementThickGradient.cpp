// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_justPath_ILinePathContext
#include <justPath/ILinePathContext.h>
#endif
#ifndef INCLUDED_justPath_SvgLinePath
#include <justPath/SvgLinePath.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_FillShape
#include <pixelimage/triangleGML/coreShape/FillShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_gradient_PathElementThickGradient
#include <pixelimage/triangleGML/gradient/PathElementThickGradient.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c07cc9dd160e3b1d_9_new,"pixelimage.triangleGML.gradient.PathElementThickGradient","new",0x2a835a3d,"pixelimage.triangleGML.gradient.PathElementThickGradient.new","pixelimage/triangleGML/gradient/PathElementThickGradient.hx",9,0x02c205f4)
HX_LOCAL_STACK_FRAME(_hx_pos_c07cc9dd160e3b1d_46_setParameter,"pixelimage.triangleGML.gradient.PathElementThickGradient","setParameter",0xdf60c82a,"pixelimage.triangleGML.gradient.PathElementThickGradient.setParameter","pixelimage/triangleGML/gradient/PathElementThickGradient.hx",46,0x02c205f4)
HX_LOCAL_STACK_FRAME(_hx_pos_c07cc9dd160e3b1d_67_render,"pixelimage.triangleGML.gradient.PathElementThickGradient","render",0x42a9a999,"pixelimage.triangleGML.gradient.PathElementThickGradient.render","pixelimage/triangleGML/gradient/PathElementThickGradient.hx",67,0x02c205f4)
HX_LOCAL_STACK_FRAME(_hx_pos_c07cc9dd160e3b1d_83_lineSegmentTo,"pixelimage.triangleGML.gradient.PathElementThickGradient","lineSegmentTo",0xf9bf3597,"pixelimage.triangleGML.gradient.PathElementThickGradient.lineSegmentTo","pixelimage/triangleGML/gradient/PathElementThickGradient.hx",83,0x02c205f4)
HX_LOCAL_STACK_FRAME(_hx_pos_c07cc9dd160e3b1d_104_lineTo,"pixelimage.triangleGML.gradient.PathElementThickGradient","lineTo",0x2a2084d2,"pixelimage.triangleGML.gradient.PathElementThickGradient.lineTo","pixelimage/triangleGML/gradient/PathElementThickGradient.hx",104,0x02c205f4)
HX_LOCAL_STACK_FRAME(_hx_pos_c07cc9dd160e3b1d_121_moveTo,"pixelimage.triangleGML.gradient.PathElementThickGradient","moveTo",0x0a2d112f,"pixelimage.triangleGML.gradient.PathElementThickGradient.moveTo","pixelimage/triangleGML/gradient/PathElementThickGradient.hx",121,0x02c205f4)
namespace pixelimage{
namespace triangleGML{
namespace gradient{

void PathElementThickGradient_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeTopColor,::hx::Null< int >  __o_strokeBottomColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::String __o_pathData,::hx::Null< Float >  __o_translateX,::hx::Null< Float >  __o_translateY,::hx::Null< Float >  __o_scaleX,::hx::Null< Float >  __o_scaleY){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeTopColor = __o_strokeTopColor.Default(-16777216);
            		int strokeBottomColor = __o_strokeBottomColor.Default(-1);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int fill = __o_fill.Default(0);
            		::String pathData = __o_pathData;
            		if (::hx::IsNull(__o_pathData)) pathData = HX_("",00,00,00,00);
            		Float translateX = __o_translateX.Default(((Float)0.));
            		Float translateY = __o_translateY.Default(((Float)0.));
            		Float scaleX = __o_scaleX.Default(((Float)1.));
            		Float scaleY = __o_scaleY.Default(((Float)1.));
            	HX_STACKFRAME(&_hx_pos_c07cc9dd160e3b1d_9_new)
HXLINE(  80)		this->toggleDraw = true;
HXLINE(  18)		this->y0 = ((Float)0.);
HXLINE(  17)		this->x0 = ((Float)0.);
HXLINE(  35)		super::__construct(opacity,visibility,-16777216,((Float)1.),strokeDashGapArray,fill);
HXLINE(  36)		this->pathData = pathData;
HXLINE(  37)		this->strokeTopColor = strokeTopColor;
HXLINE(  38)		this->strokeBottomColor = strokeBottomColor;
HXLINE(  39)		this->strokeWidth = strokeWidth;
HXLINE(  40)		this->translateX = translateX;
HXLINE(  41)		this->translateY = translateY;
HXLINE(  42)		this->scaleX = scaleX;
HXLINE(  43)		this->scaleY = scaleY;
            	}

Dynamic PathElementThickGradient_obj::__CreateEmpty() { return new PathElementThickGradient_obj; }

void *PathElementThickGradient_obj::_hx_vtable = 0;

Dynamic PathElementThickGradient_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PathElementThickGradient_obj > _hx_result = new PathElementThickGradient_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11]);
	return _hx_result;
}

bool PathElementThickGradient_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2091632c) {
		if (inClassId<=(int)0x09fa7b4f) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x09fa7b4f;
		} else {
			return inClassId==(int)0x2091632c;
		}
	} else {
		return inClassId==(int)0x24e92cfb || inClassId==(int)0x389f4e25;
	}
}

static ::justPath::ILinePathContext_obj _hx_pixelimage_triangleGML_gradient_PathElementThickGradient__hx_justPath_ILinePathContext= {
	( void (::hx::Object::*)(Float,Float))&::pixelimage::triangleGML::gradient::PathElementThickGradient_obj::moveTo,
	( void (::hx::Object::*)(Float,Float))&::pixelimage::triangleGML::gradient::PathElementThickGradient_obj::lineTo,
	( void (::hx::Object::*)(Float,Float))&::pixelimage::triangleGML::gradient::PathElementThickGradient_obj::lineSegmentTo,
};

void *PathElementThickGradient_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x4fa789de: return &_hx_pixelimage_triangleGML_gradient_PathElementThickGradient__hx_justPath_ILinePathContext;
	}
	return super::_hx_getInterface(inHash);
}

void PathElementThickGradient_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_c07cc9dd160e3b1d_46_setParameter)
HXDLIN(  46)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("pathData",6f,9e,02,38)) ){
HXLINE(  48)			this->pathData = value;
HXDLIN(  48)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("scaleX",8e,ea,25,3c)) ){
HXLINE(  60)			this->scaleX = ::Std_obj::parseFloat(value);
HXDLIN(  60)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("scaleY",8f,ea,25,3c)) ){
HXLINE(  62)			this->scaleY = ::Std_obj::parseFloat(value);
HXDLIN(  62)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("strokeBottomColor",a0,95,a8,82)) ){
HXLINE(  52)			this->strokeBottomColor = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  52)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("strokeTopColor",66,66,01,41)) ){
HXLINE(  50)			this->strokeTopColor = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  50)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("strokeWidth",2e,f7,1c,e3)) ){
HXLINE(  54)			this->strokeWidth = ::Std_obj::parseFloat(value);
HXDLIN(  54)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("translateX",4a,8d,5c,06)) ){
HXLINE(  56)			this->translateX = ::Std_obj::parseFloat(value);
HXDLIN(  56)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("translateY",4b,8d,5c,06)) ){
HXLINE(  58)			this->translateY = ::Std_obj::parseFloat(value);
HXDLIN(  58)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  64)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct PathElementThickGradient_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_c07cc9dd160e3b1d_67_render)
HXLINE(  69)		::haxe::Log_obj::trace((HX_("render pathData ",87,31,8c,87) + this->pathData),::hx::SourceInfo(HX_("pixelimage/triangleGML/gradient/PathElementThickGradient.hx",f4,05,c2,02),69,HX_("pixelimage.triangleGML.gradient.PathElementThickGradient",cb,77,68,26),HX_("render",56,6b,29,05)));
HXLINE(  70)		int w = ::Math_obj::ceil(( (Float)(pixelShape->width) ));
HXDLIN(  70)		int h = ::Math_obj::ceil(( (Float)(pixelShape->height) ));
HXDLIN(  70)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  70)		::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  70)		::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  70)		::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  70)		::pixelimage::ImageStruct this4 = this3;
HXDLIN(  70)		this->temp = this4;
HXLINE(  71)		this->temp->transparent = true;
HXLINE(  72)		::justPath::SvgLinePath sp = ::justPath::SvgLinePath_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this));
HXLINE(  73)		sp->parse(this->pathData);
HXLINE(  74)		{
HXLINE(  74)			::pixelimage::ImageStruct pixelImage = this->temp;
HXDLIN(  74)			bool forceClear = false;
HXDLIN(  74)			{
HXLINE(  74)				int _g = 0;
HXDLIN(  74)				int _g1 = pixelImage->height;
HXDLIN(  74)				while((_g < _g1)){
HXLINE(  74)					_g = (_g + 1);
HXDLIN(  74)					int dy = (_g - 1);
HXDLIN(  74)					{
HXLINE(  74)						int _g1 = 0;
HXDLIN(  74)						int _g2 = pixelImage->width;
HXDLIN(  74)						while((_g1 < _g2)){
HXLINE(  74)							_g1 = (_g1 + 1);
HXDLIN(  74)							int dx = (_g1 - 1);
HXDLIN(  74)							::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  74)							int index;
HXDLIN(  74)							if (pixelImage->useVirtualPos) {
HXLINE(  74)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            							}
            							else {
HXLINE(  74)								index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            							}
HXDLIN(  74)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  74)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  74)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  74)							int col;
HXDLIN(  74)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  74)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  74)								col = c;
            							}
HXDLIN(  74)							bool _hx_tmp;
HXDLIN(  74)							if (pixelImage->useMask) {
HXLINE(  74)								_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            							}
            							else {
HXLINE(  74)								_hx_tmp = false;
            							}
HXDLIN(  74)							if (_hx_tmp) {
HXLINE(  74)								::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  74)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  74)								int index;
HXDLIN(  74)								if (this1->useVirtualPos) {
HXLINE(  74)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  74)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  74)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  74)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  74)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  74)								int v;
HXDLIN(  74)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  74)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  74)									v = c;
            								}
HXDLIN(  74)								int this3 = v;
HXDLIN(  74)								int maskPixel = this3;
HXDLIN(  74)								int this4 = col;
HXDLIN(  74)								int this5 = this4;
HXDLIN(  74)								if ((maskPixel == 0)) {
HXLINE(  74)									int this1 = this5;
HXDLIN(  74)									col = this1;
            								}
            								else {
HXLINE(  74)									Float m0;
HXDLIN(  74)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  74)									if ((this1 == 0)) {
HXLINE(  74)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float m1;
HXDLIN(  74)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  74)									if ((this2 == 0)) {
HXLINE(  74)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float m2;
HXDLIN(  74)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  74)									if ((this3 == 0)) {
HXLINE(  74)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float m3;
HXDLIN(  74)									int this4 = (maskPixel & 255);
HXDLIN(  74)									if ((this4 == 0)) {
HXLINE(  74)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  74)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  74)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  74)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  74)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  74)							if ((col != 0)) {
HXLINE(  74)								int x = dx;
HXDLIN(  74)								int y = dy;
HXDLIN(  74)								int this1 = col;
HXDLIN(  74)								int c = this1;
HXDLIN(  74)								bool _hx_tmp;
HXDLIN(  74)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  74)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  74)									_hx_tmp = false;
            								}
HXDLIN(  74)								if (_hx_tmp) {
HXLINE(  74)									int location;
HXDLIN(  74)									if (pixelShape->useVirtualPos) {
HXLINE(  74)										location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  74)										location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            									}
HXDLIN(  74)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  74)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  74)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  74)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  74)									int this3 = this2;
HXDLIN(  74)									int this4;
HXDLIN(  74)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  74)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  74)										this4 = this3;
            									}
HXDLIN(  74)									Float a1;
HXDLIN(  74)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  74)									if ((this5 == 0)) {
HXLINE(  74)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float r1;
HXDLIN(  74)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  74)									if ((this6 == 0)) {
HXLINE(  74)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float g1;
HXDLIN(  74)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  74)									if ((this7 == 0)) {
HXLINE(  74)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float b1;
HXDLIN(  74)									int this8 = (this4 & 255);
HXDLIN(  74)									if ((this8 == 0)) {
HXLINE(  74)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float a2;
HXDLIN(  74)									int this9 = ((col >> 24) & 255);
HXDLIN(  74)									if ((this9 == 0)) {
HXLINE(  74)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float r2;
HXDLIN(  74)									int this10 = ((col >> 16) & 255);
HXDLIN(  74)									if ((this10 == 0)) {
HXLINE(  74)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float g2;
HXDLIN(  74)									int this11 = ((col >> 8) & 255);
HXDLIN(  74)									if ((this11 == 0)) {
HXLINE(  74)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float b2;
HXDLIN(  74)									int this12 = (col & 255);
HXDLIN(  74)									if ((this12 == 0)) {
HXLINE(  74)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  74)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  74)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  74)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  74)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  74)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  74)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  74)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  74)									{
HXLINE(  74)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  74)										int value;
HXDLIN(  74)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  74)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  74)											value = blended;
            										}
HXDLIN(  74)										bool _hx_tmp;
HXDLIN(  74)										if ((location >= 0)) {
HXLINE(  74)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  74)											_hx_tmp = false;
            										}
HXDLIN(  74)										if (_hx_tmp) {
HXLINE(  74)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  74)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  74)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  74)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  74)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  74)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  74)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  74)									int index;
HXDLIN(  74)									if (pixelShape->useVirtualPos) {
HXLINE(  74)										index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  74)										index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            									}
HXDLIN(  74)									int value;
HXDLIN(  74)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  74)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  74)										value = c;
            									}
HXDLIN(  74)									bool _hx_tmp;
HXDLIN(  74)									if ((index >= 0)) {
HXLINE(  74)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  74)										_hx_tmp = false;
            									}
HXDLIN(  74)									if (_hx_tmp) {
HXLINE(  74)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  74)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  74)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  74)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  74)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  74)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  74)								if (forceClear) {
HXLINE(  74)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  74)									int x = dx;
HXDLIN(  74)									int y = dy;
HXDLIN(  74)									int index;
HXDLIN(  74)									if (pixelShape->useVirtualPos) {
HXLINE(  74)										index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  74)										index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            									}
HXDLIN(  74)									bool _hx_tmp;
HXDLIN(  74)									if ((index >= 0)) {
HXLINE(  74)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  74)										_hx_tmp = false;
            									}
HXDLIN(  74)									if (_hx_tmp) {
HXLINE(  74)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  74)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  74)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  74)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  74)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  74)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  75)		this->temp = null();
HXLINE(  78)		return this->super::render(pixelShape);
            	}


void PathElementThickGradient_obj::lineSegmentTo(Float x2,Float y2){
            	HX_GC_STACKFRAME(&_hx_pos_c07cc9dd160e3b1d_83_lineSegmentTo)
HXLINE(  84)		if (this->toggleDraw) {
HXLINE(  85)			 ::Dynamic oldInfo = this->info;
HXLINE(  86)			::pixelimage::ImageStruct this1 = this->temp;
HXDLIN(  86)			Float px = ((this->x0 * this->scaleX) + this->translateX);
HXDLIN(  86)			Float py = ((this->y0 * this->scaleY) + this->translateY);
HXDLIN(  86)			int colorA = this->strokeTopColor;
HXDLIN(  86)			int colorB = this->strokeTopColor;
HXDLIN(  86)			int colorC = this->strokeBottomColor;
HXDLIN(  86)			int colorD = this->strokeBottomColor;
HXDLIN(  86)			Float o = (((y2 * this->scaleY) + this->translateY) - py);
HXDLIN(  86)			Float a = (((x2 * this->scaleX) + this->translateX) - px);
HXDLIN(  86)			Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  86)			Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  86)			 ::Dynamic debugCorners = false;
HXDLIN(  86)			if (::hx::IsNull( debugCorners )) {
HXLINE( 910)				debugCorners = false;
            			}
HXLINE(  86)			Float sin = ::Math_obj::sin(theta);
HXDLIN(  86)			Float cos = ::Math_obj::cos(theta);
HXDLIN(  86)			Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  86)			Float dx = ((Float)0.1);
HXDLIN(  86)			Float dy = radius;
HXDLIN(  86)			Float cx = h;
HXDLIN(  86)			Float cy = radius;
HXDLIN(  86)			Float bx = h;
HXDLIN(  86)			Float by = -(radius);
HXDLIN(  86)			Float ax = ((Float)0.1);
HXDLIN(  86)			Float ay = -(radius);
HXDLIN(  86)			Float temp = ((Float)0.);
HXLINE( 474)			temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 475)			ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 476)			ax = temp;
HXLINE( 478)			temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 479)			by = (py + ((by * cos) + (bx * sin)));
HXLINE( 480)			bx = temp;
HXLINE( 482)			temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 483)			cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 484)			cx = temp;
HXLINE( 486)			temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 487)			dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 488)			dx = temp;
HXLINE(  86)			if (( (bool)(debugCorners) )) {
HXLINE(  86)				{
HXLINE(  86)					Float x = (ax - ((Float)6.));
HXDLIN(  86)					Float y = (ay - ((Float)6.));
HXDLIN(  86)					int p = ::Std_obj::_hx_int(x);
HXDLIN(  86)					int xx = p;
HXDLIN(  86)					int q = ::Std_obj::_hx_int(y);
HXDLIN(  86)					int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  86)					int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  86)					while(true){
HXLINE(  86)						{
HXLINE(  86)							p = (p + 1);
HXDLIN(  86)							int x = (p - 1);
HXDLIN(  86)							int this2 = colorA;
HXDLIN(  86)							int c = this2;
HXDLIN(  86)							bool _hx_tmp;
HXDLIN(  86)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  86)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  86)								_hx_tmp = false;
            							}
HXDLIN(  86)							if (_hx_tmp) {
HXLINE(  86)								int location;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            								}
HXDLIN(  86)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  86)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)								int this4 = this3;
HXDLIN(  86)								int this5;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  86)									this5 = this4;
            								}
HXDLIN(  86)								Float a1;
HXDLIN(  86)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  86)								if ((this6 == 0)) {
HXLINE(  86)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float r1;
HXDLIN(  86)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  86)								if ((this7 == 0)) {
HXLINE(  86)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float g1;
HXDLIN(  86)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  86)								if ((this8 == 0)) {
HXLINE(  86)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float b1;
HXDLIN(  86)								int this9 = (this5 & 255);
HXDLIN(  86)								if ((this9 == 0)) {
HXLINE(  86)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float a2;
HXDLIN(  86)								int this10 = ((colorA >> 24) & 255);
HXDLIN(  86)								if ((this10 == 0)) {
HXLINE(  86)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float r2;
HXDLIN(  86)								int this11 = ((colorA >> 16) & 255);
HXDLIN(  86)								if ((this11 == 0)) {
HXLINE(  86)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float g2;
HXDLIN(  86)								int this12 = ((colorA >> 8) & 255);
HXDLIN(  86)								if ((this12 == 0)) {
HXLINE(  86)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float b2;
HXDLIN(  86)								int this13 = (colorA & 255);
HXDLIN(  86)								if ((this13 == 0)) {
HXLINE(  86)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)								{
HXLINE(  86)									::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  86)									int value;
HXDLIN(  86)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  86)										value = blended;
            									}
HXDLIN(  86)									bool _hx_tmp;
HXDLIN(  86)									if ((location >= 0)) {
HXLINE(  86)										_hx_tmp = (location < (this14->byteLength >> 2));
            									}
            									else {
HXLINE(  86)										_hx_tmp = false;
            									}
HXDLIN(  86)									if (_hx_tmp) {
HXLINE(  86)										::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  86)										int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  86)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  86)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)								int index;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            								}
HXDLIN(  86)								int value;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  86)									value = c;
            								}
HXDLIN(  86)								bool _hx_tmp;
HXDLIN(  86)								if ((index >= 0)) {
HXLINE(  86)									_hx_tmp = (index < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  86)									_hx_tmp = false;
            								}
HXDLIN(  86)								if (_hx_tmp) {
HXLINE(  86)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  86)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  86)						if ((p > maxX)) {
HXLINE( 247)							p = xx;
HXLINE(  86)							q = (q + 1);
            						}
HXDLIN(  86)						if ((q > maxY)) {
HXLINE(  86)							goto _hx_goto_6;
            						}
            					}
            					_hx_goto_6:;
            				}
HXDLIN(  86)				{
HXLINE(  86)					Float x1 = (bx - ((Float)6.));
HXDLIN(  86)					Float y1 = (by - ((Float)6.));
HXDLIN(  86)					int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  86)					int xx1 = p1;
HXDLIN(  86)					int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  86)					int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  86)					int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  86)					while(true){
HXLINE(  86)						{
HXLINE(  86)							p1 = (p1 + 1);
HXDLIN(  86)							int x = (p1 - 1);
HXDLIN(  86)							int this2 = colorB;
HXDLIN(  86)							int c = this2;
HXDLIN(  86)							bool _hx_tmp;
HXDLIN(  86)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  86)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  86)								_hx_tmp = false;
            							}
HXDLIN(  86)							if (_hx_tmp) {
HXLINE(  86)								int location;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									location = ::Std_obj::_hx_int(( (Float)(((q1 * this1->width) + x)) ));
            								}
HXDLIN(  86)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  86)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)								int this4 = this3;
HXDLIN(  86)								int this5;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  86)									this5 = this4;
            								}
HXDLIN(  86)								Float a1;
HXDLIN(  86)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  86)								if ((this6 == 0)) {
HXLINE(  86)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float r1;
HXDLIN(  86)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  86)								if ((this7 == 0)) {
HXLINE(  86)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float g1;
HXDLIN(  86)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  86)								if ((this8 == 0)) {
HXLINE(  86)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float b1;
HXDLIN(  86)								int this9 = (this5 & 255);
HXDLIN(  86)								if ((this9 == 0)) {
HXLINE(  86)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float a2;
HXDLIN(  86)								int this10 = ((colorB >> 24) & 255);
HXDLIN(  86)								if ((this10 == 0)) {
HXLINE(  86)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float r2;
HXDLIN(  86)								int this11 = ((colorB >> 16) & 255);
HXDLIN(  86)								if ((this11 == 0)) {
HXLINE(  86)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float g2;
HXDLIN(  86)								int this12 = ((colorB >> 8) & 255);
HXDLIN(  86)								if ((this12 == 0)) {
HXLINE(  86)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float b2;
HXDLIN(  86)								int this13 = (colorB & 255);
HXDLIN(  86)								if ((this13 == 0)) {
HXLINE(  86)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)								{
HXLINE(  86)									::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  86)									int value;
HXDLIN(  86)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  86)										value = blended;
            									}
HXDLIN(  86)									bool _hx_tmp;
HXDLIN(  86)									if ((location >= 0)) {
HXLINE(  86)										_hx_tmp = (location < (this14->byteLength >> 2));
            									}
            									else {
HXLINE(  86)										_hx_tmp = false;
            									}
HXDLIN(  86)									if (_hx_tmp) {
HXLINE(  86)										::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  86)										int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  86)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  86)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)								int index;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									index = ::Std_obj::_hx_int(( (Float)(((q1 * this1->width) + x)) ));
            								}
HXDLIN(  86)								int value;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  86)									value = c;
            								}
HXDLIN(  86)								bool _hx_tmp;
HXDLIN(  86)								if ((index >= 0)) {
HXLINE(  86)									_hx_tmp = (index < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  86)									_hx_tmp = false;
            								}
HXDLIN(  86)								if (_hx_tmp) {
HXLINE(  86)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  86)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  86)						if ((p1 > maxX1)) {
HXLINE( 247)							p1 = xx1;
HXLINE(  86)							q1 = (q1 + 1);
            						}
HXDLIN(  86)						if ((q1 > maxY1)) {
HXLINE(  86)							goto _hx_goto_7;
            						}
            					}
            					_hx_goto_7:;
            				}
HXDLIN(  86)				{
HXLINE(  86)					Float x2 = (cx - ((Float)6.));
HXDLIN(  86)					Float y2 = (cy - ((Float)6.));
HXDLIN(  86)					int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  86)					int xx2 = p2;
HXDLIN(  86)					int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  86)					int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  86)					int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  86)					while(true){
HXLINE(  86)						{
HXLINE(  86)							p2 = (p2 + 1);
HXDLIN(  86)							int x = (p2 - 1);
HXDLIN(  86)							int this2 = colorC;
HXDLIN(  86)							int c = this2;
HXDLIN(  86)							bool _hx_tmp;
HXDLIN(  86)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  86)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  86)								_hx_tmp = false;
            							}
HXDLIN(  86)							if (_hx_tmp) {
HXLINE(  86)								int location;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									location = ::Std_obj::_hx_int(( (Float)(((q2 * this1->width) + x)) ));
            								}
HXDLIN(  86)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  86)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)								int this4 = this3;
HXDLIN(  86)								int this5;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  86)									this5 = this4;
            								}
HXDLIN(  86)								Float a1;
HXDLIN(  86)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  86)								if ((this6 == 0)) {
HXLINE(  86)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float r1;
HXDLIN(  86)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  86)								if ((this7 == 0)) {
HXLINE(  86)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float g1;
HXDLIN(  86)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  86)								if ((this8 == 0)) {
HXLINE(  86)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float b1;
HXDLIN(  86)								int this9 = (this5 & 255);
HXDLIN(  86)								if ((this9 == 0)) {
HXLINE(  86)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float a2;
HXDLIN(  86)								int this10 = ((colorC >> 24) & 255);
HXDLIN(  86)								if ((this10 == 0)) {
HXLINE(  86)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float r2;
HXDLIN(  86)								int this11 = ((colorC >> 16) & 255);
HXDLIN(  86)								if ((this11 == 0)) {
HXLINE(  86)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float g2;
HXDLIN(  86)								int this12 = ((colorC >> 8) & 255);
HXDLIN(  86)								if ((this12 == 0)) {
HXLINE(  86)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float b2;
HXDLIN(  86)								int this13 = (colorC & 255);
HXDLIN(  86)								if ((this13 == 0)) {
HXLINE(  86)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)								{
HXLINE(  86)									::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  86)									int value;
HXDLIN(  86)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  86)										value = blended;
            									}
HXDLIN(  86)									bool _hx_tmp;
HXDLIN(  86)									if ((location >= 0)) {
HXLINE(  86)										_hx_tmp = (location < (this14->byteLength >> 2));
            									}
            									else {
HXLINE(  86)										_hx_tmp = false;
            									}
HXDLIN(  86)									if (_hx_tmp) {
HXLINE(  86)										::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  86)										int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  86)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  86)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)								int index;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									index = ::Std_obj::_hx_int(( (Float)(((q2 * this1->width) + x)) ));
            								}
HXDLIN(  86)								int value;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  86)									value = c;
            								}
HXDLIN(  86)								bool _hx_tmp;
HXDLIN(  86)								if ((index >= 0)) {
HXLINE(  86)									_hx_tmp = (index < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  86)									_hx_tmp = false;
            								}
HXDLIN(  86)								if (_hx_tmp) {
HXLINE(  86)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  86)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  86)						if ((p2 > maxX2)) {
HXLINE( 247)							p2 = xx2;
HXLINE(  86)							q2 = (q2 + 1);
            						}
HXDLIN(  86)						if ((q2 > maxY2)) {
HXLINE(  86)							goto _hx_goto_8;
            						}
            					}
            					_hx_goto_8:;
            				}
HXDLIN(  86)				{
HXLINE(  86)					Float x3 = (dx - ((Float)6.));
HXDLIN(  86)					Float y3 = (dy - ((Float)6.));
HXDLIN(  86)					int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  86)					int xx3 = p3;
HXDLIN(  86)					int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  86)					int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  86)					int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  86)					while(true){
HXLINE(  86)						{
HXLINE(  86)							p3 = (p3 + 1);
HXDLIN(  86)							int x = (p3 - 1);
HXDLIN(  86)							int this2 = colorD;
HXDLIN(  86)							int c = this2;
HXDLIN(  86)							bool _hx_tmp;
HXDLIN(  86)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  86)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  86)								_hx_tmp = false;
            							}
HXDLIN(  86)							if (_hx_tmp) {
HXLINE(  86)								int location;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									location = ::Std_obj::_hx_int(( (Float)(((q3 * this1->width) + x)) ));
            								}
HXDLIN(  86)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  86)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)								int this4 = this3;
HXDLIN(  86)								int this5;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  86)									this5 = this4;
            								}
HXDLIN(  86)								Float a1;
HXDLIN(  86)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  86)								if ((this6 == 0)) {
HXLINE(  86)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float r1;
HXDLIN(  86)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  86)								if ((this7 == 0)) {
HXLINE(  86)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float g1;
HXDLIN(  86)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  86)								if ((this8 == 0)) {
HXLINE(  86)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float b1;
HXDLIN(  86)								int this9 = (this5 & 255);
HXDLIN(  86)								if ((this9 == 0)) {
HXLINE(  86)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float a2;
HXDLIN(  86)								int this10 = ((colorD >> 24) & 255);
HXDLIN(  86)								if ((this10 == 0)) {
HXLINE(  86)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float r2;
HXDLIN(  86)								int this11 = ((colorD >> 16) & 255);
HXDLIN(  86)								if ((this11 == 0)) {
HXLINE(  86)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float g2;
HXDLIN(  86)								int this12 = ((colorD >> 8) & 255);
HXDLIN(  86)								if ((this12 == 0)) {
HXLINE(  86)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float b2;
HXDLIN(  86)								int this13 = (colorD & 255);
HXDLIN(  86)								if ((this13 == 0)) {
HXLINE(  86)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  86)									b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  86)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)								{
HXLINE(  86)									::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  86)									int value;
HXDLIN(  86)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  86)										value = blended;
            									}
HXDLIN(  86)									bool _hx_tmp;
HXDLIN(  86)									if ((location >= 0)) {
HXLINE(  86)										_hx_tmp = (location < (this14->byteLength >> 2));
            									}
            									else {
HXLINE(  86)										_hx_tmp = false;
            									}
HXDLIN(  86)									if (_hx_tmp) {
HXLINE(  86)										::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  86)										int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  86)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  86)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)								int index;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									index = ::Std_obj::_hx_int(( (Float)(((q3 * this1->width) + x)) ));
            								}
HXDLIN(  86)								int value;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  86)									value = c;
            								}
HXDLIN(  86)								bool _hx_tmp;
HXDLIN(  86)								if ((index >= 0)) {
HXLINE(  86)									_hx_tmp = (index < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  86)									_hx_tmp = false;
            								}
HXDLIN(  86)								if (_hx_tmp) {
HXLINE(  86)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  86)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  86)						if ((p3 > maxX3)) {
HXLINE( 247)							p3 = xx3;
HXLINE(  86)							q3 = (q3 + 1);
            						}
HXDLIN(  86)						if ((q3 > maxY3)) {
HXLINE(  86)							goto _hx_goto_9;
            						}
            					}
            					_hx_goto_9:;
            				}
            			}
HXDLIN(  86)			bool hasUndo = false;
HXDLIN(  86)			int aA = ((colorB >> 24) & 255);
HXDLIN(  86)			int rA = ((colorB >> 16) & 255);
HXDLIN(  86)			int gA = ((colorB >> 8) & 255);
HXDLIN(  86)			int bA = (colorB & 255);
HXDLIN(  86)			int aB = ((colorA >> 24) & 255);
HXDLIN(  86)			int rB = ((colorA >> 16) & 255);
HXDLIN(  86)			int gB = ((colorA >> 8) & 255);
HXDLIN(  86)			int bB = (colorA & 255);
HXDLIN(  86)			int aC = ((colorD >> 24) & 255);
HXDLIN(  86)			int rC = ((colorD >> 16) & 255);
HXDLIN(  86)			int gC = ((colorD >> 8) & 255);
HXDLIN(  86)			int bC = (colorD & 255);
HXDLIN(  86)			Float bcx = (bx - dx);
HXDLIN(  86)			Float bcy = (by - dy);
HXDLIN(  86)			Float acx = (ax - dx);
HXDLIN(  86)			Float acy = (ay - dy);
HXDLIN(  86)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  86)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  86)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  86)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  86)			::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  86)			if ((ax > bx)) {
HXLINE(  86)				if ((ax > dx)) {
HXLINE(  86)					int min;
HXDLIN(  86)					if ((bx > dx)) {
HXLINE(  86)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  86)						min = ::Math_obj::floor(bx);
            					}
HXDLIN(  86)					int ii_min = min;
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					xIter3 = this1;
            				}
            				else {
HXLINE(  86)					int ii_min = ::Math_obj::floor(bx);
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					xIter3 = this1;
            				}
            			}
            			else {
HXLINE(  86)				if ((bx > dx)) {
HXLINE(  86)					int min;
HXDLIN(  86)					if ((ax > dx)) {
HXLINE(  86)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  86)						min = ::Math_obj::ceil(ax);
            					}
HXDLIN(  86)					int ii_min = min;
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					xIter3 = this1;
            				}
            				else {
HXLINE(  86)					int ii_min = ::Math_obj::floor(ax);
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					xIter3 = this1;
            				}
            			}
HXDLIN(  86)			::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  86)			if ((ay > by)) {
HXLINE(  86)				if ((ay > dy)) {
HXLINE(  86)					int min;
HXDLIN(  86)					if ((by > dy)) {
HXLINE(  86)						min = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  86)						min = ::Math_obj::floor(by);
            					}
HXDLIN(  86)					int ii_min = min;
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					yIter3 = this1;
            				}
            				else {
HXLINE(  86)					int ii_min = ::Math_obj::floor(by);
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					yIter3 = this1;
            				}
            			}
            			else {
HXLINE(  86)				if ((by > dy)) {
HXLINE(  86)					int min;
HXDLIN(  86)					if ((ay > dy)) {
HXLINE(  86)						min = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  86)						min = ::Math_obj::ceil(ay);
            					}
HXDLIN(  86)					int ii_min = min;
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(by);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					yIter3 = this1;
            				}
            				else {
HXLINE(  86)					int ii_min = ::Math_obj::floor(ay);
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					yIter3 = this1;
            				}
            			}
HXDLIN(  86)			::pixelimage::ImageStruct undoImage = null();
HXDLIN(  86)			if (hasUndo) {
HXLINE(  86)				int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  86)				int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  86)				int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  86)				::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  86)				::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  86)				::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  86)				undoImage = this4;
HXDLIN(  86)				{
HXLINE(  86)					int rectLeft = xIter3->start;
HXDLIN(  86)					int rectTop = yIter3->start;
HXDLIN(  86)					int rectRight = xIter3->max;
HXDLIN(  86)					bool forceClear = false;
HXDLIN(  86)					{
HXLINE(  86)						int _g = rectTop;
HXDLIN(  86)						int _g1 = yIter3->max;
HXDLIN(  86)						while((_g < _g1)){
HXLINE(  86)							_g = (_g + 1);
HXDLIN(  86)							int dy = (_g - 1);
HXDLIN(  86)							{
HXLINE(  86)								int _g1 = rectLeft;
HXDLIN(  86)								int _g2 = rectRight;
HXDLIN(  86)								while((_g1 < _g2)){
HXLINE(  86)									_g1 = (_g1 + 1);
HXDLIN(  86)									int dx = (_g1 - 1);
HXDLIN(  86)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)									int index;
HXDLIN(  86)									if (this1->useVirtualPos) {
HXLINE(  86)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            									}
            									else {
HXLINE(  86)										index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            									}
HXDLIN(  86)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  86)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)									int col;
HXDLIN(  86)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  86)										col = c;
            									}
HXDLIN(  86)									bool _hx_tmp;
HXDLIN(  86)									if (this1->useMask) {
HXLINE(  86)										_hx_tmp = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  86)										_hx_tmp = false;
            									}
HXDLIN(  86)									if (_hx_tmp) {
HXLINE(  86)										::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  86)										::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  86)										int index;
HXDLIN(  86)										if (this2->useVirtualPos) {
HXLINE(  86)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            										}
            										else {
HXLINE(  86)											index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            										}
HXDLIN(  86)										::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  86)										int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  86)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)										int v;
HXDLIN(  86)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)											v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  86)											v = c;
            										}
HXDLIN(  86)										int this4 = v;
HXDLIN(  86)										int maskPixel = this4;
HXDLIN(  86)										int this5 = col;
HXDLIN(  86)										int this6 = this5;
HXDLIN(  86)										if ((maskPixel == 0)) {
HXLINE(  86)											int this1 = this6;
HXDLIN(  86)											col = this1;
            										}
            										else {
HXLINE(  86)											Float m0;
HXDLIN(  86)											int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  86)											if ((this1 == 0)) {
HXLINE(  86)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float m1;
HXDLIN(  86)											int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  86)											if ((this2 == 0)) {
HXLINE(  86)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float m2;
HXDLIN(  86)											int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  86)											if ((this3 == 0)) {
HXLINE(  86)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float m3;
HXDLIN(  86)											int this4 = (maskPixel & 255);
HXDLIN(  86)											if ((this4 == 0)) {
HXLINE(  86)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  86)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  86)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  86)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  86)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  86)									if ((col != 0)) {
HXLINE(  86)										int x = (dx - rectLeft);
HXDLIN(  86)										int y = (dy - rectTop);
HXDLIN(  86)										int this1 = col;
HXDLIN(  86)										int c = this1;
HXDLIN(  86)										bool _hx_tmp;
HXDLIN(  86)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  86)											_hx_tmp = undoImage->transparent;
            										}
            										else {
HXLINE(  86)											_hx_tmp = false;
            										}
HXDLIN(  86)										if (_hx_tmp) {
HXLINE(  86)											int location;
HXDLIN(  86)											if (undoImage->useVirtualPos) {
HXLINE(  86)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  86)												location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  86)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  86)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  86)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  86)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)											int this3 = this2;
HXDLIN(  86)											int this4;
HXDLIN(  86)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  86)												this4 = this3;
            											}
HXDLIN(  86)											Float a1;
HXDLIN(  86)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  86)											if ((this5 == 0)) {
HXLINE(  86)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float r1;
HXDLIN(  86)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  86)											if ((this6 == 0)) {
HXLINE(  86)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float g1;
HXDLIN(  86)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  86)											if ((this7 == 0)) {
HXLINE(  86)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float b1;
HXDLIN(  86)											int this8 = (this4 & 255);
HXDLIN(  86)											if ((this8 == 0)) {
HXLINE(  86)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float a2;
HXDLIN(  86)											int this9 = ((col >> 24) & 255);
HXDLIN(  86)											if ((this9 == 0)) {
HXLINE(  86)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float r2;
HXDLIN(  86)											int this10 = ((col >> 16) & 255);
HXDLIN(  86)											if ((this10 == 0)) {
HXLINE(  86)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float g2;
HXDLIN(  86)											int this11 = ((col >> 8) & 255);
HXDLIN(  86)											if ((this11 == 0)) {
HXLINE(  86)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float b2;
HXDLIN(  86)											int this12 = (col & 255);
HXDLIN(  86)											if ((this12 == 0)) {
HXLINE(  86)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)											{
HXLINE(  86)												::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  86)												int value;
HXDLIN(  86)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  86)													value = blended;
            												}
HXDLIN(  86)												bool _hx_tmp;
HXDLIN(  86)												if ((location >= 0)) {
HXLINE(  86)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  86)													_hx_tmp = false;
            												}
HXDLIN(  86)												if (_hx_tmp) {
HXLINE(  86)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  86)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  86)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  86)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  86)											int index;
HXDLIN(  86)											if (undoImage->useVirtualPos) {
HXLINE(  86)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  86)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  86)											int value;
HXDLIN(  86)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  86)												value = c;
            											}
HXDLIN(  86)											bool _hx_tmp;
HXDLIN(  86)											if ((index >= 0)) {
HXLINE(  86)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  86)												_hx_tmp = false;
            											}
HXDLIN(  86)											if (_hx_tmp) {
HXLINE(  86)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  86)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  86)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  86)										if (forceClear) {
HXLINE(  86)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  86)											int x = (dx - rectLeft);
HXDLIN(  86)											int y = (dy - rectTop);
HXDLIN(  86)											int index;
HXDLIN(  86)											if (undoImage->useVirtualPos) {
HXLINE(  86)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  86)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  86)											bool _hx_tmp;
HXDLIN(  86)											if ((index >= 0)) {
HXLINE(  86)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  86)												_hx_tmp = false;
            											}
HXDLIN(  86)											if (_hx_tmp) {
HXLINE(  86)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  86)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  86)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  86)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  86)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  86)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  86)			int _g_min = xIter3->start;
HXDLIN(  86)			int _g_max = xIter3->max;
HXDLIN(  86)			while((_g_min < _g_max)){
HXLINE(  86)				_g_min = (_g_min + 1);
HXDLIN(  86)				int px = (_g_min - 1);
HXDLIN(  86)				Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  86)				{
HXLINE(  86)					int _g_min1 = yIter3->start;
HXDLIN(  86)					int _g_max = yIter3->max;
HXDLIN(  86)					while((_g_min1 < _g_max)){
HXLINE(  86)						_g_min1 = (_g_min1 + 1);
HXDLIN(  86)						int py = (_g_min1 - 1);
HXDLIN(  86)						Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  86)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  86)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  86)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  86)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  86)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  86)						bool _hx_tmp;
HXDLIN(  86)						bool _hx_tmp1;
HXDLIN(  86)						if ((ratioA >= 0)) {
HXLINE(  86)							_hx_tmp1 = (ratioB >= 0);
            						}
            						else {
HXLINE(  86)							_hx_tmp1 = false;
            						}
HXDLIN(  86)						if (_hx_tmp1) {
HXLINE(  86)							_hx_tmp = (ratioC >= 0);
            						}
            						else {
HXLINE(  86)							_hx_tmp = false;
            						}
HXDLIN(  86)						if (_hx_tmp) {
HXLINE(  86)							int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  86)							if ((i > 255)) {
HXLINE(  24)								i = 255;
            							}
HXLINE(  86)							if ((i < 0)) {
HXLINE(  25)								i = 0;
            							}
HXLINE(  86)							int this2 = i;
HXDLIN(  86)							int a = this2;
HXDLIN(  86)							int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  86)							if ((i1 > 255)) {
HXLINE(  24)								i1 = 255;
            							}
HXLINE(  86)							if ((i1 < 0)) {
HXLINE(  25)								i1 = 0;
            							}
HXLINE(  86)							int this3 = i1;
HXDLIN(  86)							int r = this3;
HXDLIN(  86)							int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  86)							if ((i2 > 255)) {
HXLINE(  24)								i2 = 255;
            							}
HXLINE(  86)							if ((i2 < 0)) {
HXLINE(  25)								i2 = 0;
            							}
HXLINE(  86)							int this4 = i2;
HXDLIN(  86)							int g = this4;
HXDLIN(  86)							int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  86)							if ((i3 > 255)) {
HXLINE(  24)								i3 = 255;
            							}
HXLINE(  86)							if ((i3 < 0)) {
HXLINE(  25)								i3 = 0;
            							}
HXLINE(  86)							int this5 = i3;
HXDLIN(  86)							int b = this5;
HXDLIN(  86)							{
HXLINE(  86)								int location;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									location = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									location = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            								}
HXDLIN(  86)								bool _hx_tmp;
HXDLIN(  86)								if (this1->transparent) {
HXLINE(  86)									_hx_tmp = (a < 254);
            								}
            								else {
HXLINE(  86)									_hx_tmp = false;
            								}
HXDLIN(  86)								if (_hx_tmp) {
HXLINE(  86)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)									int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  86)									int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)									int this4 = this3;
HXDLIN(  86)									int old;
HXDLIN(  86)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										old = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            									}
            									else {
HXLINE(  86)										old = this4;
            									}
HXDLIN(  86)									int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)									Float a1;
HXDLIN(  86)									int this5 = ((old >> 24) & 255);
HXDLIN(  86)									if ((this5 == 0)) {
HXLINE(  86)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float r1;
HXDLIN(  86)									int this6 = ((old >> 16) & 255);
HXDLIN(  86)									if ((this6 == 0)) {
HXLINE(  86)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float g1;
HXDLIN(  86)									int this7 = ((old >> 8) & 255);
HXDLIN(  86)									if ((this7 == 0)) {
HXLINE(  86)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float b1;
HXDLIN(  86)									int this8 = (old & 255);
HXDLIN(  86)									if ((this8 == 0)) {
HXLINE(  86)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float a2;
HXDLIN(  86)									int this9 = ((rhs >> 24) & 255);
HXDLIN(  86)									if ((this9 == 0)) {
HXLINE(  86)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float r2;
HXDLIN(  86)									int this10 = ((rhs >> 16) & 255);
HXDLIN(  86)									if ((this10 == 0)) {
HXLINE(  86)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float g2;
HXDLIN(  86)									int this11 = ((rhs >> 8) & 255);
HXDLIN(  86)									if ((this11 == 0)) {
HXLINE(  86)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float b2;
HXDLIN(  86)									int this12 = (rhs & 255);
HXDLIN(  86)									if ((this12 == 0)) {
HXLINE(  86)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)									int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  86)									{
HXLINE(  86)										::haxe::io::ArrayBufferViewImpl this13 = this1->image;
HXDLIN(  86)										int value;
HXDLIN(  86)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  86)											value = blended;
            										}
HXDLIN(  86)										bool _hx_tmp;
HXDLIN(  86)										if ((location >= 0)) {
HXLINE(  86)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  86)											_hx_tmp = false;
            										}
HXDLIN(  86)										if (_hx_tmp) {
HXLINE(  86)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  86)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  86)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  86)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)									int value;
HXDLIN(  86)									if (this1->isLittle) {
HXLINE(  86)										value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE(  86)										value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN(  86)									bool _hx_tmp;
HXDLIN(  86)									if ((location >= 0)) {
HXLINE(  86)										_hx_tmp = (location < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  86)										_hx_tmp = false;
            									}
HXDLIN(  86)									if (_hx_tmp) {
HXLINE(  86)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)										int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  86)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  86)			bool hasHit = false;
HXDLIN(  86)			bool hasUndo1 = false;
HXDLIN(  86)			int aA1 = ((colorC >> 24) & 255);
HXDLIN(  86)			int rA1 = ((colorC >> 16) & 255);
HXDLIN(  86)			int gA1 = ((colorC >> 8) & 255);
HXDLIN(  86)			int bA1 = (colorC & 255);
HXDLIN(  86)			int aB1 = ((colorB >> 24) & 255);
HXDLIN(  86)			int rB1 = ((colorB >> 16) & 255);
HXDLIN(  86)			int gB1 = ((colorB >> 8) & 255);
HXDLIN(  86)			int bB1 = (colorB & 255);
HXDLIN(  86)			int aC1 = ((colorD >> 24) & 255);
HXDLIN(  86)			int rC1 = ((colorD >> 16) & 255);
HXDLIN(  86)			int gC1 = ((colorD >> 8) & 255);
HXDLIN(  86)			int bC1 = (colorD & 255);
HXDLIN(  86)			Float bcx1 = (cx - dx);
HXDLIN(  86)			Float bcy1 = (cy - dy);
HXDLIN(  86)			Float acx1 = (bx - dx);
HXDLIN(  86)			Float acy1 = (by - dy);
HXDLIN(  86)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  86)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  86)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  86)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  86)			::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  86)			if ((bx > cx)) {
HXLINE(  86)				if ((bx > dx)) {
HXLINE(  86)					int min;
HXDLIN(  86)					if ((cx > dx)) {
HXLINE(  86)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  86)						min = ::Math_obj::floor(cx);
            					}
HXDLIN(  86)					int ii_min = min;
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					xIter31 = this1;
            				}
            				else {
HXLINE(  86)					int ii_min = ::Math_obj::floor(cx);
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					xIter31 = this1;
            				}
            			}
            			else {
HXLINE(  86)				if ((cx > dx)) {
HXLINE(  86)					int min;
HXDLIN(  86)					if ((bx > dx)) {
HXLINE(  86)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  86)						min = ::Math_obj::ceil(bx);
            					}
HXDLIN(  86)					int ii_min = min;
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					xIter31 = this1;
            				}
            				else {
HXLINE(  86)					int ii_min = ::Math_obj::floor(bx);
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					xIter31 = this1;
            				}
            			}
HXDLIN(  86)			::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  86)			if ((by > cy)) {
HXLINE(  86)				if ((by > dy)) {
HXLINE(  86)					int min;
HXDLIN(  86)					if ((cy > dy)) {
HXLINE(  86)						min = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  86)						min = ::Math_obj::floor(cy);
            					}
HXDLIN(  86)					int ii_min = min;
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(by);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					yIter31 = this1;
            				}
            				else {
HXLINE(  86)					int ii_min = ::Math_obj::floor(cy);
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					yIter31 = this1;
            				}
            			}
            			else {
HXLINE(  86)				if ((cy > dy)) {
HXLINE(  86)					int min;
HXDLIN(  86)					if ((by > dy)) {
HXLINE(  86)						min = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  86)						min = ::Math_obj::ceil(by);
            					}
HXDLIN(  86)					int ii_min = min;
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					yIter31 = this1;
            				}
            				else {
HXLINE(  86)					int ii_min = ::Math_obj::floor(by);
HXDLIN(  86)					int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  86)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  86)					yIter31 = this1;
            				}
            			}
HXDLIN(  86)			::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  86)			if (hasUndo1) {
HXLINE(  86)				int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  86)				int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  86)				int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  86)				::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  86)				::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  86)				::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  86)				undoImage1 = this4;
HXDLIN(  86)				{
HXLINE(  86)					int rectLeft = xIter31->start;
HXDLIN(  86)					int rectTop = yIter31->start;
HXDLIN(  86)					int rectRight = xIter31->max;
HXDLIN(  86)					bool forceClear = false;
HXDLIN(  86)					{
HXLINE(  86)						int _g = rectTop;
HXDLIN(  86)						int _g1 = yIter31->max;
HXDLIN(  86)						while((_g < _g1)){
HXLINE(  86)							_g = (_g + 1);
HXDLIN(  86)							int dy = (_g - 1);
HXDLIN(  86)							{
HXLINE(  86)								int _g1 = rectLeft;
HXDLIN(  86)								int _g2 = rectRight;
HXDLIN(  86)								while((_g1 < _g2)){
HXLINE(  86)									_g1 = (_g1 + 1);
HXDLIN(  86)									int dx = (_g1 - 1);
HXDLIN(  86)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)									int index;
HXDLIN(  86)									if (this1->useVirtualPos) {
HXLINE(  86)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            									}
            									else {
HXLINE(  86)										index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            									}
HXDLIN(  86)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  86)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)									int col;
HXDLIN(  86)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  86)										col = c;
            									}
HXDLIN(  86)									bool _hx_tmp;
HXDLIN(  86)									if (this1->useMask) {
HXLINE(  86)										_hx_tmp = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  86)										_hx_tmp = false;
            									}
HXDLIN(  86)									if (_hx_tmp) {
HXLINE(  86)										::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  86)										::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  86)										int index;
HXDLIN(  86)										if (this2->useVirtualPos) {
HXLINE(  86)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            										}
            										else {
HXLINE(  86)											index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            										}
HXDLIN(  86)										::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  86)										int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  86)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)										int v;
HXDLIN(  86)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)											v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  86)											v = c;
            										}
HXDLIN(  86)										int this4 = v;
HXDLIN(  86)										int maskPixel = this4;
HXDLIN(  86)										int this5 = col;
HXDLIN(  86)										int this6 = this5;
HXDLIN(  86)										if ((maskPixel == 0)) {
HXLINE(  86)											int this1 = this6;
HXDLIN(  86)											col = this1;
            										}
            										else {
HXLINE(  86)											Float m0;
HXDLIN(  86)											int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  86)											if ((this1 == 0)) {
HXLINE(  86)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float m1;
HXDLIN(  86)											int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  86)											if ((this2 == 0)) {
HXLINE(  86)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float m2;
HXDLIN(  86)											int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  86)											if ((this3 == 0)) {
HXLINE(  86)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float m3;
HXDLIN(  86)											int this4 = (maskPixel & 255);
HXDLIN(  86)											if ((this4 == 0)) {
HXLINE(  86)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  86)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  86)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  86)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  86)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  86)									if ((col != 0)) {
HXLINE(  86)										int x = (dx - rectLeft);
HXDLIN(  86)										int y = (dy - rectTop);
HXDLIN(  86)										int this1 = col;
HXDLIN(  86)										int c = this1;
HXDLIN(  86)										bool _hx_tmp;
HXDLIN(  86)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  86)											_hx_tmp = undoImage1->transparent;
            										}
            										else {
HXLINE(  86)											_hx_tmp = false;
            										}
HXDLIN(  86)										if (_hx_tmp) {
HXLINE(  86)											int location;
HXDLIN(  86)											if (undoImage1->useVirtualPos) {
HXLINE(  86)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  86)												location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  86)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  86)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  86)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  86)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)											int this3 = this2;
HXDLIN(  86)											int this4;
HXDLIN(  86)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  86)												this4 = this3;
            											}
HXDLIN(  86)											Float a1;
HXDLIN(  86)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  86)											if ((this5 == 0)) {
HXLINE(  86)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float r1;
HXDLIN(  86)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  86)											if ((this6 == 0)) {
HXLINE(  86)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float g1;
HXDLIN(  86)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  86)											if ((this7 == 0)) {
HXLINE(  86)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float b1;
HXDLIN(  86)											int this8 = (this4 & 255);
HXDLIN(  86)											if ((this8 == 0)) {
HXLINE(  86)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float a2;
HXDLIN(  86)											int this9 = ((col >> 24) & 255);
HXDLIN(  86)											if ((this9 == 0)) {
HXLINE(  86)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float r2;
HXDLIN(  86)											int this10 = ((col >> 16) & 255);
HXDLIN(  86)											if ((this10 == 0)) {
HXLINE(  86)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float g2;
HXDLIN(  86)											int this11 = ((col >> 8) & 255);
HXDLIN(  86)											if ((this11 == 0)) {
HXLINE(  86)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float b2;
HXDLIN(  86)											int this12 = (col & 255);
HXDLIN(  86)											if ((this12 == 0)) {
HXLINE(  86)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  86)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  86)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)											{
HXLINE(  86)												::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  86)												int value;
HXDLIN(  86)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  86)													value = blended;
            												}
HXDLIN(  86)												bool _hx_tmp;
HXDLIN(  86)												if ((location >= 0)) {
HXLINE(  86)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  86)													_hx_tmp = false;
            												}
HXDLIN(  86)												if (_hx_tmp) {
HXLINE(  86)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  86)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  86)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  86)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  86)											int index;
HXDLIN(  86)											if (undoImage1->useVirtualPos) {
HXLINE(  86)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  86)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  86)											int value;
HXDLIN(  86)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  86)												value = c;
            											}
HXDLIN(  86)											bool _hx_tmp;
HXDLIN(  86)											if ((index >= 0)) {
HXLINE(  86)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  86)												_hx_tmp = false;
            											}
HXDLIN(  86)											if (_hx_tmp) {
HXLINE(  86)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  86)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  86)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  86)										if (forceClear) {
HXLINE(  86)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  86)											int x = (dx - rectLeft);
HXDLIN(  86)											int y = (dy - rectTop);
HXDLIN(  86)											int index;
HXDLIN(  86)											if (undoImage1->useVirtualPos) {
HXLINE(  86)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  86)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  86)											bool _hx_tmp;
HXDLIN(  86)											if ((index >= 0)) {
HXLINE(  86)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  86)												_hx_tmp = false;
            											}
HXDLIN(  86)											if (_hx_tmp) {
HXLINE(  86)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  86)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  86)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  86)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  86)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  86)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  86)			int _g_min1 = xIter31->start;
HXDLIN(  86)			int _g_max1 = xIter31->max;
HXDLIN(  86)			while((_g_min1 < _g_max1)){
HXLINE(  86)				_g_min1 = (_g_min1 + 1);
HXDLIN(  86)				int px = (_g_min1 - 1);
HXDLIN(  86)				Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  86)				{
HXLINE(  86)					int _g_min = yIter31->start;
HXDLIN(  86)					int _g_max = yIter31->max;
HXDLIN(  86)					while((_g_min < _g_max)){
HXLINE(  86)						_g_min = (_g_min + 1);
HXDLIN(  86)						int py = (_g_min - 1);
HXDLIN(  86)						Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  86)						Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  86)						Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  86)						Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  86)						Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  86)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  86)						bool _hx_tmp;
HXDLIN(  86)						bool _hx_tmp1;
HXDLIN(  86)						if ((ratioA >= 0)) {
HXLINE(  86)							_hx_tmp1 = (ratioB >= 0);
            						}
            						else {
HXLINE(  86)							_hx_tmp1 = false;
            						}
HXDLIN(  86)						if (_hx_tmp1) {
HXLINE(  86)							_hx_tmp = (ratioC >= 0);
            						}
            						else {
HXLINE(  86)							_hx_tmp = false;
            						}
HXDLIN(  86)						if (_hx_tmp) {
HXLINE(  86)							int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  86)							if ((i > 255)) {
HXLINE(  24)								i = 255;
            							}
HXLINE(  86)							if ((i < 0)) {
HXLINE(  25)								i = 0;
            							}
HXLINE(  86)							int this2 = i;
HXDLIN(  86)							int a = this2;
HXDLIN(  86)							int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  86)							if ((i1 > 255)) {
HXLINE(  24)								i1 = 255;
            							}
HXLINE(  86)							if ((i1 < 0)) {
HXLINE(  25)								i1 = 0;
            							}
HXLINE(  86)							int this3 = i1;
HXDLIN(  86)							int r = this3;
HXDLIN(  86)							int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  86)							if ((i2 > 255)) {
HXLINE(  24)								i2 = 255;
            							}
HXLINE(  86)							if ((i2 < 0)) {
HXLINE(  25)								i2 = 0;
            							}
HXLINE(  86)							int this4 = i2;
HXDLIN(  86)							int g = this4;
HXDLIN(  86)							int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  86)							if ((i3 > 255)) {
HXLINE(  24)								i3 = 255;
            							}
HXLINE(  86)							if ((i3 < 0)) {
HXLINE(  25)								i3 = 0;
            							}
HXLINE(  86)							int this5 = i3;
HXDLIN(  86)							int b = this5;
HXDLIN(  86)							{
HXLINE(  86)								int location;
HXDLIN(  86)								if (this1->useVirtualPos) {
HXLINE(  86)									location = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            								}
            								else {
HXLINE(  86)									location = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            								}
HXDLIN(  86)								bool _hx_tmp;
HXDLIN(  86)								if (this1->transparent) {
HXLINE(  86)									_hx_tmp = (a < 254);
            								}
            								else {
HXLINE(  86)									_hx_tmp = false;
            								}
HXDLIN(  86)								if (_hx_tmp) {
HXLINE(  86)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)									int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  86)									int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)									int this4 = this3;
HXDLIN(  86)									int old;
HXDLIN(  86)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)										old = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            									}
            									else {
HXLINE(  86)										old = this4;
            									}
HXDLIN(  86)									int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)									Float a1;
HXDLIN(  86)									int this5 = ((old >> 24) & 255);
HXDLIN(  86)									if ((this5 == 0)) {
HXLINE(  86)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float r1;
HXDLIN(  86)									int this6 = ((old >> 16) & 255);
HXDLIN(  86)									if ((this6 == 0)) {
HXLINE(  86)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float g1;
HXDLIN(  86)									int this7 = ((old >> 8) & 255);
HXDLIN(  86)									if ((this7 == 0)) {
HXLINE(  86)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float b1;
HXDLIN(  86)									int this8 = (old & 255);
HXDLIN(  86)									if ((this8 == 0)) {
HXLINE(  86)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float a2;
HXDLIN(  86)									int this9 = ((rhs >> 24) & 255);
HXDLIN(  86)									if ((this9 == 0)) {
HXLINE(  86)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float r2;
HXDLIN(  86)									int this10 = ((rhs >> 16) & 255);
HXDLIN(  86)									if ((this10 == 0)) {
HXLINE(  86)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float g2;
HXDLIN(  86)									int this11 = ((rhs >> 8) & 255);
HXDLIN(  86)									if ((this11 == 0)) {
HXLINE(  86)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float b2;
HXDLIN(  86)									int this12 = (rhs & 255);
HXDLIN(  86)									if ((this12 == 0)) {
HXLINE(  86)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  86)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  86)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)									int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)									int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)									int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  86)									{
HXLINE(  86)										::haxe::io::ArrayBufferViewImpl this13 = this1->image;
HXDLIN(  86)										int value;
HXDLIN(  86)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  86)											value = blended;
            										}
HXDLIN(  86)										bool _hx_tmp;
HXDLIN(  86)										if ((location >= 0)) {
HXLINE(  86)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  86)											_hx_tmp = false;
            										}
HXDLIN(  86)										if (_hx_tmp) {
HXLINE(  86)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  86)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  86)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  86)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  86)									int value;
HXDLIN(  86)									if (this1->isLittle) {
HXLINE(  86)										value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE(  86)										value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN(  86)									bool _hx_tmp;
HXDLIN(  86)									if ((location >= 0)) {
HXLINE(  86)										_hx_tmp = (location < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  86)										_hx_tmp = false;
            									}
HXDLIN(  86)									if (_hx_tmp) {
HXLINE(  86)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  86)										int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  86)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  86)			if ((hasHit == false)) {
HXLINE(  86)				::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  86)				if (hasUndo1) {
HXLINE(  86)					v->undoImage = undoImage1;
HXDLIN(  86)					v->undoX = xIter31->start;
HXDLIN(  86)					v->undoY = yIter31->start;
            				}
            			}
HXDLIN(  86)			::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  86)			this->info = v;
HXLINE(  90)			bool _hx_tmp;
HXDLIN(  90)			if (::hx::IsNotNull( this->info )) {
HXLINE(  90)				_hx_tmp = ::hx::IsNotNull( oldInfo );
            			}
            			else {
HXLINE(  90)				_hx_tmp = false;
            			}
HXDLIN(  90)			if (_hx_tmp) {
HXLINE(  91)				::pixelimage::ImageStruct this1 = this->temp;
HXDLIN(  91)				Float ax = ((( (Float)(oldInfo->__Field(HX_("bx",d6,55,00,00),::hx::paccDynamic)) ) * this->scaleX) + this->translateX);
HXDLIN(  91)				Float ay = ((( (Float)(oldInfo->__Field(HX_("by",d7,55,00,00),::hx::paccDynamic)) ) * this->scaleY) + this->translateY);
HXDLIN(  91)				int colorA = this->strokeTopColor;
HXDLIN(  91)				Float bx = ((( (Float)(this->info->__Field(HX_("ax",f7,54,00,00),::hx::paccDynamic)) ) * this->scaleX) + this->translateX);
HXDLIN(  91)				Float by = ((( (Float)(this->info->__Field(HX_("ay",f8,54,00,00),::hx::paccDynamic)) ) * this->scaleY) + this->translateY);
HXDLIN(  91)				int colorB = this->strokeTopColor;
HXDLIN(  91)				Float cx = ((( (Float)(this->info->__Field(HX_("dx",94,57,00,00),::hx::paccDynamic)) ) * this->scaleX) + this->translateX);
HXDLIN(  91)				Float cy = ((( (Float)(this->info->__Field(HX_("dy",95,57,00,00),::hx::paccDynamic)) ) * this->scaleY) + this->translateY);
HXDLIN(  91)				int colorC = this->strokeBottomColor;
HXDLIN(  91)				Float dx = ((( (Float)(oldInfo->__Field(HX_("cx",b5,56,00,00),::hx::paccDynamic)) ) * this->scaleX) + this->translateX);
HXDLIN(  91)				Float dy = ((( (Float)(oldInfo->__Field(HX_("cy",b6,56,00,00),::hx::paccDynamic)) ) * this->scaleY) + this->translateY);
HXDLIN(  91)				int colorD = this->strokeBottomColor;
HXDLIN(  91)				{
HXLINE(  91)					{
HXLINE(  91)						bool hasUndo = false;
HXDLIN(  91)						int aA = ((colorB >> 24) & 255);
HXDLIN(  91)						int rA = ((colorB >> 16) & 255);
HXDLIN(  91)						int gA = ((colorB >> 8) & 255);
HXDLIN(  91)						int bA = (colorB & 255);
HXDLIN(  91)						int aB = ((colorA >> 24) & 255);
HXDLIN(  91)						int rB = ((colorA >> 16) & 255);
HXDLIN(  91)						int gB = ((colorA >> 8) & 255);
HXDLIN(  91)						int bB = (colorA & 255);
HXDLIN(  91)						int aC = ((colorD >> 24) & 255);
HXDLIN(  91)						int rC = ((colorD >> 16) & 255);
HXDLIN(  91)						int gC = ((colorD >> 8) & 255);
HXDLIN(  91)						int bC = (colorD & 255);
HXDLIN(  91)						Float bcx = (bx - dx);
HXDLIN(  91)						Float bcy = (by - dy);
HXDLIN(  91)						Float acx = (ax - dx);
HXDLIN(  91)						Float acy = (ay - dy);
HXDLIN(  91)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  91)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  91)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  91)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  91)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  91)						if ((ax > bx)) {
HXLINE(  91)							if ((ax > dx)) {
HXLINE(  91)								int min;
HXDLIN(  91)								if ((bx > dx)) {
HXLINE(  91)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  91)									min = ::Math_obj::floor(bx);
            								}
HXDLIN(  91)								int ii_min = min;
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								xIter3 = this1;
            							}
            							else {
HXLINE(  91)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  91)							if ((bx > dx)) {
HXLINE(  91)								int min;
HXDLIN(  91)								if ((ax > dx)) {
HXLINE(  91)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  91)									min = ::Math_obj::ceil(ax);
            								}
HXDLIN(  91)								int ii_min = min;
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								xIter3 = this1;
            							}
            							else {
HXLINE(  91)								int ii_min = ::Math_obj::floor(ax);
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								xIter3 = this1;
            							}
            						}
HXDLIN(  91)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  91)						if ((ay > by)) {
HXLINE(  91)							if ((ay > dy)) {
HXLINE(  91)								int min;
HXDLIN(  91)								if ((by > dy)) {
HXLINE(  91)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  91)									min = ::Math_obj::floor(by);
            								}
HXDLIN(  91)								int ii_min = min;
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								yIter3 = this1;
            							}
            							else {
HXLINE(  91)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  91)							if ((by > dy)) {
HXLINE(  91)								int min;
HXDLIN(  91)								if ((ay > dy)) {
HXLINE(  91)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  91)									min = ::Math_obj::ceil(ay);
            								}
HXDLIN(  91)								int ii_min = min;
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								yIter3 = this1;
            							}
            							else {
HXLINE(  91)								int ii_min = ::Math_obj::floor(ay);
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								yIter3 = this1;
            							}
            						}
HXDLIN(  91)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  91)						if (hasUndo) {
HXLINE(  91)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  91)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  91)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  91)							::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  91)							::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  91)							::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  91)							undoImage = this4;
HXDLIN(  91)							{
HXLINE(  91)								int rectLeft = xIter3->start;
HXDLIN(  91)								int rectTop = yIter3->start;
HXDLIN(  91)								int rectRight = xIter3->max;
HXDLIN(  91)								bool forceClear = false;
HXDLIN(  91)								{
HXLINE(  91)									int _g = rectTop;
HXDLIN(  91)									int _g1 = yIter3->max;
HXDLIN(  91)									while((_g < _g1)){
HXLINE(  91)										_g = (_g + 1);
HXDLIN(  91)										int dy = (_g - 1);
HXDLIN(  91)										{
HXLINE(  91)											int _g1 = rectLeft;
HXDLIN(  91)											int _g2 = rectRight;
HXDLIN(  91)											while((_g1 < _g2)){
HXLINE(  91)												_g1 = (_g1 + 1);
HXDLIN(  91)												int dx = (_g1 - 1);
HXDLIN(  91)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  91)												int index;
HXDLIN(  91)												if (this1->useVirtualPos) {
HXLINE(  91)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  91)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  91)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  91)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  91)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)												int col;
HXDLIN(  91)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  91)													col = c;
            												}
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												if (this1->useMask) {
HXLINE(  91)													_hx_tmp = ::hx::IsNotNull( this1->mask );
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  91)													::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  91)													int index;
HXDLIN(  91)													if (this2->useVirtualPos) {
HXLINE(  91)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            													}
            													else {
HXLINE(  91)														index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            													}
HXDLIN(  91)													::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  91)													int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  91)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)													int v;
HXDLIN(  91)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  91)														v = c;
            													}
HXDLIN(  91)													int this4 = v;
HXDLIN(  91)													int maskPixel = this4;
HXDLIN(  91)													int this5 = col;
HXDLIN(  91)													int this6 = this5;
HXDLIN(  91)													if ((maskPixel == 0)) {
HXLINE(  91)														int this1 = this6;
HXDLIN(  91)														col = this1;
            													}
            													else {
HXLINE(  91)														Float m0;
HXDLIN(  91)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  91)														if ((this1 == 0)) {
HXLINE(  91)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float m1;
HXDLIN(  91)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  91)														if ((this2 == 0)) {
HXLINE(  91)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float m2;
HXDLIN(  91)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  91)														if ((this3 == 0)) {
HXLINE(  91)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float m3;
HXDLIN(  91)														int this4 = (maskPixel & 255);
HXDLIN(  91)														if ((this4 == 0)) {
HXLINE(  91)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  91)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  91)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  91)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  91)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  91)												if ((col != 0)) {
HXLINE(  91)													int x = (dx - rectLeft);
HXDLIN(  91)													int y = (dy - rectTop);
HXDLIN(  91)													int this1 = col;
HXDLIN(  91)													int c = this1;
HXDLIN(  91)													bool _hx_tmp;
HXDLIN(  91)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  91)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  91)														_hx_tmp = false;
            													}
HXDLIN(  91)													if (_hx_tmp) {
HXLINE(  91)														int location;
HXDLIN(  91)														if (undoImage->useVirtualPos) {
HXLINE(  91)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  91)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  91)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  91)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)														int this3 = this2;
HXDLIN(  91)														int this4;
HXDLIN(  91)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  91)															this4 = this3;
            														}
HXDLIN(  91)														Float a1;
HXDLIN(  91)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  91)														if ((this5 == 0)) {
HXLINE(  91)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float r1;
HXDLIN(  91)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  91)														if ((this6 == 0)) {
HXLINE(  91)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float g1;
HXDLIN(  91)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  91)														if ((this7 == 0)) {
HXLINE(  91)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float b1;
HXDLIN(  91)														int this8 = (this4 & 255);
HXDLIN(  91)														if ((this8 == 0)) {
HXLINE(  91)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float a2;
HXDLIN(  91)														int this9 = ((col >> 24) & 255);
HXDLIN(  91)														if ((this9 == 0)) {
HXLINE(  91)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float r2;
HXDLIN(  91)														int this10 = ((col >> 16) & 255);
HXDLIN(  91)														if ((this10 == 0)) {
HXLINE(  91)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float g2;
HXDLIN(  91)														int this11 = ((col >> 8) & 255);
HXDLIN(  91)														if ((this11 == 0)) {
HXLINE(  91)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float b2;
HXDLIN(  91)														int this12 = (col & 255);
HXDLIN(  91)														if ((this12 == 0)) {
HXLINE(  91)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)														{
HXLINE(  91)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  91)															int value;
HXDLIN(  91)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  91)																value = blended;
            															}
HXDLIN(  91)															bool _hx_tmp;
HXDLIN(  91)															if ((location >= 0)) {
HXLINE(  91)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  91)																_hx_tmp = false;
            															}
HXDLIN(  91)															if (_hx_tmp) {
HXLINE(  91)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  91)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  91)														int index;
HXDLIN(  91)														if (undoImage->useVirtualPos) {
HXLINE(  91)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  91)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  91)														int value;
HXDLIN(  91)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  91)															value = c;
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if ((index >= 0)) {
HXLINE(  91)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  91)													if (forceClear) {
HXLINE(  91)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  91)														int x = (dx - rectLeft);
HXDLIN(  91)														int y = (dy - rectTop);
HXDLIN(  91)														int index;
HXDLIN(  91)														if (undoImage->useVirtualPos) {
HXLINE(  91)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  91)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if ((index >= 0)) {
HXLINE(  91)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  91)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  91)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  91)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  91)						{
HXLINE(  91)							int _g_min = xIter3->start;
HXDLIN(  91)							int _g_max = xIter3->max;
HXDLIN(  91)							while((_g_min < _g_max)){
HXLINE(  91)								_g_min = (_g_min + 1);
HXDLIN(  91)								int px = (_g_min - 1);
HXDLIN(  91)								Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  91)								{
HXLINE(  91)									int _g_min1 = yIter3->start;
HXDLIN(  91)									int _g_max = yIter3->max;
HXDLIN(  91)									while((_g_min1 < _g_max)){
HXLINE(  91)										_g_min1 = (_g_min1 + 1);
HXDLIN(  91)										int py = (_g_min1 - 1);
HXDLIN(  91)										Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  91)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  91)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  91)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  91)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  91)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  91)										bool _hx_tmp;
HXDLIN(  91)										bool _hx_tmp1;
HXDLIN(  91)										if ((ratioA >= 0)) {
HXLINE(  91)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  91)											_hx_tmp1 = false;
            										}
HXDLIN(  91)										if (_hx_tmp1) {
HXLINE(  91)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  91)											_hx_tmp = false;
            										}
HXDLIN(  91)										if (_hx_tmp) {
HXLINE(  91)											int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  91)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  91)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  91)											int this2 = i;
HXDLIN(  91)											int a = this2;
HXDLIN(  91)											int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  91)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  91)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  91)											int this3 = i1;
HXDLIN(  91)											int r = this3;
HXDLIN(  91)											int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  91)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  91)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  91)											int this4 = i2;
HXDLIN(  91)											int g = this4;
HXDLIN(  91)											int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  91)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  91)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  91)											int this5 = i3;
HXDLIN(  91)											int b = this5;
HXDLIN(  91)											{
HXLINE(  91)												int location;
HXDLIN(  91)												if (this1->useVirtualPos) {
HXLINE(  91)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            												}
            												else {
HXLINE(  91)													location = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            												}
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												if (this1->transparent) {
HXLINE(  91)													_hx_tmp = (a < 254);
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  91)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  91)													int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  91)													int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)													int this4 = this3;
HXDLIN(  91)													int old;
HXDLIN(  91)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)														old = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            													}
            													else {
HXLINE(  91)														old = this4;
            													}
HXDLIN(  91)													int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)													Float a1;
HXDLIN(  91)													int this5 = ((old >> 24) & 255);
HXDLIN(  91)													if ((this5 == 0)) {
HXLINE(  91)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float r1;
HXDLIN(  91)													int this6 = ((old >> 16) & 255);
HXDLIN(  91)													if ((this6 == 0)) {
HXLINE(  91)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float g1;
HXDLIN(  91)													int this7 = ((old >> 8) & 255);
HXDLIN(  91)													if ((this7 == 0)) {
HXLINE(  91)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float b1;
HXDLIN(  91)													int this8 = (old & 255);
HXDLIN(  91)													if ((this8 == 0)) {
HXLINE(  91)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float a2;
HXDLIN(  91)													int this9 = ((rhs >> 24) & 255);
HXDLIN(  91)													if ((this9 == 0)) {
HXLINE(  91)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float r2;
HXDLIN(  91)													int this10 = ((rhs >> 16) & 255);
HXDLIN(  91)													if ((this10 == 0)) {
HXLINE(  91)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float g2;
HXDLIN(  91)													int this11 = ((rhs >> 8) & 255);
HXDLIN(  91)													if ((this11 == 0)) {
HXLINE(  91)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float b2;
HXDLIN(  91)													int this12 = (rhs & 255);
HXDLIN(  91)													if ((this12 == 0)) {
HXLINE(  91)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)													int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  91)													{
HXLINE(  91)														::haxe::io::ArrayBufferViewImpl this13 = this1->image;
HXDLIN(  91)														int value;
HXDLIN(  91)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  91)															value = blended;
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if ((location >= 0)) {
HXLINE(  91)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  91)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  91)													int value;
HXDLIN(  91)													if (this1->isLittle) {
HXLINE(  91)														value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  91)														value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  91)													bool _hx_tmp;
HXDLIN(  91)													if ((location >= 0)) {
HXLINE(  91)														_hx_tmp = (location < (this2->byteLength >> 2));
            													}
            													else {
HXLINE(  91)														_hx_tmp = false;
            													}
HXDLIN(  91)													if (_hx_tmp) {
HXLINE(  91)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  91)														int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  91)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  91)					{
HXLINE(  91)						bool hasHit = false;
HXDLIN(  91)						bool hasUndo1 = false;
HXDLIN(  91)						int aA1 = ((colorC >> 24) & 255);
HXDLIN(  91)						int rA1 = ((colorC >> 16) & 255);
HXDLIN(  91)						int gA1 = ((colorC >> 8) & 255);
HXDLIN(  91)						int bA1 = (colorC & 255);
HXDLIN(  91)						int aB1 = ((colorB >> 24) & 255);
HXDLIN(  91)						int rB1 = ((colorB >> 16) & 255);
HXDLIN(  91)						int gB1 = ((colorB >> 8) & 255);
HXDLIN(  91)						int bB1 = (colorB & 255);
HXDLIN(  91)						int aC1 = ((colorD >> 24) & 255);
HXDLIN(  91)						int rC1 = ((colorD >> 16) & 255);
HXDLIN(  91)						int gC1 = ((colorD >> 8) & 255);
HXDLIN(  91)						int bC1 = (colorD & 255);
HXDLIN(  91)						Float bcx1 = (cx - dx);
HXDLIN(  91)						Float bcy1 = (cy - dy);
HXDLIN(  91)						Float acx1 = (bx - dx);
HXDLIN(  91)						Float acy1 = (by - dy);
HXDLIN(  91)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  91)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  91)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  91)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  91)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  91)						if ((bx > cx)) {
HXLINE(  91)							if ((bx > dx)) {
HXLINE(  91)								int min;
HXDLIN(  91)								if ((cx > dx)) {
HXLINE(  91)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  91)									min = ::Math_obj::floor(cx);
            								}
HXDLIN(  91)								int ii_min = min;
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								xIter31 = this1;
            							}
            							else {
HXLINE(  91)								int ii_min = ::Math_obj::floor(cx);
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE(  91)							if ((cx > dx)) {
HXLINE(  91)								int min;
HXDLIN(  91)								if ((bx > dx)) {
HXLINE(  91)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  91)									min = ::Math_obj::ceil(bx);
            								}
HXDLIN(  91)								int ii_min = min;
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								xIter31 = this1;
            							}
            							else {
HXLINE(  91)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								xIter31 = this1;
            							}
            						}
HXDLIN(  91)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  91)						if ((by > cy)) {
HXLINE(  91)							if ((by > dy)) {
HXLINE(  91)								int min;
HXDLIN(  91)								if ((cy > dy)) {
HXLINE(  91)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  91)									min = ::Math_obj::floor(cy);
            								}
HXDLIN(  91)								int ii_min = min;
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								yIter31 = this1;
            							}
            							else {
HXLINE(  91)								int ii_min = ::Math_obj::floor(cy);
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE(  91)							if ((cy > dy)) {
HXLINE(  91)								int min;
HXDLIN(  91)								if ((by > dy)) {
HXLINE(  91)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  91)									min = ::Math_obj::ceil(by);
            								}
HXDLIN(  91)								int ii_min = min;
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								yIter31 = this1;
            							}
            							else {
HXLINE(  91)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  91)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  91)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)								yIter31 = this1;
            							}
            						}
HXDLIN(  91)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  91)						if (hasUndo1) {
HXLINE(  91)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  91)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  91)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  91)							::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  91)							::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN(  91)							::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN(  91)							undoImage1 = this4;
HXDLIN(  91)							{
HXLINE(  91)								int rectLeft = xIter31->start;
HXDLIN(  91)								int rectTop = yIter31->start;
HXDLIN(  91)								int rectRight = xIter31->max;
HXDLIN(  91)								bool forceClear = false;
HXDLIN(  91)								{
HXLINE(  91)									int _g = rectTop;
HXDLIN(  91)									int _g1 = yIter31->max;
HXDLIN(  91)									while((_g < _g1)){
HXLINE(  91)										_g = (_g + 1);
HXDLIN(  91)										int dy = (_g - 1);
HXDLIN(  91)										{
HXLINE(  91)											int _g1 = rectLeft;
HXDLIN(  91)											int _g2 = rectRight;
HXDLIN(  91)											while((_g1 < _g2)){
HXLINE(  91)												_g1 = (_g1 + 1);
HXDLIN(  91)												int dx = (_g1 - 1);
HXDLIN(  91)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  91)												int index;
HXDLIN(  91)												if (this1->useVirtualPos) {
HXLINE(  91)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  91)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  91)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  91)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  91)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)												int col;
HXDLIN(  91)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  91)													col = c;
            												}
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												if (this1->useMask) {
HXLINE(  91)													_hx_tmp = ::hx::IsNotNull( this1->mask );
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN(  91)													::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN(  91)													int index;
HXDLIN(  91)													if (this2->useVirtualPos) {
HXLINE(  91)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            													}
            													else {
HXLINE(  91)														index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            													}
HXDLIN(  91)													::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  91)													int pos = ((index << 2) + this3->byteOffset);
HXDLIN(  91)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)													int v;
HXDLIN(  91)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  91)														v = c;
            													}
HXDLIN(  91)													int this4 = v;
HXDLIN(  91)													int maskPixel = this4;
HXDLIN(  91)													int this5 = col;
HXDLIN(  91)													int this6 = this5;
HXDLIN(  91)													if ((maskPixel == 0)) {
HXLINE(  91)														int this1 = this6;
HXDLIN(  91)														col = this1;
            													}
            													else {
HXLINE(  91)														Float m0;
HXDLIN(  91)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  91)														if ((this1 == 0)) {
HXLINE(  91)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float m1;
HXDLIN(  91)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  91)														if ((this2 == 0)) {
HXLINE(  91)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float m2;
HXDLIN(  91)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  91)														if ((this3 == 0)) {
HXLINE(  91)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float m3;
HXDLIN(  91)														int this4 = (maskPixel & 255);
HXDLIN(  91)														if ((this4 == 0)) {
HXLINE(  91)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  91)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  91)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  91)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  91)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  91)												if ((col != 0)) {
HXLINE(  91)													int x = (dx - rectLeft);
HXDLIN(  91)													int y = (dy - rectTop);
HXDLIN(  91)													int this1 = col;
HXDLIN(  91)													int c = this1;
HXDLIN(  91)													bool _hx_tmp;
HXDLIN(  91)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  91)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE(  91)														_hx_tmp = false;
            													}
HXDLIN(  91)													if (_hx_tmp) {
HXLINE(  91)														int location;
HXDLIN(  91)														if (undoImage1->useVirtualPos) {
HXLINE(  91)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  91)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  91)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  91)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)														int this3 = this2;
HXDLIN(  91)														int this4;
HXDLIN(  91)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  91)															this4 = this3;
            														}
HXDLIN(  91)														Float a1;
HXDLIN(  91)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  91)														if ((this5 == 0)) {
HXLINE(  91)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float r1;
HXDLIN(  91)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  91)														if ((this6 == 0)) {
HXLINE(  91)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float g1;
HXDLIN(  91)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  91)														if ((this7 == 0)) {
HXLINE(  91)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float b1;
HXDLIN(  91)														int this8 = (this4 & 255);
HXDLIN(  91)														if ((this8 == 0)) {
HXLINE(  91)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float a2;
HXDLIN(  91)														int this9 = ((col >> 24) & 255);
HXDLIN(  91)														if ((this9 == 0)) {
HXLINE(  91)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float r2;
HXDLIN(  91)														int this10 = ((col >> 16) & 255);
HXDLIN(  91)														if ((this10 == 0)) {
HXLINE(  91)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float g2;
HXDLIN(  91)														int this11 = ((col >> 8) & 255);
HXDLIN(  91)														if ((this11 == 0)) {
HXLINE(  91)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float b2;
HXDLIN(  91)														int this12 = (col & 255);
HXDLIN(  91)														if ((this12 == 0)) {
HXLINE(  91)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  91)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  91)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)														{
HXLINE(  91)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  91)															int value;
HXDLIN(  91)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  91)																value = blended;
            															}
HXDLIN(  91)															bool _hx_tmp;
HXDLIN(  91)															if ((location >= 0)) {
HXLINE(  91)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  91)																_hx_tmp = false;
            															}
HXDLIN(  91)															if (_hx_tmp) {
HXLINE(  91)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  91)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  91)														int index;
HXDLIN(  91)														if (undoImage1->useVirtualPos) {
HXLINE(  91)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  91)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  91)														int value;
HXDLIN(  91)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  91)															value = c;
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if ((index >= 0)) {
HXLINE(  91)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  91)													if (forceClear) {
HXLINE(  91)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  91)														int x = (dx - rectLeft);
HXDLIN(  91)														int y = (dy - rectTop);
HXDLIN(  91)														int index;
HXDLIN(  91)														if (undoImage1->useVirtualPos) {
HXLINE(  91)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  91)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if ((index >= 0)) {
HXLINE(  91)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  91)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  91)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  91)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  91)						{
HXLINE(  91)							int _g_min1 = xIter31->start;
HXDLIN(  91)							int _g_max1 = xIter31->max;
HXDLIN(  91)							while((_g_min1 < _g_max1)){
HXLINE(  91)								_g_min1 = (_g_min1 + 1);
HXDLIN(  91)								int px = (_g_min1 - 1);
HXDLIN(  91)								Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  91)								{
HXLINE(  91)									int _g_min = yIter31->start;
HXDLIN(  91)									int _g_max = yIter31->max;
HXDLIN(  91)									while((_g_min < _g_max)){
HXLINE(  91)										_g_min = (_g_min + 1);
HXDLIN(  91)										int py = (_g_min - 1);
HXDLIN(  91)										Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  91)										Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  91)										Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  91)										Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  91)										Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  91)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  91)										bool _hx_tmp;
HXDLIN(  91)										bool _hx_tmp1;
HXDLIN(  91)										if ((ratioA >= 0)) {
HXLINE(  91)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  91)											_hx_tmp1 = false;
            										}
HXDLIN(  91)										if (_hx_tmp1) {
HXLINE(  91)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  91)											_hx_tmp = false;
            										}
HXDLIN(  91)										if (_hx_tmp) {
HXLINE(  91)											int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  91)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  91)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  91)											int this2 = i;
HXDLIN(  91)											int a = this2;
HXDLIN(  91)											int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  91)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  91)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  91)											int this3 = i1;
HXDLIN(  91)											int r = this3;
HXDLIN(  91)											int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  91)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  91)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  91)											int this4 = i2;
HXDLIN(  91)											int g = this4;
HXDLIN(  91)											int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  91)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  91)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  91)											int this5 = i3;
HXDLIN(  91)											int b = this5;
HXDLIN(  91)											{
HXLINE(  91)												int location;
HXDLIN(  91)												if (this1->useVirtualPos) {
HXLINE(  91)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            												}
            												else {
HXLINE(  91)													location = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            												}
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												if (this1->transparent) {
HXLINE(  91)													_hx_tmp = (a < 254);
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  91)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  91)													int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  91)													int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)													int this4 = this3;
HXDLIN(  91)													int old;
HXDLIN(  91)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)														old = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            													}
            													else {
HXLINE(  91)														old = this4;
            													}
HXDLIN(  91)													int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)													Float a1;
HXDLIN(  91)													int this5 = ((old >> 24) & 255);
HXDLIN(  91)													if ((this5 == 0)) {
HXLINE(  91)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float r1;
HXDLIN(  91)													int this6 = ((old >> 16) & 255);
HXDLIN(  91)													if ((this6 == 0)) {
HXLINE(  91)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float g1;
HXDLIN(  91)													int this7 = ((old >> 8) & 255);
HXDLIN(  91)													if ((this7 == 0)) {
HXLINE(  91)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float b1;
HXDLIN(  91)													int this8 = (old & 255);
HXDLIN(  91)													if ((this8 == 0)) {
HXLINE(  91)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float a2;
HXDLIN(  91)													int this9 = ((rhs >> 24) & 255);
HXDLIN(  91)													if ((this9 == 0)) {
HXLINE(  91)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float r2;
HXDLIN(  91)													int this10 = ((rhs >> 16) & 255);
HXDLIN(  91)													if ((this10 == 0)) {
HXLINE(  91)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float g2;
HXDLIN(  91)													int this11 = ((rhs >> 8) & 255);
HXDLIN(  91)													if ((this11 == 0)) {
HXLINE(  91)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float b2;
HXDLIN(  91)													int this12 = (rhs & 255);
HXDLIN(  91)													if ((this12 == 0)) {
HXLINE(  91)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  91)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  91)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)													int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  91)													{
HXLINE(  91)														::haxe::io::ArrayBufferViewImpl this13 = this1->image;
HXDLIN(  91)														int value;
HXDLIN(  91)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  91)															value = blended;
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if ((location >= 0)) {
HXLINE(  91)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  91)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  91)													int value;
HXDLIN(  91)													if (this1->isLittle) {
HXLINE(  91)														value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  91)														value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  91)													bool _hx_tmp;
HXDLIN(  91)													if ((location >= 0)) {
HXLINE(  91)														_hx_tmp = (location < (this2->byteLength >> 2));
            													}
            													else {
HXLINE(  91)														_hx_tmp = false;
            													}
HXDLIN(  91)													if (_hx_tmp) {
HXLINE(  91)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  91)														int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  91)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  91)						if ((hasHit == false)) {
HXLINE(  91)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  91)							if (hasUndo1) {
HXLINE(  91)								v->undoImage = undoImage1;
HXDLIN(  91)								v->undoX = xIter31->start;
HXDLIN(  91)								v->undoY = yIter31->start;
            							}
            						}
            					}
HXDLIN(  91)					::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            				}
            			}
            		}
HXLINE(  99)		this->toggleDraw = !(this->toggleDraw);
HXLINE( 100)		this->x0 = x2;
HXLINE( 101)		this->y0 = y2;
            	}


HX_DEFINE_DYNAMIC_FUNC2(PathElementThickGradient_obj,lineSegmentTo,(void))

void PathElementThickGradient_obj::lineTo(Float x2,Float y2){
            	HX_GC_STACKFRAME(&_hx_pos_c07cc9dd160e3b1d_104_lineTo)
HXLINE( 105)		 ::Dynamic oldInfo = this->info;
HXLINE( 106)		::pixelimage::ImageStruct this1 = this->temp;
HXDLIN( 106)		Float px = ((this->x0 * this->scaleX) + this->translateX);
HXDLIN( 106)		Float py = ((this->y0 * this->scaleY) + this->translateY);
HXDLIN( 106)		int colorA = this->strokeTopColor;
HXDLIN( 106)		int colorB = this->strokeTopColor;
HXDLIN( 106)		int colorC = this->strokeBottomColor;
HXDLIN( 106)		int colorD = this->strokeBottomColor;
HXDLIN( 106)		Float o = (((y2 * this->scaleY) + this->translateY) - py);
HXDLIN( 106)		Float a = (((x2 * this->scaleX) + this->translateX) - px);
HXDLIN( 106)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 106)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 106)		 ::Dynamic debugCorners = false;
HXDLIN( 106)		if (::hx::IsNull( debugCorners )) {
HXLINE( 910)			debugCorners = false;
            		}
HXLINE( 106)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 106)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 106)		Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN( 106)		Float dx = ((Float)0.1);
HXDLIN( 106)		Float dy = radius;
HXDLIN( 106)		Float cx = h;
HXDLIN( 106)		Float cy = radius;
HXDLIN( 106)		Float bx = h;
HXDLIN( 106)		Float by = -(radius);
HXDLIN( 106)		Float ax = ((Float)0.1);
HXDLIN( 106)		Float ay = -(radius);
HXDLIN( 106)		Float temp = ((Float)0.);
HXLINE( 474)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 475)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 476)		ax = temp;
HXLINE( 478)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 479)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 480)		bx = temp;
HXLINE( 482)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 483)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 484)		cx = temp;
HXLINE( 486)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 487)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 488)		dx = temp;
HXLINE( 106)		if (( (bool)(debugCorners) )) {
HXLINE( 106)			{
HXLINE( 106)				Float x = (ax - ((Float)6.));
HXDLIN( 106)				Float y = (ay - ((Float)6.));
HXDLIN( 106)				int p = ::Std_obj::_hx_int(x);
HXDLIN( 106)				int xx = p;
HXDLIN( 106)				int q = ::Std_obj::_hx_int(y);
HXDLIN( 106)				int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN( 106)				int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN( 106)				while(true){
HXLINE( 106)					{
HXLINE( 106)						p = (p + 1);
HXDLIN( 106)						int x = (p - 1);
HXDLIN( 106)						int this2 = colorA;
HXDLIN( 106)						int c = this2;
HXDLIN( 106)						bool _hx_tmp;
HXDLIN( 106)						if ((((c >> 24) & 255) < 254)) {
HXLINE( 106)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE( 106)							_hx_tmp = false;
            						}
HXDLIN( 106)						if (_hx_tmp) {
HXLINE( 106)							int location;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            							}
HXDLIN( 106)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 106)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)							int this4 = this3;
HXDLIN( 106)							int this5;
HXDLIN( 106)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE( 106)								this5 = this4;
            							}
HXDLIN( 106)							Float a1;
HXDLIN( 106)							int this6 = ((this5 >> 24) & 255);
HXDLIN( 106)							if ((this6 == 0)) {
HXLINE( 106)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float r1;
HXDLIN( 106)							int this7 = ((this5 >> 16) & 255);
HXDLIN( 106)							if ((this7 == 0)) {
HXLINE( 106)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float g1;
HXDLIN( 106)							int this8 = ((this5 >> 8) & 255);
HXDLIN( 106)							if ((this8 == 0)) {
HXLINE( 106)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float b1;
HXDLIN( 106)							int this9 = (this5 & 255);
HXDLIN( 106)							if ((this9 == 0)) {
HXLINE( 106)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float a2;
HXDLIN( 106)							int this10 = ((colorA >> 24) & 255);
HXDLIN( 106)							if ((this10 == 0)) {
HXLINE( 106)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float r2;
HXDLIN( 106)							int this11 = ((colorA >> 16) & 255);
HXDLIN( 106)							if ((this11 == 0)) {
HXLINE( 106)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float g2;
HXDLIN( 106)							int this12 = ((colorA >> 8) & 255);
HXDLIN( 106)							if ((this12 == 0)) {
HXLINE( 106)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float b2;
HXDLIN( 106)							int this13 = (colorA & 255);
HXDLIN( 106)							if ((this13 == 0)) {
HXLINE( 106)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 106)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 106)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 106)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 106)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 106)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 106)							{
HXLINE( 106)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN( 106)								int value;
HXDLIN( 106)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 106)									value = blended;
            								}
HXDLIN( 106)								bool _hx_tmp;
HXDLIN( 106)								if ((location >= 0)) {
HXLINE( 106)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE( 106)									_hx_tmp = false;
            								}
HXDLIN( 106)								if (_hx_tmp) {
HXLINE( 106)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN( 106)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN( 106)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE( 106)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)							int index;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            							}
HXDLIN( 106)							int value;
HXDLIN( 106)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 106)								value = c;
            							}
HXDLIN( 106)							bool _hx_tmp;
HXDLIN( 106)							if ((index >= 0)) {
HXLINE( 106)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE( 106)								_hx_tmp = false;
            							}
HXDLIN( 106)							if (_hx_tmp) {
HXLINE( 106)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 106)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN( 106)					if ((p > maxX)) {
HXLINE( 247)						p = xx;
HXLINE( 106)						q = (q + 1);
            					}
HXDLIN( 106)					if ((q > maxY)) {
HXLINE( 106)						goto _hx_goto_27;
            					}
            				}
            				_hx_goto_27:;
            			}
HXDLIN( 106)			{
HXLINE( 106)				Float x1 = (bx - ((Float)6.));
HXDLIN( 106)				Float y1 = (by - ((Float)6.));
HXDLIN( 106)				int p1 = ::Std_obj::_hx_int(x1);
HXDLIN( 106)				int xx1 = p1;
HXDLIN( 106)				int q1 = ::Std_obj::_hx_int(y1);
HXDLIN( 106)				int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN( 106)				int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN( 106)				while(true){
HXLINE( 106)					{
HXLINE( 106)						p1 = (p1 + 1);
HXDLIN( 106)						int x = (p1 - 1);
HXDLIN( 106)						int this2 = colorB;
HXDLIN( 106)						int c = this2;
HXDLIN( 106)						bool _hx_tmp;
HXDLIN( 106)						if ((((c >> 24) & 255) < 254)) {
HXLINE( 106)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE( 106)							_hx_tmp = false;
            						}
HXDLIN( 106)						if (_hx_tmp) {
HXLINE( 106)							int location;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								location = ::Std_obj::_hx_int(( (Float)(((q1 * this1->width) + x)) ));
            							}
HXDLIN( 106)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 106)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)							int this4 = this3;
HXDLIN( 106)							int this5;
HXDLIN( 106)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE( 106)								this5 = this4;
            							}
HXDLIN( 106)							Float a1;
HXDLIN( 106)							int this6 = ((this5 >> 24) & 255);
HXDLIN( 106)							if ((this6 == 0)) {
HXLINE( 106)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float r1;
HXDLIN( 106)							int this7 = ((this5 >> 16) & 255);
HXDLIN( 106)							if ((this7 == 0)) {
HXLINE( 106)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float g1;
HXDLIN( 106)							int this8 = ((this5 >> 8) & 255);
HXDLIN( 106)							if ((this8 == 0)) {
HXLINE( 106)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float b1;
HXDLIN( 106)							int this9 = (this5 & 255);
HXDLIN( 106)							if ((this9 == 0)) {
HXLINE( 106)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float a2;
HXDLIN( 106)							int this10 = ((colorB >> 24) & 255);
HXDLIN( 106)							if ((this10 == 0)) {
HXLINE( 106)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float r2;
HXDLIN( 106)							int this11 = ((colorB >> 16) & 255);
HXDLIN( 106)							if ((this11 == 0)) {
HXLINE( 106)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float g2;
HXDLIN( 106)							int this12 = ((colorB >> 8) & 255);
HXDLIN( 106)							if ((this12 == 0)) {
HXLINE( 106)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float b2;
HXDLIN( 106)							int this13 = (colorB & 255);
HXDLIN( 106)							if ((this13 == 0)) {
HXLINE( 106)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 106)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 106)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 106)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 106)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 106)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 106)							{
HXLINE( 106)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN( 106)								int value;
HXDLIN( 106)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 106)									value = blended;
            								}
HXDLIN( 106)								bool _hx_tmp;
HXDLIN( 106)								if ((location >= 0)) {
HXLINE( 106)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE( 106)									_hx_tmp = false;
            								}
HXDLIN( 106)								if (_hx_tmp) {
HXLINE( 106)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN( 106)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN( 106)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE( 106)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)							int index;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								index = ::Std_obj::_hx_int(( (Float)(((q1 * this1->width) + x)) ));
            							}
HXDLIN( 106)							int value;
HXDLIN( 106)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 106)								value = c;
            							}
HXDLIN( 106)							bool _hx_tmp;
HXDLIN( 106)							if ((index >= 0)) {
HXLINE( 106)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE( 106)								_hx_tmp = false;
            							}
HXDLIN( 106)							if (_hx_tmp) {
HXLINE( 106)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 106)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN( 106)					if ((p1 > maxX1)) {
HXLINE( 247)						p1 = xx1;
HXLINE( 106)						q1 = (q1 + 1);
            					}
HXDLIN( 106)					if ((q1 > maxY1)) {
HXLINE( 106)						goto _hx_goto_28;
            					}
            				}
            				_hx_goto_28:;
            			}
HXDLIN( 106)			{
HXLINE( 106)				Float x2 = (cx - ((Float)6.));
HXDLIN( 106)				Float y2 = (cy - ((Float)6.));
HXDLIN( 106)				int p2 = ::Std_obj::_hx_int(x2);
HXDLIN( 106)				int xx2 = p2;
HXDLIN( 106)				int q2 = ::Std_obj::_hx_int(y2);
HXDLIN( 106)				int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN( 106)				int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN( 106)				while(true){
HXLINE( 106)					{
HXLINE( 106)						p2 = (p2 + 1);
HXDLIN( 106)						int x = (p2 - 1);
HXDLIN( 106)						int this2 = colorC;
HXDLIN( 106)						int c = this2;
HXDLIN( 106)						bool _hx_tmp;
HXDLIN( 106)						if ((((c >> 24) & 255) < 254)) {
HXLINE( 106)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE( 106)							_hx_tmp = false;
            						}
HXDLIN( 106)						if (_hx_tmp) {
HXLINE( 106)							int location;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								location = ::Std_obj::_hx_int(( (Float)(((q2 * this1->width) + x)) ));
            							}
HXDLIN( 106)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 106)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)							int this4 = this3;
HXDLIN( 106)							int this5;
HXDLIN( 106)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE( 106)								this5 = this4;
            							}
HXDLIN( 106)							Float a1;
HXDLIN( 106)							int this6 = ((this5 >> 24) & 255);
HXDLIN( 106)							if ((this6 == 0)) {
HXLINE( 106)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float r1;
HXDLIN( 106)							int this7 = ((this5 >> 16) & 255);
HXDLIN( 106)							if ((this7 == 0)) {
HXLINE( 106)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float g1;
HXDLIN( 106)							int this8 = ((this5 >> 8) & 255);
HXDLIN( 106)							if ((this8 == 0)) {
HXLINE( 106)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float b1;
HXDLIN( 106)							int this9 = (this5 & 255);
HXDLIN( 106)							if ((this9 == 0)) {
HXLINE( 106)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float a2;
HXDLIN( 106)							int this10 = ((colorC >> 24) & 255);
HXDLIN( 106)							if ((this10 == 0)) {
HXLINE( 106)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float r2;
HXDLIN( 106)							int this11 = ((colorC >> 16) & 255);
HXDLIN( 106)							if ((this11 == 0)) {
HXLINE( 106)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float g2;
HXDLIN( 106)							int this12 = ((colorC >> 8) & 255);
HXDLIN( 106)							if ((this12 == 0)) {
HXLINE( 106)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float b2;
HXDLIN( 106)							int this13 = (colorC & 255);
HXDLIN( 106)							if ((this13 == 0)) {
HXLINE( 106)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 106)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 106)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 106)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 106)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 106)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 106)							{
HXLINE( 106)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN( 106)								int value;
HXDLIN( 106)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 106)									value = blended;
            								}
HXDLIN( 106)								bool _hx_tmp;
HXDLIN( 106)								if ((location >= 0)) {
HXLINE( 106)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE( 106)									_hx_tmp = false;
            								}
HXDLIN( 106)								if (_hx_tmp) {
HXLINE( 106)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN( 106)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN( 106)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE( 106)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)							int index;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								index = ::Std_obj::_hx_int(( (Float)(((q2 * this1->width) + x)) ));
            							}
HXDLIN( 106)							int value;
HXDLIN( 106)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 106)								value = c;
            							}
HXDLIN( 106)							bool _hx_tmp;
HXDLIN( 106)							if ((index >= 0)) {
HXLINE( 106)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE( 106)								_hx_tmp = false;
            							}
HXDLIN( 106)							if (_hx_tmp) {
HXLINE( 106)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 106)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN( 106)					if ((p2 > maxX2)) {
HXLINE( 247)						p2 = xx2;
HXLINE( 106)						q2 = (q2 + 1);
            					}
HXDLIN( 106)					if ((q2 > maxY2)) {
HXLINE( 106)						goto _hx_goto_29;
            					}
            				}
            				_hx_goto_29:;
            			}
HXDLIN( 106)			{
HXLINE( 106)				Float x3 = (dx - ((Float)6.));
HXDLIN( 106)				Float y3 = (dy - ((Float)6.));
HXDLIN( 106)				int p3 = ::Std_obj::_hx_int(x3);
HXDLIN( 106)				int xx3 = p3;
HXDLIN( 106)				int q3 = ::Std_obj::_hx_int(y3);
HXDLIN( 106)				int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN( 106)				int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN( 106)				while(true){
HXLINE( 106)					{
HXLINE( 106)						p3 = (p3 + 1);
HXDLIN( 106)						int x = (p3 - 1);
HXDLIN( 106)						int this2 = colorD;
HXDLIN( 106)						int c = this2;
HXDLIN( 106)						bool _hx_tmp;
HXDLIN( 106)						if ((((c >> 24) & 255) < 254)) {
HXLINE( 106)							_hx_tmp = this1->transparent;
            						}
            						else {
HXLINE( 106)							_hx_tmp = false;
            						}
HXDLIN( 106)						if (_hx_tmp) {
HXLINE( 106)							int location;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								location = ::Std_obj::_hx_int(( (Float)(((q3 * this1->width) + x)) ));
            							}
HXDLIN( 106)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)							int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 106)							int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)							int this4 = this3;
HXDLIN( 106)							int this5;
HXDLIN( 106)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)								this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            							}
            							else {
HXLINE( 106)								this5 = this4;
            							}
HXDLIN( 106)							Float a1;
HXDLIN( 106)							int this6 = ((this5 >> 24) & 255);
HXDLIN( 106)							if ((this6 == 0)) {
HXLINE( 106)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float r1;
HXDLIN( 106)							int this7 = ((this5 >> 16) & 255);
HXDLIN( 106)							if ((this7 == 0)) {
HXLINE( 106)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float g1;
HXDLIN( 106)							int this8 = ((this5 >> 8) & 255);
HXDLIN( 106)							if ((this8 == 0)) {
HXLINE( 106)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float b1;
HXDLIN( 106)							int this9 = (this5 & 255);
HXDLIN( 106)							if ((this9 == 0)) {
HXLINE( 106)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float a2;
HXDLIN( 106)							int this10 = ((colorD >> 24) & 255);
HXDLIN( 106)							if ((this10 == 0)) {
HXLINE( 106)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float r2;
HXDLIN( 106)							int this11 = ((colorD >> 16) & 255);
HXDLIN( 106)							if ((this11 == 0)) {
HXLINE( 106)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float g2;
HXDLIN( 106)							int this12 = ((colorD >> 8) & 255);
HXDLIN( 106)							if ((this12 == 0)) {
HXLINE( 106)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float b2;
HXDLIN( 106)							int this13 = (colorD & 255);
HXDLIN( 106)							if ((this13 == 0)) {
HXLINE( 106)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 106)								b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 106)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 106)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 106)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 106)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 106)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 106)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 106)							{
HXLINE( 106)								::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN( 106)								int value;
HXDLIN( 106)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 106)									value = blended;
            								}
HXDLIN( 106)								bool _hx_tmp;
HXDLIN( 106)								if ((location >= 0)) {
HXLINE( 106)									_hx_tmp = (location < (this14->byteLength >> 2));
            								}
            								else {
HXLINE( 106)									_hx_tmp = false;
            								}
HXDLIN( 106)								if (_hx_tmp) {
HXLINE( 106)									::haxe::io::Bytes _this = this14->bytes;
HXDLIN( 106)									int pos = ((location << 2) + this14->byteOffset);
HXDLIN( 106)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE( 106)							::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)							int index;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								index = ::Std_obj::_hx_int(( (Float)(((q3 * this1->width) + x)) ));
            							}
HXDLIN( 106)							int value;
HXDLIN( 106)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 106)								value = c;
            							}
HXDLIN( 106)							bool _hx_tmp;
HXDLIN( 106)							if ((index >= 0)) {
HXLINE( 106)								_hx_tmp = (index < (this2->byteLength >> 2));
            							}
            							else {
HXLINE( 106)								_hx_tmp = false;
            							}
HXDLIN( 106)							if (_hx_tmp) {
HXLINE( 106)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 106)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN( 106)					if ((p3 > maxX3)) {
HXLINE( 247)						p3 = xx3;
HXLINE( 106)						q3 = (q3 + 1);
            					}
HXDLIN( 106)					if ((q3 > maxY3)) {
HXLINE( 106)						goto _hx_goto_30;
            					}
            				}
            				_hx_goto_30:;
            			}
            		}
HXDLIN( 106)		bool hasUndo = false;
HXDLIN( 106)		int aA = ((colorB >> 24) & 255);
HXDLIN( 106)		int rA = ((colorB >> 16) & 255);
HXDLIN( 106)		int gA = ((colorB >> 8) & 255);
HXDLIN( 106)		int bA = (colorB & 255);
HXDLIN( 106)		int aB = ((colorA >> 24) & 255);
HXDLIN( 106)		int rB = ((colorA >> 16) & 255);
HXDLIN( 106)		int gB = ((colorA >> 8) & 255);
HXDLIN( 106)		int bB = (colorA & 255);
HXDLIN( 106)		int aC = ((colorD >> 24) & 255);
HXDLIN( 106)		int rC = ((colorD >> 16) & 255);
HXDLIN( 106)		int gC = ((colorD >> 8) & 255);
HXDLIN( 106)		int bC = (colorD & 255);
HXDLIN( 106)		Float bcx = (bx - dx);
HXDLIN( 106)		Float bcy = (by - dy);
HXDLIN( 106)		Float acx = (ax - dx);
HXDLIN( 106)		Float acy = (ay - dy);
HXDLIN( 106)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 106)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 106)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 106)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 106)		::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 106)		if ((ax > bx)) {
HXLINE( 106)			if ((ax > dx)) {
HXLINE( 106)				int min;
HXDLIN( 106)				if ((bx > dx)) {
HXLINE( 106)					min = ::Math_obj::floor(dx);
            				}
            				else {
HXLINE( 106)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 106)				int ii_min = min;
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				xIter3 = this1;
            			}
            			else {
HXLINE( 106)				int ii_min = ::Math_obj::floor(bx);
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				xIter3 = this1;
            			}
            		}
            		else {
HXLINE( 106)			if ((bx > dx)) {
HXLINE( 106)				int min;
HXDLIN( 106)				if ((ax > dx)) {
HXLINE( 106)					min = ::Math_obj::floor(dx);
            				}
            				else {
HXLINE( 106)					min = ::Math_obj::ceil(ax);
            				}
HXDLIN( 106)				int ii_min = min;
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				xIter3 = this1;
            			}
            			else {
HXLINE( 106)				int ii_min = ::Math_obj::floor(ax);
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				xIter3 = this1;
            			}
            		}
HXDLIN( 106)		::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 106)		if ((ay > by)) {
HXLINE( 106)			if ((ay > dy)) {
HXLINE( 106)				int min;
HXDLIN( 106)				if ((by > dy)) {
HXLINE( 106)					min = ::Math_obj::floor(dy);
            				}
            				else {
HXLINE( 106)					min = ::Math_obj::floor(by);
            				}
HXDLIN( 106)				int ii_min = min;
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(ay);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				yIter3 = this1;
            			}
            			else {
HXLINE( 106)				int ii_min = ::Math_obj::floor(by);
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(dy);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				yIter3 = this1;
            			}
            		}
            		else {
HXLINE( 106)			if ((by > dy)) {
HXLINE( 106)				int min;
HXDLIN( 106)				if ((ay > dy)) {
HXLINE( 106)					min = ::Math_obj::floor(dy);
            				}
            				else {
HXLINE( 106)					min = ::Math_obj::ceil(ay);
            				}
HXDLIN( 106)				int ii_min = min;
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(by);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				yIter3 = this1;
            			}
            			else {
HXLINE( 106)				int ii_min = ::Math_obj::floor(ay);
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(dy);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				yIter3 = this1;
            			}
            		}
HXDLIN( 106)		::pixelimage::ImageStruct undoImage = null();
HXDLIN( 106)		if (hasUndo) {
HXLINE( 106)			int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 106)			int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 106)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 106)			::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 106)			::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN( 106)			::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN( 106)			undoImage = this4;
HXDLIN( 106)			{
HXLINE( 106)				int rectLeft = xIter3->start;
HXDLIN( 106)				int rectTop = yIter3->start;
HXDLIN( 106)				int rectRight = xIter3->max;
HXDLIN( 106)				bool forceClear = false;
HXDLIN( 106)				{
HXLINE( 106)					int _g = rectTop;
HXDLIN( 106)					int _g1 = yIter3->max;
HXDLIN( 106)					while((_g < _g1)){
HXLINE( 106)						_g = (_g + 1);
HXDLIN( 106)						int dy = (_g - 1);
HXDLIN( 106)						{
HXLINE( 106)							int _g1 = rectLeft;
HXDLIN( 106)							int _g2 = rectRight;
HXDLIN( 106)							while((_g1 < _g2)){
HXLINE( 106)								_g1 = (_g1 + 1);
HXDLIN( 106)								int dx = (_g1 - 1);
HXDLIN( 106)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)								int index;
HXDLIN( 106)								if (this1->useVirtualPos) {
HXLINE( 106)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE( 106)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN( 106)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 106)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)								int col;
HXDLIN( 106)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 106)									col = c;
            								}
HXDLIN( 106)								bool _hx_tmp;
HXDLIN( 106)								if (this1->useMask) {
HXLINE( 106)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE( 106)									_hx_tmp = false;
            								}
HXDLIN( 106)								if (_hx_tmp) {
HXLINE( 106)									::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN( 106)									::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN( 106)									int index;
HXDLIN( 106)									if (this2->useVirtualPos) {
HXLINE( 106)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            									}
            									else {
HXLINE( 106)										index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            									}
HXDLIN( 106)									::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 106)									int pos = ((index << 2) + this3->byteOffset);
HXDLIN( 106)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)									int v;
HXDLIN( 106)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)										v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 106)										v = c;
            									}
HXDLIN( 106)									int this4 = v;
HXDLIN( 106)									int maskPixel = this4;
HXDLIN( 106)									int this5 = col;
HXDLIN( 106)									int this6 = this5;
HXDLIN( 106)									if ((maskPixel == 0)) {
HXLINE( 106)										int this1 = this6;
HXDLIN( 106)										col = this1;
            									}
            									else {
HXLINE( 106)										Float m0;
HXDLIN( 106)										int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 106)										if ((this1 == 0)) {
HXLINE( 106)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float m1;
HXDLIN( 106)										int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 106)										if ((this2 == 0)) {
HXLINE( 106)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float m2;
HXDLIN( 106)										int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 106)										if ((this3 == 0)) {
HXLINE( 106)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float m3;
HXDLIN( 106)										int this4 = (maskPixel & 255);
HXDLIN( 106)										if ((this4 == 0)) {
HXLINE( 106)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 106)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 106)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 106)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 106)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 106)								if ((col != 0)) {
HXLINE( 106)									int x = (dx - rectLeft);
HXDLIN( 106)									int y = (dy - rectTop);
HXDLIN( 106)									int this1 = col;
HXDLIN( 106)									int c = this1;
HXDLIN( 106)									bool _hx_tmp;
HXDLIN( 106)									if ((((c >> 24) & 255) < 254)) {
HXLINE( 106)										_hx_tmp = undoImage->transparent;
            									}
            									else {
HXLINE( 106)										_hx_tmp = false;
            									}
HXDLIN( 106)									if (_hx_tmp) {
HXLINE( 106)										int location;
HXDLIN( 106)										if (undoImage->useVirtualPos) {
HXLINE( 106)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            										}
            										else {
HXLINE( 106)											location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            										}
HXDLIN( 106)										::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 106)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 106)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 106)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)										int this3 = this2;
HXDLIN( 106)										int this4;
HXDLIN( 106)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE( 106)											this4 = this3;
            										}
HXDLIN( 106)										Float a1;
HXDLIN( 106)										int this5 = ((this4 >> 24) & 255);
HXDLIN( 106)										if ((this5 == 0)) {
HXLINE( 106)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float r1;
HXDLIN( 106)										int this6 = ((this4 >> 16) & 255);
HXDLIN( 106)										if ((this6 == 0)) {
HXLINE( 106)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float g1;
HXDLIN( 106)										int this7 = ((this4 >> 8) & 255);
HXDLIN( 106)										if ((this7 == 0)) {
HXLINE( 106)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float b1;
HXDLIN( 106)										int this8 = (this4 & 255);
HXDLIN( 106)										if ((this8 == 0)) {
HXLINE( 106)											b1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float a2;
HXDLIN( 106)										int this9 = ((col >> 24) & 255);
HXDLIN( 106)										if ((this9 == 0)) {
HXLINE( 106)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float r2;
HXDLIN( 106)										int this10 = ((col >> 16) & 255);
HXDLIN( 106)										if ((this10 == 0)) {
HXLINE( 106)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float g2;
HXDLIN( 106)										int this11 = ((col >> 8) & 255);
HXDLIN( 106)										if ((this11 == 0)) {
HXLINE( 106)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float b2;
HXDLIN( 106)										int this12 = (col & 255);
HXDLIN( 106)										if ((this12 == 0)) {
HXLINE( 106)											b2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 106)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 106)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 106)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 106)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 106)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 106)										{
HXLINE( 106)											::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 106)											int value;
HXDLIN( 106)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 106)												value = blended;
            											}
HXDLIN( 106)											bool _hx_tmp;
HXDLIN( 106)											if ((location >= 0)) {
HXLINE( 106)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE( 106)												_hx_tmp = false;
            											}
HXDLIN( 106)											if (_hx_tmp) {
HXLINE( 106)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 106)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 106)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE( 106)										::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 106)										int index;
HXDLIN( 106)										if (undoImage->useVirtualPos) {
HXLINE( 106)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            										}
            										else {
HXLINE( 106)											index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            										}
HXDLIN( 106)										int value;
HXDLIN( 106)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 106)											value = c;
            										}
HXDLIN( 106)										bool _hx_tmp;
HXDLIN( 106)										if ((index >= 0)) {
HXLINE( 106)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE( 106)											_hx_tmp = false;
            										}
HXDLIN( 106)										if (_hx_tmp) {
HXLINE( 106)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 106)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 106)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 106)									if (forceClear) {
HXLINE( 106)										::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 106)										int x = (dx - rectLeft);
HXDLIN( 106)										int y = (dy - rectTop);
HXDLIN( 106)										int index;
HXDLIN( 106)										if (undoImage->useVirtualPos) {
HXLINE( 106)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            										}
            										else {
HXLINE( 106)											index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            										}
HXDLIN( 106)										bool _hx_tmp;
HXDLIN( 106)										if ((index >= 0)) {
HXLINE( 106)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE( 106)											_hx_tmp = false;
            										}
HXDLIN( 106)										if (_hx_tmp) {
HXLINE( 106)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 106)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 106)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 106)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 106)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 106)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 106)		int _g_min = xIter3->start;
HXDLIN( 106)		int _g_max = xIter3->max;
HXDLIN( 106)		while((_g_min < _g_max)){
HXLINE( 106)			_g_min = (_g_min + 1);
HXDLIN( 106)			int px = (_g_min - 1);
HXDLIN( 106)			Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 106)			{
HXLINE( 106)				int _g_min1 = yIter3->start;
HXDLIN( 106)				int _g_max = yIter3->max;
HXDLIN( 106)				while((_g_min1 < _g_max)){
HXLINE( 106)					_g_min1 = (_g_min1 + 1);
HXDLIN( 106)					int py = (_g_min1 - 1);
HXDLIN( 106)					Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 106)					Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 106)					Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 106)					Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 106)					Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 106)					Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 106)					bool _hx_tmp;
HXDLIN( 106)					bool _hx_tmp1;
HXDLIN( 106)					if ((ratioA >= 0)) {
HXLINE( 106)						_hx_tmp1 = (ratioB >= 0);
            					}
            					else {
HXLINE( 106)						_hx_tmp1 = false;
            					}
HXDLIN( 106)					if (_hx_tmp1) {
HXLINE( 106)						_hx_tmp = (ratioC >= 0);
            					}
            					else {
HXLINE( 106)						_hx_tmp = false;
            					}
HXDLIN( 106)					if (_hx_tmp) {
HXLINE( 106)						int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 106)						if ((i > 255)) {
HXLINE(  24)							i = 255;
            						}
HXLINE( 106)						if ((i < 0)) {
HXLINE(  25)							i = 0;
            						}
HXLINE( 106)						int this2 = i;
HXDLIN( 106)						int a = this2;
HXDLIN( 106)						int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 106)						if ((i1 > 255)) {
HXLINE(  24)							i1 = 255;
            						}
HXLINE( 106)						if ((i1 < 0)) {
HXLINE(  25)							i1 = 0;
            						}
HXLINE( 106)						int this3 = i1;
HXDLIN( 106)						int r = this3;
HXDLIN( 106)						int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 106)						if ((i2 > 255)) {
HXLINE(  24)							i2 = 255;
            						}
HXLINE( 106)						if ((i2 < 0)) {
HXLINE(  25)							i2 = 0;
            						}
HXLINE( 106)						int this4 = i2;
HXDLIN( 106)						int g = this4;
HXDLIN( 106)						int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 106)						if ((i3 > 255)) {
HXLINE(  24)							i3 = 255;
            						}
HXLINE( 106)						if ((i3 < 0)) {
HXLINE(  25)							i3 = 0;
            						}
HXLINE( 106)						int this5 = i3;
HXDLIN( 106)						int b = this5;
HXDLIN( 106)						{
HXLINE( 106)							int location;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								location = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								location = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            							}
HXDLIN( 106)							bool _hx_tmp;
HXDLIN( 106)							if (this1->transparent) {
HXLINE( 106)								_hx_tmp = (a < 254);
            							}
            							else {
HXLINE( 106)								_hx_tmp = false;
            							}
HXDLIN( 106)							if (_hx_tmp) {
HXLINE( 106)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 106)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)								int this4 = this3;
HXDLIN( 106)								int old;
HXDLIN( 106)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									old = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE( 106)									old = this4;
            								}
HXDLIN( 106)								int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 106)								Float a1;
HXDLIN( 106)								int this5 = ((old >> 24) & 255);
HXDLIN( 106)								if ((this5 == 0)) {
HXLINE( 106)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float r1;
HXDLIN( 106)								int this6 = ((old >> 16) & 255);
HXDLIN( 106)								if ((this6 == 0)) {
HXLINE( 106)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float g1;
HXDLIN( 106)								int this7 = ((old >> 8) & 255);
HXDLIN( 106)								if ((this7 == 0)) {
HXLINE( 106)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float b1;
HXDLIN( 106)								int this8 = (old & 255);
HXDLIN( 106)								if ((this8 == 0)) {
HXLINE( 106)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float a2;
HXDLIN( 106)								int this9 = ((rhs >> 24) & 255);
HXDLIN( 106)								if ((this9 == 0)) {
HXLINE( 106)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float r2;
HXDLIN( 106)								int this10 = ((rhs >> 16) & 255);
HXDLIN( 106)								if ((this10 == 0)) {
HXLINE( 106)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float g2;
HXDLIN( 106)								int this11 = ((rhs >> 8) & 255);
HXDLIN( 106)								if ((this11 == 0)) {
HXLINE( 106)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float b2;
HXDLIN( 106)								int this12 = (rhs & 255);
HXDLIN( 106)								if ((this12 == 0)) {
HXLINE( 106)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 106)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 106)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 106)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 106)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 106)								int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 106)								{
HXLINE( 106)									::haxe::io::ArrayBufferViewImpl this13 = this1->image;
HXDLIN( 106)									int value;
HXDLIN( 106)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 106)										value = blended;
            									}
HXDLIN( 106)									bool _hx_tmp;
HXDLIN( 106)									if ((location >= 0)) {
HXLINE( 106)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE( 106)										_hx_tmp = false;
            									}
HXDLIN( 106)									if (_hx_tmp) {
HXLINE( 106)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 106)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 106)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE( 106)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)								int value;
HXDLIN( 106)								if (this1->isLittle) {
HXLINE( 106)									value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            								}
            								else {
HXLINE( 106)									value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            								}
HXDLIN( 106)								bool _hx_tmp;
HXDLIN( 106)								if ((location >= 0)) {
HXLINE( 106)									_hx_tmp = (location < (this2->byteLength >> 2));
            								}
            								else {
HXLINE( 106)									_hx_tmp = false;
            								}
HXDLIN( 106)								if (_hx_tmp) {
HXLINE( 106)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)									int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 106)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 106)		bool hasHit = false;
HXDLIN( 106)		bool hasUndo1 = false;
HXDLIN( 106)		int aA1 = ((colorC >> 24) & 255);
HXDLIN( 106)		int rA1 = ((colorC >> 16) & 255);
HXDLIN( 106)		int gA1 = ((colorC >> 8) & 255);
HXDLIN( 106)		int bA1 = (colorC & 255);
HXDLIN( 106)		int aB1 = ((colorB >> 24) & 255);
HXDLIN( 106)		int rB1 = ((colorB >> 16) & 255);
HXDLIN( 106)		int gB1 = ((colorB >> 8) & 255);
HXDLIN( 106)		int bB1 = (colorB & 255);
HXDLIN( 106)		int aC1 = ((colorD >> 24) & 255);
HXDLIN( 106)		int rC1 = ((colorD >> 16) & 255);
HXDLIN( 106)		int gC1 = ((colorD >> 8) & 255);
HXDLIN( 106)		int bC1 = (colorD & 255);
HXDLIN( 106)		Float bcx1 = (cx - dx);
HXDLIN( 106)		Float bcy1 = (cy - dy);
HXDLIN( 106)		Float acx1 = (bx - dx);
HXDLIN( 106)		Float acy1 = (by - dy);
HXDLIN( 106)		Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 106)		Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 106)		Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 106)		Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 106)		::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 106)		if ((bx > cx)) {
HXLINE( 106)			if ((bx > dx)) {
HXLINE( 106)				int min;
HXDLIN( 106)				if ((cx > dx)) {
HXLINE( 106)					min = ::Math_obj::floor(dx);
            				}
            				else {
HXLINE( 106)					min = ::Math_obj::floor(cx);
            				}
HXDLIN( 106)				int ii_min = min;
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				xIter31 = this1;
            			}
            			else {
HXLINE( 106)				int ii_min = ::Math_obj::floor(cx);
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				xIter31 = this1;
            			}
            		}
            		else {
HXLINE( 106)			if ((cx > dx)) {
HXLINE( 106)				int min;
HXDLIN( 106)				if ((bx > dx)) {
HXLINE( 106)					min = ::Math_obj::floor(dx);
            				}
            				else {
HXLINE( 106)					min = ::Math_obj::ceil(bx);
            				}
HXDLIN( 106)				int ii_min = min;
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				xIter31 = this1;
            			}
            			else {
HXLINE( 106)				int ii_min = ::Math_obj::floor(bx);
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				xIter31 = this1;
            			}
            		}
HXDLIN( 106)		::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 106)		if ((by > cy)) {
HXLINE( 106)			if ((by > dy)) {
HXLINE( 106)				int min;
HXDLIN( 106)				if ((cy > dy)) {
HXLINE( 106)					min = ::Math_obj::floor(dy);
            				}
            				else {
HXLINE( 106)					min = ::Math_obj::floor(cy);
            				}
HXDLIN( 106)				int ii_min = min;
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(by);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				yIter31 = this1;
            			}
            			else {
HXLINE( 106)				int ii_min = ::Math_obj::floor(cy);
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(dy);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				yIter31 = this1;
            			}
            		}
            		else {
HXLINE( 106)			if ((cy > dy)) {
HXLINE( 106)				int min;
HXDLIN( 106)				if ((by > dy)) {
HXLINE( 106)					min = ::Math_obj::floor(dy);
            				}
            				else {
HXLINE( 106)					min = ::Math_obj::ceil(by);
            				}
HXDLIN( 106)				int ii_min = min;
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(cy);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				yIter31 = this1;
            			}
            			else {
HXLINE( 106)				int ii_min = ::Math_obj::floor(by);
HXDLIN( 106)				int ii_max = ::Math_obj::ceil(dy);
HXDLIN( 106)				::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 106)				yIter31 = this1;
            			}
            		}
HXDLIN( 106)		::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 106)		if (hasUndo1) {
HXLINE( 106)			int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 106)			int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 106)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 106)			::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 106)			::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN( 106)			::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN( 106)			undoImage1 = this4;
HXDLIN( 106)			{
HXLINE( 106)				int rectLeft = xIter31->start;
HXDLIN( 106)				int rectTop = yIter31->start;
HXDLIN( 106)				int rectRight = xIter31->max;
HXDLIN( 106)				bool forceClear = false;
HXDLIN( 106)				{
HXLINE( 106)					int _g = rectTop;
HXDLIN( 106)					int _g1 = yIter31->max;
HXDLIN( 106)					while((_g < _g1)){
HXLINE( 106)						_g = (_g + 1);
HXDLIN( 106)						int dy = (_g - 1);
HXDLIN( 106)						{
HXLINE( 106)							int _g1 = rectLeft;
HXDLIN( 106)							int _g2 = rectRight;
HXDLIN( 106)							while((_g1 < _g2)){
HXLINE( 106)								_g1 = (_g1 + 1);
HXDLIN( 106)								int dx = (_g1 - 1);
HXDLIN( 106)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)								int index;
HXDLIN( 106)								if (this1->useVirtualPos) {
HXLINE( 106)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE( 106)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN( 106)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 106)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)								int col;
HXDLIN( 106)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 106)									col = c;
            								}
HXDLIN( 106)								bool _hx_tmp;
HXDLIN( 106)								if (this1->useMask) {
HXLINE( 106)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE( 106)									_hx_tmp = false;
            								}
HXDLIN( 106)								if (_hx_tmp) {
HXLINE( 106)									::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN( 106)									::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN( 106)									int index;
HXDLIN( 106)									if (this2->useVirtualPos) {
HXLINE( 106)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            									}
            									else {
HXLINE( 106)										index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            									}
HXDLIN( 106)									::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 106)									int pos = ((index << 2) + this3->byteOffset);
HXDLIN( 106)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)									int v;
HXDLIN( 106)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)										v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 106)										v = c;
            									}
HXDLIN( 106)									int this4 = v;
HXDLIN( 106)									int maskPixel = this4;
HXDLIN( 106)									int this5 = col;
HXDLIN( 106)									int this6 = this5;
HXDLIN( 106)									if ((maskPixel == 0)) {
HXLINE( 106)										int this1 = this6;
HXDLIN( 106)										col = this1;
            									}
            									else {
HXLINE( 106)										Float m0;
HXDLIN( 106)										int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 106)										if ((this1 == 0)) {
HXLINE( 106)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float m1;
HXDLIN( 106)										int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 106)										if ((this2 == 0)) {
HXLINE( 106)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float m2;
HXDLIN( 106)										int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 106)										if ((this3 == 0)) {
HXLINE( 106)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float m3;
HXDLIN( 106)										int this4 = (maskPixel & 255);
HXDLIN( 106)										if ((this4 == 0)) {
HXLINE( 106)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 106)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 106)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 106)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 106)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 106)								if ((col != 0)) {
HXLINE( 106)									int x = (dx - rectLeft);
HXDLIN( 106)									int y = (dy - rectTop);
HXDLIN( 106)									int this1 = col;
HXDLIN( 106)									int c = this1;
HXDLIN( 106)									bool _hx_tmp;
HXDLIN( 106)									if ((((c >> 24) & 255) < 254)) {
HXLINE( 106)										_hx_tmp = undoImage1->transparent;
            									}
            									else {
HXLINE( 106)										_hx_tmp = false;
            									}
HXDLIN( 106)									if (_hx_tmp) {
HXLINE( 106)										int location;
HXDLIN( 106)										if (undoImage1->useVirtualPos) {
HXLINE( 106)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            										}
            										else {
HXLINE( 106)											location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            										}
HXDLIN( 106)										::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 106)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 106)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 106)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)										int this3 = this2;
HXDLIN( 106)										int this4;
HXDLIN( 106)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE( 106)											this4 = this3;
            										}
HXDLIN( 106)										Float a1;
HXDLIN( 106)										int this5 = ((this4 >> 24) & 255);
HXDLIN( 106)										if ((this5 == 0)) {
HXLINE( 106)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float r1;
HXDLIN( 106)										int this6 = ((this4 >> 16) & 255);
HXDLIN( 106)										if ((this6 == 0)) {
HXLINE( 106)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float g1;
HXDLIN( 106)										int this7 = ((this4 >> 8) & 255);
HXDLIN( 106)										if ((this7 == 0)) {
HXLINE( 106)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float b1;
HXDLIN( 106)										int this8 = (this4 & 255);
HXDLIN( 106)										if ((this8 == 0)) {
HXLINE( 106)											b1 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float a2;
HXDLIN( 106)										int this9 = ((col >> 24) & 255);
HXDLIN( 106)										if ((this9 == 0)) {
HXLINE( 106)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float r2;
HXDLIN( 106)										int this10 = ((col >> 16) & 255);
HXDLIN( 106)										if ((this10 == 0)) {
HXLINE( 106)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float g2;
HXDLIN( 106)										int this11 = ((col >> 8) & 255);
HXDLIN( 106)										if ((this11 == 0)) {
HXLINE( 106)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float b2;
HXDLIN( 106)										int this12 = (col & 255);
HXDLIN( 106)										if ((this12 == 0)) {
HXLINE( 106)											b2 = ((Float)0.);
            										}
            										else {
HXLINE( 106)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN( 106)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 106)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 106)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 106)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 106)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 106)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 106)										{
HXLINE( 106)											::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 106)											int value;
HXDLIN( 106)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 106)												value = blended;
            											}
HXDLIN( 106)											bool _hx_tmp;
HXDLIN( 106)											if ((location >= 0)) {
HXLINE( 106)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE( 106)												_hx_tmp = false;
            											}
HXDLIN( 106)											if (_hx_tmp) {
HXLINE( 106)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 106)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 106)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE( 106)										::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 106)										int index;
HXDLIN( 106)										if (undoImage1->useVirtualPos) {
HXLINE( 106)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            										}
            										else {
HXLINE( 106)											index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            										}
HXDLIN( 106)										int value;
HXDLIN( 106)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 106)											value = c;
            										}
HXDLIN( 106)										bool _hx_tmp;
HXDLIN( 106)										if ((index >= 0)) {
HXLINE( 106)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE( 106)											_hx_tmp = false;
            										}
HXDLIN( 106)										if (_hx_tmp) {
HXLINE( 106)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 106)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 106)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 106)									if (forceClear) {
HXLINE( 106)										::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 106)										int x = (dx - rectLeft);
HXDLIN( 106)										int y = (dy - rectTop);
HXDLIN( 106)										int index;
HXDLIN( 106)										if (undoImage1->useVirtualPos) {
HXLINE( 106)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            										}
            										else {
HXLINE( 106)											index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            										}
HXDLIN( 106)										bool _hx_tmp;
HXDLIN( 106)										if ((index >= 0)) {
HXLINE( 106)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE( 106)											_hx_tmp = false;
            										}
HXDLIN( 106)										if (_hx_tmp) {
HXLINE( 106)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 106)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 106)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 106)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 106)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 106)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 106)		int _g_min1 = xIter31->start;
HXDLIN( 106)		int _g_max1 = xIter31->max;
HXDLIN( 106)		while((_g_min1 < _g_max1)){
HXLINE( 106)			_g_min1 = (_g_min1 + 1);
HXDLIN( 106)			int px = (_g_min1 - 1);
HXDLIN( 106)			Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 106)			{
HXLINE( 106)				int _g_min = yIter31->start;
HXDLIN( 106)				int _g_max = yIter31->max;
HXDLIN( 106)				while((_g_min < _g_max)){
HXLINE( 106)					_g_min = (_g_min + 1);
HXDLIN( 106)					int py = (_g_min - 1);
HXDLIN( 106)					Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 106)					Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN( 106)					Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN( 106)					Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN( 106)					Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN( 106)					Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 106)					bool _hx_tmp;
HXDLIN( 106)					bool _hx_tmp1;
HXDLIN( 106)					if ((ratioA >= 0)) {
HXLINE( 106)						_hx_tmp1 = (ratioB >= 0);
            					}
            					else {
HXLINE( 106)						_hx_tmp1 = false;
            					}
HXDLIN( 106)					if (_hx_tmp1) {
HXLINE( 106)						_hx_tmp = (ratioC >= 0);
            					}
            					else {
HXLINE( 106)						_hx_tmp = false;
            					}
HXDLIN( 106)					if (_hx_tmp) {
HXLINE( 106)						int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN( 106)						if ((i > 255)) {
HXLINE(  24)							i = 255;
            						}
HXLINE( 106)						if ((i < 0)) {
HXLINE(  25)							i = 0;
            						}
HXLINE( 106)						int this2 = i;
HXDLIN( 106)						int a = this2;
HXDLIN( 106)						int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN( 106)						if ((i1 > 255)) {
HXLINE(  24)							i1 = 255;
            						}
HXLINE( 106)						if ((i1 < 0)) {
HXLINE(  25)							i1 = 0;
            						}
HXLINE( 106)						int this3 = i1;
HXDLIN( 106)						int r = this3;
HXDLIN( 106)						int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN( 106)						if ((i2 > 255)) {
HXLINE(  24)							i2 = 255;
            						}
HXLINE( 106)						if ((i2 < 0)) {
HXLINE(  25)							i2 = 0;
            						}
HXLINE( 106)						int this4 = i2;
HXDLIN( 106)						int g = this4;
HXDLIN( 106)						int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN( 106)						if ((i3 > 255)) {
HXLINE(  24)							i3 = 255;
            						}
HXLINE( 106)						if ((i3 < 0)) {
HXLINE(  25)							i3 = 0;
            						}
HXLINE( 106)						int this5 = i3;
HXDLIN( 106)						int b = this5;
HXDLIN( 106)						{
HXLINE( 106)							int location;
HXDLIN( 106)							if (this1->useVirtualPos) {
HXLINE( 106)								location = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            							}
            							else {
HXLINE( 106)								location = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            							}
HXDLIN( 106)							bool _hx_tmp;
HXDLIN( 106)							if (this1->transparent) {
HXLINE( 106)								_hx_tmp = (a < 254);
            							}
            							else {
HXLINE( 106)								_hx_tmp = false;
            							}
HXDLIN( 106)							if (_hx_tmp) {
HXLINE( 106)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)								int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 106)								int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 106)								int this4 = this3;
HXDLIN( 106)								int old;
HXDLIN( 106)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)									old = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE( 106)									old = this4;
            								}
HXDLIN( 106)								int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 106)								Float a1;
HXDLIN( 106)								int this5 = ((old >> 24) & 255);
HXDLIN( 106)								if ((this5 == 0)) {
HXLINE( 106)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float r1;
HXDLIN( 106)								int this6 = ((old >> 16) & 255);
HXDLIN( 106)								if ((this6 == 0)) {
HXLINE( 106)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float g1;
HXDLIN( 106)								int this7 = ((old >> 8) & 255);
HXDLIN( 106)								if ((this7 == 0)) {
HXLINE( 106)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float b1;
HXDLIN( 106)								int this8 = (old & 255);
HXDLIN( 106)								if ((this8 == 0)) {
HXLINE( 106)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float a2;
HXDLIN( 106)								int this9 = ((rhs >> 24) & 255);
HXDLIN( 106)								if ((this9 == 0)) {
HXLINE( 106)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float r2;
HXDLIN( 106)								int this10 = ((rhs >> 16) & 255);
HXDLIN( 106)								if ((this10 == 0)) {
HXLINE( 106)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float g2;
HXDLIN( 106)								int this11 = ((rhs >> 8) & 255);
HXDLIN( 106)								if ((this11 == 0)) {
HXLINE( 106)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float b2;
HXDLIN( 106)								int this12 = (rhs & 255);
HXDLIN( 106)								if ((this12 == 0)) {
HXLINE( 106)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 106)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN( 106)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 106)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 106)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 106)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 106)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 106)								int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 106)								{
HXLINE( 106)									::haxe::io::ArrayBufferViewImpl this13 = this1->image;
HXDLIN( 106)									int value;
HXDLIN( 106)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 106)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 106)										value = blended;
            									}
HXDLIN( 106)									bool _hx_tmp;
HXDLIN( 106)									if ((location >= 0)) {
HXLINE( 106)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE( 106)										_hx_tmp = false;
            									}
HXDLIN( 106)									if (_hx_tmp) {
HXLINE( 106)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 106)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 106)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE( 106)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 106)								int value;
HXDLIN( 106)								if (this1->isLittle) {
HXLINE( 106)									value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            								}
            								else {
HXLINE( 106)									value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            								}
HXDLIN( 106)								bool _hx_tmp;
HXDLIN( 106)								if ((location >= 0)) {
HXLINE( 106)									_hx_tmp = (location < (this2->byteLength >> 2));
            								}
            								else {
HXLINE( 106)									_hx_tmp = false;
            								}
HXDLIN( 106)								if (_hx_tmp) {
HXLINE( 106)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 106)									int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 106)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 106)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 106)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 106)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 106)		if ((hasHit == false)) {
HXLINE( 106)			::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 106)			if (hasUndo1) {
HXLINE( 106)				v->undoImage = undoImage1;
HXDLIN( 106)				v->undoX = xIter31->start;
HXDLIN( 106)				v->undoY = yIter31->start;
            			}
            		}
HXDLIN( 106)		::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 106)		this->info = v;
HXLINE( 110)		bool _hx_tmp;
HXDLIN( 110)		if (::hx::IsNotNull( this->info )) {
HXLINE( 110)			_hx_tmp = ::hx::IsNotNull( oldInfo );
            		}
            		else {
HXLINE( 110)			_hx_tmp = false;
            		}
HXDLIN( 110)		if (_hx_tmp) {
HXLINE( 111)			::pixelimage::ImageStruct this1 = this->temp;
HXDLIN( 111)			Float ax = ((( (Float)(oldInfo->__Field(HX_("bx",d6,55,00,00),::hx::paccDynamic)) ) * this->scaleX) + this->translateX);
HXDLIN( 111)			Float ay = ((( (Float)(oldInfo->__Field(HX_("by",d7,55,00,00),::hx::paccDynamic)) ) * this->scaleY) + this->translateY);
HXDLIN( 111)			int colorA = this->strokeTopColor;
HXDLIN( 111)			Float bx = ((( (Float)(this->info->__Field(HX_("ax",f7,54,00,00),::hx::paccDynamic)) ) * this->scaleX) + this->translateX);
HXDLIN( 111)			Float by = ((( (Float)(this->info->__Field(HX_("ay",f8,54,00,00),::hx::paccDynamic)) ) * this->scaleY) + this->translateY);
HXDLIN( 111)			int colorB = this->strokeTopColor;
HXDLIN( 111)			Float cx = ((( (Float)(this->info->__Field(HX_("dx",94,57,00,00),::hx::paccDynamic)) ) * this->scaleX) + this->translateX);
HXDLIN( 111)			Float cy = ((( (Float)(this->info->__Field(HX_("dy",95,57,00,00),::hx::paccDynamic)) ) * this->scaleY) + this->translateY);
HXDLIN( 111)			int colorC = this->strokeBottomColor;
HXDLIN( 111)			Float dx = ((( (Float)(oldInfo->__Field(HX_("cx",b5,56,00,00),::hx::paccDynamic)) ) * this->scaleX) + this->translateX);
HXDLIN( 111)			Float dy = ((( (Float)(oldInfo->__Field(HX_("cy",b6,56,00,00),::hx::paccDynamic)) ) * this->scaleY) + this->translateY);
HXDLIN( 111)			int colorD = this->strokeBottomColor;
HXDLIN( 111)			{
HXLINE( 111)				{
HXLINE( 111)					bool hasUndo = false;
HXDLIN( 111)					int aA = ((colorB >> 24) & 255);
HXDLIN( 111)					int rA = ((colorB >> 16) & 255);
HXDLIN( 111)					int gA = ((colorB >> 8) & 255);
HXDLIN( 111)					int bA = (colorB & 255);
HXDLIN( 111)					int aB = ((colorA >> 24) & 255);
HXDLIN( 111)					int rB = ((colorA >> 16) & 255);
HXDLIN( 111)					int gB = ((colorA >> 8) & 255);
HXDLIN( 111)					int bB = (colorA & 255);
HXDLIN( 111)					int aC = ((colorD >> 24) & 255);
HXDLIN( 111)					int rC = ((colorD >> 16) & 255);
HXDLIN( 111)					int gC = ((colorD >> 8) & 255);
HXDLIN( 111)					int bC = (colorD & 255);
HXDLIN( 111)					Float bcx = (bx - dx);
HXDLIN( 111)					Float bcy = (by - dy);
HXDLIN( 111)					Float acx = (ax - dx);
HXDLIN( 111)					Float acy = (ay - dy);
HXDLIN( 111)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 111)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 111)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 111)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 111)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 111)					if ((ax > bx)) {
HXLINE( 111)						if ((ax > dx)) {
HXLINE( 111)							int min;
HXDLIN( 111)							if ((bx > dx)) {
HXLINE( 111)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE( 111)								min = ::Math_obj::floor(bx);
            							}
HXDLIN( 111)							int ii_min = min;
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							xIter3 = this1;
            						}
            						else {
HXLINE( 111)							int ii_min = ::Math_obj::floor(bx);
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE( 111)						if ((bx > dx)) {
HXLINE( 111)							int min;
HXDLIN( 111)							if ((ax > dx)) {
HXLINE( 111)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE( 111)								min = ::Math_obj::ceil(ax);
            							}
HXDLIN( 111)							int ii_min = min;
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							xIter3 = this1;
            						}
            						else {
HXLINE( 111)							int ii_min = ::Math_obj::floor(ax);
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							xIter3 = this1;
            						}
            					}
HXDLIN( 111)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 111)					if ((ay > by)) {
HXLINE( 111)						if ((ay > dy)) {
HXLINE( 111)							int min;
HXDLIN( 111)							if ((by > dy)) {
HXLINE( 111)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE( 111)								min = ::Math_obj::floor(by);
            							}
HXDLIN( 111)							int ii_min = min;
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(ay);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							yIter3 = this1;
            						}
            						else {
HXLINE( 111)							int ii_min = ::Math_obj::floor(by);
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE( 111)						if ((by > dy)) {
HXLINE( 111)							int min;
HXDLIN( 111)							if ((ay > dy)) {
HXLINE( 111)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE( 111)								min = ::Math_obj::ceil(ay);
            							}
HXDLIN( 111)							int ii_min = min;
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(by);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							yIter3 = this1;
            						}
            						else {
HXLINE( 111)							int ii_min = ::Math_obj::floor(ay);
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							yIter3 = this1;
            						}
            					}
HXDLIN( 111)					::pixelimage::ImageStruct undoImage = null();
HXDLIN( 111)					if (hasUndo) {
HXLINE( 111)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 111)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 111)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 111)						::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 111)						::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN( 111)						::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN( 111)						undoImage = this4;
HXDLIN( 111)						{
HXLINE( 111)							int rectLeft = xIter3->start;
HXDLIN( 111)							int rectTop = yIter3->start;
HXDLIN( 111)							int rectRight = xIter3->max;
HXDLIN( 111)							bool forceClear = false;
HXDLIN( 111)							{
HXLINE( 111)								int _g = rectTop;
HXDLIN( 111)								int _g1 = yIter3->max;
HXDLIN( 111)								while((_g < _g1)){
HXLINE( 111)									_g = (_g + 1);
HXDLIN( 111)									int dy = (_g - 1);
HXDLIN( 111)									{
HXLINE( 111)										int _g1 = rectLeft;
HXDLIN( 111)										int _g2 = rectRight;
HXDLIN( 111)										while((_g1 < _g2)){
HXLINE( 111)											_g1 = (_g1 + 1);
HXDLIN( 111)											int dx = (_g1 - 1);
HXDLIN( 111)											::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 111)											int index;
HXDLIN( 111)											if (this1->useVirtualPos) {
HXLINE( 111)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            											}
            											else {
HXLINE( 111)												index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            											}
HXDLIN( 111)											::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 111)											int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 111)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 111)											int col;
HXDLIN( 111)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 111)												col = c;
            											}
HXDLIN( 111)											bool _hx_tmp;
HXDLIN( 111)											if (this1->useMask) {
HXLINE( 111)												_hx_tmp = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXLINE( 111)												_hx_tmp = false;
            											}
HXDLIN( 111)											if (_hx_tmp) {
HXLINE( 111)												::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN( 111)												::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN( 111)												int index;
HXDLIN( 111)												if (this2->useVirtualPos) {
HXLINE( 111)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            												}
            												else {
HXLINE( 111)													index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            												}
HXDLIN( 111)												::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 111)												int pos = ((index << 2) + this3->byteOffset);
HXDLIN( 111)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 111)												int v;
HXDLIN( 111)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 111)													v = c;
            												}
HXDLIN( 111)												int this4 = v;
HXDLIN( 111)												int maskPixel = this4;
HXDLIN( 111)												int this5 = col;
HXDLIN( 111)												int this6 = this5;
HXDLIN( 111)												if ((maskPixel == 0)) {
HXLINE( 111)													int this1 = this6;
HXDLIN( 111)													col = this1;
            												}
            												else {
HXLINE( 111)													Float m0;
HXDLIN( 111)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 111)													if ((this1 == 0)) {
HXLINE( 111)														m0 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float m1;
HXDLIN( 111)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 111)													if ((this2 == 0)) {
HXLINE( 111)														m1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float m2;
HXDLIN( 111)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 111)													if ((this3 == 0)) {
HXLINE( 111)														m2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float m3;
HXDLIN( 111)													int this4 = (maskPixel & 255);
HXDLIN( 111)													if ((this4 == 0)) {
HXLINE( 111)														m3 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 111)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 111)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 111)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 111)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 111)											if ((col != 0)) {
HXLINE( 111)												int x = (dx - rectLeft);
HXDLIN( 111)												int y = (dy - rectTop);
HXDLIN( 111)												int this1 = col;
HXDLIN( 111)												int c = this1;
HXDLIN( 111)												bool _hx_tmp;
HXDLIN( 111)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 111)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE( 111)													_hx_tmp = false;
            												}
HXDLIN( 111)												if (_hx_tmp) {
HXLINE( 111)													int location;
HXDLIN( 111)													if (undoImage->useVirtualPos) {
HXLINE( 111)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 111)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 111)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 111)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 111)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 111)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 111)													int this3 = this2;
HXDLIN( 111)													int this4;
HXDLIN( 111)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 111)														this4 = this3;
            													}
HXDLIN( 111)													Float a1;
HXDLIN( 111)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 111)													if ((this5 == 0)) {
HXLINE( 111)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float r1;
HXDLIN( 111)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 111)													if ((this6 == 0)) {
HXLINE( 111)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float g1;
HXDLIN( 111)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 111)													if ((this7 == 0)) {
HXLINE( 111)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float b1;
HXDLIN( 111)													int this8 = (this4 & 255);
HXDLIN( 111)													if ((this8 == 0)) {
HXLINE( 111)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float a2;
HXDLIN( 111)													int this9 = ((col >> 24) & 255);
HXDLIN( 111)													if ((this9 == 0)) {
HXLINE( 111)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float r2;
HXDLIN( 111)													int this10 = ((col >> 16) & 255);
HXDLIN( 111)													if ((this10 == 0)) {
HXLINE( 111)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float g2;
HXDLIN( 111)													int this11 = ((col >> 8) & 255);
HXDLIN( 111)													if ((this11 == 0)) {
HXLINE( 111)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float b2;
HXDLIN( 111)													int this12 = (col & 255);
HXDLIN( 111)													if ((this12 == 0)) {
HXLINE( 111)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 111)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 111)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 111)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 111)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 111)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 111)													{
HXLINE( 111)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 111)														int value;
HXDLIN( 111)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 111)															value = blended;
            														}
HXDLIN( 111)														bool _hx_tmp;
HXDLIN( 111)														if ((location >= 0)) {
HXLINE( 111)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 111)															_hx_tmp = false;
            														}
HXDLIN( 111)														if (_hx_tmp) {
HXLINE( 111)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 111)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 111)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 111)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 111)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 111)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 111)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 111)													int index;
HXDLIN( 111)													if (undoImage->useVirtualPos) {
HXLINE( 111)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 111)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 111)													int value;
HXDLIN( 111)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 111)														value = c;
            													}
HXDLIN( 111)													bool _hx_tmp;
HXDLIN( 111)													if ((index >= 0)) {
HXLINE( 111)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 111)														_hx_tmp = false;
            													}
HXDLIN( 111)													if (_hx_tmp) {
HXLINE( 111)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 111)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 111)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 111)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 111)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 111)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 111)												if (forceClear) {
HXLINE( 111)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 111)													int x = (dx - rectLeft);
HXDLIN( 111)													int y = (dy - rectTop);
HXDLIN( 111)													int index;
HXDLIN( 111)													if (undoImage->useVirtualPos) {
HXLINE( 111)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 111)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 111)													bool _hx_tmp;
HXDLIN( 111)													if ((index >= 0)) {
HXLINE( 111)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 111)														_hx_tmp = false;
            													}
HXDLIN( 111)													if (_hx_tmp) {
HXLINE( 111)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 111)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 111)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 111)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 111)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 111)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 111)					{
HXLINE( 111)						int _g_min = xIter3->start;
HXDLIN( 111)						int _g_max = xIter3->max;
HXDLIN( 111)						while((_g_min < _g_max)){
HXLINE( 111)							_g_min = (_g_min + 1);
HXDLIN( 111)							int px = (_g_min - 1);
HXDLIN( 111)							Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 111)							{
HXLINE( 111)								int _g_min1 = yIter3->start;
HXDLIN( 111)								int _g_max = yIter3->max;
HXDLIN( 111)								while((_g_min1 < _g_max)){
HXLINE( 111)									_g_min1 = (_g_min1 + 1);
HXDLIN( 111)									int py = (_g_min1 - 1);
HXDLIN( 111)									Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 111)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 111)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 111)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 111)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 111)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 111)									bool _hx_tmp;
HXDLIN( 111)									bool _hx_tmp1;
HXDLIN( 111)									if ((ratioA >= 0)) {
HXLINE( 111)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE( 111)										_hx_tmp1 = false;
            									}
HXDLIN( 111)									if (_hx_tmp1) {
HXLINE( 111)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE( 111)										_hx_tmp = false;
            									}
HXDLIN( 111)									if (_hx_tmp) {
HXLINE( 111)										int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 111)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE( 111)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE( 111)										int this2 = i;
HXDLIN( 111)										int a = this2;
HXDLIN( 111)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 111)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE( 111)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE( 111)										int this3 = i1;
HXDLIN( 111)										int r = this3;
HXDLIN( 111)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 111)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE( 111)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE( 111)										int this4 = i2;
HXDLIN( 111)										int g = this4;
HXDLIN( 111)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 111)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE( 111)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE( 111)										int this5 = i3;
HXDLIN( 111)										int b = this5;
HXDLIN( 111)										{
HXLINE( 111)											int location;
HXDLIN( 111)											if (this1->useVirtualPos) {
HXLINE( 111)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            											}
            											else {
HXLINE( 111)												location = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            											}
HXDLIN( 111)											bool _hx_tmp;
HXDLIN( 111)											if (this1->transparent) {
HXLINE( 111)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE( 111)												_hx_tmp = false;
            											}
HXDLIN( 111)											if (_hx_tmp) {
HXLINE( 111)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 111)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 111)												int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 111)												int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 111)												int this4 = this3;
HXDLIN( 111)												int old;
HXDLIN( 111)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)													old = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            												}
            												else {
HXLINE( 111)													old = this4;
            												}
HXDLIN( 111)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 111)												Float a1;
HXDLIN( 111)												int this5 = ((old >> 24) & 255);
HXDLIN( 111)												if ((this5 == 0)) {
HXLINE( 111)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float r1;
HXDLIN( 111)												int this6 = ((old >> 16) & 255);
HXDLIN( 111)												if ((this6 == 0)) {
HXLINE( 111)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float g1;
HXDLIN( 111)												int this7 = ((old >> 8) & 255);
HXDLIN( 111)												if ((this7 == 0)) {
HXLINE( 111)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float b1;
HXDLIN( 111)												int this8 = (old & 255);
HXDLIN( 111)												if ((this8 == 0)) {
HXLINE( 111)													b1 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float a2;
HXDLIN( 111)												int this9 = ((rhs >> 24) & 255);
HXDLIN( 111)												if ((this9 == 0)) {
HXLINE( 111)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float r2;
HXDLIN( 111)												int this10 = ((rhs >> 16) & 255);
HXDLIN( 111)												if ((this10 == 0)) {
HXLINE( 111)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float g2;
HXDLIN( 111)												int this11 = ((rhs >> 8) & 255);
HXDLIN( 111)												if ((this11 == 0)) {
HXLINE( 111)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float b2;
HXDLIN( 111)												int this12 = (rhs & 255);
HXDLIN( 111)												if ((this12 == 0)) {
HXLINE( 111)													b2 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 111)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 111)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 111)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 111)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 111)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 111)												{
HXLINE( 111)													::haxe::io::ArrayBufferViewImpl this13 = this1->image;
HXDLIN( 111)													int value;
HXDLIN( 111)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 111)														value = blended;
            													}
HXDLIN( 111)													bool _hx_tmp;
HXDLIN( 111)													if ((location >= 0)) {
HXLINE( 111)														_hx_tmp = (location < (this13->byteLength >> 2));
            													}
            													else {
HXLINE( 111)														_hx_tmp = false;
            													}
HXDLIN( 111)													if (_hx_tmp) {
HXLINE( 111)														::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 111)														int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 111)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 111)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 111)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 111)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 111)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 111)												int value;
HXDLIN( 111)												if (this1->isLittle) {
HXLINE( 111)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE( 111)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN( 111)												bool _hx_tmp;
HXDLIN( 111)												if ((location >= 0)) {
HXLINE( 111)													_hx_tmp = (location < (this2->byteLength >> 2));
            												}
            												else {
HXLINE( 111)													_hx_tmp = false;
            												}
HXDLIN( 111)												if (_hx_tmp) {
HXLINE( 111)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 111)													int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 111)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 111)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 111)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 111)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 111)				{
HXLINE( 111)					bool hasHit = false;
HXDLIN( 111)					bool hasUndo1 = false;
HXDLIN( 111)					int aA1 = ((colorC >> 24) & 255);
HXDLIN( 111)					int rA1 = ((colorC >> 16) & 255);
HXDLIN( 111)					int gA1 = ((colorC >> 8) & 255);
HXDLIN( 111)					int bA1 = (colorC & 255);
HXDLIN( 111)					int aB1 = ((colorB >> 24) & 255);
HXDLIN( 111)					int rB1 = ((colorB >> 16) & 255);
HXDLIN( 111)					int gB1 = ((colorB >> 8) & 255);
HXDLIN( 111)					int bB1 = (colorB & 255);
HXDLIN( 111)					int aC1 = ((colorD >> 24) & 255);
HXDLIN( 111)					int rC1 = ((colorD >> 16) & 255);
HXDLIN( 111)					int gC1 = ((colorD >> 8) & 255);
HXDLIN( 111)					int bC1 = (colorD & 255);
HXDLIN( 111)					Float bcx1 = (cx - dx);
HXDLIN( 111)					Float bcy1 = (cy - dy);
HXDLIN( 111)					Float acx1 = (bx - dx);
HXDLIN( 111)					Float acy1 = (by - dy);
HXDLIN( 111)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 111)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 111)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 111)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 111)					::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 111)					if ((bx > cx)) {
HXLINE( 111)						if ((bx > dx)) {
HXLINE( 111)							int min;
HXDLIN( 111)							if ((cx > dx)) {
HXLINE( 111)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE( 111)								min = ::Math_obj::floor(cx);
            							}
HXDLIN( 111)							int ii_min = min;
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							xIter31 = this1;
            						}
            						else {
HXLINE( 111)							int ii_min = ::Math_obj::floor(cx);
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							xIter31 = this1;
            						}
            					}
            					else {
HXLINE( 111)						if ((cx > dx)) {
HXLINE( 111)							int min;
HXDLIN( 111)							if ((bx > dx)) {
HXLINE( 111)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE( 111)								min = ::Math_obj::ceil(bx);
            							}
HXDLIN( 111)							int ii_min = min;
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							xIter31 = this1;
            						}
            						else {
HXLINE( 111)							int ii_min = ::Math_obj::floor(bx);
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							xIter31 = this1;
            						}
            					}
HXDLIN( 111)					::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 111)					if ((by > cy)) {
HXLINE( 111)						if ((by > dy)) {
HXLINE( 111)							int min;
HXDLIN( 111)							if ((cy > dy)) {
HXLINE( 111)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE( 111)								min = ::Math_obj::floor(cy);
            							}
HXDLIN( 111)							int ii_min = min;
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(by);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							yIter31 = this1;
            						}
            						else {
HXLINE( 111)							int ii_min = ::Math_obj::floor(cy);
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							yIter31 = this1;
            						}
            					}
            					else {
HXLINE( 111)						if ((cy > dy)) {
HXLINE( 111)							int min;
HXDLIN( 111)							if ((by > dy)) {
HXLINE( 111)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE( 111)								min = ::Math_obj::ceil(by);
            							}
HXDLIN( 111)							int ii_min = min;
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							yIter31 = this1;
            						}
            						else {
HXLINE( 111)							int ii_min = ::Math_obj::floor(by);
HXDLIN( 111)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN( 111)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 111)							yIter31 = this1;
            						}
            					}
HXDLIN( 111)					::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 111)					if (hasUndo1) {
HXLINE( 111)						int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 111)						int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 111)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 111)						::haxe::io::ArrayBufferViewImpl this2 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 111)						::haxe::io::ArrayBufferViewImpl this3 = this2;
HXDLIN( 111)						::pixelimage::ImageStruct this4 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this3);
HXDLIN( 111)						undoImage1 = this4;
HXDLIN( 111)						{
HXLINE( 111)							int rectLeft = xIter31->start;
HXDLIN( 111)							int rectTop = yIter31->start;
HXDLIN( 111)							int rectRight = xIter31->max;
HXDLIN( 111)							bool forceClear = false;
HXDLIN( 111)							{
HXLINE( 111)								int _g = rectTop;
HXDLIN( 111)								int _g1 = yIter31->max;
HXDLIN( 111)								while((_g < _g1)){
HXLINE( 111)									_g = (_g + 1);
HXDLIN( 111)									int dy = (_g - 1);
HXDLIN( 111)									{
HXLINE( 111)										int _g1 = rectLeft;
HXDLIN( 111)										int _g2 = rectRight;
HXDLIN( 111)										while((_g1 < _g2)){
HXLINE( 111)											_g1 = (_g1 + 1);
HXDLIN( 111)											int dx = (_g1 - 1);
HXDLIN( 111)											::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 111)											int index;
HXDLIN( 111)											if (this1->useVirtualPos) {
HXLINE( 111)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            											}
            											else {
HXLINE( 111)												index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            											}
HXDLIN( 111)											::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 111)											int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 111)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 111)											int col;
HXDLIN( 111)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 111)												col = c;
            											}
HXDLIN( 111)											bool _hx_tmp;
HXDLIN( 111)											if (this1->useMask) {
HXLINE( 111)												_hx_tmp = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXLINE( 111)												_hx_tmp = false;
            											}
HXDLIN( 111)											if (_hx_tmp) {
HXLINE( 111)												::pixelimage::ImageStruct this2 = this1->mask;
HXDLIN( 111)												::haxe::io::ArrayBufferViewImpl this3 = this2->image;
HXDLIN( 111)												int index;
HXDLIN( 111)												if (this2->useVirtualPos) {
HXLINE( 111)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            												}
            												else {
HXLINE( 111)													index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            												}
HXDLIN( 111)												::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 111)												int pos = ((index << 2) + this3->byteOffset);
HXDLIN( 111)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 111)												int v;
HXDLIN( 111)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 111)													v = c;
            												}
HXDLIN( 111)												int this4 = v;
HXDLIN( 111)												int maskPixel = this4;
HXDLIN( 111)												int this5 = col;
HXDLIN( 111)												int this6 = this5;
HXDLIN( 111)												if ((maskPixel == 0)) {
HXLINE( 111)													int this1 = this6;
HXDLIN( 111)													col = this1;
            												}
            												else {
HXLINE( 111)													Float m0;
HXDLIN( 111)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 111)													if ((this1 == 0)) {
HXLINE( 111)														m0 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float m1;
HXDLIN( 111)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 111)													if ((this2 == 0)) {
HXLINE( 111)														m1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float m2;
HXDLIN( 111)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 111)													if ((this3 == 0)) {
HXLINE( 111)														m2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float m3;
HXDLIN( 111)													int this4 = (maskPixel & 255);
HXDLIN( 111)													if ((this4 == 0)) {
HXLINE( 111)														m3 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 111)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 111)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 111)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 111)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 111)											if ((col != 0)) {
HXLINE( 111)												int x = (dx - rectLeft);
HXDLIN( 111)												int y = (dy - rectTop);
HXDLIN( 111)												int this1 = col;
HXDLIN( 111)												int c = this1;
HXDLIN( 111)												bool _hx_tmp;
HXDLIN( 111)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 111)													_hx_tmp = undoImage1->transparent;
            												}
            												else {
HXLINE( 111)													_hx_tmp = false;
            												}
HXDLIN( 111)												if (_hx_tmp) {
HXLINE( 111)													int location;
HXDLIN( 111)													if (undoImage1->useVirtualPos) {
HXLINE( 111)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE( 111)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN( 111)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 111)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 111)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 111)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 111)													int this3 = this2;
HXDLIN( 111)													int this4;
HXDLIN( 111)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 111)														this4 = this3;
            													}
HXDLIN( 111)													Float a1;
HXDLIN( 111)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 111)													if ((this5 == 0)) {
HXLINE( 111)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float r1;
HXDLIN( 111)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 111)													if ((this6 == 0)) {
HXLINE( 111)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float g1;
HXDLIN( 111)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 111)													if ((this7 == 0)) {
HXLINE( 111)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float b1;
HXDLIN( 111)													int this8 = (this4 & 255);
HXDLIN( 111)													if ((this8 == 0)) {
HXLINE( 111)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float a2;
HXDLIN( 111)													int this9 = ((col >> 24) & 255);
HXDLIN( 111)													if ((this9 == 0)) {
HXLINE( 111)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float r2;
HXDLIN( 111)													int this10 = ((col >> 16) & 255);
HXDLIN( 111)													if ((this10 == 0)) {
HXLINE( 111)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float g2;
HXDLIN( 111)													int this11 = ((col >> 8) & 255);
HXDLIN( 111)													if ((this11 == 0)) {
HXLINE( 111)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float b2;
HXDLIN( 111)													int this12 = (col & 255);
HXDLIN( 111)													if ((this12 == 0)) {
HXLINE( 111)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 111)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 111)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 111)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 111)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 111)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 111)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 111)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 111)													{
HXLINE( 111)														::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 111)														int value;
HXDLIN( 111)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 111)															value = blended;
            														}
HXDLIN( 111)														bool _hx_tmp;
HXDLIN( 111)														if ((location >= 0)) {
HXLINE( 111)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 111)															_hx_tmp = false;
            														}
HXDLIN( 111)														if (_hx_tmp) {
HXLINE( 111)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 111)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 111)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 111)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 111)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 111)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 111)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 111)													int index;
HXDLIN( 111)													if (undoImage1->useVirtualPos) {
HXLINE( 111)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE( 111)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN( 111)													int value;
HXDLIN( 111)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 111)														value = c;
            													}
HXDLIN( 111)													bool _hx_tmp;
HXDLIN( 111)													if ((index >= 0)) {
HXLINE( 111)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 111)														_hx_tmp = false;
            													}
HXDLIN( 111)													if (_hx_tmp) {
HXLINE( 111)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 111)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 111)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 111)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 111)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 111)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 111)												if (forceClear) {
HXLINE( 111)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 111)													int x = (dx - rectLeft);
HXDLIN( 111)													int y = (dy - rectTop);
HXDLIN( 111)													int index;
HXDLIN( 111)													if (undoImage1->useVirtualPos) {
HXLINE( 111)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE( 111)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN( 111)													bool _hx_tmp;
HXDLIN( 111)													if ((index >= 0)) {
HXLINE( 111)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 111)														_hx_tmp = false;
            													}
HXDLIN( 111)													if (_hx_tmp) {
HXLINE( 111)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 111)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 111)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 111)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 111)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 111)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 111)					{
HXLINE( 111)						int _g_min1 = xIter31->start;
HXDLIN( 111)						int _g_max1 = xIter31->max;
HXDLIN( 111)						while((_g_min1 < _g_max1)){
HXLINE( 111)							_g_min1 = (_g_min1 + 1);
HXDLIN( 111)							int px = (_g_min1 - 1);
HXDLIN( 111)							Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 111)							{
HXLINE( 111)								int _g_min = yIter31->start;
HXDLIN( 111)								int _g_max = yIter31->max;
HXDLIN( 111)								while((_g_min < _g_max)){
HXLINE( 111)									_g_min = (_g_min + 1);
HXDLIN( 111)									int py = (_g_min - 1);
HXDLIN( 111)									Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 111)									Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN( 111)									Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN( 111)									Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN( 111)									Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN( 111)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 111)									bool _hx_tmp;
HXDLIN( 111)									bool _hx_tmp1;
HXDLIN( 111)									if ((ratioA >= 0)) {
HXLINE( 111)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE( 111)										_hx_tmp1 = false;
            									}
HXDLIN( 111)									if (_hx_tmp1) {
HXLINE( 111)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE( 111)										_hx_tmp = false;
            									}
HXDLIN( 111)									if (_hx_tmp) {
HXLINE( 111)										int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN( 111)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE( 111)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE( 111)										int this2 = i;
HXDLIN( 111)										int a = this2;
HXDLIN( 111)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN( 111)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE( 111)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE( 111)										int this3 = i1;
HXDLIN( 111)										int r = this3;
HXDLIN( 111)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN( 111)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE( 111)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE( 111)										int this4 = i2;
HXDLIN( 111)										int g = this4;
HXDLIN( 111)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN( 111)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE( 111)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE( 111)										int this5 = i3;
HXDLIN( 111)										int b = this5;
HXDLIN( 111)										{
HXLINE( 111)											int location;
HXDLIN( 111)											if (this1->useVirtualPos) {
HXLINE( 111)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            											}
            											else {
HXLINE( 111)												location = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            											}
HXDLIN( 111)											bool _hx_tmp;
HXDLIN( 111)											if (this1->transparent) {
HXLINE( 111)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE( 111)												_hx_tmp = false;
            											}
HXDLIN( 111)											if (_hx_tmp) {
HXLINE( 111)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 111)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 111)												int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 111)												int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 111)												int this4 = this3;
HXDLIN( 111)												int old;
HXDLIN( 111)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)													old = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            												}
            												else {
HXLINE( 111)													old = this4;
            												}
HXDLIN( 111)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 111)												Float a1;
HXDLIN( 111)												int this5 = ((old >> 24) & 255);
HXDLIN( 111)												if ((this5 == 0)) {
HXLINE( 111)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float r1;
HXDLIN( 111)												int this6 = ((old >> 16) & 255);
HXDLIN( 111)												if ((this6 == 0)) {
HXLINE( 111)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float g1;
HXDLIN( 111)												int this7 = ((old >> 8) & 255);
HXDLIN( 111)												if ((this7 == 0)) {
HXLINE( 111)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float b1;
HXDLIN( 111)												int this8 = (old & 255);
HXDLIN( 111)												if ((this8 == 0)) {
HXLINE( 111)													b1 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float a2;
HXDLIN( 111)												int this9 = ((rhs >> 24) & 255);
HXDLIN( 111)												if ((this9 == 0)) {
HXLINE( 111)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float r2;
HXDLIN( 111)												int this10 = ((rhs >> 16) & 255);
HXDLIN( 111)												if ((this10 == 0)) {
HXLINE( 111)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float g2;
HXDLIN( 111)												int this11 = ((rhs >> 8) & 255);
HXDLIN( 111)												if ((this11 == 0)) {
HXLINE( 111)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float b2;
HXDLIN( 111)												int this12 = (rhs & 255);
HXDLIN( 111)												if ((this12 == 0)) {
HXLINE( 111)													b2 = ((Float)0.);
            												}
            												else {
HXLINE( 111)													b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            												}
HXDLIN( 111)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 111)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 111)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 111)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 111)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 111)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 111)												{
HXLINE( 111)													::haxe::io::ArrayBufferViewImpl this13 = this1->image;
HXDLIN( 111)													int value;
HXDLIN( 111)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 111)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 111)														value = blended;
            													}
HXDLIN( 111)													bool _hx_tmp;
HXDLIN( 111)													if ((location >= 0)) {
HXLINE( 111)														_hx_tmp = (location < (this13->byteLength >> 2));
            													}
            													else {
HXLINE( 111)														_hx_tmp = false;
            													}
HXDLIN( 111)													if (_hx_tmp) {
HXLINE( 111)														::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 111)														int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 111)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 111)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 111)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 111)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 111)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 111)												int value;
HXDLIN( 111)												if (this1->isLittle) {
HXLINE( 111)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE( 111)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN( 111)												bool _hx_tmp;
HXDLIN( 111)												if ((location >= 0)) {
HXLINE( 111)													_hx_tmp = (location < (this2->byteLength >> 2));
            												}
            												else {
HXLINE( 111)													_hx_tmp = false;
            												}
HXDLIN( 111)												if (_hx_tmp) {
HXLINE( 111)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 111)													int pos = ((location << 2) + this2->byteOffset);
HXDLIN( 111)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 111)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 111)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 111)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 111)					if ((hasHit == false)) {
HXLINE( 111)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 111)						if (hasUndo1) {
HXLINE( 111)							v->undoImage = undoImage1;
HXDLIN( 111)							v->undoX = xIter31->start;
HXDLIN( 111)							v->undoY = yIter31->start;
            						}
            					}
            				}
HXDLIN( 111)				::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            			}
            		}
HXLINE( 116)		this->x0 = x2;
HXLINE( 117)		this->y0 = y2;
HXLINE( 118)		this->toggleDraw = true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(PathElementThickGradient_obj,lineTo,(void))

void PathElementThickGradient_obj::moveTo(Float x1,Float y1){
            	HX_STACKFRAME(&_hx_pos_c07cc9dd160e3b1d_121_moveTo)
HXLINE( 122)		this->x0 = x1;
HXLINE( 123)		this->y0 = y1;
HXLINE( 124)		this->info = null();
HXLINE( 125)		this->toggleDraw = true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(PathElementThickGradient_obj,moveTo,(void))


::hx::ObjectPtr< PathElementThickGradient_obj > PathElementThickGradient_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeTopColor,::hx::Null< int >  __o_strokeBottomColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::String __o_pathData,::hx::Null< Float >  __o_translateX,::hx::Null< Float >  __o_translateY,::hx::Null< Float >  __o_scaleX,::hx::Null< Float >  __o_scaleY) {
	::hx::ObjectPtr< PathElementThickGradient_obj > __this = new PathElementThickGradient_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeTopColor,__o_strokeBottomColor,__o_strokeWidth,strokeDashGapArray,__o_fill,__o_pathData,__o_translateX,__o_translateY,__o_scaleX,__o_scaleY);
	return __this;
}

::hx::ObjectPtr< PathElementThickGradient_obj > PathElementThickGradient_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeTopColor,::hx::Null< int >  __o_strokeBottomColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::String __o_pathData,::hx::Null< Float >  __o_translateX,::hx::Null< Float >  __o_translateY,::hx::Null< Float >  __o_scaleX,::hx::Null< Float >  __o_scaleY) {
	PathElementThickGradient_obj *__this = (PathElementThickGradient_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PathElementThickGradient_obj), true, "pixelimage.triangleGML.gradient.PathElementThickGradient"));
	*(void **)__this = PathElementThickGradient_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeTopColor,__o_strokeBottomColor,__o_strokeWidth,strokeDashGapArray,__o_fill,__o_pathData,__o_translateX,__o_translateY,__o_scaleX,__o_scaleY);
	return __this;
}

PathElementThickGradient_obj::PathElementThickGradient_obj()
{
}

void PathElementThickGradient_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PathElementThickGradient);
	HX_MARK_MEMBER_NAME(pathData,"pathData");
	HX_MARK_MEMBER_NAME(strokeTopColor,"strokeTopColor");
	HX_MARK_MEMBER_NAME(strokeBottomColor,"strokeBottomColor");
	HX_MARK_MEMBER_NAME(translateX,"translateX");
	HX_MARK_MEMBER_NAME(translateY,"translateY");
	HX_MARK_MEMBER_NAME(scaleX,"scaleX");
	HX_MARK_MEMBER_NAME(scaleY,"scaleY");
	HX_MARK_MEMBER_NAME(x0,"x0");
	HX_MARK_MEMBER_NAME(y0,"y0");
	HX_MARK_MEMBER_NAME(temp,"temp");
	HX_MARK_MEMBER_NAME(toggleDraw,"toggleDraw");
	HX_MARK_MEMBER_NAME(info,"info");
	::pixelimage::triangleGML::coreShape::BasicShape_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PathElementThickGradient_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(pathData,"pathData");
	HX_VISIT_MEMBER_NAME(strokeTopColor,"strokeTopColor");
	HX_VISIT_MEMBER_NAME(strokeBottomColor,"strokeBottomColor");
	HX_VISIT_MEMBER_NAME(translateX,"translateX");
	HX_VISIT_MEMBER_NAME(translateY,"translateY");
	HX_VISIT_MEMBER_NAME(scaleX,"scaleX");
	HX_VISIT_MEMBER_NAME(scaleY,"scaleY");
	HX_VISIT_MEMBER_NAME(x0,"x0");
	HX_VISIT_MEMBER_NAME(y0,"y0");
	HX_VISIT_MEMBER_NAME(temp,"temp");
	HX_VISIT_MEMBER_NAME(toggleDraw,"toggleDraw");
	HX_VISIT_MEMBER_NAME(info,"info");
	::pixelimage::triangleGML::coreShape::BasicShape_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val PathElementThickGradient_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x0") ) { return ::hx::Val( x0 ); }
		if (HX_FIELD_EQ(inName,"y0") ) { return ::hx::Val( y0 ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"temp") ) { return ::hx::Val( temp ); }
		if (HX_FIELD_EQ(inName,"info") ) { return ::hx::Val( info ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"scaleX") ) { return ::hx::Val( scaleX ); }
		if (HX_FIELD_EQ(inName,"scaleY") ) { return ::hx::Val( scaleY ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		if (HX_FIELD_EQ(inName,"lineTo") ) { return ::hx::Val( lineTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"pathData") ) { return ::hx::Val( pathData ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"translateX") ) { return ::hx::Val( translateX ); }
		if (HX_FIELD_EQ(inName,"translateY") ) { return ::hx::Val( translateY ); }
		if (HX_FIELD_EQ(inName,"toggleDraw") ) { return ::hx::Val( toggleDraw ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"lineSegmentTo") ) { return ::hx::Val( lineSegmentTo_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"strokeTopColor") ) { return ::hx::Val( strokeTopColor ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"strokeBottomColor") ) { return ::hx::Val( strokeBottomColor ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val PathElementThickGradient_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x0") ) { x0=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y0") ) { y0=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"temp") ) { temp=inValue.Cast< ::pixelimage::ImageStruct >(); return inValue; }
		if (HX_FIELD_EQ(inName,"info") ) { info=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"scaleX") ) { scaleX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scaleY") ) { scaleY=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"pathData") ) { pathData=inValue.Cast< ::String >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"translateX") ) { translateX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"translateY") ) { translateY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"toggleDraw") ) { toggleDraw=inValue.Cast< bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"strokeTopColor") ) { strokeTopColor=inValue.Cast< int >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"strokeBottomColor") ) { strokeBottomColor=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PathElementThickGradient_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("pathData",6f,9e,02,38));
	outFields->push(HX_("strokeTopColor",66,66,01,41));
	outFields->push(HX_("strokeBottomColor",a0,95,a8,82));
	outFields->push(HX_("translateX",4a,8d,5c,06));
	outFields->push(HX_("translateY",4b,8d,5c,06));
	outFields->push(HX_("scaleX",8e,ea,25,3c));
	outFields->push(HX_("scaleY",8f,ea,25,3c));
	outFields->push(HX_("x0",b8,68,00,00));
	outFields->push(HX_("y0",97,69,00,00));
	outFields->push(HX_("temp",14,c3,f9,4c));
	outFields->push(HX_("toggleDraw",b8,71,26,da));
	outFields->push(HX_("info",6e,38,bb,45));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PathElementThickGradient_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(PathElementThickGradient_obj,pathData),HX_("pathData",6f,9e,02,38)},
	{::hx::fsInt,(int)offsetof(PathElementThickGradient_obj,strokeTopColor),HX_("strokeTopColor",66,66,01,41)},
	{::hx::fsInt,(int)offsetof(PathElementThickGradient_obj,strokeBottomColor),HX_("strokeBottomColor",a0,95,a8,82)},
	{::hx::fsFloat,(int)offsetof(PathElementThickGradient_obj,translateX),HX_("translateX",4a,8d,5c,06)},
	{::hx::fsFloat,(int)offsetof(PathElementThickGradient_obj,translateY),HX_("translateY",4b,8d,5c,06)},
	{::hx::fsFloat,(int)offsetof(PathElementThickGradient_obj,scaleX),HX_("scaleX",8e,ea,25,3c)},
	{::hx::fsFloat,(int)offsetof(PathElementThickGradient_obj,scaleY),HX_("scaleY",8f,ea,25,3c)},
	{::hx::fsFloat,(int)offsetof(PathElementThickGradient_obj,x0),HX_("x0",b8,68,00,00)},
	{::hx::fsFloat,(int)offsetof(PathElementThickGradient_obj,y0),HX_("y0",97,69,00,00)},
	{::hx::fsObject /* ::pixelimage::ImageStruct */ ,(int)offsetof(PathElementThickGradient_obj,temp),HX_("temp",14,c3,f9,4c)},
	{::hx::fsBool,(int)offsetof(PathElementThickGradient_obj,toggleDraw),HX_("toggleDraw",b8,71,26,da)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PathElementThickGradient_obj,info),HX_("info",6e,38,bb,45)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *PathElementThickGradient_obj_sStaticStorageInfo = 0;
#endif

static ::String PathElementThickGradient_obj_sMemberFields[] = {
	HX_("pathData",6f,9e,02,38),
	HX_("strokeTopColor",66,66,01,41),
	HX_("strokeBottomColor",a0,95,a8,82),
	HX_("translateX",4a,8d,5c,06),
	HX_("translateY",4b,8d,5c,06),
	HX_("scaleX",8e,ea,25,3c),
	HX_("scaleY",8f,ea,25,3c),
	HX_("x0",b8,68,00,00),
	HX_("y0",97,69,00,00),
	HX_("temp",14,c3,f9,4c),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	HX_("toggleDraw",b8,71,26,da),
	HX_("info",6e,38,bb,45),
	HX_("lineSegmentTo",7a,d5,67,57),
	HX_("lineTo",8f,46,a0,ec),
	HX_("moveTo",ec,d2,ac,cc),
	::String(null()) };

::hx::Class PathElementThickGradient_obj::__mClass;

void PathElementThickGradient_obj::__register()
{
	PathElementThickGradient_obj _hx_dummy;
	PathElementThickGradient_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.gradient.PathElementThickGradient",cb,77,68,26);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PathElementThickGradient_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PathElementThickGradient_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PathElementThickGradient_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PathElementThickGradient_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace gradient
