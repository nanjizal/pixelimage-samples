// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicGradient
#include <pixelimage/triangleGML/coreShape/BasicGradient.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_gradient_EllipseRadialGradient
#include <pixelimage/triangleGML/gradient/EllipseRadialGradient.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_bd811fe788ff4191_30_new,"pixelimage.triangleGML.gradient.EllipseRadialGradient","new",0xb6906aca,"pixelimage.triangleGML.gradient.EllipseRadialGradient.new","pixelimage/triangleGML/gradient/EllipseRadialGradient.hx",30,0x2df6c325)
HX_LOCAL_STACK_FRAME(_hx_pos_bd811fe788ff4191_41_setParameter,"pixelimage.triangleGML.gradient.EllipseRadialGradient","setParameter",0x7a35bdfd,"pixelimage.triangleGML.gradient.EllipseRadialGradient.setParameter","pixelimage/triangleGML/gradient/EllipseRadialGradient.hx",41,0x2df6c325)
HX_LOCAL_STACK_FRAME(_hx_pos_bd811fe788ff4191_64_render,"pixelimage.triangleGML.gradient.EllipseRadialGradient","render",0xed59af2c,"pixelimage.triangleGML.gradient.EllipseRadialGradient.render","pixelimage/triangleGML/gradient/EllipseRadialGradient.hx",64,0x2df6c325)
namespace pixelimage{
namespace triangleGML{
namespace gradient{

void EllipseRadialGradient_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_centreX,::hx::Null< int >  __o_centreY,::hx::Null< int >  __o_radiusX,::hx::Null< int >  __o_radiusY,::hx::Null< int >  __o_colorIn,::hx::Null< int >  __o_colorOut,::hx::Null< Float >  __o_gradientCentreX,::hx::Null< Float >  __o_gradientCentreY,::hx::Null< Float >  __o_rotation){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int centreX = __o_centreX.Default(30);
            		int centreY = __o_centreY.Default(30);
            		int radiusX = __o_radiusX.Default(10);
            		int radiusY = __o_radiusY.Default(10);
            		int colorIn = __o_colorIn.Default(-256);
            		int colorOut = __o_colorOut.Default(-16776961);
            		Float gradientCentreX = __o_gradientCentreX.Default(((Float)-1.));
            		Float gradientCentreY = __o_gradientCentreY.Default(((Float)-1.));
            		Float rotation = __o_rotation.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_bd811fe788ff4191_30_new)
HXLINE(  31)		super::__construct(opacity,visibility,::Array_obj< int >::__new(2)->init(0,colorIn)->init(1,colorOut));
HXLINE(  32)		this->centreX = ( (Float)(centreX) );
HXLINE(  33)		this->centreY = ( (Float)(centreY) );
HXLINE(  34)		this->radiusX = ( (Float)(radiusX) );
HXLINE(  35)		this->radiusY = ( (Float)(radiusY) );
HXLINE(  36)		this->gradientCentreY = gradientCentreX;
HXLINE(  37)		this->gradientCentreY = gradientCentreY;
HXLINE(  38)		this->rotation = rotation;
            	}

Dynamic EllipseRadialGradient_obj::__CreateEmpty() { return new EllipseRadialGradient_obj; }

void *EllipseRadialGradient_obj::_hx_vtable = 0;

Dynamic EllipseRadialGradient_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< EllipseRadialGradient_obj > _hx_result = new EllipseRadialGradient_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10]);
	return _hx_result;
}

bool EllipseRadialGradient_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x682b5a9c) {
		if (inClassId<=(int)0x24e92cfb) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x24e92cfb;
		} else {
			return inClassId==(int)0x682b5a9c;
		}
	} else {
		return inClassId==(int)0x68e012c5;
	}
}

void EllipseRadialGradient_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_bd811fe788ff4191_41_setParameter)
HXDLIN(  41)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("centreX",dd,c6,ef,19)) ){
HXLINE(  43)			this->centreX = ::Std_obj::parseFloat(value);
HXDLIN(  43)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("centreY",de,c6,ef,19)) ){
HXLINE(  45)			this->centreY = ::Std_obj::parseFloat(value);
HXDLIN(  45)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("colorIn",28,10,66,ef)) ){
HXLINE(  57)			this->cornerColors[0] = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  57)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("colorOut",eb,a6,ec,89)) ){
HXLINE(  59)			this->cornerColors[1] = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  59)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("gradientCentreX",cd,d2,95,ed)) ){
HXLINE(  51)			this->gradientCentreX = ::Std_obj::parseFloat(value);
HXDLIN(  51)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("gradientCentreY",ce,d2,95,ed)) ){
HXLINE(  53)			this->gradientCentreY = ::Std_obj::parseFloat(value);
HXDLIN(  53)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("radiusX",c6,77,ff,26)) ){
HXLINE(  47)			this->radiusX = ::Std_obj::parseFloat(value);
HXDLIN(  47)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("radiusY",c7,77,ff,26)) ){
HXLINE(  49)			this->radiusY = ::Std_obj::parseFloat(value);
HXDLIN(  49)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("rotation",3e,3d,86,08)) ){
HXLINE(  55)			this->rotation = ::Std_obj::parseFloat(value);
HXDLIN(  55)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  61)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct EllipseRadialGradient_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_bd811fe788ff4191_64_render)
HXLINE(  65)		if ((this->gradientCentreX == ((Float)-1.))) {
HXLINE(  65)			this->gradientCentreX = this->centreX;
            		}
HXLINE(  66)		if ((this->gradientCentreY == ((Float)-1.))) {
HXLINE(  66)			this->gradientCentreY = this->centreY;
            		}
HXLINE(  67)		Float rSmall;
HXDLIN(  67)		if ((this->radiusX > this->radiusY)) {
HXLINE(  67)			rSmall = this->radiusY;
            		}
            		else {
HXLINE(  67)			rSmall = this->radiusX;
            		}
HXLINE(  68)		Float rLarge;
HXDLIN(  68)		if ((this->radiusX < this->radiusY)) {
HXLINE(  68)			rLarge = this->radiusY;
            		}
            		else {
HXLINE(  68)			rLarge = this->radiusX;
            		}
HXLINE(  69)		Float rDif = (rLarge - rSmall);
HXLINE(  70)		::pixelimage::ImageStruct temp;
HXDLIN(  70)		if ((this->rotation == 0)) {
HXLINE(  70)			int w = ::Std_obj::_hx_int((( (Float)(2) ) * this->radiusX));
HXDLIN(  70)			int h = ::Std_obj::_hx_int((( (Float)(2) ) * this->radiusY));
HXDLIN(  70)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  70)			::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  70)			::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  70)			::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  70)			::pixelimage::ImageStruct this4 = this3;
HXDLIN(  70)			temp = this4;
            		}
            		else {
HXLINE(  71)			int w = ::Std_obj::_hx_int(((( (Float)(2) ) * rLarge) + rDif));
HXDLIN(  71)			int h = ::Std_obj::_hx_int(((( (Float)(2) ) * rLarge) + rDif));
HXDLIN(  71)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  71)			::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  71)			::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  71)			::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  71)			::pixelimage::ImageStruct this4 = this3;
HXLINE(  70)			temp = this4;
            		}
HXLINE(  72)		temp->transparent = false;
HXLINE(  73)		{
HXLINE(  73)			Float cx = this->centreX;
HXDLIN(  73)			Float cy = this->centreY;
HXDLIN(  73)			Float rx = this->radiusX;
HXDLIN(  73)			Float ry = this->radiusY;
HXDLIN(  73)			int colorIn = this->colorIn;
HXDLIN(  73)			int colorOut = this->colorOut;
HXDLIN(  73)			 ::Dynamic gx = this->gradientCentreX;
HXDLIN(  73)			 ::Dynamic gy = this->gradientCentreY;
HXDLIN(  73)			 ::Dynamic phi = this->rotation;
HXDLIN(  73)			if (::hx::IsNull( phi )) {
HXLINE(  73)				phi = ((Float)0.);
            			}
HXDLIN(  73)			if (::hx::IsNull( gy )) {
HXLINE(  73)				gy = 0;
            			}
HXDLIN(  73)			if (::hx::IsNull( gx )) {
HXLINE(  73)				gx = 0;
            			}
HXDLIN(  73)			if (::hx::IsLess( gx,((Float)-1.) )) {
HXLINE( 193)				gx = -1;
            			}
HXLINE(  73)			if (::hx::IsGreater( gx,((Float)1.) )) {
HXLINE( 194)				gx = 1;
            			}
HXLINE(  73)			if (::hx::IsLess( gy,((Float)-1.) )) {
HXLINE( 195)				gy = ((Float)-1.);
            			}
HXLINE(  73)			if (::hx::IsGreater( gy,((Float)1.) )) {
HXLINE( 196)				gy = 1;
            			}
HXLINE(  73)			Float mx = (cx + (( (Float)(gx) ) * rx));
HXDLIN(  73)			Float my = (cy + (( (Float)(gy) ) * ry));
HXDLIN(  73)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(36) ));
HXDLIN(  73)			Float omega = ((Float)0.);
HXDLIN(  73)			Float lastX = ((Float)0.);
HXDLIN(  73)			Float lastY = ((Float)0.);
HXDLIN(  73)			if (::hx::IsNotEq( phi,0 )) {
HXLINE( 221)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(36) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(36) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE( 222)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(36) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(36) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            			}
            			else {
HXLINE( 224)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(36) ) * theta) + omega))));
HXLINE( 225)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(36) ) * theta) + omega))));
            			}
HXLINE(  73)			if (::hx::IsNotEq( phi,0 )) {
HXLINE(  73)				Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN(  73)				Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN(  73)				{
HXLINE(  73)					int _g = 0;
HXDLIN(  73)					int _g1 = 37;
HXDLIN(  73)					while((_g < _g1)){
HXLINE(  73)						_g = (_g + 1);
HXDLIN(  73)						int i = (_g - 1);
HXDLIN(  73)						Float stheta = ::Math_obj::sin(((( (Float)(i) ) * theta) + omega));
HXDLIN(  73)						Float ctheta = ::Math_obj::cos(((( (Float)(i) ) * theta) + omega));
HXDLIN(  73)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN(  73)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN(  73)						{
HXLINE(  73)							bool hasHit = false;
HXDLIN(  73)							bool hasUndo = false;
HXDLIN(  73)							int aA = ((colorOut >> 24) & 255);
HXDLIN(  73)							int rA = ((colorOut >> 16) & 255);
HXDLIN(  73)							int gA = ((colorOut >> 8) & 255);
HXDLIN(  73)							int bA = (colorOut & 255);
HXDLIN(  73)							int aB = ((colorIn >> 24) & 255);
HXDLIN(  73)							int rB = ((colorIn >> 16) & 255);
HXDLIN(  73)							int gB = ((colorIn >> 8) & 255);
HXDLIN(  73)							int bB = (colorIn & 255);
HXDLIN(  73)							int aC = ((colorOut >> 24) & 255);
HXDLIN(  73)							int rC = ((colorOut >> 16) & 255);
HXDLIN(  73)							int gC = ((colorOut >> 8) & 255);
HXDLIN(  73)							int bC = (colorOut & 255);
HXDLIN(  73)							Float bcx = (lastX - nextX);
HXDLIN(  73)							Float bcy = (lastY - nextY);
HXDLIN(  73)							Float acx = (mx - nextX);
HXDLIN(  73)							Float acy = (my - nextY);
HXDLIN(  73)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  73)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  73)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  73)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  73)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  73)							if ((mx > lastX)) {
HXLINE(  73)								if ((mx > nextX)) {
HXLINE(  73)									int min;
HXDLIN(  73)									if ((lastX > nextX)) {
HXLINE(  73)										min = ::Math_obj::floor(nextX);
            									}
            									else {
HXLINE(  73)										min = ::Math_obj::floor(lastX);
            									}
HXDLIN(  73)									int ii_min = min;
HXDLIN(  73)									int ii_max = ::Math_obj::ceil(mx);
HXDLIN(  73)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)									xIter3 = this1;
            								}
            								else {
HXLINE(  73)									int ii_min = ::Math_obj::floor(lastX);
HXDLIN(  73)									int ii_max = ::Math_obj::ceil(nextX);
HXDLIN(  73)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  73)								if ((lastX > nextX)) {
HXLINE(  73)									int min;
HXDLIN(  73)									if ((mx > nextX)) {
HXLINE(  73)										min = ::Math_obj::floor(nextX);
            									}
            									else {
HXLINE(  73)										min = ::Math_obj::ceil(mx);
            									}
HXDLIN(  73)									int ii_min = min;
HXDLIN(  73)									int ii_max = ::Math_obj::ceil(lastX);
HXDLIN(  73)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)									xIter3 = this1;
            								}
            								else {
HXLINE(  73)									int ii_min = ::Math_obj::floor(mx);
HXDLIN(  73)									int ii_max = ::Math_obj::ceil(nextX);
HXDLIN(  73)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)									xIter3 = this1;
            								}
            							}
HXDLIN(  73)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  73)							if ((my > lastY)) {
HXLINE(  73)								if ((my > nextY)) {
HXLINE(  73)									int min;
HXDLIN(  73)									if ((lastY > nextY)) {
HXLINE(  73)										min = ::Math_obj::floor(nextY);
            									}
            									else {
HXLINE(  73)										min = ::Math_obj::floor(lastY);
            									}
HXDLIN(  73)									int ii_min = min;
HXDLIN(  73)									int ii_max = ::Math_obj::ceil(my);
HXDLIN(  73)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)									yIter3 = this1;
            								}
            								else {
HXLINE(  73)									int ii_min = ::Math_obj::floor(lastY);
HXDLIN(  73)									int ii_max = ::Math_obj::ceil(nextY);
HXDLIN(  73)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  73)								if ((lastY > nextY)) {
HXLINE(  73)									int min;
HXDLIN(  73)									if ((my > nextY)) {
HXLINE(  73)										min = ::Math_obj::floor(nextY);
            									}
            									else {
HXLINE(  73)										min = ::Math_obj::ceil(my);
            									}
HXDLIN(  73)									int ii_min = min;
HXDLIN(  73)									int ii_max = ::Math_obj::ceil(lastY);
HXDLIN(  73)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)									yIter3 = this1;
            								}
            								else {
HXLINE(  73)									int ii_min = ::Math_obj::floor(my);
HXDLIN(  73)									int ii_max = ::Math_obj::ceil(nextY);
HXDLIN(  73)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)									yIter3 = this1;
            								}
            							}
HXDLIN(  73)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  73)							if (hasUndo) {
HXLINE(  73)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  73)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  73)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  73)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  73)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  73)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  73)								undoImage = this3;
HXDLIN(  73)								{
HXLINE(  73)									int rectLeft = xIter3->start;
HXDLIN(  73)									int rectTop = yIter3->start;
HXDLIN(  73)									int rectRight = xIter3->max;
HXDLIN(  73)									bool forceClear = false;
HXDLIN(  73)									{
HXLINE(  73)										int _g = rectTop;
HXDLIN(  73)										int _g1 = yIter3->max;
HXDLIN(  73)										while((_g < _g1)){
HXLINE(  73)											_g = (_g + 1);
HXDLIN(  73)											int dy = (_g - 1);
HXDLIN(  73)											{
HXLINE(  73)												int _g1 = rectLeft;
HXDLIN(  73)												int _g2 = rectRight;
HXDLIN(  73)												while((_g1 < _g2)){
HXLINE(  73)													_g1 = (_g1 + 1);
HXDLIN(  73)													int dx = (_g1 - 1);
HXDLIN(  73)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  73)													int index;
HXDLIN(  73)													if (temp->useVirtualPos) {
HXLINE(  73)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE(  73)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN(  73)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)													int col;
HXDLIN(  73)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  73)														col = c;
            													}
HXDLIN(  73)													bool _hx_tmp;
HXDLIN(  73)													if (temp->useMask) {
HXLINE(  73)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE(  73)														_hx_tmp = false;
            													}
HXDLIN(  73)													if (_hx_tmp) {
HXLINE(  73)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  73)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  73)														int index;
HXDLIN(  73)														if (this1->useVirtualPos) {
HXLINE(  73)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  73)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  73)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  73)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  73)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)														int v;
HXDLIN(  73)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  73)															v = c;
            														}
HXDLIN(  73)														int this3 = v;
HXDLIN(  73)														int maskPixel = this3;
HXDLIN(  73)														int this4 = col;
HXDLIN(  73)														int this5 = this4;
HXDLIN(  73)														if ((maskPixel == 0)) {
HXLINE(  73)															int this1 = this5;
HXDLIN(  73)															col = this1;
            														}
            														else {
HXLINE(  73)															Float m0;
HXDLIN(  73)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  73)															if ((this1 == 0)) {
HXLINE(  73)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float m1;
HXDLIN(  73)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  73)															if ((this2 == 0)) {
HXLINE(  73)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float m2;
HXDLIN(  73)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  73)															if ((this3 == 0)) {
HXLINE(  73)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float m3;
HXDLIN(  73)															int this4 = (maskPixel & 255);
HXDLIN(  73)															if ((this4 == 0)) {
HXLINE(  73)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  73)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  73)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  73)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  73)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  73)													if ((col != 0)) {
HXLINE(  73)														int x = (dx - rectLeft);
HXDLIN(  73)														int y = (dy - rectTop);
HXDLIN(  73)														int this1 = col;
HXDLIN(  73)														int c = this1;
HXDLIN(  73)														bool _hx_tmp;
HXDLIN(  73)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  73)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE(  73)															_hx_tmp = false;
            														}
HXDLIN(  73)														if (_hx_tmp) {
HXLINE(  73)															int location;
HXDLIN(  73)															if (undoImage->useVirtualPos) {
HXLINE(  73)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  73)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  73)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)															int this3 = this2;
HXDLIN(  73)															int this4;
HXDLIN(  73)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  73)																this4 = this3;
            															}
HXDLIN(  73)															Float a1;
HXDLIN(  73)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  73)															if ((this5 == 0)) {
HXLINE(  73)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float r1;
HXDLIN(  73)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  73)															if ((this6 == 0)) {
HXLINE(  73)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float g1;
HXDLIN(  73)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  73)															if ((this7 == 0)) {
HXLINE(  73)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float b1;
HXDLIN(  73)															int this8 = (this4 & 255);
HXDLIN(  73)															if ((this8 == 0)) {
HXLINE(  73)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float a2;
HXDLIN(  73)															int this9 = ((col >> 24) & 255);
HXDLIN(  73)															if ((this9 == 0)) {
HXLINE(  73)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float r2;
HXDLIN(  73)															int this10 = ((col >> 16) & 255);
HXDLIN(  73)															if ((this10 == 0)) {
HXLINE(  73)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float g2;
HXDLIN(  73)															int this11 = ((col >> 8) & 255);
HXDLIN(  73)															if ((this11 == 0)) {
HXLINE(  73)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float b2;
HXDLIN(  73)															int this12 = (col & 255);
HXDLIN(  73)															if ((this12 == 0)) {
HXLINE(  73)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  73)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  73)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  73)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  73)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  73)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  73)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  73)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  73)															{
HXLINE(  73)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  73)																int value;
HXDLIN(  73)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  73)																	value = blended;
            																}
HXDLIN(  73)																bool _hx_tmp;
HXDLIN(  73)																if ((location >= 0)) {
HXLINE(  73)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  73)																	_hx_tmp = false;
            																}
HXDLIN(  73)																if (_hx_tmp) {
HXLINE(  73)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  73)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  73)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  73)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)															int index;
HXDLIN(  73)															if (undoImage->useVirtualPos) {
HXLINE(  73)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  73)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  73)															int value;
HXDLIN(  73)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  73)																value = c;
            															}
HXDLIN(  73)															bool _hx_tmp;
HXDLIN(  73)															if ((index >= 0)) {
HXLINE(  73)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  73)																_hx_tmp = false;
            															}
HXDLIN(  73)															if (_hx_tmp) {
HXLINE(  73)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  73)														if (forceClear) {
HXLINE(  73)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)															int x = (dx - rectLeft);
HXDLIN(  73)															int y = (dy - rectTop);
HXDLIN(  73)															int index;
HXDLIN(  73)															if (undoImage->useVirtualPos) {
HXLINE(  73)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  73)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  73)															bool _hx_tmp;
HXDLIN(  73)															if ((index >= 0)) {
HXLINE(  73)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  73)																_hx_tmp = false;
            															}
HXDLIN(  73)															if (_hx_tmp) {
HXLINE(  73)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  73)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  73)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  73)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  73)							{
HXLINE(  73)								int _g_min = xIter3->start;
HXDLIN(  73)								int _g_max = xIter3->max;
HXDLIN(  73)								while((_g_min < _g_max)){
HXLINE(  73)									_g_min = (_g_min + 1);
HXDLIN(  73)									int px = (_g_min - 1);
HXDLIN(  73)									Float pcx = (( (Float)(px) ) - nextX);
HXDLIN(  73)									{
HXLINE(  73)										int _g_min1 = yIter3->start;
HXDLIN(  73)										int _g_max = yIter3->max;
HXDLIN(  73)										while((_g_min1 < _g_max)){
HXLINE(  73)											_g_min1 = (_g_min1 + 1);
HXDLIN(  73)											int py = (_g_min1 - 1);
HXDLIN(  73)											Float pcy = (( (Float)(py) ) - nextY);
HXDLIN(  73)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  73)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  73)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  73)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  73)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  73)											bool _hx_tmp;
HXDLIN(  73)											bool _hx_tmp1;
HXDLIN(  73)											if ((ratioA >= 0)) {
HXLINE(  73)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  73)												_hx_tmp1 = false;
            											}
HXDLIN(  73)											if (_hx_tmp1) {
HXLINE(  73)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  73)												_hx_tmp = false;
            											}
HXDLIN(  73)											if (_hx_tmp) {
HXLINE(  73)												int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												int a = this1;
HXDLIN(  73)												int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  73)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  73)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  73)												int this2 = i1;
HXDLIN(  73)												int r = this2;
HXDLIN(  73)												int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  73)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  73)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  73)												int this3 = i2;
HXDLIN(  73)												int g = this3;
HXDLIN(  73)												int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  73)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  73)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  73)												int this4 = i3;
HXDLIN(  73)												int b = this4;
HXDLIN(  73)												{
HXLINE(  73)													int location;
HXDLIN(  73)													if (temp->useVirtualPos) {
HXLINE(  73)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - temp->virtualY) * ( (Float)(temp->width) )) + px) - temp->virtualX));
            													}
            													else {
HXLINE(  73)														location = ::Std_obj::_hx_int(( (Float)(((py * temp->width) + px)) ));
            													}
HXDLIN(  73)													bool _hx_tmp;
HXDLIN(  73)													if (temp->transparent) {
HXLINE(  73)														_hx_tmp = (a < 254);
            													}
            													else {
HXLINE(  73)														_hx_tmp = false;
            													}
HXDLIN(  73)													if (_hx_tmp) {
HXLINE(  73)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  73)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)														int this3 = this2;
HXDLIN(  73)														int old;
HXDLIN(  73)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  73)															old = this3;
            														}
HXDLIN(  73)														int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  73)														Float a1;
HXDLIN(  73)														int this4 = ((old >> 24) & 255);
HXDLIN(  73)														if ((this4 == 0)) {
HXLINE(  73)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float r1;
HXDLIN(  73)														int this5 = ((old >> 16) & 255);
HXDLIN(  73)														if ((this5 == 0)) {
HXLINE(  73)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float g1;
HXDLIN(  73)														int this6 = ((old >> 8) & 255);
HXDLIN(  73)														if ((this6 == 0)) {
HXLINE(  73)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float b1;
HXDLIN(  73)														int this7 = (old & 255);
HXDLIN(  73)														if ((this7 == 0)) {
HXLINE(  73)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float a2;
HXDLIN(  73)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  73)														if ((this8 == 0)) {
HXLINE(  73)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float r2;
HXDLIN(  73)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  73)														if ((this9 == 0)) {
HXLINE(  73)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float g2;
HXDLIN(  73)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  73)														if ((this10 == 0)) {
HXLINE(  73)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float b2;
HXDLIN(  73)														int this11 = (rhs & 255);
HXDLIN(  73)														if ((this11 == 0)) {
HXLINE(  73)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  73)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  73)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  73)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  73)														int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  73)														int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  73)														{
HXLINE(  73)															::haxe::io::ArrayBufferViewImpl this12 = temp->image;
HXDLIN(  73)															int value;
HXDLIN(  73)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  73)																value = blended;
            															}
HXDLIN(  73)															bool _hx_tmp;
HXDLIN(  73)															if ((location >= 0)) {
HXLINE(  73)																_hx_tmp = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  73)																_hx_tmp = false;
            															}
HXDLIN(  73)															if (_hx_tmp) {
HXLINE(  73)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  73)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  73)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  73)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  73)														int value;
HXDLIN(  73)														if (temp->isLittle) {
HXLINE(  73)															value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            														}
            														else {
HXLINE(  73)															value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            														}
HXDLIN(  73)														bool _hx_tmp;
HXDLIN(  73)														if ((location >= 0)) {
HXLINE(  73)															_hx_tmp = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  73)															_hx_tmp = false;
            														}
HXDLIN(  73)														if (_hx_tmp) {
HXLINE(  73)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  73)							if ((hasHit == false)) {
HXLINE(  73)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX,nextY,true);
HXDLIN(  73)								if (hasUndo) {
HXLINE(  73)									v->undoImage = undoImage;
HXDLIN(  73)									v->undoX = xIter3->start;
HXDLIN(  73)									v->undoY = yIter3->start;
            								}
            							}
            						}
HXLINE( 236)						lastX = nextX;
HXLINE( 237)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXLINE(  73)				int _g = 0;
HXDLIN(  73)				int _g1 = 37;
HXDLIN(  73)				while((_g < _g1)){
HXLINE(  73)					_g = (_g + 1);
HXDLIN(  73)					int i = (_g - 1);
HXDLIN(  73)					Float nextX = (cx + (rx * ::Math_obj::cos(((( (Float)(i) ) * theta) + omega))));
HXDLIN(  73)					Float nextY = (cy + (ry * ::Math_obj::sin(((( (Float)(i) ) * theta) + omega))));
HXDLIN(  73)					{
HXLINE(  73)						bool hasHit = false;
HXDLIN(  73)						bool hasUndo = false;
HXDLIN(  73)						int aA = ((colorOut >> 24) & 255);
HXDLIN(  73)						int rA = ((colorOut >> 16) & 255);
HXDLIN(  73)						int gA = ((colorOut >> 8) & 255);
HXDLIN(  73)						int bA = (colorOut & 255);
HXDLIN(  73)						int aB = ((colorIn >> 24) & 255);
HXDLIN(  73)						int rB = ((colorIn >> 16) & 255);
HXDLIN(  73)						int gB = ((colorIn >> 8) & 255);
HXDLIN(  73)						int bB = (colorIn & 255);
HXDLIN(  73)						int aC = ((colorOut >> 24) & 255);
HXDLIN(  73)						int rC = ((colorOut >> 16) & 255);
HXDLIN(  73)						int gC = ((colorOut >> 8) & 255);
HXDLIN(  73)						int bC = (colorOut & 255);
HXDLIN(  73)						Float bcx = (lastX - nextX);
HXDLIN(  73)						Float bcy = (lastY - nextY);
HXDLIN(  73)						Float acx = (mx - nextX);
HXDLIN(  73)						Float acy = (my - nextY);
HXDLIN(  73)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  73)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  73)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  73)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  73)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  73)						if ((mx > lastX)) {
HXLINE(  73)							if ((mx > nextX)) {
HXLINE(  73)								int min;
HXDLIN(  73)								if ((lastX > nextX)) {
HXLINE(  73)									min = ::Math_obj::floor(nextX);
            								}
            								else {
HXLINE(  73)									min = ::Math_obj::floor(lastX);
            								}
HXDLIN(  73)								int ii_min = min;
HXDLIN(  73)								int ii_max = ::Math_obj::ceil(mx);
HXDLIN(  73)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)								xIter3 = this1;
            							}
            							else {
HXLINE(  73)								int ii_min = ::Math_obj::floor(lastX);
HXDLIN(  73)								int ii_max = ::Math_obj::ceil(nextX);
HXDLIN(  73)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  73)							if ((lastX > nextX)) {
HXLINE(  73)								int min;
HXDLIN(  73)								if ((mx > nextX)) {
HXLINE(  73)									min = ::Math_obj::floor(nextX);
            								}
            								else {
HXLINE(  73)									min = ::Math_obj::ceil(mx);
            								}
HXDLIN(  73)								int ii_min = min;
HXDLIN(  73)								int ii_max = ::Math_obj::ceil(lastX);
HXDLIN(  73)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)								xIter3 = this1;
            							}
            							else {
HXLINE(  73)								int ii_min = ::Math_obj::floor(mx);
HXDLIN(  73)								int ii_max = ::Math_obj::ceil(nextX);
HXDLIN(  73)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)								xIter3 = this1;
            							}
            						}
HXDLIN(  73)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  73)						if ((my > lastY)) {
HXLINE(  73)							if ((my > nextY)) {
HXLINE(  73)								int min;
HXDLIN(  73)								if ((lastY > nextY)) {
HXLINE(  73)									min = ::Math_obj::floor(nextY);
            								}
            								else {
HXLINE(  73)									min = ::Math_obj::floor(lastY);
            								}
HXDLIN(  73)								int ii_min = min;
HXDLIN(  73)								int ii_max = ::Math_obj::ceil(my);
HXDLIN(  73)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)								yIter3 = this1;
            							}
            							else {
HXLINE(  73)								int ii_min = ::Math_obj::floor(lastY);
HXDLIN(  73)								int ii_max = ::Math_obj::ceil(nextY);
HXDLIN(  73)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  73)							if ((lastY > nextY)) {
HXLINE(  73)								int min;
HXDLIN(  73)								if ((my > nextY)) {
HXLINE(  73)									min = ::Math_obj::floor(nextY);
            								}
            								else {
HXLINE(  73)									min = ::Math_obj::ceil(my);
            								}
HXDLIN(  73)								int ii_min = min;
HXDLIN(  73)								int ii_max = ::Math_obj::ceil(lastY);
HXDLIN(  73)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)								yIter3 = this1;
            							}
            							else {
HXLINE(  73)								int ii_min = ::Math_obj::floor(my);
HXDLIN(  73)								int ii_max = ::Math_obj::ceil(nextY);
HXDLIN(  73)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)								yIter3 = this1;
            							}
            						}
HXDLIN(  73)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  73)						if (hasUndo) {
HXLINE(  73)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  73)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  73)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  73)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  73)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  73)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  73)							undoImage = this3;
HXDLIN(  73)							{
HXLINE(  73)								int rectLeft = xIter3->start;
HXDLIN(  73)								int rectTop = yIter3->start;
HXDLIN(  73)								int rectRight = xIter3->max;
HXDLIN(  73)								bool forceClear = false;
HXDLIN(  73)								{
HXLINE(  73)									int _g = rectTop;
HXDLIN(  73)									int _g1 = yIter3->max;
HXDLIN(  73)									while((_g < _g1)){
HXLINE(  73)										_g = (_g + 1);
HXDLIN(  73)										int dy = (_g - 1);
HXDLIN(  73)										{
HXLINE(  73)											int _g1 = rectLeft;
HXDLIN(  73)											int _g2 = rectRight;
HXDLIN(  73)											while((_g1 < _g2)){
HXLINE(  73)												_g1 = (_g1 + 1);
HXDLIN(  73)												int dx = (_g1 - 1);
HXDLIN(  73)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  73)												int index;
HXDLIN(  73)												if (temp->useVirtualPos) {
HXLINE(  73)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE(  73)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN(  73)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)												int col;
HXDLIN(  73)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  73)													col = c;
            												}
HXDLIN(  73)												bool _hx_tmp;
HXDLIN(  73)												if (temp->useMask) {
HXLINE(  73)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  73)													_hx_tmp = false;
            												}
HXDLIN(  73)												if (_hx_tmp) {
HXLINE(  73)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  73)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  73)													int index;
HXDLIN(  73)													if (this1->useVirtualPos) {
HXLINE(  73)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  73)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  73)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  73)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  73)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)													int v;
HXDLIN(  73)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  73)														v = c;
            													}
HXDLIN(  73)													int this3 = v;
HXDLIN(  73)													int maskPixel = this3;
HXDLIN(  73)													int this4 = col;
HXDLIN(  73)													int this5 = this4;
HXDLIN(  73)													if ((maskPixel == 0)) {
HXLINE(  73)														int this1 = this5;
HXDLIN(  73)														col = this1;
            													}
            													else {
HXLINE(  73)														Float m0;
HXDLIN(  73)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  73)														if ((this1 == 0)) {
HXLINE(  73)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float m1;
HXDLIN(  73)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  73)														if ((this2 == 0)) {
HXLINE(  73)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float m2;
HXDLIN(  73)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  73)														if ((this3 == 0)) {
HXLINE(  73)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float m3;
HXDLIN(  73)														int this4 = (maskPixel & 255);
HXDLIN(  73)														if ((this4 == 0)) {
HXLINE(  73)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  73)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  73)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  73)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  73)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  73)												if ((col != 0)) {
HXLINE(  73)													int x = (dx - rectLeft);
HXDLIN(  73)													int y = (dy - rectTop);
HXDLIN(  73)													int this1 = col;
HXDLIN(  73)													int c = this1;
HXDLIN(  73)													bool _hx_tmp;
HXDLIN(  73)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  73)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  73)														_hx_tmp = false;
            													}
HXDLIN(  73)													if (_hx_tmp) {
HXLINE(  73)														int location;
HXDLIN(  73)														if (undoImage->useVirtualPos) {
HXLINE(  73)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  73)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  73)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)														int this3 = this2;
HXDLIN(  73)														int this4;
HXDLIN(  73)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  73)															this4 = this3;
            														}
HXDLIN(  73)														Float a1;
HXDLIN(  73)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  73)														if ((this5 == 0)) {
HXLINE(  73)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float r1;
HXDLIN(  73)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  73)														if ((this6 == 0)) {
HXLINE(  73)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float g1;
HXDLIN(  73)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  73)														if ((this7 == 0)) {
HXLINE(  73)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float b1;
HXDLIN(  73)														int this8 = (this4 & 255);
HXDLIN(  73)														if ((this8 == 0)) {
HXLINE(  73)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float a2;
HXDLIN(  73)														int this9 = ((col >> 24) & 255);
HXDLIN(  73)														if ((this9 == 0)) {
HXLINE(  73)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float r2;
HXDLIN(  73)														int this10 = ((col >> 16) & 255);
HXDLIN(  73)														if ((this10 == 0)) {
HXLINE(  73)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float g2;
HXDLIN(  73)														int this11 = ((col >> 8) & 255);
HXDLIN(  73)														if ((this11 == 0)) {
HXLINE(  73)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float b2;
HXDLIN(  73)														int this12 = (col & 255);
HXDLIN(  73)														if ((this12 == 0)) {
HXLINE(  73)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  73)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  73)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  73)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  73)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  73)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  73)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  73)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  73)														{
HXLINE(  73)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  73)															int value;
HXDLIN(  73)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  73)																value = blended;
            															}
HXDLIN(  73)															bool _hx_tmp;
HXDLIN(  73)															if ((location >= 0)) {
HXLINE(  73)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  73)																_hx_tmp = false;
            															}
HXDLIN(  73)															if (_hx_tmp) {
HXLINE(  73)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  73)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  73)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  73)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)														int index;
HXDLIN(  73)														if (undoImage->useVirtualPos) {
HXLINE(  73)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  73)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  73)														int value;
HXDLIN(  73)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  73)															value = c;
            														}
HXDLIN(  73)														bool _hx_tmp;
HXDLIN(  73)														if ((index >= 0)) {
HXLINE(  73)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  73)															_hx_tmp = false;
            														}
HXDLIN(  73)														if (_hx_tmp) {
HXLINE(  73)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  73)													if (forceClear) {
HXLINE(  73)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)														int x = (dx - rectLeft);
HXDLIN(  73)														int y = (dy - rectTop);
HXDLIN(  73)														int index;
HXDLIN(  73)														if (undoImage->useVirtualPos) {
HXLINE(  73)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  73)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  73)														bool _hx_tmp;
HXDLIN(  73)														if ((index >= 0)) {
HXLINE(  73)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  73)															_hx_tmp = false;
            														}
HXDLIN(  73)														if (_hx_tmp) {
HXLINE(  73)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  73)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  73)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  73)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  73)						{
HXLINE(  73)							int _g_min = xIter3->start;
HXDLIN(  73)							int _g_max = xIter3->max;
HXDLIN(  73)							while((_g_min < _g_max)){
HXLINE(  73)								_g_min = (_g_min + 1);
HXDLIN(  73)								int px = (_g_min - 1);
HXDLIN(  73)								Float pcx = (( (Float)(px) ) - nextX);
HXDLIN(  73)								{
HXLINE(  73)									int _g_min1 = yIter3->start;
HXDLIN(  73)									int _g_max = yIter3->max;
HXDLIN(  73)									while((_g_min1 < _g_max)){
HXLINE(  73)										_g_min1 = (_g_min1 + 1);
HXDLIN(  73)										int py = (_g_min1 - 1);
HXDLIN(  73)										Float pcy = (( (Float)(py) ) - nextY);
HXDLIN(  73)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  73)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  73)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  73)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  73)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  73)										bool _hx_tmp;
HXDLIN(  73)										bool _hx_tmp1;
HXDLIN(  73)										if ((ratioA >= 0)) {
HXLINE(  73)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  73)											_hx_tmp1 = false;
            										}
HXDLIN(  73)										if (_hx_tmp1) {
HXLINE(  73)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  73)											_hx_tmp = false;
            										}
HXDLIN(  73)										if (_hx_tmp) {
HXLINE(  73)											int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  73)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  73)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  73)											int this1 = i;
HXDLIN(  73)											int a = this1;
HXDLIN(  73)											int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  73)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  73)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  73)											int this2 = i1;
HXDLIN(  73)											int r = this2;
HXDLIN(  73)											int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  73)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  73)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  73)											int this3 = i2;
HXDLIN(  73)											int g = this3;
HXDLIN(  73)											int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  73)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  73)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  73)											int this4 = i3;
HXDLIN(  73)											int b = this4;
HXDLIN(  73)											{
HXLINE(  73)												int location;
HXDLIN(  73)												if (temp->useVirtualPos) {
HXLINE(  73)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - temp->virtualY) * ( (Float)(temp->width) )) + px) - temp->virtualX));
            												}
            												else {
HXLINE(  73)													location = ::Std_obj::_hx_int(( (Float)(((py * temp->width) + px)) ));
            												}
HXDLIN(  73)												bool _hx_tmp;
HXDLIN(  73)												if (temp->transparent) {
HXLINE(  73)													_hx_tmp = (a < 254);
            												}
            												else {
HXLINE(  73)													_hx_tmp = false;
            												}
HXDLIN(  73)												if (_hx_tmp) {
HXLINE(  73)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  73)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)													int this3 = this2;
HXDLIN(  73)													int old;
HXDLIN(  73)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  73)														old = this3;
            													}
HXDLIN(  73)													int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  73)													Float a1;
HXDLIN(  73)													int this4 = ((old >> 24) & 255);
HXDLIN(  73)													if ((this4 == 0)) {
HXLINE(  73)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  73)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  73)													Float r1;
HXDLIN(  73)													int this5 = ((old >> 16) & 255);
HXDLIN(  73)													if ((this5 == 0)) {
HXLINE(  73)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  73)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  73)													Float g1;
HXDLIN(  73)													int this6 = ((old >> 8) & 255);
HXDLIN(  73)													if ((this6 == 0)) {
HXLINE(  73)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  73)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  73)													Float b1;
HXDLIN(  73)													int this7 = (old & 255);
HXDLIN(  73)													if ((this7 == 0)) {
HXLINE(  73)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  73)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  73)													Float a2;
HXDLIN(  73)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  73)													if ((this8 == 0)) {
HXLINE(  73)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  73)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  73)													Float r2;
HXDLIN(  73)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  73)													if ((this9 == 0)) {
HXLINE(  73)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  73)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  73)													Float g2;
HXDLIN(  73)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  73)													if ((this10 == 0)) {
HXLINE(  73)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  73)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  73)													Float b2;
HXDLIN(  73)													int this11 = (rhs & 255);
HXDLIN(  73)													if ((this11 == 0)) {
HXLINE(  73)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  73)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  73)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  73)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  73)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  73)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  73)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  73)													int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  73)													{
HXLINE(  73)														::haxe::io::ArrayBufferViewImpl this12 = temp->image;
HXDLIN(  73)														int value;
HXDLIN(  73)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  73)															value = blended;
            														}
HXDLIN(  73)														bool _hx_tmp;
HXDLIN(  73)														if ((location >= 0)) {
HXLINE(  73)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  73)															_hx_tmp = false;
            														}
HXDLIN(  73)														if (_hx_tmp) {
HXLINE(  73)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  73)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  73)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  73)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  73)													int value;
HXDLIN(  73)													if (temp->isLittle) {
HXLINE(  73)														value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  73)														value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  73)													bool _hx_tmp;
HXDLIN(  73)													if ((location >= 0)) {
HXLINE(  73)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  73)														_hx_tmp = false;
            													}
HXDLIN(  73)													if (_hx_tmp) {
HXLINE(  73)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  73)						if ((hasHit == false)) {
HXLINE(  73)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX,nextY,true);
HXDLIN(  73)							if (hasUndo) {
HXLINE(  73)								v->undoImage = undoImage;
HXDLIN(  73)								v->undoX = xIter3->start;
HXDLIN(  73)								v->undoY = yIter3->start;
            							}
            						}
            					}
HXLINE( 244)					lastX = nextX;
HXLINE( 245)					lastY = nextY;
            				}
            			}
            		}
HXLINE(  74)		if ((this->rotation == 0)) {
HXLINE(  75)			int x = ::Std_obj::_hx_int((this->centreX - this->radiusX));
HXDLIN(  75)			int y = ::Std_obj::_hx_int((this->centreY - this->radiusY));
HXDLIN(  75)			bool forceClear = false;
HXDLIN(  75)			{
HXLINE(  75)				int _g = 0;
HXDLIN(  75)				int _g1 = temp->height;
HXDLIN(  75)				while((_g < _g1)){
HXLINE(  75)					_g = (_g + 1);
HXDLIN(  75)					int dy = (_g - 1);
HXDLIN(  75)					{
HXLINE(  75)						int _g1 = 0;
HXDLIN(  75)						int _g2 = temp->width;
HXDLIN(  75)						while((_g1 < _g2)){
HXLINE(  75)							_g1 = (_g1 + 1);
HXDLIN(  75)							int dx = (_g1 - 1);
HXDLIN(  75)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  75)							int index;
HXDLIN(  75)							if (temp->useVirtualPos) {
HXLINE(  75)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  75)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  75)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)							int col;
HXDLIN(  75)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  75)								col = c;
            							}
HXDLIN(  75)							bool _hx_tmp;
HXDLIN(  75)							if (temp->useMask) {
HXLINE(  75)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  75)								_hx_tmp = false;
            							}
HXDLIN(  75)							if (_hx_tmp) {
HXLINE(  75)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  75)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  75)								int index;
HXDLIN(  75)								if (this1->useVirtualPos) {
HXLINE(  75)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  75)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  75)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  75)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  75)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)								int v;
HXDLIN(  75)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  75)									v = c;
            								}
HXDLIN(  75)								int this3 = v;
HXDLIN(  75)								int maskPixel = this3;
HXDLIN(  75)								int this4 = col;
HXDLIN(  75)								int this5 = this4;
HXDLIN(  75)								if ((maskPixel == 0)) {
HXLINE(  75)									int this1 = this5;
HXDLIN(  75)									col = this1;
            								}
            								else {
HXLINE(  75)									Float m0;
HXDLIN(  75)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  75)									if ((this1 == 0)) {
HXLINE(  75)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float m1;
HXDLIN(  75)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  75)									if ((this2 == 0)) {
HXLINE(  75)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float m2;
HXDLIN(  75)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  75)									if ((this3 == 0)) {
HXLINE(  75)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float m3;
HXDLIN(  75)									int this4 = (maskPixel & 255);
HXDLIN(  75)									if ((this4 == 0)) {
HXLINE(  75)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  75)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  75)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  75)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  75)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  75)							if ((col != 0)) {
HXLINE(  75)								int x1 = (x + dx);
HXDLIN(  75)								int y1 = (y + dy);
HXDLIN(  75)								int this1 = col;
HXDLIN(  75)								int c = this1;
HXDLIN(  75)								bool _hx_tmp;
HXDLIN(  75)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  75)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  75)									_hx_tmp = false;
            								}
HXDLIN(  75)								if (_hx_tmp) {
HXLINE(  75)									int location;
HXDLIN(  75)									if (pixelShape->useVirtualPos) {
HXLINE(  75)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  75)										location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  75)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)									int this3 = this2;
HXDLIN(  75)									int this4;
HXDLIN(  75)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  75)										this4 = this3;
            									}
HXDLIN(  75)									Float a1;
HXDLIN(  75)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  75)									if ((this5 == 0)) {
HXLINE(  75)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float r1;
HXDLIN(  75)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  75)									if ((this6 == 0)) {
HXLINE(  75)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float g1;
HXDLIN(  75)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  75)									if ((this7 == 0)) {
HXLINE(  75)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float b1;
HXDLIN(  75)									int this8 = (this4 & 255);
HXDLIN(  75)									if ((this8 == 0)) {
HXLINE(  75)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float a2;
HXDLIN(  75)									int this9 = ((col >> 24) & 255);
HXDLIN(  75)									if ((this9 == 0)) {
HXLINE(  75)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float r2;
HXDLIN(  75)									int this10 = ((col >> 16) & 255);
HXDLIN(  75)									if ((this10 == 0)) {
HXLINE(  75)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float g2;
HXDLIN(  75)									int this11 = ((col >> 8) & 255);
HXDLIN(  75)									if ((this11 == 0)) {
HXLINE(  75)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float b2;
HXDLIN(  75)									int this12 = (col & 255);
HXDLIN(  75)									if ((this12 == 0)) {
HXLINE(  75)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  75)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  75)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  75)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  75)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  75)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  75)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  75)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)									{
HXLINE(  75)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  75)										int value;
HXDLIN(  75)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  75)											value = blended;
            										}
HXDLIN(  75)										bool _hx_tmp;
HXDLIN(  75)										if ((location >= 0)) {
HXLINE(  75)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  75)											_hx_tmp = false;
            										}
HXDLIN(  75)										if (_hx_tmp) {
HXLINE(  75)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  75)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  75)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  75)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)									int index;
HXDLIN(  75)									if (pixelShape->useVirtualPos) {
HXLINE(  75)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  75)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  75)									int value;
HXDLIN(  75)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  75)										value = c;
            									}
HXDLIN(  75)									bool _hx_tmp;
HXDLIN(  75)									if ((index >= 0)) {
HXLINE(  75)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  75)										_hx_tmp = false;
            									}
HXDLIN(  75)									if (_hx_tmp) {
HXLINE(  75)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  75)								if (forceClear) {
HXLINE(  75)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)									int x1 = (x + dx);
HXDLIN(  75)									int y1 = (y + dy);
HXDLIN(  75)									int index;
HXDLIN(  75)									if (pixelShape->useVirtualPos) {
HXLINE(  75)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  75)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  75)									bool _hx_tmp;
HXDLIN(  75)									if ((index >= 0)) {
HXLINE(  75)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  75)										_hx_tmp = false;
            									}
HXDLIN(  75)									if (_hx_tmp) {
HXLINE(  75)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  75)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  75)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  75)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE(  77)			int x = ::Std_obj::_hx_int(((this->centreX - this->radiusX) - rDif));
HXDLIN(  77)			int y = ::Std_obj::_hx_int(((this->centreY - this->radiusY) - rDif));
HXDLIN(  77)			bool forceClear = false;
HXDLIN(  77)			{
HXLINE(  77)				int _g = 0;
HXDLIN(  77)				int _g1 = temp->height;
HXDLIN(  77)				while((_g < _g1)){
HXLINE(  77)					_g = (_g + 1);
HXDLIN(  77)					int dy = (_g - 1);
HXDLIN(  77)					{
HXLINE(  77)						int _g1 = 0;
HXDLIN(  77)						int _g2 = temp->width;
HXDLIN(  77)						while((_g1 < _g2)){
HXLINE(  77)							_g1 = (_g1 + 1);
HXDLIN(  77)							int dx = (_g1 - 1);
HXDLIN(  77)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  77)							int index;
HXDLIN(  77)							if (temp->useVirtualPos) {
HXLINE(  77)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  77)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  77)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)							int col;
HXDLIN(  77)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  77)								col = c;
            							}
HXDLIN(  77)							bool _hx_tmp;
HXDLIN(  77)							if (temp->useMask) {
HXLINE(  77)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  77)								_hx_tmp = false;
            							}
HXDLIN(  77)							if (_hx_tmp) {
HXLINE(  77)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  77)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  77)								int index;
HXDLIN(  77)								if (this1->useVirtualPos) {
HXLINE(  77)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  77)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  77)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  77)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  77)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)								int v;
HXDLIN(  77)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  77)									v = c;
            								}
HXDLIN(  77)								int this3 = v;
HXDLIN(  77)								int maskPixel = this3;
HXDLIN(  77)								int this4 = col;
HXDLIN(  77)								int this5 = this4;
HXDLIN(  77)								if ((maskPixel == 0)) {
HXLINE(  77)									int this1 = this5;
HXDLIN(  77)									col = this1;
            								}
            								else {
HXLINE(  77)									Float m0;
HXDLIN(  77)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  77)									if ((this1 == 0)) {
HXLINE(  77)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float m1;
HXDLIN(  77)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  77)									if ((this2 == 0)) {
HXLINE(  77)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float m2;
HXDLIN(  77)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  77)									if ((this3 == 0)) {
HXLINE(  77)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float m3;
HXDLIN(  77)									int this4 = (maskPixel & 255);
HXDLIN(  77)									if ((this4 == 0)) {
HXLINE(  77)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  77)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  77)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  77)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  77)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  77)							if ((col != 0)) {
HXLINE(  77)								int x1 = (x + dx);
HXDLIN(  77)								int y1 = (y + dy);
HXDLIN(  77)								int this1 = col;
HXDLIN(  77)								int c = this1;
HXDLIN(  77)								bool _hx_tmp;
HXDLIN(  77)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  77)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  77)									_hx_tmp = false;
            								}
HXDLIN(  77)								if (_hx_tmp) {
HXLINE(  77)									int location;
HXDLIN(  77)									if (pixelShape->useVirtualPos) {
HXLINE(  77)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  77)										location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  77)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  77)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)									int this3 = this2;
HXDLIN(  77)									int this4;
HXDLIN(  77)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  77)										this4 = this3;
            									}
HXDLIN(  77)									Float a1;
HXDLIN(  77)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  77)									if ((this5 == 0)) {
HXLINE(  77)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float r1;
HXDLIN(  77)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  77)									if ((this6 == 0)) {
HXLINE(  77)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float g1;
HXDLIN(  77)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  77)									if ((this7 == 0)) {
HXLINE(  77)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float b1;
HXDLIN(  77)									int this8 = (this4 & 255);
HXDLIN(  77)									if ((this8 == 0)) {
HXLINE(  77)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float a2;
HXDLIN(  77)									int this9 = ((col >> 24) & 255);
HXDLIN(  77)									if ((this9 == 0)) {
HXLINE(  77)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float r2;
HXDLIN(  77)									int this10 = ((col >> 16) & 255);
HXDLIN(  77)									if ((this10 == 0)) {
HXLINE(  77)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float g2;
HXDLIN(  77)									int this11 = ((col >> 8) & 255);
HXDLIN(  77)									if ((this11 == 0)) {
HXLINE(  77)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float b2;
HXDLIN(  77)									int this12 = (col & 255);
HXDLIN(  77)									if ((this12 == 0)) {
HXLINE(  77)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  77)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  77)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  77)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  77)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  77)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  77)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  77)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  77)									{
HXLINE(  77)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  77)										int value;
HXDLIN(  77)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  77)											value = blended;
            										}
HXDLIN(  77)										bool _hx_tmp;
HXDLIN(  77)										if ((location >= 0)) {
HXLINE(  77)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  77)											_hx_tmp = false;
            										}
HXDLIN(  77)										if (_hx_tmp) {
HXLINE(  77)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  77)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  77)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  77)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)									int index;
HXDLIN(  77)									if (pixelShape->useVirtualPos) {
HXLINE(  77)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  77)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  77)									int value;
HXDLIN(  77)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  77)										value = c;
            									}
HXDLIN(  77)									bool _hx_tmp;
HXDLIN(  77)									if ((index >= 0)) {
HXLINE(  77)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  77)										_hx_tmp = false;
            									}
HXDLIN(  77)									if (_hx_tmp) {
HXLINE(  77)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  77)								if (forceClear) {
HXLINE(  77)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)									int x1 = (x + dx);
HXDLIN(  77)									int y1 = (y + dy);
HXDLIN(  77)									int index;
HXDLIN(  77)									if (pixelShape->useVirtualPos) {
HXLINE(  77)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  77)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  77)									bool _hx_tmp;
HXDLIN(  77)									if ((index >= 0)) {
HXLINE(  77)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  77)										_hx_tmp = false;
            									}
HXDLIN(  77)									if (_hx_tmp) {
HXLINE(  77)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  77)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  77)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  77)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  79)		temp = null();
HXLINE(  80)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< EllipseRadialGradient_obj > EllipseRadialGradient_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_centreX,::hx::Null< int >  __o_centreY,::hx::Null< int >  __o_radiusX,::hx::Null< int >  __o_radiusY,::hx::Null< int >  __o_colorIn,::hx::Null< int >  __o_colorOut,::hx::Null< Float >  __o_gradientCentreX,::hx::Null< Float >  __o_gradientCentreY,::hx::Null< Float >  __o_rotation) {
	::hx::ObjectPtr< EllipseRadialGradient_obj > __this = new EllipseRadialGradient_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_centreX,__o_centreY,__o_radiusX,__o_radiusY,__o_colorIn,__o_colorOut,__o_gradientCentreX,__o_gradientCentreY,__o_rotation);
	return __this;
}

::hx::ObjectPtr< EllipseRadialGradient_obj > EllipseRadialGradient_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_centreX,::hx::Null< int >  __o_centreY,::hx::Null< int >  __o_radiusX,::hx::Null< int >  __o_radiusY,::hx::Null< int >  __o_colorIn,::hx::Null< int >  __o_colorOut,::hx::Null< Float >  __o_gradientCentreX,::hx::Null< Float >  __o_gradientCentreY,::hx::Null< Float >  __o_rotation) {
	EllipseRadialGradient_obj *__this = (EllipseRadialGradient_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(EllipseRadialGradient_obj), true, "pixelimage.triangleGML.gradient.EllipseRadialGradient"));
	*(void **)__this = EllipseRadialGradient_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_centreX,__o_centreY,__o_radiusX,__o_radiusY,__o_colorIn,__o_colorOut,__o_gradientCentreX,__o_gradientCentreY,__o_rotation);
	return __this;
}

EllipseRadialGradient_obj::EllipseRadialGradient_obj()
{
}

::hx::Val EllipseRadialGradient_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"centreX") ) { return ::hx::Val( centreX ); }
		if (HX_FIELD_EQ(inName,"centreY") ) { return ::hx::Val( centreY ); }
		if (HX_FIELD_EQ(inName,"radiusX") ) { return ::hx::Val( radiusX ); }
		if (HX_FIELD_EQ(inName,"radiusY") ) { return ::hx::Val( radiusY ); }
		if (HX_FIELD_EQ(inName,"colorIn") ) { return ::hx::Val( colorIn ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"colorOut") ) { return ::hx::Val( colorOut ); }
		if (HX_FIELD_EQ(inName,"rotation") ) { return ::hx::Val( rotation ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"gradientCentreX") ) { return ::hx::Val( gradientCentreX ); }
		if (HX_FIELD_EQ(inName,"gradientCentreY") ) { return ::hx::Val( gradientCentreY ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val EllipseRadialGradient_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"centreX") ) { centreX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"centreY") ) { centreY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"radiusX") ) { radiusX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"radiusY") ) { radiusY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorIn") ) { colorIn=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"colorOut") ) { colorOut=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rotation") ) { rotation=inValue.Cast< Float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"gradientCentreX") ) { gradientCentreX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"gradientCentreY") ) { gradientCentreY=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void EllipseRadialGradient_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("centreX",dd,c6,ef,19));
	outFields->push(HX_("centreY",de,c6,ef,19));
	outFields->push(HX_("radiusX",c6,77,ff,26));
	outFields->push(HX_("radiusY",c7,77,ff,26));
	outFields->push(HX_("colorIn",28,10,66,ef));
	outFields->push(HX_("colorOut",eb,a6,ec,89));
	outFields->push(HX_("gradientCentreX",cd,d2,95,ed));
	outFields->push(HX_("gradientCentreY",ce,d2,95,ed));
	outFields->push(HX_("rotation",3e,3d,86,08));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo EllipseRadialGradient_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(EllipseRadialGradient_obj,centreX),HX_("centreX",dd,c6,ef,19)},
	{::hx::fsFloat,(int)offsetof(EllipseRadialGradient_obj,centreY),HX_("centreY",de,c6,ef,19)},
	{::hx::fsFloat,(int)offsetof(EllipseRadialGradient_obj,radiusX),HX_("radiusX",c6,77,ff,26)},
	{::hx::fsFloat,(int)offsetof(EllipseRadialGradient_obj,radiusY),HX_("radiusY",c7,77,ff,26)},
	{::hx::fsInt,(int)offsetof(EllipseRadialGradient_obj,colorIn),HX_("colorIn",28,10,66,ef)},
	{::hx::fsInt,(int)offsetof(EllipseRadialGradient_obj,colorOut),HX_("colorOut",eb,a6,ec,89)},
	{::hx::fsFloat,(int)offsetof(EllipseRadialGradient_obj,gradientCentreX),HX_("gradientCentreX",cd,d2,95,ed)},
	{::hx::fsFloat,(int)offsetof(EllipseRadialGradient_obj,gradientCentreY),HX_("gradientCentreY",ce,d2,95,ed)},
	{::hx::fsFloat,(int)offsetof(EllipseRadialGradient_obj,rotation),HX_("rotation",3e,3d,86,08)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *EllipseRadialGradient_obj_sStaticStorageInfo = 0;
#endif

static ::String EllipseRadialGradient_obj_sMemberFields[] = {
	HX_("centreX",dd,c6,ef,19),
	HX_("centreY",de,c6,ef,19),
	HX_("radiusX",c6,77,ff,26),
	HX_("radiusY",c7,77,ff,26),
	HX_("colorIn",28,10,66,ef),
	HX_("colorOut",eb,a6,ec,89),
	HX_("gradientCentreX",cd,d2,95,ed),
	HX_("gradientCentreY",ce,d2,95,ed),
	HX_("rotation",3e,3d,86,08),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class EllipseRadialGradient_obj::__mClass;

void EllipseRadialGradient_obj::__register()
{
	EllipseRadialGradient_obj _hx_dummy;
	EllipseRadialGradient_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.gradient.EllipseRadialGradient",d8,fd,84,46);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(EllipseRadialGradient_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< EllipseRadialGradient_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = EllipseRadialGradient_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = EllipseRadialGradient_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace gradient
