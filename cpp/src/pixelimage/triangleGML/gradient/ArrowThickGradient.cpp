// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTriArray
#include <pixelimage/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_pixel__TwoGrad_TwoGrad_
#include <pixelimage/pixel/_TwoGrad/TwoGrad_.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_FillShape
#include <pixelimage/triangleGML/coreShape/FillShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_gradient_ArrowThickGradient
#include <pixelimage/triangleGML/gradient/ArrowThickGradient.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_6c02f04fd32299a6_36_new,"pixelimage.triangleGML.gradient.ArrowThickGradient","new",0x1ffb120b,"pixelimage.triangleGML.gradient.ArrowThickGradient.new","pixelimage/triangleGML/gradient/ArrowThickGradient.hx",36,0x43028326)
HX_LOCAL_STACK_FRAME(_hx_pos_6c02f04fd32299a6_51_setParameter,"pixelimage.triangleGML.gradient.ArrowThickGradient","setParameter",0xfaa6a69c,"pixelimage.triangleGML.gradient.ArrowThickGradient.setParameter","pixelimage/triangleGML/gradient/ArrowThickGradient.hx",51,0x43028326)
HX_LOCAL_STACK_FRAME(_hx_pos_6c02f04fd32299a6_78_render,"pixelimage.triangleGML.gradient.ArrowThickGradient","render",0x4fc8468b,"pixelimage.triangleGML.gradient.ArrowThickGradient.render","pixelimage/triangleGML/gradient/ArrowThickGradient.hx",78,0x43028326)
namespace pixelimage{
namespace triangleGML{
namespace gradient{

void ArrowThickGradient_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeTopColor,::hx::Null< int >  __o_strokeBottomColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< bool >  __o_both,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_arrowWidth,::hx::Null< Float >  __o_arrowHeight){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeTopColor = __o_strokeTopColor.Default(-16777216);
            		int strokeBottomColor = __o_strokeBottomColor.Default(-1);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		bool both = __o_both.Default(false);
            		bool flare = __o_flare.Default(false);
            		bool reverseFlare = __o_reverseFlare.Default(false);
            		Float x1 = __o_x1.Default(((Float)0.));
            		Float y1 = __o_y1.Default(((Float)0.));
            		Float x2 = __o_x2.Default(((Float)0.));
            		Float y2 = __o_y2.Default(((Float)0.));
            		Float arrowWidth = __o_arrowWidth.Default(((Float)0.));
            		Float arrowHeight = __o_arrowHeight.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_6c02f04fd32299a6_36_new)
HXLINE(  37)		super::__construct(opacity,visibility,-16777216,((Float)1.),strokeDashGapArray,this->fill);
HXLINE(  38)		this->both = both;
HXLINE(  39)		this->flare = flare;
HXLINE(  41)		this->x1 = x1;
HXLINE(  42)		this->y1 = y1;
HXLINE(  43)		this->x2 = x2;
HXLINE(  44)		this->y2 = y2;
HXLINE(  47)		this->strokeTopColor = strokeTopColor;
HXLINE(  48)		this->strokeBottomColor = strokeBottomColor;
            	}

Dynamic ArrowThickGradient_obj::__CreateEmpty() { return new ArrowThickGradient_obj; }

void *ArrowThickGradient_obj::_hx_vtable = 0;

Dynamic ArrowThickGradient_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ArrowThickGradient_obj > _hx_result = new ArrowThickGradient_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14]);
	return _hx_result;
}

bool ArrowThickGradient_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x389f4e25 || inClassId==(int)0x5d13791d;
	}
}

void ArrowThickGradient_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_6c02f04fd32299a6_51_setParameter)
HXDLIN(  51)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("arrowHeight",90,f2,2a,bd)) ){
HXLINE(  69)			this->arrowHeight = ::Std_obj::parseFloat(value);
HXDLIN(  69)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("arrowWidth",7d,93,05,3e)) ){
HXLINE(  67)			this->arrowWidth = ::Std_obj::parseFloat(value);
HXDLIN(  67)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("both",81,88,1b,41)) ){
HXLINE(  53)			bool _hx_tmp;
HXDLIN(  53)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  53)				_hx_tmp = true;
            			}
            			else {
HXLINE(  53)				_hx_tmp = false;
            			}
HXDLIN(  53)			this->both = _hx_tmp;
HXDLIN(  53)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("flare",ce,34,8c,02)) ){
HXLINE(  55)			bool _hx_tmp;
HXDLIN(  55)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  55)				_hx_tmp = true;
            			}
            			else {
HXLINE(  55)				_hx_tmp = false;
            			}
HXDLIN(  55)			this->flare = _hx_tmp;
HXDLIN(  55)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("reverseFlare",4c,10,f1,18)) ){
HXLINE(  57)			bool _hx_tmp;
HXDLIN(  57)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  57)				_hx_tmp = true;
            			}
            			else {
HXLINE(  57)				_hx_tmp = false;
            			}
HXDLIN(  57)			this->reverseFlare = _hx_tmp;
HXDLIN(  57)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("strokeBottomColor",a0,95,a8,82)) ){
HXLINE(  73)			this->strokeBottomColor = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  73)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("strokeTopColor",66,66,01,41)) ){
HXLINE(  71)			this->strokeTopColor = ( (int)(::Std_obj::parseInt(value)) );
HXDLIN(  71)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x1",b9,68,00,00)) ){
HXLINE(  59)			this->x1 = ::Std_obj::parseFloat(value);
HXDLIN(  59)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x2",ba,68,00,00)) ){
HXLINE(  63)			this->x2 = ::Std_obj::parseFloat(value);
HXDLIN(  63)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y1",98,69,00,00)) ){
HXLINE(  61)			this->y1 = ::Std_obj::parseFloat(value);
HXDLIN(  61)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y2",99,69,00,00)) ){
HXLINE(  65)			this->y2 = ::Std_obj::parseFloat(value);
HXDLIN(  65)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  75)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct ArrowThickGradient_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_6c02f04fd32299a6_78_render)
HXLINE(  79)		Float px = (this->x1 + this->offX);
HXLINE(  80)		Float qx = (this->x2 + this->offX);
HXLINE(  81)		Float py = (this->y1 + this->offY);
HXLINE(  82)		Float qy = (this->y2 + this->offY);
HXLINE(  83)		if ((this->both == false)) {
HXLINE(  84)			bool _hx_tmp;
HXDLIN(  84)			if (!((this->arrowHeight > ((Float)0.)))) {
HXLINE(  84)				_hx_tmp = (this->arrowWidth > ((Float)0.));
            			}
            			else {
HXLINE(  84)				_hx_tmp = true;
            			}
HXDLIN(  84)			if (_hx_tmp) {
HXLINE(  85)				Float arrowWidth = this->arrowWidth;
HXDLIN(  85)				Float arrowHeight = this->arrowHeight;
HXDLIN(  85)				Float thick = this->strokeWidth;
HXDLIN(  85)				int color1 = this->strokeTopColor;
HXDLIN(  85)				int color2 = this->strokeBottomColor;
HXDLIN(  85)				bool hasHit = true;
HXDLIN(  85)				{
HXLINE(  85)					Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  85)					Float o = (qy - py);
HXDLIN(  85)					Float a = (qx - px);
HXDLIN(  85)					Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  85)					Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  85)					Float thicker;
HXDLIN(  85)					if ((arrowWidth > (thick * ((Float)1.1)))) {
HXLINE(  85)						thicker = arrowWidth;
            					}
            					else {
HXLINE(  85)						thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            					}
HXDLIN(  85)					Float sin = ::Math_obj::sin(theta);
HXDLIN(  85)					Float cos = ::Math_obj::cos(theta);
HXDLIN(  85)					Float radius = (thick / ( (Float)(2) ));
HXDLIN(  85)					Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  85)					Float h2;
HXDLIN(  85)					if ((arrowHeight < (h * ((Float)1.1)))) {
HXLINE(  85)						h2 = (h - arrowHeight);
            					}
            					else {
HXLINE(  85)						h2 = (h / goldenRatio);
            					}
HXDLIN(  85)					::pixelimage::algo::HitQuad hitQuad;
HXDLIN(  85)					if (this->flare) {
HXLINE(  85)						if (this->reverseFlare) {
HXLINE(  85)							Float sin = ::Math_obj::sin(theta);
HXDLIN(  85)							Float cos = ::Math_obj::cos(theta);
HXDLIN(  85)							Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  85)							Float radius2 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  85)							Float dx = ((Float)0.1);
HXDLIN(  85)							Float dy = radius1;
HXDLIN(  85)							Float cx = h2;
HXDLIN(  85)							Float cy = radius2;
HXDLIN(  85)							Float bx = h2;
HXDLIN(  85)							Float by = -(radius2);
HXDLIN(  85)							Float ax = ((Float)0.1);
HXDLIN(  85)							Float ay = -(radius1);
HXDLIN(  85)							Float temp = ((Float)0.);
HXLINE( 525)							temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 526)							ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 527)							ax = temp;
HXLINE( 529)							temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 530)							by = (py + ((by * cos) + (bx * sin)));
HXLINE( 531)							bx = temp;
HXLINE( 533)							temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 534)							cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 535)							cx = temp;
HXLINE( 537)							temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 538)							dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 539)							dx = temp;
HXLINE(  85)							{
HXLINE(  85)								bool hasUndo = false;
HXDLIN(  85)								int aA = ((color1 >> 24) & 255);
HXDLIN(  85)								int rA = ((color1 >> 16) & 255);
HXDLIN(  85)								int gA = ((color1 >> 8) & 255);
HXDLIN(  85)								int bA = (color1 & 255);
HXDLIN(  85)								int aB = ((color1 >> 24) & 255);
HXDLIN(  85)								int rB = ((color1 >> 16) & 255);
HXDLIN(  85)								int gB = ((color1 >> 8) & 255);
HXDLIN(  85)								int bB = (color1 & 255);
HXDLIN(  85)								int aC = ((color2 >> 24) & 255);
HXDLIN(  85)								int rC = ((color2 >> 16) & 255);
HXDLIN(  85)								int gC = ((color2 >> 8) & 255);
HXDLIN(  85)								int bC = (color2 & 255);
HXDLIN(  85)								Float bcx = (bx - dx);
HXDLIN(  85)								Float bcy = (by - dy);
HXDLIN(  85)								Float acx = (ax - dx);
HXDLIN(  85)								Float acy = (ay - dy);
HXDLIN(  85)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  85)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  85)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  85)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  85)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  85)								if ((ax > bx)) {
HXLINE(  85)									if ((ax > dx)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((bx > dx)) {
HXLINE(  85)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter3 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  85)									if ((bx > dx)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((ax > dx)) {
HXLINE(  85)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter3 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter3 = this1;
            									}
            								}
HXDLIN(  85)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  85)								if ((ay > by)) {
HXLINE(  85)									if ((ay > dy)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((by > dy)) {
HXLINE(  85)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter3 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  85)									if ((by > dy)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((ay > dy)) {
HXLINE(  85)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter3 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter3 = this1;
            									}
            								}
HXDLIN(  85)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  85)								if (hasUndo) {
HXLINE(  85)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  85)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  85)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  85)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  85)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  85)									undoImage = this3;
HXDLIN(  85)									{
HXLINE(  85)										int rectLeft = xIter3->start;
HXDLIN(  85)										int rectTop = yIter3->start;
HXDLIN(  85)										int rectRight = xIter3->max;
HXDLIN(  85)										bool forceClear = false;
HXDLIN(  85)										{
HXLINE(  85)											int _g = rectTop;
HXDLIN(  85)											int _g1 = yIter3->max;
HXDLIN(  85)											while((_g < _g1)){
HXLINE(  85)												_g = (_g + 1);
HXDLIN(  85)												int dy = (_g - 1);
HXDLIN(  85)												{
HXLINE(  85)													int _g1 = rectLeft;
HXDLIN(  85)													int _g2 = rectRight;
HXDLIN(  85)													while((_g1 < _g2)){
HXLINE(  85)														_g1 = (_g1 + 1);
HXDLIN(  85)														int dx = (_g1 - 1);
HXDLIN(  85)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)														int index;
HXDLIN(  85)														if (pixelShape->useVirtualPos) {
HXLINE(  85)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  85)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  85)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)														int col;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  85)															col = c;
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if (pixelShape->useMask) {
HXLINE(  85)															hitQuad = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  85)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  85)															int index;
HXDLIN(  85)															if (this1->useVirtualPos) {
HXLINE(  85)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  85)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  85)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  85)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  85)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int v;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  85)																v = c;
            															}
HXDLIN(  85)															int this3 = v;
HXDLIN(  85)															int maskPixel = this3;
HXDLIN(  85)															int this4 = col;
HXDLIN(  85)															int this5 = this4;
HXDLIN(  85)															if ((maskPixel == 0)) {
HXLINE(  85)																int this1 = this5;
HXDLIN(  85)																col = this1;
            															}
            															else {
HXLINE(  85)																Float m0;
HXDLIN(  85)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  85)																if ((this1 == 0)) {
HXLINE(  85)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m1;
HXDLIN(  85)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  85)																if ((this2 == 0)) {
HXLINE(  85)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m2;
HXDLIN(  85)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  85)																if ((this3 == 0)) {
HXLINE(  85)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m3;
HXDLIN(  85)																int this4 = (maskPixel & 255);
HXDLIN(  85)																if ((this4 == 0)) {
HXLINE(  85)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  85)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  85)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  85)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  85)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  85)														if ((col != 0)) {
HXLINE(  85)															int x = (dx - rectLeft);
HXDLIN(  85)															int y = (dy - rectTop);
HXDLIN(  85)															int this1 = col;
HXDLIN(  85)															int c = this1;
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  85)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																int location;
HXDLIN(  85)																if (undoImage->useVirtualPos) {
HXLINE(  85)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  85)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)																int this3 = this2;
HXDLIN(  85)																int this4;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	this4 = this3;
            																}
HXDLIN(  85)																Float a1;
HXDLIN(  85)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  85)																if ((this5 == 0)) {
HXLINE(  85)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r1;
HXDLIN(  85)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  85)																if ((this6 == 0)) {
HXLINE(  85)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g1;
HXDLIN(  85)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  85)																if ((this7 == 0)) {
HXLINE(  85)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b1;
HXDLIN(  85)																int this8 = (this4 & 255);
HXDLIN(  85)																if ((this8 == 0)) {
HXLINE(  85)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a2;
HXDLIN(  85)																int this9 = ((col >> 24) & 255);
HXDLIN(  85)																if ((this9 == 0)) {
HXLINE(  85)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r2;
HXDLIN(  85)																int this10 = ((col >> 16) & 255);
HXDLIN(  85)																if ((this10 == 0)) {
HXLINE(  85)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g2;
HXDLIN(  85)																int this11 = ((col >> 8) & 255);
HXDLIN(  85)																if ((this11 == 0)) {
HXLINE(  85)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b2;
HXDLIN(  85)																int this12 = (col & 255);
HXDLIN(  85)																if ((this12 == 0)) {
HXLINE(  85)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)																{
HXLINE(  85)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  85)																	int value;
HXDLIN(  85)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  85)																		value = blended;
            																	}
HXDLIN(  85)																	bool hitQuad;
HXDLIN(  85)																	if ((location >= 0)) {
HXLINE(  85)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  85)																		hitQuad = false;
            																	}
HXDLIN(  85)																	if (hitQuad) {
HXLINE(  85)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  85)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  85)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)																int index;
HXDLIN(  85)																if (undoImage->useVirtualPos) {
HXLINE(  85)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  85)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = c;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((index >= 0)) {
HXLINE(  85)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															if (forceClear) {
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)																int x = (dx - rectLeft);
HXDLIN(  85)																int y = (dy - rectTop);
HXDLIN(  85)																int index;
HXDLIN(  85)																if (undoImage->useVirtualPos) {
HXLINE(  85)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  85)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((index >= 0)) {
HXLINE(  85)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								{
HXLINE(  85)									int _g_min = xIter3->start;
HXDLIN(  85)									int _g_max = xIter3->max;
HXDLIN(  85)									while((_g_min < _g_max)){
HXLINE(  85)										_g_min = (_g_min + 1);
HXDLIN(  85)										int px = (_g_min - 1);
HXDLIN(  85)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  85)										{
HXLINE(  85)											int _g_min1 = yIter3->start;
HXDLIN(  85)											int _g_max = yIter3->max;
HXDLIN(  85)											while((_g_min1 < _g_max)){
HXLINE(  85)												_g_min1 = (_g_min1 + 1);
HXDLIN(  85)												int py = (_g_min1 - 1);
HXDLIN(  85)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  85)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  85)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  85)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  85)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  85)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  85)												bool hitQuad;
HXDLIN(  85)												bool hitQuad1;
HXDLIN(  85)												if ((ratioA >= 0)) {
HXLINE(  85)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  85)													hitQuad1 = false;
            												}
HXDLIN(  85)												if (hitQuad1) {
HXLINE(  85)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  85)													hitQuad = false;
            												}
HXDLIN(  85)												if (hitQuad) {
HXLINE(  85)													int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  85)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  85)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  85)													int this1 = i;
HXDLIN(  85)													int a = this1;
HXDLIN(  85)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  85)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  85)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  85)													int this2 = i1;
HXDLIN(  85)													int r = this2;
HXDLIN(  85)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  85)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  85)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  85)													int this3 = i2;
HXDLIN(  85)													int g = this3;
HXDLIN(  85)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  85)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  85)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  85)													int this4 = i3;
HXDLIN(  85)													int b = this4;
HXDLIN(  85)													{
HXLINE(  85)														int location;
HXDLIN(  85)														if (pixelShape->useVirtualPos) {
HXLINE(  85)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  85)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if (pixelShape->transparent) {
HXLINE(  85)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int this3 = this2;
HXDLIN(  85)															int old;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  85)																old = this3;
            															}
HXDLIN(  85)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)															Float a1;
HXDLIN(  85)															int this4 = ((old >> 24) & 255);
HXDLIN(  85)															if ((this4 == 0)) {
HXLINE(  85)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r1;
HXDLIN(  85)															int this5 = ((old >> 16) & 255);
HXDLIN(  85)															if ((this5 == 0)) {
HXLINE(  85)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g1;
HXDLIN(  85)															int this6 = ((old >> 8) & 255);
HXDLIN(  85)															if ((this6 == 0)) {
HXLINE(  85)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b1;
HXDLIN(  85)															int this7 = (old & 255);
HXDLIN(  85)															if ((this7 == 0)) {
HXLINE(  85)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a2;
HXDLIN(  85)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  85)															if ((this8 == 0)) {
HXLINE(  85)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r2;
HXDLIN(  85)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  85)															if ((this9 == 0)) {
HXLINE(  85)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g2;
HXDLIN(  85)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  85)															if ((this10 == 0)) {
HXLINE(  85)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b2;
HXDLIN(  85)															int this11 = (rhs & 255);
HXDLIN(  85)															if ((this11 == 0)) {
HXLINE(  85)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  85)															{
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = blended;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((location >= 0)) {
HXLINE(  85)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  85)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)															int value;
HXDLIN(  85)															if (pixelShape->isLittle) {
HXLINE(  85)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  85)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((location >= 0)) {
HXLINE(  85)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							{
HXLINE(  85)								bool hasHit = false;
HXDLIN(  85)								bool hasUndo1 = false;
HXDLIN(  85)								int aA1 = ((color2 >> 24) & 255);
HXDLIN(  85)								int rA1 = ((color2 >> 16) & 255);
HXDLIN(  85)								int gA1 = ((color2 >> 8) & 255);
HXDLIN(  85)								int bA1 = (color2 & 255);
HXDLIN(  85)								int aB1 = ((color1 >> 24) & 255);
HXDLIN(  85)								int rB1 = ((color1 >> 16) & 255);
HXDLIN(  85)								int gB1 = ((color1 >> 8) & 255);
HXDLIN(  85)								int bB1 = (color1 & 255);
HXDLIN(  85)								int aC1 = ((color2 >> 24) & 255);
HXDLIN(  85)								int rC1 = ((color2 >> 16) & 255);
HXDLIN(  85)								int gC1 = ((color2 >> 8) & 255);
HXDLIN(  85)								int bC1 = (color2 & 255);
HXDLIN(  85)								Float bcx1 = (cx - dx);
HXDLIN(  85)								Float bcy1 = (cy - dy);
HXDLIN(  85)								Float acx1 = (bx - dx);
HXDLIN(  85)								Float acy1 = (by - dy);
HXDLIN(  85)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  85)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  85)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  85)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  85)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  85)								if ((bx > cx)) {
HXLINE(  85)									if ((bx > dx)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((cx > dx)) {
HXLINE(  85)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter31 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  85)									if ((cx > dx)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((bx > dx)) {
HXLINE(  85)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter31 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter31 = this1;
            									}
            								}
HXDLIN(  85)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  85)								if ((by > cy)) {
HXLINE(  85)									if ((by > dy)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((cy > dy)) {
HXLINE(  85)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter31 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  85)									if ((cy > dy)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((by > dy)) {
HXLINE(  85)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter31 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter31 = this1;
            									}
            								}
HXDLIN(  85)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  85)								if (hasUndo1) {
HXLINE(  85)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  85)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  85)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  85)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  85)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  85)									undoImage1 = this3;
HXDLIN(  85)									{
HXLINE(  85)										int rectLeft = xIter31->start;
HXDLIN(  85)										int rectTop = yIter31->start;
HXDLIN(  85)										int rectRight = xIter31->max;
HXDLIN(  85)										bool forceClear = false;
HXDLIN(  85)										{
HXLINE(  85)											int _g = rectTop;
HXDLIN(  85)											int _g1 = yIter31->max;
HXDLIN(  85)											while((_g < _g1)){
HXLINE(  85)												_g = (_g + 1);
HXDLIN(  85)												int dy = (_g - 1);
HXDLIN(  85)												{
HXLINE(  85)													int _g1 = rectLeft;
HXDLIN(  85)													int _g2 = rectRight;
HXDLIN(  85)													while((_g1 < _g2)){
HXLINE(  85)														_g1 = (_g1 + 1);
HXDLIN(  85)														int dx = (_g1 - 1);
HXDLIN(  85)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)														int index;
HXDLIN(  85)														if (pixelShape->useVirtualPos) {
HXLINE(  85)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  85)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  85)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)														int col;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  85)															col = c;
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if (pixelShape->useMask) {
HXLINE(  85)															hitQuad = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  85)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  85)															int index;
HXDLIN(  85)															if (this1->useVirtualPos) {
HXLINE(  85)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  85)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  85)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  85)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  85)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int v;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  85)																v = c;
            															}
HXDLIN(  85)															int this3 = v;
HXDLIN(  85)															int maskPixel = this3;
HXDLIN(  85)															int this4 = col;
HXDLIN(  85)															int this5 = this4;
HXDLIN(  85)															if ((maskPixel == 0)) {
HXLINE(  85)																int this1 = this5;
HXDLIN(  85)																col = this1;
            															}
            															else {
HXLINE(  85)																Float m0;
HXDLIN(  85)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  85)																if ((this1 == 0)) {
HXLINE(  85)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m1;
HXDLIN(  85)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  85)																if ((this2 == 0)) {
HXLINE(  85)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m2;
HXDLIN(  85)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  85)																if ((this3 == 0)) {
HXLINE(  85)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m3;
HXDLIN(  85)																int this4 = (maskPixel & 255);
HXDLIN(  85)																if ((this4 == 0)) {
HXLINE(  85)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  85)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  85)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  85)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  85)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  85)														if ((col != 0)) {
HXLINE(  85)															int x = (dx - rectLeft);
HXDLIN(  85)															int y = (dy - rectTop);
HXDLIN(  85)															int this1 = col;
HXDLIN(  85)															int c = this1;
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  85)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																int location;
HXDLIN(  85)																if (undoImage1->useVirtualPos) {
HXLINE(  85)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  85)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)																int this3 = this2;
HXDLIN(  85)																int this4;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	this4 = this3;
            																}
HXDLIN(  85)																Float a1;
HXDLIN(  85)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  85)																if ((this5 == 0)) {
HXLINE(  85)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r1;
HXDLIN(  85)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  85)																if ((this6 == 0)) {
HXLINE(  85)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g1;
HXDLIN(  85)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  85)																if ((this7 == 0)) {
HXLINE(  85)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b1;
HXDLIN(  85)																int this8 = (this4 & 255);
HXDLIN(  85)																if ((this8 == 0)) {
HXLINE(  85)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a2;
HXDLIN(  85)																int this9 = ((col >> 24) & 255);
HXDLIN(  85)																if ((this9 == 0)) {
HXLINE(  85)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r2;
HXDLIN(  85)																int this10 = ((col >> 16) & 255);
HXDLIN(  85)																if ((this10 == 0)) {
HXLINE(  85)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g2;
HXDLIN(  85)																int this11 = ((col >> 8) & 255);
HXDLIN(  85)																if ((this11 == 0)) {
HXLINE(  85)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b2;
HXDLIN(  85)																int this12 = (col & 255);
HXDLIN(  85)																if ((this12 == 0)) {
HXLINE(  85)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)																{
HXLINE(  85)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  85)																	int value;
HXDLIN(  85)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  85)																		value = blended;
            																	}
HXDLIN(  85)																	bool hitQuad;
HXDLIN(  85)																	if ((location >= 0)) {
HXLINE(  85)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  85)																		hitQuad = false;
            																	}
HXDLIN(  85)																	if (hitQuad) {
HXLINE(  85)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  85)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  85)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)																int index;
HXDLIN(  85)																if (undoImage1->useVirtualPos) {
HXLINE(  85)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  85)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = c;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((index >= 0)) {
HXLINE(  85)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															if (forceClear) {
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)																int x = (dx - rectLeft);
HXDLIN(  85)																int y = (dy - rectTop);
HXDLIN(  85)																int index;
HXDLIN(  85)																if (undoImage1->useVirtualPos) {
HXLINE(  85)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  85)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((index >= 0)) {
HXLINE(  85)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								{
HXLINE(  85)									int _g_min1 = xIter31->start;
HXDLIN(  85)									int _g_max1 = xIter31->max;
HXDLIN(  85)									while((_g_min1 < _g_max1)){
HXLINE(  85)										_g_min1 = (_g_min1 + 1);
HXDLIN(  85)										int px = (_g_min1 - 1);
HXDLIN(  85)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  85)										{
HXLINE(  85)											int _g_min = yIter31->start;
HXDLIN(  85)											int _g_max = yIter31->max;
HXDLIN(  85)											while((_g_min < _g_max)){
HXLINE(  85)												_g_min = (_g_min + 1);
HXDLIN(  85)												int py = (_g_min - 1);
HXDLIN(  85)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  85)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  85)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  85)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  85)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  85)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  85)												bool hitQuad;
HXDLIN(  85)												bool hitQuad1;
HXDLIN(  85)												if ((ratioA >= 0)) {
HXLINE(  85)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  85)													hitQuad1 = false;
            												}
HXDLIN(  85)												if (hitQuad1) {
HXLINE(  85)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  85)													hitQuad = false;
            												}
HXDLIN(  85)												if (hitQuad) {
HXLINE(  85)													int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  85)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  85)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  85)													int this1 = i;
HXDLIN(  85)													int a = this1;
HXDLIN(  85)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  85)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  85)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  85)													int this2 = i1;
HXDLIN(  85)													int r = this2;
HXDLIN(  85)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  85)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  85)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  85)													int this3 = i2;
HXDLIN(  85)													int g = this3;
HXDLIN(  85)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  85)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  85)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  85)													int this4 = i3;
HXDLIN(  85)													int b = this4;
HXDLIN(  85)													{
HXLINE(  85)														int location;
HXDLIN(  85)														if (pixelShape->useVirtualPos) {
HXLINE(  85)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  85)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if (pixelShape->transparent) {
HXLINE(  85)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int this3 = this2;
HXDLIN(  85)															int old;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  85)																old = this3;
            															}
HXDLIN(  85)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)															Float a1;
HXDLIN(  85)															int this4 = ((old >> 24) & 255);
HXDLIN(  85)															if ((this4 == 0)) {
HXLINE(  85)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r1;
HXDLIN(  85)															int this5 = ((old >> 16) & 255);
HXDLIN(  85)															if ((this5 == 0)) {
HXLINE(  85)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g1;
HXDLIN(  85)															int this6 = ((old >> 8) & 255);
HXDLIN(  85)															if ((this6 == 0)) {
HXLINE(  85)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b1;
HXDLIN(  85)															int this7 = (old & 255);
HXDLIN(  85)															if ((this7 == 0)) {
HXLINE(  85)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a2;
HXDLIN(  85)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  85)															if ((this8 == 0)) {
HXLINE(  85)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r2;
HXDLIN(  85)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  85)															if ((this9 == 0)) {
HXLINE(  85)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g2;
HXDLIN(  85)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  85)															if ((this10 == 0)) {
HXLINE(  85)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b2;
HXDLIN(  85)															int this11 = (rhs & 255);
HXDLIN(  85)															if ((this11 == 0)) {
HXLINE(  85)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  85)															{
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = blended;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((location >= 0)) {
HXLINE(  85)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  85)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)															int value;
HXDLIN(  85)															if (pixelShape->isLittle) {
HXLINE(  85)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  85)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((location >= 0)) {
HXLINE(  85)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								if ((hasHit == false)) {
HXLINE(  85)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  85)									if (hasUndo1) {
HXLINE(  85)										v->undoImage = undoImage1;
HXDLIN(  85)										v->undoX = xIter31->start;
HXDLIN(  85)										v->undoY = yIter31->start;
            									}
            								}
            							}
HXDLIN(  85)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  85)							hitQuad = v;
            						}
            						else {
HXLINE(  85)							Float sin = ::Math_obj::sin(theta);
HXDLIN(  85)							Float cos = ::Math_obj::cos(theta);
HXDLIN(  85)							Float radius1 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  85)							Float radius2 = (thick / ( (Float)(2) ));
HXDLIN(  85)							Float dx = ((Float)0.1);
HXDLIN(  85)							Float dy = radius1;
HXDLIN(  85)							Float cx = h2;
HXDLIN(  85)							Float cy = radius2;
HXDLIN(  85)							Float bx = h2;
HXDLIN(  85)							Float by = -(radius2);
HXDLIN(  85)							Float ax = ((Float)0.1);
HXDLIN(  85)							Float ay = -(radius1);
HXDLIN(  85)							Float temp = ((Float)0.);
HXLINE( 525)							temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 526)							ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 527)							ax = temp;
HXLINE( 529)							temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 530)							by = (py + ((by * cos) + (bx * sin)));
HXLINE( 531)							bx = temp;
HXLINE( 533)							temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 534)							cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 535)							cx = temp;
HXLINE( 537)							temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 538)							dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 539)							dx = temp;
HXLINE(  85)							{
HXLINE(  85)								bool hasUndo = false;
HXDLIN(  85)								int aA = ((color1 >> 24) & 255);
HXDLIN(  85)								int rA = ((color1 >> 16) & 255);
HXDLIN(  85)								int gA = ((color1 >> 8) & 255);
HXDLIN(  85)								int bA = (color1 & 255);
HXDLIN(  85)								int aB = ((color1 >> 24) & 255);
HXDLIN(  85)								int rB = ((color1 >> 16) & 255);
HXDLIN(  85)								int gB = ((color1 >> 8) & 255);
HXDLIN(  85)								int bB = (color1 & 255);
HXDLIN(  85)								int aC = ((color2 >> 24) & 255);
HXDLIN(  85)								int rC = ((color2 >> 16) & 255);
HXDLIN(  85)								int gC = ((color2 >> 8) & 255);
HXDLIN(  85)								int bC = (color2 & 255);
HXDLIN(  85)								Float bcx = (bx - dx);
HXDLIN(  85)								Float bcy = (by - dy);
HXDLIN(  85)								Float acx = (ax - dx);
HXDLIN(  85)								Float acy = (ay - dy);
HXDLIN(  85)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  85)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  85)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  85)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  85)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  85)								if ((ax > bx)) {
HXLINE(  85)									if ((ax > dx)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((bx > dx)) {
HXLINE(  85)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter3 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  85)									if ((bx > dx)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((ax > dx)) {
HXLINE(  85)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter3 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter3 = this1;
            									}
            								}
HXDLIN(  85)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  85)								if ((ay > by)) {
HXLINE(  85)									if ((ay > dy)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((by > dy)) {
HXLINE(  85)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter3 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  85)									if ((by > dy)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((ay > dy)) {
HXLINE(  85)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter3 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter3 = this1;
            									}
            								}
HXDLIN(  85)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  85)								if (hasUndo) {
HXLINE(  85)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  85)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  85)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  85)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  85)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  85)									undoImage = this3;
HXDLIN(  85)									{
HXLINE(  85)										int rectLeft = xIter3->start;
HXDLIN(  85)										int rectTop = yIter3->start;
HXDLIN(  85)										int rectRight = xIter3->max;
HXDLIN(  85)										bool forceClear = false;
HXDLIN(  85)										{
HXLINE(  85)											int _g = rectTop;
HXDLIN(  85)											int _g1 = yIter3->max;
HXDLIN(  85)											while((_g < _g1)){
HXLINE(  85)												_g = (_g + 1);
HXDLIN(  85)												int dy = (_g - 1);
HXDLIN(  85)												{
HXLINE(  85)													int _g1 = rectLeft;
HXDLIN(  85)													int _g2 = rectRight;
HXDLIN(  85)													while((_g1 < _g2)){
HXLINE(  85)														_g1 = (_g1 + 1);
HXDLIN(  85)														int dx = (_g1 - 1);
HXDLIN(  85)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)														int index;
HXDLIN(  85)														if (pixelShape->useVirtualPos) {
HXLINE(  85)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  85)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  85)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)														int col;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  85)															col = c;
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if (pixelShape->useMask) {
HXLINE(  85)															hitQuad = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  85)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  85)															int index;
HXDLIN(  85)															if (this1->useVirtualPos) {
HXLINE(  85)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  85)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  85)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  85)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  85)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int v;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  85)																v = c;
            															}
HXDLIN(  85)															int this3 = v;
HXDLIN(  85)															int maskPixel = this3;
HXDLIN(  85)															int this4 = col;
HXDLIN(  85)															int this5 = this4;
HXDLIN(  85)															if ((maskPixel == 0)) {
HXLINE(  85)																int this1 = this5;
HXDLIN(  85)																col = this1;
            															}
            															else {
HXLINE(  85)																Float m0;
HXDLIN(  85)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  85)																if ((this1 == 0)) {
HXLINE(  85)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m1;
HXDLIN(  85)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  85)																if ((this2 == 0)) {
HXLINE(  85)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m2;
HXDLIN(  85)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  85)																if ((this3 == 0)) {
HXLINE(  85)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m3;
HXDLIN(  85)																int this4 = (maskPixel & 255);
HXDLIN(  85)																if ((this4 == 0)) {
HXLINE(  85)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  85)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  85)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  85)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  85)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  85)														if ((col != 0)) {
HXLINE(  85)															int x = (dx - rectLeft);
HXDLIN(  85)															int y = (dy - rectTop);
HXDLIN(  85)															int this1 = col;
HXDLIN(  85)															int c = this1;
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  85)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																int location;
HXDLIN(  85)																if (undoImage->useVirtualPos) {
HXLINE(  85)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  85)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)																int this3 = this2;
HXDLIN(  85)																int this4;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	this4 = this3;
            																}
HXDLIN(  85)																Float a1;
HXDLIN(  85)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  85)																if ((this5 == 0)) {
HXLINE(  85)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r1;
HXDLIN(  85)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  85)																if ((this6 == 0)) {
HXLINE(  85)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g1;
HXDLIN(  85)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  85)																if ((this7 == 0)) {
HXLINE(  85)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b1;
HXDLIN(  85)																int this8 = (this4 & 255);
HXDLIN(  85)																if ((this8 == 0)) {
HXLINE(  85)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a2;
HXDLIN(  85)																int this9 = ((col >> 24) & 255);
HXDLIN(  85)																if ((this9 == 0)) {
HXLINE(  85)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r2;
HXDLIN(  85)																int this10 = ((col >> 16) & 255);
HXDLIN(  85)																if ((this10 == 0)) {
HXLINE(  85)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g2;
HXDLIN(  85)																int this11 = ((col >> 8) & 255);
HXDLIN(  85)																if ((this11 == 0)) {
HXLINE(  85)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b2;
HXDLIN(  85)																int this12 = (col & 255);
HXDLIN(  85)																if ((this12 == 0)) {
HXLINE(  85)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)																{
HXLINE(  85)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  85)																	int value;
HXDLIN(  85)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  85)																		value = blended;
            																	}
HXDLIN(  85)																	bool hitQuad;
HXDLIN(  85)																	if ((location >= 0)) {
HXLINE(  85)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  85)																		hitQuad = false;
            																	}
HXDLIN(  85)																	if (hitQuad) {
HXLINE(  85)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  85)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  85)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)																int index;
HXDLIN(  85)																if (undoImage->useVirtualPos) {
HXLINE(  85)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  85)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = c;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((index >= 0)) {
HXLINE(  85)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															if (forceClear) {
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)																int x = (dx - rectLeft);
HXDLIN(  85)																int y = (dy - rectTop);
HXDLIN(  85)																int index;
HXDLIN(  85)																if (undoImage->useVirtualPos) {
HXLINE(  85)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  85)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((index >= 0)) {
HXLINE(  85)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								{
HXLINE(  85)									int _g_min = xIter3->start;
HXDLIN(  85)									int _g_max = xIter3->max;
HXDLIN(  85)									while((_g_min < _g_max)){
HXLINE(  85)										_g_min = (_g_min + 1);
HXDLIN(  85)										int px = (_g_min - 1);
HXDLIN(  85)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  85)										{
HXLINE(  85)											int _g_min1 = yIter3->start;
HXDLIN(  85)											int _g_max = yIter3->max;
HXDLIN(  85)											while((_g_min1 < _g_max)){
HXLINE(  85)												_g_min1 = (_g_min1 + 1);
HXDLIN(  85)												int py = (_g_min1 - 1);
HXDLIN(  85)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  85)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  85)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  85)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  85)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  85)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  85)												bool hitQuad;
HXDLIN(  85)												bool hitQuad1;
HXDLIN(  85)												if ((ratioA >= 0)) {
HXLINE(  85)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  85)													hitQuad1 = false;
            												}
HXDLIN(  85)												if (hitQuad1) {
HXLINE(  85)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  85)													hitQuad = false;
            												}
HXDLIN(  85)												if (hitQuad) {
HXLINE(  85)													int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  85)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  85)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  85)													int this1 = i;
HXDLIN(  85)													int a = this1;
HXDLIN(  85)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  85)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  85)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  85)													int this2 = i1;
HXDLIN(  85)													int r = this2;
HXDLIN(  85)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  85)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  85)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  85)													int this3 = i2;
HXDLIN(  85)													int g = this3;
HXDLIN(  85)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  85)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  85)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  85)													int this4 = i3;
HXDLIN(  85)													int b = this4;
HXDLIN(  85)													{
HXLINE(  85)														int location;
HXDLIN(  85)														if (pixelShape->useVirtualPos) {
HXLINE(  85)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  85)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if (pixelShape->transparent) {
HXLINE(  85)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int this3 = this2;
HXDLIN(  85)															int old;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  85)																old = this3;
            															}
HXDLIN(  85)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)															Float a1;
HXDLIN(  85)															int this4 = ((old >> 24) & 255);
HXDLIN(  85)															if ((this4 == 0)) {
HXLINE(  85)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r1;
HXDLIN(  85)															int this5 = ((old >> 16) & 255);
HXDLIN(  85)															if ((this5 == 0)) {
HXLINE(  85)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g1;
HXDLIN(  85)															int this6 = ((old >> 8) & 255);
HXDLIN(  85)															if ((this6 == 0)) {
HXLINE(  85)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b1;
HXDLIN(  85)															int this7 = (old & 255);
HXDLIN(  85)															if ((this7 == 0)) {
HXLINE(  85)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a2;
HXDLIN(  85)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  85)															if ((this8 == 0)) {
HXLINE(  85)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r2;
HXDLIN(  85)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  85)															if ((this9 == 0)) {
HXLINE(  85)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g2;
HXDLIN(  85)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  85)															if ((this10 == 0)) {
HXLINE(  85)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b2;
HXDLIN(  85)															int this11 = (rhs & 255);
HXDLIN(  85)															if ((this11 == 0)) {
HXLINE(  85)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  85)															{
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = blended;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((location >= 0)) {
HXLINE(  85)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  85)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)															int value;
HXDLIN(  85)															if (pixelShape->isLittle) {
HXLINE(  85)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  85)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((location >= 0)) {
HXLINE(  85)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							{
HXLINE(  85)								bool hasHit = false;
HXDLIN(  85)								bool hasUndo1 = false;
HXDLIN(  85)								int aA1 = ((color2 >> 24) & 255);
HXDLIN(  85)								int rA1 = ((color2 >> 16) & 255);
HXDLIN(  85)								int gA1 = ((color2 >> 8) & 255);
HXDLIN(  85)								int bA1 = (color2 & 255);
HXDLIN(  85)								int aB1 = ((color1 >> 24) & 255);
HXDLIN(  85)								int rB1 = ((color1 >> 16) & 255);
HXDLIN(  85)								int gB1 = ((color1 >> 8) & 255);
HXDLIN(  85)								int bB1 = (color1 & 255);
HXDLIN(  85)								int aC1 = ((color2 >> 24) & 255);
HXDLIN(  85)								int rC1 = ((color2 >> 16) & 255);
HXDLIN(  85)								int gC1 = ((color2 >> 8) & 255);
HXDLIN(  85)								int bC1 = (color2 & 255);
HXDLIN(  85)								Float bcx1 = (cx - dx);
HXDLIN(  85)								Float bcy1 = (cy - dy);
HXDLIN(  85)								Float acx1 = (bx - dx);
HXDLIN(  85)								Float acy1 = (by - dy);
HXDLIN(  85)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  85)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  85)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  85)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  85)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  85)								if ((bx > cx)) {
HXLINE(  85)									if ((bx > dx)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((cx > dx)) {
HXLINE(  85)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter31 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  85)									if ((cx > dx)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((bx > dx)) {
HXLINE(  85)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter31 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										xIter31 = this1;
            									}
            								}
HXDLIN(  85)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  85)								if ((by > cy)) {
HXLINE(  85)									if ((by > dy)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((cy > dy)) {
HXLINE(  85)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter31 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  85)									if ((cy > dy)) {
HXLINE(  85)										int min;
HXDLIN(  85)										if ((by > dy)) {
HXLINE(  85)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  85)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  85)										int ii_min = min;
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter31 = this1;
            									}
            									else {
HXLINE(  85)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  85)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)										yIter31 = this1;
            									}
            								}
HXDLIN(  85)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  85)								if (hasUndo1) {
HXLINE(  85)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  85)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  85)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  85)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  85)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  85)									undoImage1 = this3;
HXDLIN(  85)									{
HXLINE(  85)										int rectLeft = xIter31->start;
HXDLIN(  85)										int rectTop = yIter31->start;
HXDLIN(  85)										int rectRight = xIter31->max;
HXDLIN(  85)										bool forceClear = false;
HXDLIN(  85)										{
HXLINE(  85)											int _g = rectTop;
HXDLIN(  85)											int _g1 = yIter31->max;
HXDLIN(  85)											while((_g < _g1)){
HXLINE(  85)												_g = (_g + 1);
HXDLIN(  85)												int dy = (_g - 1);
HXDLIN(  85)												{
HXLINE(  85)													int _g1 = rectLeft;
HXDLIN(  85)													int _g2 = rectRight;
HXDLIN(  85)													while((_g1 < _g2)){
HXLINE(  85)														_g1 = (_g1 + 1);
HXDLIN(  85)														int dx = (_g1 - 1);
HXDLIN(  85)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)														int index;
HXDLIN(  85)														if (pixelShape->useVirtualPos) {
HXLINE(  85)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  85)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  85)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)														int col;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  85)															col = c;
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if (pixelShape->useMask) {
HXLINE(  85)															hitQuad = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  85)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  85)															int index;
HXDLIN(  85)															if (this1->useVirtualPos) {
HXLINE(  85)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  85)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  85)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  85)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  85)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int v;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  85)																v = c;
            															}
HXDLIN(  85)															int this3 = v;
HXDLIN(  85)															int maskPixel = this3;
HXDLIN(  85)															int this4 = col;
HXDLIN(  85)															int this5 = this4;
HXDLIN(  85)															if ((maskPixel == 0)) {
HXLINE(  85)																int this1 = this5;
HXDLIN(  85)																col = this1;
            															}
            															else {
HXLINE(  85)																Float m0;
HXDLIN(  85)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  85)																if ((this1 == 0)) {
HXLINE(  85)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m1;
HXDLIN(  85)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  85)																if ((this2 == 0)) {
HXLINE(  85)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m2;
HXDLIN(  85)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  85)																if ((this3 == 0)) {
HXLINE(  85)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m3;
HXDLIN(  85)																int this4 = (maskPixel & 255);
HXDLIN(  85)																if ((this4 == 0)) {
HXLINE(  85)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  85)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  85)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  85)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  85)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  85)														if ((col != 0)) {
HXLINE(  85)															int x = (dx - rectLeft);
HXDLIN(  85)															int y = (dy - rectTop);
HXDLIN(  85)															int this1 = col;
HXDLIN(  85)															int c = this1;
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  85)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																int location;
HXDLIN(  85)																if (undoImage1->useVirtualPos) {
HXLINE(  85)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  85)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)																int this3 = this2;
HXDLIN(  85)																int this4;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	this4 = this3;
            																}
HXDLIN(  85)																Float a1;
HXDLIN(  85)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  85)																if ((this5 == 0)) {
HXLINE(  85)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r1;
HXDLIN(  85)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  85)																if ((this6 == 0)) {
HXLINE(  85)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g1;
HXDLIN(  85)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  85)																if ((this7 == 0)) {
HXLINE(  85)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b1;
HXDLIN(  85)																int this8 = (this4 & 255);
HXDLIN(  85)																if ((this8 == 0)) {
HXLINE(  85)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a2;
HXDLIN(  85)																int this9 = ((col >> 24) & 255);
HXDLIN(  85)																if ((this9 == 0)) {
HXLINE(  85)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r2;
HXDLIN(  85)																int this10 = ((col >> 16) & 255);
HXDLIN(  85)																if ((this10 == 0)) {
HXLINE(  85)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g2;
HXDLIN(  85)																int this11 = ((col >> 8) & 255);
HXDLIN(  85)																if ((this11 == 0)) {
HXLINE(  85)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b2;
HXDLIN(  85)																int this12 = (col & 255);
HXDLIN(  85)																if ((this12 == 0)) {
HXLINE(  85)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  85)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)																{
HXLINE(  85)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  85)																	int value;
HXDLIN(  85)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  85)																		value = blended;
            																	}
HXDLIN(  85)																	bool hitQuad;
HXDLIN(  85)																	if ((location >= 0)) {
HXLINE(  85)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  85)																		hitQuad = false;
            																	}
HXDLIN(  85)																	if (hitQuad) {
HXLINE(  85)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  85)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  85)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)																int index;
HXDLIN(  85)																if (undoImage1->useVirtualPos) {
HXLINE(  85)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  85)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = c;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((index >= 0)) {
HXLINE(  85)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															if (forceClear) {
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)																int x = (dx - rectLeft);
HXDLIN(  85)																int y = (dy - rectTop);
HXDLIN(  85)																int index;
HXDLIN(  85)																if (undoImage1->useVirtualPos) {
HXLINE(  85)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  85)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((index >= 0)) {
HXLINE(  85)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								{
HXLINE(  85)									int _g_min1 = xIter31->start;
HXDLIN(  85)									int _g_max1 = xIter31->max;
HXDLIN(  85)									while((_g_min1 < _g_max1)){
HXLINE(  85)										_g_min1 = (_g_min1 + 1);
HXDLIN(  85)										int px = (_g_min1 - 1);
HXDLIN(  85)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  85)										{
HXLINE(  85)											int _g_min = yIter31->start;
HXDLIN(  85)											int _g_max = yIter31->max;
HXDLIN(  85)											while((_g_min < _g_max)){
HXLINE(  85)												_g_min = (_g_min + 1);
HXDLIN(  85)												int py = (_g_min - 1);
HXDLIN(  85)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  85)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  85)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  85)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  85)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  85)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  85)												bool hitQuad;
HXDLIN(  85)												bool hitQuad1;
HXDLIN(  85)												if ((ratioA >= 0)) {
HXLINE(  85)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  85)													hitQuad1 = false;
            												}
HXDLIN(  85)												if (hitQuad1) {
HXLINE(  85)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  85)													hitQuad = false;
            												}
HXDLIN(  85)												if (hitQuad) {
HXLINE(  85)													int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  85)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  85)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  85)													int this1 = i;
HXDLIN(  85)													int a = this1;
HXDLIN(  85)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  85)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  85)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  85)													int this2 = i1;
HXDLIN(  85)													int r = this2;
HXDLIN(  85)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  85)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  85)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  85)													int this3 = i2;
HXDLIN(  85)													int g = this3;
HXDLIN(  85)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  85)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  85)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  85)													int this4 = i3;
HXDLIN(  85)													int b = this4;
HXDLIN(  85)													{
HXLINE(  85)														int location;
HXDLIN(  85)														if (pixelShape->useVirtualPos) {
HXLINE(  85)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  85)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if (pixelShape->transparent) {
HXLINE(  85)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int this3 = this2;
HXDLIN(  85)															int old;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  85)																old = this3;
            															}
HXDLIN(  85)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)															Float a1;
HXDLIN(  85)															int this4 = ((old >> 24) & 255);
HXDLIN(  85)															if ((this4 == 0)) {
HXLINE(  85)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r1;
HXDLIN(  85)															int this5 = ((old >> 16) & 255);
HXDLIN(  85)															if ((this5 == 0)) {
HXLINE(  85)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g1;
HXDLIN(  85)															int this6 = ((old >> 8) & 255);
HXDLIN(  85)															if ((this6 == 0)) {
HXLINE(  85)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b1;
HXDLIN(  85)															int this7 = (old & 255);
HXDLIN(  85)															if ((this7 == 0)) {
HXLINE(  85)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a2;
HXDLIN(  85)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  85)															if ((this8 == 0)) {
HXLINE(  85)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r2;
HXDLIN(  85)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  85)															if ((this9 == 0)) {
HXLINE(  85)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g2;
HXDLIN(  85)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  85)															if ((this10 == 0)) {
HXLINE(  85)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b2;
HXDLIN(  85)															int this11 = (rhs & 255);
HXDLIN(  85)															if ((this11 == 0)) {
HXLINE(  85)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  85)															{
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = blended;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((location >= 0)) {
HXLINE(  85)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  85)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)															int value;
HXDLIN(  85)															if (pixelShape->isLittle) {
HXLINE(  85)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  85)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((location >= 0)) {
HXLINE(  85)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								if ((hasHit == false)) {
HXLINE(  85)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  85)									if (hasUndo1) {
HXLINE(  85)										v->undoImage = undoImage1;
HXDLIN(  85)										v->undoX = xIter31->start;
HXDLIN(  85)										v->undoY = yIter31->start;
            									}
            								}
            							}
HXDLIN(  85)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  85)							hitQuad = v;
            						}
            					}
            					else {
HXLINE(  85)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  85)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  85)						Float radius = (thick / ( (Float)(2) ));
HXDLIN(  85)						Float dx = ((Float)0.1);
HXDLIN(  85)						Float dy = radius;
HXDLIN(  85)						Float cx = h2;
HXDLIN(  85)						Float cy = radius;
HXDLIN(  85)						Float bx = h2;
HXDLIN(  85)						Float by = -(radius);
HXDLIN(  85)						Float ax = ((Float)0.1);
HXDLIN(  85)						Float ay = -(radius);
HXDLIN(  85)						Float temp = ((Float)0.);
HXLINE( 474)						temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 475)						ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 476)						ax = temp;
HXLINE( 478)						temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 479)						by = (py + ((by * cos) + (bx * sin)));
HXLINE( 480)						bx = temp;
HXLINE( 482)						temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 483)						cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 484)						cx = temp;
HXLINE( 486)						temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 487)						dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 488)						dx = temp;
HXLINE(  85)						{
HXLINE(  85)							bool hasUndo = false;
HXDLIN(  85)							int aA = ((color1 >> 24) & 255);
HXDLIN(  85)							int rA = ((color1 >> 16) & 255);
HXDLIN(  85)							int gA = ((color1 >> 8) & 255);
HXDLIN(  85)							int bA = (color1 & 255);
HXDLIN(  85)							int aB = ((color1 >> 24) & 255);
HXDLIN(  85)							int rB = ((color1 >> 16) & 255);
HXDLIN(  85)							int gB = ((color1 >> 8) & 255);
HXDLIN(  85)							int bB = (color1 & 255);
HXDLIN(  85)							int aC = ((color2 >> 24) & 255);
HXDLIN(  85)							int rC = ((color2 >> 16) & 255);
HXDLIN(  85)							int gC = ((color2 >> 8) & 255);
HXDLIN(  85)							int bC = (color2 & 255);
HXDLIN(  85)							Float bcx = (bx - dx);
HXDLIN(  85)							Float bcy = (by - dy);
HXDLIN(  85)							Float acx = (ax - dx);
HXDLIN(  85)							Float acy = (ay - dy);
HXDLIN(  85)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  85)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  85)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  85)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  85)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  85)							if ((ax > bx)) {
HXLINE(  85)								if ((ax > dx)) {
HXLINE(  85)									int min;
HXDLIN(  85)									if ((bx > dx)) {
HXLINE(  85)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  85)										min = ::Math_obj::floor(bx);
            									}
HXDLIN(  85)									int ii_min = min;
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									xIter3 = this1;
            								}
            								else {
HXLINE(  85)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  85)								if ((bx > dx)) {
HXLINE(  85)									int min;
HXDLIN(  85)									if ((ax > dx)) {
HXLINE(  85)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  85)										min = ::Math_obj::ceil(ax);
            									}
HXDLIN(  85)									int ii_min = min;
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									xIter3 = this1;
            								}
            								else {
HXLINE(  85)									int ii_min = ::Math_obj::floor(ax);
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									xIter3 = this1;
            								}
            							}
HXDLIN(  85)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  85)							if ((ay > by)) {
HXLINE(  85)								if ((ay > dy)) {
HXLINE(  85)									int min;
HXDLIN(  85)									if ((by > dy)) {
HXLINE(  85)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  85)										min = ::Math_obj::floor(by);
            									}
HXDLIN(  85)									int ii_min = min;
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									yIter3 = this1;
            								}
            								else {
HXLINE(  85)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  85)								if ((by > dy)) {
HXLINE(  85)									int min;
HXDLIN(  85)									if ((ay > dy)) {
HXLINE(  85)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  85)										min = ::Math_obj::ceil(ay);
            									}
HXDLIN(  85)									int ii_min = min;
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									yIter3 = this1;
            								}
            								else {
HXLINE(  85)									int ii_min = ::Math_obj::floor(ay);
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									yIter3 = this1;
            								}
            							}
HXDLIN(  85)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  85)							if (hasUndo) {
HXLINE(  85)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  85)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  85)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  85)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  85)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  85)								undoImage = this3;
HXDLIN(  85)								{
HXLINE(  85)									int rectLeft = xIter3->start;
HXDLIN(  85)									int rectTop = yIter3->start;
HXDLIN(  85)									int rectRight = xIter3->max;
HXDLIN(  85)									bool forceClear = false;
HXDLIN(  85)									{
HXLINE(  85)										int _g = rectTop;
HXDLIN(  85)										int _g1 = yIter3->max;
HXDLIN(  85)										while((_g < _g1)){
HXLINE(  85)											_g = (_g + 1);
HXDLIN(  85)											int dy = (_g - 1);
HXDLIN(  85)											{
HXLINE(  85)												int _g1 = rectLeft;
HXDLIN(  85)												int _g2 = rectRight;
HXDLIN(  85)												while((_g1 < _g2)){
HXLINE(  85)													_g1 = (_g1 + 1);
HXDLIN(  85)													int dx = (_g1 - 1);
HXDLIN(  85)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)													int index;
HXDLIN(  85)													if (pixelShape->useVirtualPos) {
HXLINE(  85)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  85)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  85)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)													int col;
HXDLIN(  85)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  85)														col = c;
            													}
HXDLIN(  85)													bool hitQuad;
HXDLIN(  85)													if (pixelShape->useMask) {
HXLINE(  85)														hitQuad = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  85)														hitQuad = false;
            													}
HXDLIN(  85)													if (hitQuad) {
HXLINE(  85)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  85)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  85)														int index;
HXDLIN(  85)														if (this1->useVirtualPos) {
HXLINE(  85)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  85)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  85)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  85)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  85)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)														int v;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  85)															v = c;
            														}
HXDLIN(  85)														int this3 = v;
HXDLIN(  85)														int maskPixel = this3;
HXDLIN(  85)														int this4 = col;
HXDLIN(  85)														int this5 = this4;
HXDLIN(  85)														if ((maskPixel == 0)) {
HXLINE(  85)															int this1 = this5;
HXDLIN(  85)															col = this1;
            														}
            														else {
HXLINE(  85)															Float m0;
HXDLIN(  85)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  85)															if ((this1 == 0)) {
HXLINE(  85)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m1;
HXDLIN(  85)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  85)															if ((this2 == 0)) {
HXLINE(  85)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m2;
HXDLIN(  85)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  85)															if ((this3 == 0)) {
HXLINE(  85)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m3;
HXDLIN(  85)															int this4 = (maskPixel & 255);
HXDLIN(  85)															if ((this4 == 0)) {
HXLINE(  85)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  85)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  85)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  85)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  85)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  85)													if ((col != 0)) {
HXLINE(  85)														int x = (dx - rectLeft);
HXDLIN(  85)														int y = (dy - rectTop);
HXDLIN(  85)														int this1 = col;
HXDLIN(  85)														int c = this1;
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  85)															hitQuad = undoImage->transparent;
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															int location;
HXDLIN(  85)															if (undoImage->useVirtualPos) {
HXLINE(  85)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  85)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  85)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int this3 = this2;
HXDLIN(  85)															int this4;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  85)																this4 = this3;
            															}
HXDLIN(  85)															Float a1;
HXDLIN(  85)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  85)															if ((this5 == 0)) {
HXLINE(  85)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r1;
HXDLIN(  85)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  85)															if ((this6 == 0)) {
HXLINE(  85)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g1;
HXDLIN(  85)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  85)															if ((this7 == 0)) {
HXLINE(  85)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b1;
HXDLIN(  85)															int this8 = (this4 & 255);
HXDLIN(  85)															if ((this8 == 0)) {
HXLINE(  85)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a2;
HXDLIN(  85)															int this9 = ((col >> 24) & 255);
HXDLIN(  85)															if ((this9 == 0)) {
HXLINE(  85)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r2;
HXDLIN(  85)															int this10 = ((col >> 16) & 255);
HXDLIN(  85)															if ((this10 == 0)) {
HXLINE(  85)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g2;
HXDLIN(  85)															int this11 = ((col >> 8) & 255);
HXDLIN(  85)															if ((this11 == 0)) {
HXLINE(  85)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b2;
HXDLIN(  85)															int this12 = (col & 255);
HXDLIN(  85)															if ((this12 == 0)) {
HXLINE(  85)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)															{
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = blended;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((location >= 0)) {
HXLINE(  85)																	hitQuad = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  85)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)															int index;
HXDLIN(  85)															if (undoImage->useVirtualPos) {
HXLINE(  85)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  85)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  85)															int value;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  85)																value = c;
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((index >= 0)) {
HXLINE(  85)																hitQuad = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  85)														if (forceClear) {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)															int x = (dx - rectLeft);
HXDLIN(  85)															int y = (dy - rectTop);
HXDLIN(  85)															int index;
HXDLIN(  85)															if (undoImage->useVirtualPos) {
HXLINE(  85)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  85)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((index >= 0)) {
HXLINE(  85)																hitQuad = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							{
HXLINE(  85)								int _g_min = xIter3->start;
HXDLIN(  85)								int _g_max = xIter3->max;
HXDLIN(  85)								while((_g_min < _g_max)){
HXLINE(  85)									_g_min = (_g_min + 1);
HXDLIN(  85)									int px = (_g_min - 1);
HXDLIN(  85)									Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  85)									{
HXLINE(  85)										int _g_min1 = yIter3->start;
HXDLIN(  85)										int _g_max = yIter3->max;
HXDLIN(  85)										while((_g_min1 < _g_max)){
HXLINE(  85)											_g_min1 = (_g_min1 + 1);
HXDLIN(  85)											int py = (_g_min1 - 1);
HXDLIN(  85)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  85)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  85)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  85)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  85)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  85)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  85)											bool hitQuad;
HXDLIN(  85)											bool hitQuad1;
HXDLIN(  85)											if ((ratioA >= 0)) {
HXLINE(  85)												hitQuad1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  85)												hitQuad1 = false;
            											}
HXDLIN(  85)											if (hitQuad1) {
HXLINE(  85)												hitQuad = (ratioC >= 0);
            											}
            											else {
HXLINE(  85)												hitQuad = false;
            											}
HXDLIN(  85)											if (hitQuad) {
HXLINE(  85)												int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  85)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  85)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  85)												int this1 = i;
HXDLIN(  85)												int a = this1;
HXDLIN(  85)												int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  85)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  85)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  85)												int this2 = i1;
HXDLIN(  85)												int r = this2;
HXDLIN(  85)												int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  85)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  85)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  85)												int this3 = i2;
HXDLIN(  85)												int g = this3;
HXDLIN(  85)												int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  85)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  85)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  85)												int this4 = i3;
HXDLIN(  85)												int b = this4;
HXDLIN(  85)												{
HXLINE(  85)													int location;
HXDLIN(  85)													if (pixelShape->useVirtualPos) {
HXLINE(  85)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  85)														location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            													}
HXDLIN(  85)													bool hitQuad;
HXDLIN(  85)													if (pixelShape->transparent) {
HXLINE(  85)														hitQuad = (a < 254);
            													}
            													else {
HXLINE(  85)														hitQuad = false;
            													}
HXDLIN(  85)													if (hitQuad) {
HXLINE(  85)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)														int this3 = this2;
HXDLIN(  85)														int old;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  85)															old = this3;
            														}
HXDLIN(  85)														int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)														Float a1;
HXDLIN(  85)														int this4 = ((old >> 24) & 255);
HXDLIN(  85)														if ((this4 == 0)) {
HXLINE(  85)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float r1;
HXDLIN(  85)														int this5 = ((old >> 16) & 255);
HXDLIN(  85)														if ((this5 == 0)) {
HXLINE(  85)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float g1;
HXDLIN(  85)														int this6 = ((old >> 8) & 255);
HXDLIN(  85)														if ((this6 == 0)) {
HXLINE(  85)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float b1;
HXDLIN(  85)														int this7 = (old & 255);
HXDLIN(  85)														if ((this7 == 0)) {
HXLINE(  85)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float a2;
HXDLIN(  85)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  85)														if ((this8 == 0)) {
HXLINE(  85)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float r2;
HXDLIN(  85)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  85)														if ((this9 == 0)) {
HXLINE(  85)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float g2;
HXDLIN(  85)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  85)														if ((this10 == 0)) {
HXLINE(  85)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float b2;
HXDLIN(  85)														int this11 = (rhs & 255);
HXDLIN(  85)														if ((this11 == 0)) {
HXLINE(  85)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)														int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)														int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  85)														{
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  85)															int value;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  85)																value = blended;
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((location >= 0)) {
HXLINE(  85)																hitQuad = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  85)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)														int value;
HXDLIN(  85)														if (pixelShape->isLittle) {
HXLINE(  85)															value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            														}
            														else {
HXLINE(  85)															value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if ((location >= 0)) {
HXLINE(  85)															hitQuad = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  85)						{
HXLINE(  85)							bool hasHit = false;
HXDLIN(  85)							bool hasUndo1 = false;
HXDLIN(  85)							int aA1 = ((color2 >> 24) & 255);
HXDLIN(  85)							int rA1 = ((color2 >> 16) & 255);
HXDLIN(  85)							int gA1 = ((color2 >> 8) & 255);
HXDLIN(  85)							int bA1 = (color2 & 255);
HXDLIN(  85)							int aB1 = ((color1 >> 24) & 255);
HXDLIN(  85)							int rB1 = ((color1 >> 16) & 255);
HXDLIN(  85)							int gB1 = ((color1 >> 8) & 255);
HXDLIN(  85)							int bB1 = (color1 & 255);
HXDLIN(  85)							int aC1 = ((color2 >> 24) & 255);
HXDLIN(  85)							int rC1 = ((color2 >> 16) & 255);
HXDLIN(  85)							int gC1 = ((color2 >> 8) & 255);
HXDLIN(  85)							int bC1 = (color2 & 255);
HXDLIN(  85)							Float bcx1 = (cx - dx);
HXDLIN(  85)							Float bcy1 = (cy - dy);
HXDLIN(  85)							Float acx1 = (bx - dx);
HXDLIN(  85)							Float acy1 = (by - dy);
HXDLIN(  85)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  85)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  85)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  85)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  85)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  85)							if ((bx > cx)) {
HXLINE(  85)								if ((bx > dx)) {
HXLINE(  85)									int min;
HXDLIN(  85)									if ((cx > dx)) {
HXLINE(  85)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  85)										min = ::Math_obj::floor(cx);
            									}
HXDLIN(  85)									int ii_min = min;
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									xIter31 = this1;
            								}
            								else {
HXLINE(  85)									int ii_min = ::Math_obj::floor(cx);
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  85)								if ((cx > dx)) {
HXLINE(  85)									int min;
HXDLIN(  85)									if ((bx > dx)) {
HXLINE(  85)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  85)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  85)									int ii_min = min;
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									xIter31 = this1;
            								}
            								else {
HXLINE(  85)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									xIter31 = this1;
            								}
            							}
HXDLIN(  85)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  85)							if ((by > cy)) {
HXLINE(  85)								if ((by > dy)) {
HXLINE(  85)									int min;
HXDLIN(  85)									if ((cy > dy)) {
HXLINE(  85)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  85)										min = ::Math_obj::floor(cy);
            									}
HXDLIN(  85)									int ii_min = min;
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									yIter31 = this1;
            								}
            								else {
HXLINE(  85)									int ii_min = ::Math_obj::floor(cy);
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  85)								if ((cy > dy)) {
HXLINE(  85)									int min;
HXDLIN(  85)									if ((by > dy)) {
HXLINE(  85)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  85)										min = ::Math_obj::ceil(by);
            									}
HXDLIN(  85)									int ii_min = min;
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									yIter31 = this1;
            								}
            								else {
HXLINE(  85)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  85)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  85)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)									yIter31 = this1;
            								}
            							}
HXDLIN(  85)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  85)							if (hasUndo1) {
HXLINE(  85)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  85)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  85)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  85)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  85)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  85)								undoImage1 = this3;
HXDLIN(  85)								{
HXLINE(  85)									int rectLeft = xIter31->start;
HXDLIN(  85)									int rectTop = yIter31->start;
HXDLIN(  85)									int rectRight = xIter31->max;
HXDLIN(  85)									bool forceClear = false;
HXDLIN(  85)									{
HXLINE(  85)										int _g = rectTop;
HXDLIN(  85)										int _g1 = yIter31->max;
HXDLIN(  85)										while((_g < _g1)){
HXLINE(  85)											_g = (_g + 1);
HXDLIN(  85)											int dy = (_g - 1);
HXDLIN(  85)											{
HXLINE(  85)												int _g1 = rectLeft;
HXDLIN(  85)												int _g2 = rectRight;
HXDLIN(  85)												while((_g1 < _g2)){
HXLINE(  85)													_g1 = (_g1 + 1);
HXDLIN(  85)													int dx = (_g1 - 1);
HXDLIN(  85)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)													int index;
HXDLIN(  85)													if (pixelShape->useVirtualPos) {
HXLINE(  85)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  85)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  85)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)													int col;
HXDLIN(  85)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  85)														col = c;
            													}
HXDLIN(  85)													bool hitQuad;
HXDLIN(  85)													if (pixelShape->useMask) {
HXLINE(  85)														hitQuad = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  85)														hitQuad = false;
            													}
HXDLIN(  85)													if (hitQuad) {
HXLINE(  85)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  85)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  85)														int index;
HXDLIN(  85)														if (this1->useVirtualPos) {
HXLINE(  85)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  85)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  85)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  85)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  85)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)														int v;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  85)															v = c;
            														}
HXDLIN(  85)														int this3 = v;
HXDLIN(  85)														int maskPixel = this3;
HXDLIN(  85)														int this4 = col;
HXDLIN(  85)														int this5 = this4;
HXDLIN(  85)														if ((maskPixel == 0)) {
HXLINE(  85)															int this1 = this5;
HXDLIN(  85)															col = this1;
            														}
            														else {
HXLINE(  85)															Float m0;
HXDLIN(  85)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  85)															if ((this1 == 0)) {
HXLINE(  85)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m1;
HXDLIN(  85)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  85)															if ((this2 == 0)) {
HXLINE(  85)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m2;
HXDLIN(  85)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  85)															if ((this3 == 0)) {
HXLINE(  85)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m3;
HXDLIN(  85)															int this4 = (maskPixel & 255);
HXDLIN(  85)															if ((this4 == 0)) {
HXLINE(  85)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  85)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  85)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  85)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  85)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  85)													if ((col != 0)) {
HXLINE(  85)														int x = (dx - rectLeft);
HXDLIN(  85)														int y = (dy - rectTop);
HXDLIN(  85)														int this1 = col;
HXDLIN(  85)														int c = this1;
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  85)															hitQuad = undoImage1->transparent;
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															int location;
HXDLIN(  85)															if (undoImage1->useVirtualPos) {
HXLINE(  85)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  85)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  85)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)															int this3 = this2;
HXDLIN(  85)															int this4;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  85)																this4 = this3;
            															}
HXDLIN(  85)															Float a1;
HXDLIN(  85)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  85)															if ((this5 == 0)) {
HXLINE(  85)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r1;
HXDLIN(  85)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  85)															if ((this6 == 0)) {
HXLINE(  85)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g1;
HXDLIN(  85)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  85)															if ((this7 == 0)) {
HXLINE(  85)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b1;
HXDLIN(  85)															int this8 = (this4 & 255);
HXDLIN(  85)															if ((this8 == 0)) {
HXLINE(  85)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a2;
HXDLIN(  85)															int this9 = ((col >> 24) & 255);
HXDLIN(  85)															if ((this9 == 0)) {
HXLINE(  85)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r2;
HXDLIN(  85)															int this10 = ((col >> 16) & 255);
HXDLIN(  85)															if ((this10 == 0)) {
HXLINE(  85)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g2;
HXDLIN(  85)															int this11 = ((col >> 8) & 255);
HXDLIN(  85)															if ((this11 == 0)) {
HXLINE(  85)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b2;
HXDLIN(  85)															int this12 = (col & 255);
HXDLIN(  85)															if ((this12 == 0)) {
HXLINE(  85)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  85)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)															{
HXLINE(  85)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  85)																int value;
HXDLIN(  85)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  85)																	value = blended;
            																}
HXDLIN(  85)																bool hitQuad;
HXDLIN(  85)																if ((location >= 0)) {
HXLINE(  85)																	hitQuad = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  85)																	hitQuad = false;
            																}
HXDLIN(  85)																if (hitQuad) {
HXLINE(  85)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  85)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  85)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)															int index;
HXDLIN(  85)															if (undoImage1->useVirtualPos) {
HXLINE(  85)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  85)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  85)															int value;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  85)																value = c;
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((index >= 0)) {
HXLINE(  85)																hitQuad = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  85)														if (forceClear) {
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  85)															int x = (dx - rectLeft);
HXDLIN(  85)															int y = (dy - rectTop);
HXDLIN(  85)															int index;
HXDLIN(  85)															if (undoImage1->useVirtualPos) {
HXLINE(  85)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  85)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((index >= 0)) {
HXLINE(  85)																hitQuad = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							{
HXLINE(  85)								int _g_min1 = xIter31->start;
HXDLIN(  85)								int _g_max1 = xIter31->max;
HXDLIN(  85)								while((_g_min1 < _g_max1)){
HXLINE(  85)									_g_min1 = (_g_min1 + 1);
HXDLIN(  85)									int px = (_g_min1 - 1);
HXDLIN(  85)									Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  85)									{
HXLINE(  85)										int _g_min = yIter31->start;
HXDLIN(  85)										int _g_max = yIter31->max;
HXDLIN(  85)										while((_g_min < _g_max)){
HXLINE(  85)											_g_min = (_g_min + 1);
HXDLIN(  85)											int py = (_g_min - 1);
HXDLIN(  85)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  85)											Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  85)											Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  85)											Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  85)											Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  85)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  85)											bool hitQuad;
HXDLIN(  85)											bool hitQuad1;
HXDLIN(  85)											if ((ratioA >= 0)) {
HXLINE(  85)												hitQuad1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  85)												hitQuad1 = false;
            											}
HXDLIN(  85)											if (hitQuad1) {
HXLINE(  85)												hitQuad = (ratioC >= 0);
            											}
            											else {
HXLINE(  85)												hitQuad = false;
            											}
HXDLIN(  85)											if (hitQuad) {
HXLINE(  85)												int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  85)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  85)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  85)												int this1 = i;
HXDLIN(  85)												int a = this1;
HXDLIN(  85)												int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  85)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  85)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  85)												int this2 = i1;
HXDLIN(  85)												int r = this2;
HXDLIN(  85)												int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  85)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  85)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  85)												int this3 = i2;
HXDLIN(  85)												int g = this3;
HXDLIN(  85)												int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  85)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  85)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  85)												int this4 = i3;
HXDLIN(  85)												int b = this4;
HXDLIN(  85)												{
HXLINE(  85)													int location;
HXDLIN(  85)													if (pixelShape->useVirtualPos) {
HXLINE(  85)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  85)														location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            													}
HXDLIN(  85)													bool hitQuad;
HXDLIN(  85)													if (pixelShape->transparent) {
HXLINE(  85)														hitQuad = (a < 254);
            													}
            													else {
HXLINE(  85)														hitQuad = false;
            													}
HXDLIN(  85)													if (hitQuad) {
HXLINE(  85)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)														int this3 = this2;
HXDLIN(  85)														int old;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  85)															old = this3;
            														}
HXDLIN(  85)														int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)														Float a1;
HXDLIN(  85)														int this4 = ((old >> 24) & 255);
HXDLIN(  85)														if ((this4 == 0)) {
HXLINE(  85)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float r1;
HXDLIN(  85)														int this5 = ((old >> 16) & 255);
HXDLIN(  85)														if ((this5 == 0)) {
HXLINE(  85)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float g1;
HXDLIN(  85)														int this6 = ((old >> 8) & 255);
HXDLIN(  85)														if ((this6 == 0)) {
HXLINE(  85)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float b1;
HXDLIN(  85)														int this7 = (old & 255);
HXDLIN(  85)														if ((this7 == 0)) {
HXLINE(  85)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float a2;
HXDLIN(  85)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  85)														if ((this8 == 0)) {
HXLINE(  85)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float r2;
HXDLIN(  85)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  85)														if ((this9 == 0)) {
HXLINE(  85)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float g2;
HXDLIN(  85)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  85)														if ((this10 == 0)) {
HXLINE(  85)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float b2;
HXDLIN(  85)														int this11 = (rhs & 255);
HXDLIN(  85)														if ((this11 == 0)) {
HXLINE(  85)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  85)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)														int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)														int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  85)														{
HXLINE(  85)															::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  85)															int value;
HXDLIN(  85)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  85)																value = blended;
            															}
HXDLIN(  85)															bool hitQuad;
HXDLIN(  85)															if ((location >= 0)) {
HXLINE(  85)																hitQuad = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  85)																hitQuad = false;
            															}
HXDLIN(  85)															if (hitQuad) {
HXLINE(  85)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  85)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  85)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  85)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)														int value;
HXDLIN(  85)														if (pixelShape->isLittle) {
HXLINE(  85)															value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            														}
            														else {
HXLINE(  85)															value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            														}
HXDLIN(  85)														bool hitQuad;
HXDLIN(  85)														if ((location >= 0)) {
HXLINE(  85)															hitQuad = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  85)															hitQuad = false;
            														}
HXDLIN(  85)														if (hitQuad) {
HXLINE(  85)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							if ((hasHit == false)) {
HXLINE(  85)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  85)								if (hasUndo1) {
HXLINE(  85)									v->undoImage = undoImage1;
HXDLIN(  85)									v->undoX = xIter31->start;
HXDLIN(  85)									v->undoY = yIter31->start;
            								}
            							}
            						}
HXDLIN(  85)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  85)						hitQuad = v;
            					}
HXDLIN(  85)					Float cx = h2;
HXDLIN(  85)					Float cy = radius2;
HXDLIN(  85)					Float bx = h2;
HXDLIN(  85)					Float by = -(radius2);
HXDLIN(  85)					Float temp = ((Float)0.);
HXLINE( 526)					temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 527)					by = (py + ((by * cos) + (bx * sin)));
HXLINE( 528)					bx = temp;
HXLINE( 529)					temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 530)					cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 531)					cx = temp;
HXLINE(  85)					::pixelimage::pixel::_TwoGrad::TwoGrad_ this1 = ::pixelimage::pixel::_TwoGrad::TwoGrad__obj::__alloc( HX_CTX ,color1,color2);
HXDLIN(  85)					::pixelimage::pixel::_TwoGrad::TwoGrad_ twoColors = this1;
HXDLIN(  85)					int a1 = twoColors->colorClock;
HXDLIN(  85)					int b = twoColors->colorAnti;
HXDLIN(  85)					int half = ((((::Math_obj::round(((((( (Float)(((a1 >> 24) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 24) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 24) | (::Math_obj::round(((((( (Float)(((a1 >> 16) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 16) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 16)) | (::Math_obj::round(((((( (Float)(((a1 >> 8) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 8) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 8)) | ::Math_obj::round(((((( (Float)((a1 & 255)) ) / ( (Float)(255) )) + (( (Float)((b & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))));
HXDLIN(  85)					bool hasUndo = false;
HXDLIN(  85)					int aA = ((color1 >> 24) & 255);
HXDLIN(  85)					int rA = ((color1 >> 16) & 255);
HXDLIN(  85)					int gA = ((color1 >> 8) & 255);
HXDLIN(  85)					int bA = (color1 & 255);
HXDLIN(  85)					int aB = ((half >> 24) & 255);
HXDLIN(  85)					int rB = ((half >> 16) & 255);
HXDLIN(  85)					int gB = ((half >> 8) & 255);
HXDLIN(  85)					int bB = (half & 255);
HXDLIN(  85)					int aC = ((color2 >> 24) & 255);
HXDLIN(  85)					int rC = ((color2 >> 16) & 255);
HXDLIN(  85)					int gC = ((color2 >> 8) & 255);
HXDLIN(  85)					int bC = (color2 & 255);
HXDLIN(  85)					Float bcx = (bx - cx);
HXDLIN(  85)					Float bcy = (by - cy);
HXDLIN(  85)					Float acx = (qx - cx);
HXDLIN(  85)					Float acy = (qy - cy);
HXDLIN(  85)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  85)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  85)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  85)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  85)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  85)					if ((qx > bx)) {
HXLINE(  85)						if ((qx > cx)) {
HXLINE(  85)							int min;
HXDLIN(  85)							if ((bx > cx)) {
HXLINE(  85)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE(  85)								min = ::Math_obj::floor(bx);
            							}
HXDLIN(  85)							int ii_min = min;
HXDLIN(  85)							int ii_max = ::Math_obj::ceil(qx);
HXDLIN(  85)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)							xIter3 = this1;
            						}
            						else {
HXLINE(  85)							int ii_min = ::Math_obj::floor(bx);
HXDLIN(  85)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  85)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE(  85)						if ((bx > cx)) {
HXLINE(  85)							int min;
HXDLIN(  85)							if ((qx > cx)) {
HXLINE(  85)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE(  85)								min = ::Math_obj::ceil(qx);
            							}
HXDLIN(  85)							int ii_min = min;
HXDLIN(  85)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  85)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)							xIter3 = this1;
            						}
            						else {
HXLINE(  85)							int ii_min = ::Math_obj::floor(qx);
HXDLIN(  85)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  85)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)							xIter3 = this1;
            						}
            					}
HXDLIN(  85)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  85)					if ((qy > by)) {
HXLINE(  85)						if ((qy > cy)) {
HXLINE(  85)							int min;
HXDLIN(  85)							if ((by > cy)) {
HXLINE(  85)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  85)								min = ::Math_obj::floor(by);
            							}
HXDLIN(  85)							int ii_min = min;
HXDLIN(  85)							int ii_max = ::Math_obj::ceil(qy);
HXDLIN(  85)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)							yIter3 = this1;
            						}
            						else {
HXLINE(  85)							int ii_min = ::Math_obj::floor(by);
HXDLIN(  85)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  85)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE(  85)						if ((by > cy)) {
HXLINE(  85)							int min;
HXDLIN(  85)							if ((qy > cy)) {
HXLINE(  85)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  85)								min = ::Math_obj::ceil(qy);
            							}
HXDLIN(  85)							int ii_min = min;
HXDLIN(  85)							int ii_max = ::Math_obj::ceil(by);
HXDLIN(  85)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)							yIter3 = this1;
            						}
            						else {
HXLINE(  85)							int ii_min = ::Math_obj::floor(qy);
HXDLIN(  85)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  85)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  85)							yIter3 = this1;
            						}
            					}
HXDLIN(  85)					::pixelimage::ImageStruct undoImage = null();
HXDLIN(  85)					if (hasUndo) {
HXLINE(  85)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  85)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  85)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  85)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  85)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  85)						undoImage = this3;
HXDLIN(  85)						{
HXLINE(  85)							int rectLeft = xIter3->start;
HXDLIN(  85)							int rectTop = yIter3->start;
HXDLIN(  85)							int rectRight = xIter3->max;
HXDLIN(  85)							bool forceClear = false;
HXDLIN(  85)							{
HXLINE(  85)								int _g = rectTop;
HXDLIN(  85)								int _g1 = yIter3->max;
HXDLIN(  85)								while((_g < _g1)){
HXLINE(  85)									_g = (_g + 1);
HXDLIN(  85)									int dy = (_g - 1);
HXDLIN(  85)									{
HXLINE(  85)										int _g1 = rectLeft;
HXDLIN(  85)										int _g2 = rectRight;
HXDLIN(  85)										while((_g1 < _g2)){
HXLINE(  85)											_g1 = (_g1 + 1);
HXDLIN(  85)											int dx = (_g1 - 1);
HXDLIN(  85)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)											int index;
HXDLIN(  85)											if (pixelShape->useVirtualPos) {
HXLINE(  85)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  85)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  85)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)											int col;
HXDLIN(  85)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  85)												col = c;
            											}
HXDLIN(  85)											bool _hx_tmp;
HXDLIN(  85)											if (pixelShape->useMask) {
HXLINE(  85)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  85)												_hx_tmp = false;
            											}
HXDLIN(  85)											if (_hx_tmp) {
HXLINE(  85)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  85)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  85)												int index;
HXDLIN(  85)												if (this1->useVirtualPos) {
HXLINE(  85)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  85)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  85)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  85)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  85)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)												int v;
HXDLIN(  85)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  85)													v = c;
            												}
HXDLIN(  85)												int this3 = v;
HXDLIN(  85)												int maskPixel = this3;
HXDLIN(  85)												int this4 = col;
HXDLIN(  85)												int this5 = this4;
HXDLIN(  85)												if ((maskPixel == 0)) {
HXLINE(  85)													int this1 = this5;
HXDLIN(  85)													col = this1;
            												}
            												else {
HXLINE(  85)													Float m0;
HXDLIN(  85)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  85)													if ((this1 == 0)) {
HXLINE(  85)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float m1;
HXDLIN(  85)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  85)													if ((this2 == 0)) {
HXLINE(  85)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float m2;
HXDLIN(  85)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  85)													if ((this3 == 0)) {
HXLINE(  85)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float m3;
HXDLIN(  85)													int this4 = (maskPixel & 255);
HXDLIN(  85)													if ((this4 == 0)) {
HXLINE(  85)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  85)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  85)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  85)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  85)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  85)											if ((col != 0)) {
HXLINE(  85)												int x = (dx - rectLeft);
HXDLIN(  85)												int y = (dy - rectTop);
HXDLIN(  85)												int this1 = col;
HXDLIN(  85)												int c = this1;
HXDLIN(  85)												bool _hx_tmp;
HXDLIN(  85)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  85)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE(  85)													_hx_tmp = false;
            												}
HXDLIN(  85)												if (_hx_tmp) {
HXLINE(  85)													int location;
HXDLIN(  85)													if (undoImage->useVirtualPos) {
HXLINE(  85)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  85)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  85)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)													int this3 = this2;
HXDLIN(  85)													int this4;
HXDLIN(  85)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  85)														this4 = this3;
            													}
HXDLIN(  85)													Float a1;
HXDLIN(  85)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  85)													if ((this5 == 0)) {
HXLINE(  85)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float r1;
HXDLIN(  85)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  85)													if ((this6 == 0)) {
HXLINE(  85)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float g1;
HXDLIN(  85)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  85)													if ((this7 == 0)) {
HXLINE(  85)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float b1;
HXDLIN(  85)													int this8 = (this4 & 255);
HXDLIN(  85)													if ((this8 == 0)) {
HXLINE(  85)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float a2;
HXDLIN(  85)													int this9 = ((col >> 24) & 255);
HXDLIN(  85)													if ((this9 == 0)) {
HXLINE(  85)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float r2;
HXDLIN(  85)													int this10 = ((col >> 16) & 255);
HXDLIN(  85)													if ((this10 == 0)) {
HXLINE(  85)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float g2;
HXDLIN(  85)													int this11 = ((col >> 8) & 255);
HXDLIN(  85)													if ((this11 == 0)) {
HXLINE(  85)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float b2;
HXDLIN(  85)													int this12 = (col & 255);
HXDLIN(  85)													if ((this12 == 0)) {
HXLINE(  85)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  85)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  85)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)													{
HXLINE(  85)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  85)														int value;
HXDLIN(  85)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  85)															value = blended;
            														}
HXDLIN(  85)														bool _hx_tmp;
HXDLIN(  85)														if ((location >= 0)) {
HXLINE(  85)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  85)															_hx_tmp = false;
            														}
HXDLIN(  85)														if (_hx_tmp) {
HXLINE(  85)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  85)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  85)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  85)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)													int index;
HXDLIN(  85)													if (undoImage->useVirtualPos) {
HXLINE(  85)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  85)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  85)													int value;
HXDLIN(  85)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  85)														value = c;
            													}
HXDLIN(  85)													bool _hx_tmp;
HXDLIN(  85)													if ((index >= 0)) {
HXLINE(  85)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  85)														_hx_tmp = false;
            													}
HXDLIN(  85)													if (_hx_tmp) {
HXLINE(  85)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  85)												if (forceClear) {
HXLINE(  85)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  85)													int x = (dx - rectLeft);
HXDLIN(  85)													int y = (dy - rectTop);
HXDLIN(  85)													int index;
HXDLIN(  85)													if (undoImage->useVirtualPos) {
HXLINE(  85)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  85)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  85)													bool _hx_tmp;
HXDLIN(  85)													if ((index >= 0)) {
HXLINE(  85)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  85)														_hx_tmp = false;
            													}
HXDLIN(  85)													if (_hx_tmp) {
HXLINE(  85)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  85)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  85)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  85)					{
HXLINE(  85)						int _g_min = xIter3->start;
HXDLIN(  85)						int _g_max = xIter3->max;
HXDLIN(  85)						while((_g_min < _g_max)){
HXLINE(  85)							_g_min = (_g_min + 1);
HXDLIN(  85)							int px = (_g_min - 1);
HXDLIN(  85)							Float pcx = (( (Float)(px) ) - cx);
HXDLIN(  85)							{
HXLINE(  85)								int _g_min1 = yIter3->start;
HXDLIN(  85)								int _g_max = yIter3->max;
HXDLIN(  85)								while((_g_min1 < _g_max)){
HXLINE(  85)									_g_min1 = (_g_min1 + 1);
HXDLIN(  85)									int py = (_g_min1 - 1);
HXDLIN(  85)									Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  85)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  85)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  85)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  85)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  85)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  85)									bool _hx_tmp;
HXDLIN(  85)									bool _hx_tmp1;
HXDLIN(  85)									if ((ratioA >= 0)) {
HXLINE(  85)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  85)										_hx_tmp1 = false;
            									}
HXDLIN(  85)									if (_hx_tmp1) {
HXLINE(  85)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  85)										_hx_tmp = false;
            									}
HXDLIN(  85)									if (_hx_tmp) {
HXLINE(  85)										int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  85)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  85)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  85)										int this1 = i;
HXDLIN(  85)										int a = this1;
HXDLIN(  85)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  85)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  85)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  85)										int this2 = i1;
HXDLIN(  85)										int r = this2;
HXDLIN(  85)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  85)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  85)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  85)										int this3 = i2;
HXDLIN(  85)										int g = this3;
HXDLIN(  85)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  85)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  85)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  85)										int this4 = i3;
HXDLIN(  85)										int b = this4;
HXDLIN(  85)										{
HXLINE(  85)											int location;
HXDLIN(  85)											if (pixelShape->useVirtualPos) {
HXLINE(  85)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  85)												location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            											}
HXDLIN(  85)											bool _hx_tmp;
HXDLIN(  85)											if (pixelShape->transparent) {
HXLINE(  85)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  85)												_hx_tmp = false;
            											}
HXDLIN(  85)											if (_hx_tmp) {
HXLINE(  85)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  85)												int this3 = this2;
HXDLIN(  85)												int old;
HXDLIN(  85)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  85)													old = this3;
            												}
HXDLIN(  85)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  85)												Float a1;
HXDLIN(  85)												int this4 = ((old >> 24) & 255);
HXDLIN(  85)												if ((this4 == 0)) {
HXLINE(  85)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  85)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  85)												Float r1;
HXDLIN(  85)												int this5 = ((old >> 16) & 255);
HXDLIN(  85)												if ((this5 == 0)) {
HXLINE(  85)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  85)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  85)												Float g1;
HXDLIN(  85)												int this6 = ((old >> 8) & 255);
HXDLIN(  85)												if ((this6 == 0)) {
HXLINE(  85)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  85)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  85)												Float b1;
HXDLIN(  85)												int this7 = (old & 255);
HXDLIN(  85)												if ((this7 == 0)) {
HXLINE(  85)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  85)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  85)												Float a2;
HXDLIN(  85)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  85)												if ((this8 == 0)) {
HXLINE(  85)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  85)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  85)												Float r2;
HXDLIN(  85)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  85)												if ((this9 == 0)) {
HXLINE(  85)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  85)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  85)												Float g2;
HXDLIN(  85)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  85)												if ((this10 == 0)) {
HXLINE(  85)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  85)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  85)												Float b2;
HXDLIN(  85)												int this11 = (rhs & 255);
HXDLIN(  85)												if ((this11 == 0)) {
HXLINE(  85)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  85)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  85)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  85)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  85)												{
HXLINE(  85)													::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  85)													int value;
HXDLIN(  85)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  85)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  85)														value = blended;
            													}
HXDLIN(  85)													bool _hx_tmp;
HXDLIN(  85)													if ((location >= 0)) {
HXLINE(  85)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  85)														_hx_tmp = false;
            													}
HXDLIN(  85)													if (_hx_tmp) {
HXLINE(  85)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  85)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  85)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  85)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  85)												int value;
HXDLIN(  85)												if (pixelShape->isLittle) {
HXLINE(  85)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  85)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  85)												bool _hx_tmp;
HXDLIN(  85)												if ((location >= 0)) {
HXLINE(  85)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  85)													_hx_tmp = false;
            												}
HXDLIN(  85)												if (_hx_tmp) {
HXLINE(  85)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  85)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  85)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  85)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  85)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  85)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  85)					::pixelimage::algo::HitTri hitTri;
HXDLIN(  85)					if ((hasHit == false)) {
HXLINE(  85)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx,by,cx,cy,true);
HXDLIN(  85)						if (hasUndo) {
HXLINE(  85)							v->undoImage = undoImage;
HXDLIN(  85)							v->undoX = xIter3->start;
HXDLIN(  85)							v->undoY = yIter3->start;
            						}
HXDLIN(  85)						hitTri = v;
            					}
            					else {
HXLINE(  85)						hitTri = null();
            					}
HXDLIN(  85)					if (hasHit) {
HXLINE(  85)						::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN(  85)						if (::hx::IsNotNull( hitQuad )) {
HXLINE(  85)							hitArr->triArr->push(hitQuad->triABD);
            						}
HXDLIN(  85)						hitArr->triArr->push(hitQuad->triBCD);
            					}
            				}
            			}
            			else {
HXLINE(  87)				Float thick = this->strokeWidth;
HXDLIN(  87)				int color1 = this->strokeTopColor;
HXDLIN(  87)				int color2 = this->strokeBottomColor;
HXDLIN(  87)				bool hasHit = true;
HXDLIN(  87)				{
HXLINE(  87)					Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  87)					Float o = (qy - py);
HXDLIN(  87)					Float a = (qx - px);
HXDLIN(  87)					Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  87)					Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  87)					Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN(  87)					Float sin = ::Math_obj::sin(theta);
HXDLIN(  87)					Float cos = ::Math_obj::cos(theta);
HXDLIN(  87)					Float radius = (thick / ( (Float)(2) ));
HXDLIN(  87)					Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  87)					Float h2 = (h / goldenRatio);
HXDLIN(  87)					::pixelimage::algo::HitQuad hitQuad;
HXDLIN(  87)					if (this->flare) {
HXLINE(  87)						if (this->reverseFlare) {
HXLINE(  87)							Float sin = ::Math_obj::sin(theta);
HXDLIN(  87)							Float cos = ::Math_obj::cos(theta);
HXDLIN(  87)							Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  87)							Float radius2 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  87)							Float dx = ((Float)0.1);
HXDLIN(  87)							Float dy = radius1;
HXDLIN(  87)							Float cx = h2;
HXDLIN(  87)							Float cy = radius2;
HXDLIN(  87)							Float bx = h2;
HXDLIN(  87)							Float by = -(radius2);
HXDLIN(  87)							Float ax = ((Float)0.1);
HXDLIN(  87)							Float ay = -(radius1);
HXDLIN(  87)							Float temp = ((Float)0.);
HXLINE( 525)							temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 526)							ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 527)							ax = temp;
HXLINE( 529)							temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 530)							by = (py + ((by * cos) + (bx * sin)));
HXLINE( 531)							bx = temp;
HXLINE( 533)							temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 534)							cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 535)							cx = temp;
HXLINE( 537)							temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 538)							dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 539)							dx = temp;
HXLINE(  87)							{
HXLINE(  87)								bool hasUndo = false;
HXDLIN(  87)								int aA = ((color1 >> 24) & 255);
HXDLIN(  87)								int rA = ((color1 >> 16) & 255);
HXDLIN(  87)								int gA = ((color1 >> 8) & 255);
HXDLIN(  87)								int bA = (color1 & 255);
HXDLIN(  87)								int aB = ((color1 >> 24) & 255);
HXDLIN(  87)								int rB = ((color1 >> 16) & 255);
HXDLIN(  87)								int gB = ((color1 >> 8) & 255);
HXDLIN(  87)								int bB = (color1 & 255);
HXDLIN(  87)								int aC = ((color2 >> 24) & 255);
HXDLIN(  87)								int rC = ((color2 >> 16) & 255);
HXDLIN(  87)								int gC = ((color2 >> 8) & 255);
HXDLIN(  87)								int bC = (color2 & 255);
HXDLIN(  87)								Float bcx = (bx - dx);
HXDLIN(  87)								Float bcy = (by - dy);
HXDLIN(  87)								Float acx = (ax - dx);
HXDLIN(  87)								Float acy = (ay - dy);
HXDLIN(  87)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  87)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  87)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  87)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  87)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  87)								if ((ax > bx)) {
HXLINE(  87)									if ((ax > dx)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((bx > dx)) {
HXLINE(  87)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter3 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  87)									if ((bx > dx)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((ax > dx)) {
HXLINE(  87)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter3 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter3 = this1;
            									}
            								}
HXDLIN(  87)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  87)								if ((ay > by)) {
HXLINE(  87)									if ((ay > dy)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((by > dy)) {
HXLINE(  87)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter3 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  87)									if ((by > dy)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((ay > dy)) {
HXLINE(  87)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter3 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter3 = this1;
            									}
            								}
HXDLIN(  87)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  87)								if (hasUndo) {
HXLINE(  87)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  87)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  87)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  87)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  87)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  87)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  87)									undoImage = this3;
HXDLIN(  87)									{
HXLINE(  87)										int rectLeft = xIter3->start;
HXDLIN(  87)										int rectTop = yIter3->start;
HXDLIN(  87)										int rectRight = xIter3->max;
HXDLIN(  87)										bool forceClear = false;
HXDLIN(  87)										{
HXLINE(  87)											int _g = rectTop;
HXDLIN(  87)											int _g1 = yIter3->max;
HXDLIN(  87)											while((_g < _g1)){
HXLINE(  87)												_g = (_g + 1);
HXDLIN(  87)												int dy = (_g - 1);
HXDLIN(  87)												{
HXLINE(  87)													int _g1 = rectLeft;
HXDLIN(  87)													int _g2 = rectRight;
HXDLIN(  87)													while((_g1 < _g2)){
HXLINE(  87)														_g1 = (_g1 + 1);
HXDLIN(  87)														int dx = (_g1 - 1);
HXDLIN(  87)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)														int index;
HXDLIN(  87)														if (pixelShape->useVirtualPos) {
HXLINE(  87)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  87)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  87)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)														int col;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  87)															col = c;
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if (pixelShape->useMask) {
HXLINE(  87)															hitQuad = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  87)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  87)															int index;
HXDLIN(  87)															if (this1->useVirtualPos) {
HXLINE(  87)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  87)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  87)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  87)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  87)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int v;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  87)																v = c;
            															}
HXDLIN(  87)															int this3 = v;
HXDLIN(  87)															int maskPixel = this3;
HXDLIN(  87)															int this4 = col;
HXDLIN(  87)															int this5 = this4;
HXDLIN(  87)															if ((maskPixel == 0)) {
HXLINE(  87)																int this1 = this5;
HXDLIN(  87)																col = this1;
            															}
            															else {
HXLINE(  87)																Float m0;
HXDLIN(  87)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  87)																if ((this1 == 0)) {
HXLINE(  87)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m1;
HXDLIN(  87)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  87)																if ((this2 == 0)) {
HXLINE(  87)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m2;
HXDLIN(  87)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  87)																if ((this3 == 0)) {
HXLINE(  87)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m3;
HXDLIN(  87)																int this4 = (maskPixel & 255);
HXDLIN(  87)																if ((this4 == 0)) {
HXLINE(  87)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  87)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  87)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  87)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  87)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  87)														if ((col != 0)) {
HXLINE(  87)															int x = (dx - rectLeft);
HXDLIN(  87)															int y = (dy - rectTop);
HXDLIN(  87)															int this1 = col;
HXDLIN(  87)															int c = this1;
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  87)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																int location;
HXDLIN(  87)																if (undoImage->useVirtualPos) {
HXLINE(  87)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  87)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)																int this3 = this2;
HXDLIN(  87)																int this4;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	this4 = this3;
            																}
HXDLIN(  87)																Float a1;
HXDLIN(  87)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  87)																if ((this5 == 0)) {
HXLINE(  87)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float r1;
HXDLIN(  87)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  87)																if ((this6 == 0)) {
HXLINE(  87)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float g1;
HXDLIN(  87)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  87)																if ((this7 == 0)) {
HXLINE(  87)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float b1;
HXDLIN(  87)																int this8 = (this4 & 255);
HXDLIN(  87)																if ((this8 == 0)) {
HXLINE(  87)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float a2;
HXDLIN(  87)																int this9 = ((col >> 24) & 255);
HXDLIN(  87)																if ((this9 == 0)) {
HXLINE(  87)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float r2;
HXDLIN(  87)																int this10 = ((col >> 16) & 255);
HXDLIN(  87)																if ((this10 == 0)) {
HXLINE(  87)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float g2;
HXDLIN(  87)																int this11 = ((col >> 8) & 255);
HXDLIN(  87)																if ((this11 == 0)) {
HXLINE(  87)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float b2;
HXDLIN(  87)																int this12 = (col & 255);
HXDLIN(  87)																if ((this12 == 0)) {
HXLINE(  87)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)																{
HXLINE(  87)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  87)																	int value;
HXDLIN(  87)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  87)																		value = blended;
            																	}
HXDLIN(  87)																	bool hitQuad;
HXDLIN(  87)																	if ((location >= 0)) {
HXLINE(  87)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  87)																		hitQuad = false;
            																	}
HXDLIN(  87)																	if (hitQuad) {
HXLINE(  87)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  87)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  87)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)																int index;
HXDLIN(  87)																if (undoImage->useVirtualPos) {
HXLINE(  87)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  87)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = c;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((index >= 0)) {
HXLINE(  87)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															if (forceClear) {
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)																int x = (dx - rectLeft);
HXDLIN(  87)																int y = (dy - rectTop);
HXDLIN(  87)																int index;
HXDLIN(  87)																if (undoImage->useVirtualPos) {
HXLINE(  87)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  87)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((index >= 0)) {
HXLINE(  87)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  87)								{
HXLINE(  87)									int _g_min = xIter3->start;
HXDLIN(  87)									int _g_max = xIter3->max;
HXDLIN(  87)									while((_g_min < _g_max)){
HXLINE(  87)										_g_min = (_g_min + 1);
HXDLIN(  87)										int px = (_g_min - 1);
HXDLIN(  87)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  87)										{
HXLINE(  87)											int _g_min1 = yIter3->start;
HXDLIN(  87)											int _g_max = yIter3->max;
HXDLIN(  87)											while((_g_min1 < _g_max)){
HXLINE(  87)												_g_min1 = (_g_min1 + 1);
HXDLIN(  87)												int py = (_g_min1 - 1);
HXDLIN(  87)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  87)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  87)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  87)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  87)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  87)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  87)												bool hitQuad;
HXDLIN(  87)												bool hitQuad1;
HXDLIN(  87)												if ((ratioA >= 0)) {
HXLINE(  87)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  87)													hitQuad1 = false;
            												}
HXDLIN(  87)												if (hitQuad1) {
HXLINE(  87)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  87)													hitQuad = false;
            												}
HXDLIN(  87)												if (hitQuad) {
HXLINE(  87)													int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  87)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  87)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  87)													int this1 = i;
HXDLIN(  87)													int a = this1;
HXDLIN(  87)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  87)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  87)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  87)													int this2 = i1;
HXDLIN(  87)													int r = this2;
HXDLIN(  87)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  87)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  87)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  87)													int this3 = i2;
HXDLIN(  87)													int g = this3;
HXDLIN(  87)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  87)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  87)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  87)													int this4 = i3;
HXDLIN(  87)													int b = this4;
HXDLIN(  87)													{
HXLINE(  87)														int location;
HXDLIN(  87)														if (pixelShape->useVirtualPos) {
HXLINE(  87)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  87)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if (pixelShape->transparent) {
HXLINE(  87)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int this3 = this2;
HXDLIN(  87)															int old;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  87)																old = this3;
            															}
HXDLIN(  87)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)															Float a1;
HXDLIN(  87)															int this4 = ((old >> 24) & 255);
HXDLIN(  87)															if ((this4 == 0)) {
HXLINE(  87)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r1;
HXDLIN(  87)															int this5 = ((old >> 16) & 255);
HXDLIN(  87)															if ((this5 == 0)) {
HXLINE(  87)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g1;
HXDLIN(  87)															int this6 = ((old >> 8) & 255);
HXDLIN(  87)															if ((this6 == 0)) {
HXLINE(  87)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b1;
HXDLIN(  87)															int this7 = (old & 255);
HXDLIN(  87)															if ((this7 == 0)) {
HXLINE(  87)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a2;
HXDLIN(  87)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  87)															if ((this8 == 0)) {
HXLINE(  87)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r2;
HXDLIN(  87)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  87)															if ((this9 == 0)) {
HXLINE(  87)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g2;
HXDLIN(  87)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  87)															if ((this10 == 0)) {
HXLINE(  87)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b2;
HXDLIN(  87)															int this11 = (rhs & 255);
HXDLIN(  87)															if ((this11 == 0)) {
HXLINE(  87)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  87)															{
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = blended;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((location >= 0)) {
HXLINE(  87)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  87)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)															int value;
HXDLIN(  87)															if (pixelShape->isLittle) {
HXLINE(  87)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  87)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((location >= 0)) {
HXLINE(  87)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  87)							{
HXLINE(  87)								bool hasHit = false;
HXDLIN(  87)								bool hasUndo1 = false;
HXDLIN(  87)								int aA1 = ((color2 >> 24) & 255);
HXDLIN(  87)								int rA1 = ((color2 >> 16) & 255);
HXDLIN(  87)								int gA1 = ((color2 >> 8) & 255);
HXDLIN(  87)								int bA1 = (color2 & 255);
HXDLIN(  87)								int aB1 = ((color1 >> 24) & 255);
HXDLIN(  87)								int rB1 = ((color1 >> 16) & 255);
HXDLIN(  87)								int gB1 = ((color1 >> 8) & 255);
HXDLIN(  87)								int bB1 = (color1 & 255);
HXDLIN(  87)								int aC1 = ((color2 >> 24) & 255);
HXDLIN(  87)								int rC1 = ((color2 >> 16) & 255);
HXDLIN(  87)								int gC1 = ((color2 >> 8) & 255);
HXDLIN(  87)								int bC1 = (color2 & 255);
HXDLIN(  87)								Float bcx1 = (cx - dx);
HXDLIN(  87)								Float bcy1 = (cy - dy);
HXDLIN(  87)								Float acx1 = (bx - dx);
HXDLIN(  87)								Float acy1 = (by - dy);
HXDLIN(  87)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  87)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  87)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  87)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  87)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  87)								if ((bx > cx)) {
HXLINE(  87)									if ((bx > dx)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((cx > dx)) {
HXLINE(  87)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter31 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  87)									if ((cx > dx)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((bx > dx)) {
HXLINE(  87)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter31 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter31 = this1;
            									}
            								}
HXDLIN(  87)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  87)								if ((by > cy)) {
HXLINE(  87)									if ((by > dy)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((cy > dy)) {
HXLINE(  87)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter31 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  87)									if ((cy > dy)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((by > dy)) {
HXLINE(  87)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter31 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter31 = this1;
            									}
            								}
HXDLIN(  87)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  87)								if (hasUndo1) {
HXLINE(  87)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  87)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  87)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  87)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  87)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  87)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  87)									undoImage1 = this3;
HXDLIN(  87)									{
HXLINE(  87)										int rectLeft = xIter31->start;
HXDLIN(  87)										int rectTop = yIter31->start;
HXDLIN(  87)										int rectRight = xIter31->max;
HXDLIN(  87)										bool forceClear = false;
HXDLIN(  87)										{
HXLINE(  87)											int _g = rectTop;
HXDLIN(  87)											int _g1 = yIter31->max;
HXDLIN(  87)											while((_g < _g1)){
HXLINE(  87)												_g = (_g + 1);
HXDLIN(  87)												int dy = (_g - 1);
HXDLIN(  87)												{
HXLINE(  87)													int _g1 = rectLeft;
HXDLIN(  87)													int _g2 = rectRight;
HXDLIN(  87)													while((_g1 < _g2)){
HXLINE(  87)														_g1 = (_g1 + 1);
HXDLIN(  87)														int dx = (_g1 - 1);
HXDLIN(  87)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)														int index;
HXDLIN(  87)														if (pixelShape->useVirtualPos) {
HXLINE(  87)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  87)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  87)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)														int col;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  87)															col = c;
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if (pixelShape->useMask) {
HXLINE(  87)															hitQuad = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  87)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  87)															int index;
HXDLIN(  87)															if (this1->useVirtualPos) {
HXLINE(  87)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  87)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  87)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  87)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  87)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int v;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  87)																v = c;
            															}
HXDLIN(  87)															int this3 = v;
HXDLIN(  87)															int maskPixel = this3;
HXDLIN(  87)															int this4 = col;
HXDLIN(  87)															int this5 = this4;
HXDLIN(  87)															if ((maskPixel == 0)) {
HXLINE(  87)																int this1 = this5;
HXDLIN(  87)																col = this1;
            															}
            															else {
HXLINE(  87)																Float m0;
HXDLIN(  87)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  87)																if ((this1 == 0)) {
HXLINE(  87)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m1;
HXDLIN(  87)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  87)																if ((this2 == 0)) {
HXLINE(  87)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m2;
HXDLIN(  87)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  87)																if ((this3 == 0)) {
HXLINE(  87)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m3;
HXDLIN(  87)																int this4 = (maskPixel & 255);
HXDLIN(  87)																if ((this4 == 0)) {
HXLINE(  87)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  87)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  87)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  87)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  87)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  87)														if ((col != 0)) {
HXLINE(  87)															int x = (dx - rectLeft);
HXDLIN(  87)															int y = (dy - rectTop);
HXDLIN(  87)															int this1 = col;
HXDLIN(  87)															int c = this1;
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  87)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																int location;
HXDLIN(  87)																if (undoImage1->useVirtualPos) {
HXLINE(  87)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  87)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)																int this3 = this2;
HXDLIN(  87)																int this4;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	this4 = this3;
            																}
HXDLIN(  87)																Float a1;
HXDLIN(  87)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  87)																if ((this5 == 0)) {
HXLINE(  87)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float r1;
HXDLIN(  87)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  87)																if ((this6 == 0)) {
HXLINE(  87)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float g1;
HXDLIN(  87)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  87)																if ((this7 == 0)) {
HXLINE(  87)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float b1;
HXDLIN(  87)																int this8 = (this4 & 255);
HXDLIN(  87)																if ((this8 == 0)) {
HXLINE(  87)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float a2;
HXDLIN(  87)																int this9 = ((col >> 24) & 255);
HXDLIN(  87)																if ((this9 == 0)) {
HXLINE(  87)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float r2;
HXDLIN(  87)																int this10 = ((col >> 16) & 255);
HXDLIN(  87)																if ((this10 == 0)) {
HXLINE(  87)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float g2;
HXDLIN(  87)																int this11 = ((col >> 8) & 255);
HXDLIN(  87)																if ((this11 == 0)) {
HXLINE(  87)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float b2;
HXDLIN(  87)																int this12 = (col & 255);
HXDLIN(  87)																if ((this12 == 0)) {
HXLINE(  87)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)																{
HXLINE(  87)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  87)																	int value;
HXDLIN(  87)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  87)																		value = blended;
            																	}
HXDLIN(  87)																	bool hitQuad;
HXDLIN(  87)																	if ((location >= 0)) {
HXLINE(  87)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  87)																		hitQuad = false;
            																	}
HXDLIN(  87)																	if (hitQuad) {
HXLINE(  87)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  87)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  87)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)																int index;
HXDLIN(  87)																if (undoImage1->useVirtualPos) {
HXLINE(  87)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  87)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = c;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((index >= 0)) {
HXLINE(  87)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															if (forceClear) {
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)																int x = (dx - rectLeft);
HXDLIN(  87)																int y = (dy - rectTop);
HXDLIN(  87)																int index;
HXDLIN(  87)																if (undoImage1->useVirtualPos) {
HXLINE(  87)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  87)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((index >= 0)) {
HXLINE(  87)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  87)								{
HXLINE(  87)									int _g_min1 = xIter31->start;
HXDLIN(  87)									int _g_max1 = xIter31->max;
HXDLIN(  87)									while((_g_min1 < _g_max1)){
HXLINE(  87)										_g_min1 = (_g_min1 + 1);
HXDLIN(  87)										int px = (_g_min1 - 1);
HXDLIN(  87)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  87)										{
HXLINE(  87)											int _g_min = yIter31->start;
HXDLIN(  87)											int _g_max = yIter31->max;
HXDLIN(  87)											while((_g_min < _g_max)){
HXLINE(  87)												_g_min = (_g_min + 1);
HXDLIN(  87)												int py = (_g_min - 1);
HXDLIN(  87)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  87)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  87)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  87)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  87)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  87)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  87)												bool hitQuad;
HXDLIN(  87)												bool hitQuad1;
HXDLIN(  87)												if ((ratioA >= 0)) {
HXLINE(  87)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  87)													hitQuad1 = false;
            												}
HXDLIN(  87)												if (hitQuad1) {
HXLINE(  87)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  87)													hitQuad = false;
            												}
HXDLIN(  87)												if (hitQuad) {
HXLINE(  87)													int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  87)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  87)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  87)													int this1 = i;
HXDLIN(  87)													int a = this1;
HXDLIN(  87)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  87)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  87)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  87)													int this2 = i1;
HXDLIN(  87)													int r = this2;
HXDLIN(  87)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  87)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  87)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  87)													int this3 = i2;
HXDLIN(  87)													int g = this3;
HXDLIN(  87)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  87)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  87)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  87)													int this4 = i3;
HXDLIN(  87)													int b = this4;
HXDLIN(  87)													{
HXLINE(  87)														int location;
HXDLIN(  87)														if (pixelShape->useVirtualPos) {
HXLINE(  87)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  87)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if (pixelShape->transparent) {
HXLINE(  87)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int this3 = this2;
HXDLIN(  87)															int old;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  87)																old = this3;
            															}
HXDLIN(  87)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)															Float a1;
HXDLIN(  87)															int this4 = ((old >> 24) & 255);
HXDLIN(  87)															if ((this4 == 0)) {
HXLINE(  87)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r1;
HXDLIN(  87)															int this5 = ((old >> 16) & 255);
HXDLIN(  87)															if ((this5 == 0)) {
HXLINE(  87)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g1;
HXDLIN(  87)															int this6 = ((old >> 8) & 255);
HXDLIN(  87)															if ((this6 == 0)) {
HXLINE(  87)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b1;
HXDLIN(  87)															int this7 = (old & 255);
HXDLIN(  87)															if ((this7 == 0)) {
HXLINE(  87)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a2;
HXDLIN(  87)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  87)															if ((this8 == 0)) {
HXLINE(  87)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r2;
HXDLIN(  87)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  87)															if ((this9 == 0)) {
HXLINE(  87)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g2;
HXDLIN(  87)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  87)															if ((this10 == 0)) {
HXLINE(  87)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b2;
HXDLIN(  87)															int this11 = (rhs & 255);
HXDLIN(  87)															if ((this11 == 0)) {
HXLINE(  87)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  87)															{
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = blended;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((location >= 0)) {
HXLINE(  87)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  87)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)															int value;
HXDLIN(  87)															if (pixelShape->isLittle) {
HXLINE(  87)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  87)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((location >= 0)) {
HXLINE(  87)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  87)								if ((hasHit == false)) {
HXLINE(  87)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  87)									if (hasUndo1) {
HXLINE(  87)										v->undoImage = undoImage1;
HXDLIN(  87)										v->undoX = xIter31->start;
HXDLIN(  87)										v->undoY = yIter31->start;
            									}
            								}
            							}
HXDLIN(  87)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  87)							hitQuad = v;
            						}
            						else {
HXLINE(  87)							Float sin = ::Math_obj::sin(theta);
HXDLIN(  87)							Float cos = ::Math_obj::cos(theta);
HXDLIN(  87)							Float radius1 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  87)							Float radius2 = (thick / ( (Float)(2) ));
HXDLIN(  87)							Float dx = ((Float)0.1);
HXDLIN(  87)							Float dy = radius1;
HXDLIN(  87)							Float cx = h2;
HXDLIN(  87)							Float cy = radius2;
HXDLIN(  87)							Float bx = h2;
HXDLIN(  87)							Float by = -(radius2);
HXDLIN(  87)							Float ax = ((Float)0.1);
HXDLIN(  87)							Float ay = -(radius1);
HXDLIN(  87)							Float temp = ((Float)0.);
HXLINE( 525)							temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 526)							ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 527)							ax = temp;
HXLINE( 529)							temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 530)							by = (py + ((by * cos) + (bx * sin)));
HXLINE( 531)							bx = temp;
HXLINE( 533)							temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 534)							cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 535)							cx = temp;
HXLINE( 537)							temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 538)							dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 539)							dx = temp;
HXLINE(  87)							{
HXLINE(  87)								bool hasUndo = false;
HXDLIN(  87)								int aA = ((color1 >> 24) & 255);
HXDLIN(  87)								int rA = ((color1 >> 16) & 255);
HXDLIN(  87)								int gA = ((color1 >> 8) & 255);
HXDLIN(  87)								int bA = (color1 & 255);
HXDLIN(  87)								int aB = ((color1 >> 24) & 255);
HXDLIN(  87)								int rB = ((color1 >> 16) & 255);
HXDLIN(  87)								int gB = ((color1 >> 8) & 255);
HXDLIN(  87)								int bB = (color1 & 255);
HXDLIN(  87)								int aC = ((color2 >> 24) & 255);
HXDLIN(  87)								int rC = ((color2 >> 16) & 255);
HXDLIN(  87)								int gC = ((color2 >> 8) & 255);
HXDLIN(  87)								int bC = (color2 & 255);
HXDLIN(  87)								Float bcx = (bx - dx);
HXDLIN(  87)								Float bcy = (by - dy);
HXDLIN(  87)								Float acx = (ax - dx);
HXDLIN(  87)								Float acy = (ay - dy);
HXDLIN(  87)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  87)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  87)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  87)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  87)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  87)								if ((ax > bx)) {
HXLINE(  87)									if ((ax > dx)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((bx > dx)) {
HXLINE(  87)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter3 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  87)									if ((bx > dx)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((ax > dx)) {
HXLINE(  87)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter3 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter3 = this1;
            									}
            								}
HXDLIN(  87)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  87)								if ((ay > by)) {
HXLINE(  87)									if ((ay > dy)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((by > dy)) {
HXLINE(  87)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter3 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  87)									if ((by > dy)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((ay > dy)) {
HXLINE(  87)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter3 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter3 = this1;
            									}
            								}
HXDLIN(  87)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  87)								if (hasUndo) {
HXLINE(  87)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  87)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  87)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  87)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  87)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  87)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  87)									undoImage = this3;
HXDLIN(  87)									{
HXLINE(  87)										int rectLeft = xIter3->start;
HXDLIN(  87)										int rectTop = yIter3->start;
HXDLIN(  87)										int rectRight = xIter3->max;
HXDLIN(  87)										bool forceClear = false;
HXDLIN(  87)										{
HXLINE(  87)											int _g = rectTop;
HXDLIN(  87)											int _g1 = yIter3->max;
HXDLIN(  87)											while((_g < _g1)){
HXLINE(  87)												_g = (_g + 1);
HXDLIN(  87)												int dy = (_g - 1);
HXDLIN(  87)												{
HXLINE(  87)													int _g1 = rectLeft;
HXDLIN(  87)													int _g2 = rectRight;
HXDLIN(  87)													while((_g1 < _g2)){
HXLINE(  87)														_g1 = (_g1 + 1);
HXDLIN(  87)														int dx = (_g1 - 1);
HXDLIN(  87)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)														int index;
HXDLIN(  87)														if (pixelShape->useVirtualPos) {
HXLINE(  87)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  87)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  87)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)														int col;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  87)															col = c;
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if (pixelShape->useMask) {
HXLINE(  87)															hitQuad = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  87)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  87)															int index;
HXDLIN(  87)															if (this1->useVirtualPos) {
HXLINE(  87)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  87)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  87)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  87)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  87)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int v;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  87)																v = c;
            															}
HXDLIN(  87)															int this3 = v;
HXDLIN(  87)															int maskPixel = this3;
HXDLIN(  87)															int this4 = col;
HXDLIN(  87)															int this5 = this4;
HXDLIN(  87)															if ((maskPixel == 0)) {
HXLINE(  87)																int this1 = this5;
HXDLIN(  87)																col = this1;
            															}
            															else {
HXLINE(  87)																Float m0;
HXDLIN(  87)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  87)																if ((this1 == 0)) {
HXLINE(  87)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m1;
HXDLIN(  87)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  87)																if ((this2 == 0)) {
HXLINE(  87)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m2;
HXDLIN(  87)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  87)																if ((this3 == 0)) {
HXLINE(  87)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m3;
HXDLIN(  87)																int this4 = (maskPixel & 255);
HXDLIN(  87)																if ((this4 == 0)) {
HXLINE(  87)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  87)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  87)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  87)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  87)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  87)														if ((col != 0)) {
HXLINE(  87)															int x = (dx - rectLeft);
HXDLIN(  87)															int y = (dy - rectTop);
HXDLIN(  87)															int this1 = col;
HXDLIN(  87)															int c = this1;
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  87)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																int location;
HXDLIN(  87)																if (undoImage->useVirtualPos) {
HXLINE(  87)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  87)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)																int this3 = this2;
HXDLIN(  87)																int this4;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	this4 = this3;
            																}
HXDLIN(  87)																Float a1;
HXDLIN(  87)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  87)																if ((this5 == 0)) {
HXLINE(  87)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float r1;
HXDLIN(  87)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  87)																if ((this6 == 0)) {
HXLINE(  87)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float g1;
HXDLIN(  87)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  87)																if ((this7 == 0)) {
HXLINE(  87)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float b1;
HXDLIN(  87)																int this8 = (this4 & 255);
HXDLIN(  87)																if ((this8 == 0)) {
HXLINE(  87)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float a2;
HXDLIN(  87)																int this9 = ((col >> 24) & 255);
HXDLIN(  87)																if ((this9 == 0)) {
HXLINE(  87)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float r2;
HXDLIN(  87)																int this10 = ((col >> 16) & 255);
HXDLIN(  87)																if ((this10 == 0)) {
HXLINE(  87)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float g2;
HXDLIN(  87)																int this11 = ((col >> 8) & 255);
HXDLIN(  87)																if ((this11 == 0)) {
HXLINE(  87)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float b2;
HXDLIN(  87)																int this12 = (col & 255);
HXDLIN(  87)																if ((this12 == 0)) {
HXLINE(  87)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)																{
HXLINE(  87)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  87)																	int value;
HXDLIN(  87)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  87)																		value = blended;
            																	}
HXDLIN(  87)																	bool hitQuad;
HXDLIN(  87)																	if ((location >= 0)) {
HXLINE(  87)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  87)																		hitQuad = false;
            																	}
HXDLIN(  87)																	if (hitQuad) {
HXLINE(  87)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  87)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  87)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)																int index;
HXDLIN(  87)																if (undoImage->useVirtualPos) {
HXLINE(  87)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  87)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = c;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((index >= 0)) {
HXLINE(  87)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															if (forceClear) {
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)																int x = (dx - rectLeft);
HXDLIN(  87)																int y = (dy - rectTop);
HXDLIN(  87)																int index;
HXDLIN(  87)																if (undoImage->useVirtualPos) {
HXLINE(  87)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  87)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((index >= 0)) {
HXLINE(  87)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  87)								{
HXLINE(  87)									int _g_min = xIter3->start;
HXDLIN(  87)									int _g_max = xIter3->max;
HXDLIN(  87)									while((_g_min < _g_max)){
HXLINE(  87)										_g_min = (_g_min + 1);
HXDLIN(  87)										int px = (_g_min - 1);
HXDLIN(  87)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  87)										{
HXLINE(  87)											int _g_min1 = yIter3->start;
HXDLIN(  87)											int _g_max = yIter3->max;
HXDLIN(  87)											while((_g_min1 < _g_max)){
HXLINE(  87)												_g_min1 = (_g_min1 + 1);
HXDLIN(  87)												int py = (_g_min1 - 1);
HXDLIN(  87)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  87)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  87)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  87)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  87)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  87)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  87)												bool hitQuad;
HXDLIN(  87)												bool hitQuad1;
HXDLIN(  87)												if ((ratioA >= 0)) {
HXLINE(  87)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  87)													hitQuad1 = false;
            												}
HXDLIN(  87)												if (hitQuad1) {
HXLINE(  87)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  87)													hitQuad = false;
            												}
HXDLIN(  87)												if (hitQuad) {
HXLINE(  87)													int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  87)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  87)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  87)													int this1 = i;
HXDLIN(  87)													int a = this1;
HXDLIN(  87)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  87)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  87)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  87)													int this2 = i1;
HXDLIN(  87)													int r = this2;
HXDLIN(  87)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  87)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  87)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  87)													int this3 = i2;
HXDLIN(  87)													int g = this3;
HXDLIN(  87)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  87)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  87)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  87)													int this4 = i3;
HXDLIN(  87)													int b = this4;
HXDLIN(  87)													{
HXLINE(  87)														int location;
HXDLIN(  87)														if (pixelShape->useVirtualPos) {
HXLINE(  87)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  87)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if (pixelShape->transparent) {
HXLINE(  87)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int this3 = this2;
HXDLIN(  87)															int old;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  87)																old = this3;
            															}
HXDLIN(  87)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)															Float a1;
HXDLIN(  87)															int this4 = ((old >> 24) & 255);
HXDLIN(  87)															if ((this4 == 0)) {
HXLINE(  87)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r1;
HXDLIN(  87)															int this5 = ((old >> 16) & 255);
HXDLIN(  87)															if ((this5 == 0)) {
HXLINE(  87)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g1;
HXDLIN(  87)															int this6 = ((old >> 8) & 255);
HXDLIN(  87)															if ((this6 == 0)) {
HXLINE(  87)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b1;
HXDLIN(  87)															int this7 = (old & 255);
HXDLIN(  87)															if ((this7 == 0)) {
HXLINE(  87)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a2;
HXDLIN(  87)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  87)															if ((this8 == 0)) {
HXLINE(  87)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r2;
HXDLIN(  87)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  87)															if ((this9 == 0)) {
HXLINE(  87)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g2;
HXDLIN(  87)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  87)															if ((this10 == 0)) {
HXLINE(  87)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b2;
HXDLIN(  87)															int this11 = (rhs & 255);
HXDLIN(  87)															if ((this11 == 0)) {
HXLINE(  87)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  87)															{
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = blended;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((location >= 0)) {
HXLINE(  87)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  87)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)															int value;
HXDLIN(  87)															if (pixelShape->isLittle) {
HXLINE(  87)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  87)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((location >= 0)) {
HXLINE(  87)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  87)							{
HXLINE(  87)								bool hasHit = false;
HXDLIN(  87)								bool hasUndo1 = false;
HXDLIN(  87)								int aA1 = ((color2 >> 24) & 255);
HXDLIN(  87)								int rA1 = ((color2 >> 16) & 255);
HXDLIN(  87)								int gA1 = ((color2 >> 8) & 255);
HXDLIN(  87)								int bA1 = (color2 & 255);
HXDLIN(  87)								int aB1 = ((color1 >> 24) & 255);
HXDLIN(  87)								int rB1 = ((color1 >> 16) & 255);
HXDLIN(  87)								int gB1 = ((color1 >> 8) & 255);
HXDLIN(  87)								int bB1 = (color1 & 255);
HXDLIN(  87)								int aC1 = ((color2 >> 24) & 255);
HXDLIN(  87)								int rC1 = ((color2 >> 16) & 255);
HXDLIN(  87)								int gC1 = ((color2 >> 8) & 255);
HXDLIN(  87)								int bC1 = (color2 & 255);
HXDLIN(  87)								Float bcx1 = (cx - dx);
HXDLIN(  87)								Float bcy1 = (cy - dy);
HXDLIN(  87)								Float acx1 = (bx - dx);
HXDLIN(  87)								Float acy1 = (by - dy);
HXDLIN(  87)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  87)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  87)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  87)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  87)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  87)								if ((bx > cx)) {
HXLINE(  87)									if ((bx > dx)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((cx > dx)) {
HXLINE(  87)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter31 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  87)									if ((cx > dx)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((bx > dx)) {
HXLINE(  87)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter31 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										xIter31 = this1;
            									}
            								}
HXDLIN(  87)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  87)								if ((by > cy)) {
HXLINE(  87)									if ((by > dy)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((cy > dy)) {
HXLINE(  87)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter31 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  87)									if ((cy > dy)) {
HXLINE(  87)										int min;
HXDLIN(  87)										if ((by > dy)) {
HXLINE(  87)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  87)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  87)										int ii_min = min;
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter31 = this1;
            									}
            									else {
HXLINE(  87)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  87)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)										yIter31 = this1;
            									}
            								}
HXDLIN(  87)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  87)								if (hasUndo1) {
HXLINE(  87)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  87)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  87)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  87)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  87)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  87)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  87)									undoImage1 = this3;
HXDLIN(  87)									{
HXLINE(  87)										int rectLeft = xIter31->start;
HXDLIN(  87)										int rectTop = yIter31->start;
HXDLIN(  87)										int rectRight = xIter31->max;
HXDLIN(  87)										bool forceClear = false;
HXDLIN(  87)										{
HXLINE(  87)											int _g = rectTop;
HXDLIN(  87)											int _g1 = yIter31->max;
HXDLIN(  87)											while((_g < _g1)){
HXLINE(  87)												_g = (_g + 1);
HXDLIN(  87)												int dy = (_g - 1);
HXDLIN(  87)												{
HXLINE(  87)													int _g1 = rectLeft;
HXDLIN(  87)													int _g2 = rectRight;
HXDLIN(  87)													while((_g1 < _g2)){
HXLINE(  87)														_g1 = (_g1 + 1);
HXDLIN(  87)														int dx = (_g1 - 1);
HXDLIN(  87)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)														int index;
HXDLIN(  87)														if (pixelShape->useVirtualPos) {
HXLINE(  87)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  87)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  87)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)														int col;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  87)															col = c;
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if (pixelShape->useMask) {
HXLINE(  87)															hitQuad = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  87)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  87)															int index;
HXDLIN(  87)															if (this1->useVirtualPos) {
HXLINE(  87)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  87)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  87)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  87)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  87)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int v;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  87)																v = c;
            															}
HXDLIN(  87)															int this3 = v;
HXDLIN(  87)															int maskPixel = this3;
HXDLIN(  87)															int this4 = col;
HXDLIN(  87)															int this5 = this4;
HXDLIN(  87)															if ((maskPixel == 0)) {
HXLINE(  87)																int this1 = this5;
HXDLIN(  87)																col = this1;
            															}
            															else {
HXLINE(  87)																Float m0;
HXDLIN(  87)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  87)																if ((this1 == 0)) {
HXLINE(  87)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m1;
HXDLIN(  87)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  87)																if ((this2 == 0)) {
HXLINE(  87)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m2;
HXDLIN(  87)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  87)																if ((this3 == 0)) {
HXLINE(  87)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float m3;
HXDLIN(  87)																int this4 = (maskPixel & 255);
HXDLIN(  87)																if ((this4 == 0)) {
HXLINE(  87)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  87)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  87)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  87)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  87)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  87)														if ((col != 0)) {
HXLINE(  87)															int x = (dx - rectLeft);
HXDLIN(  87)															int y = (dy - rectTop);
HXDLIN(  87)															int this1 = col;
HXDLIN(  87)															int c = this1;
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  87)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																int location;
HXDLIN(  87)																if (undoImage1->useVirtualPos) {
HXLINE(  87)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  87)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)																int this3 = this2;
HXDLIN(  87)																int this4;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	this4 = this3;
            																}
HXDLIN(  87)																Float a1;
HXDLIN(  87)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  87)																if ((this5 == 0)) {
HXLINE(  87)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float r1;
HXDLIN(  87)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  87)																if ((this6 == 0)) {
HXLINE(  87)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float g1;
HXDLIN(  87)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  87)																if ((this7 == 0)) {
HXLINE(  87)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float b1;
HXDLIN(  87)																int this8 = (this4 & 255);
HXDLIN(  87)																if ((this8 == 0)) {
HXLINE(  87)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float a2;
HXDLIN(  87)																int this9 = ((col >> 24) & 255);
HXDLIN(  87)																if ((this9 == 0)) {
HXLINE(  87)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float r2;
HXDLIN(  87)																int this10 = ((col >> 16) & 255);
HXDLIN(  87)																if ((this10 == 0)) {
HXLINE(  87)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float g2;
HXDLIN(  87)																int this11 = ((col >> 8) & 255);
HXDLIN(  87)																if ((this11 == 0)) {
HXLINE(  87)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float b2;
HXDLIN(  87)																int this12 = (col & 255);
HXDLIN(  87)																if ((this12 == 0)) {
HXLINE(  87)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  87)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  87)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)																{
HXLINE(  87)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  87)																	int value;
HXDLIN(  87)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  87)																		value = blended;
            																	}
HXDLIN(  87)																	bool hitQuad;
HXDLIN(  87)																	if ((location >= 0)) {
HXLINE(  87)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  87)																		hitQuad = false;
            																	}
HXDLIN(  87)																	if (hitQuad) {
HXLINE(  87)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  87)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  87)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)																int index;
HXDLIN(  87)																if (undoImage1->useVirtualPos) {
HXLINE(  87)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  87)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = c;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((index >= 0)) {
HXLINE(  87)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															if (forceClear) {
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)																int x = (dx - rectLeft);
HXDLIN(  87)																int y = (dy - rectTop);
HXDLIN(  87)																int index;
HXDLIN(  87)																if (undoImage1->useVirtualPos) {
HXLINE(  87)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  87)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((index >= 0)) {
HXLINE(  87)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  87)								{
HXLINE(  87)									int _g_min1 = xIter31->start;
HXDLIN(  87)									int _g_max1 = xIter31->max;
HXDLIN(  87)									while((_g_min1 < _g_max1)){
HXLINE(  87)										_g_min1 = (_g_min1 + 1);
HXDLIN(  87)										int px = (_g_min1 - 1);
HXDLIN(  87)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  87)										{
HXLINE(  87)											int _g_min = yIter31->start;
HXDLIN(  87)											int _g_max = yIter31->max;
HXDLIN(  87)											while((_g_min < _g_max)){
HXLINE(  87)												_g_min = (_g_min + 1);
HXDLIN(  87)												int py = (_g_min - 1);
HXDLIN(  87)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  87)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  87)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  87)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  87)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  87)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  87)												bool hitQuad;
HXDLIN(  87)												bool hitQuad1;
HXDLIN(  87)												if ((ratioA >= 0)) {
HXLINE(  87)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  87)													hitQuad1 = false;
            												}
HXDLIN(  87)												if (hitQuad1) {
HXLINE(  87)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  87)													hitQuad = false;
            												}
HXDLIN(  87)												if (hitQuad) {
HXLINE(  87)													int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  87)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  87)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  87)													int this1 = i;
HXDLIN(  87)													int a = this1;
HXDLIN(  87)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  87)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  87)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  87)													int this2 = i1;
HXDLIN(  87)													int r = this2;
HXDLIN(  87)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  87)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  87)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  87)													int this3 = i2;
HXDLIN(  87)													int g = this3;
HXDLIN(  87)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  87)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  87)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  87)													int this4 = i3;
HXDLIN(  87)													int b = this4;
HXDLIN(  87)													{
HXLINE(  87)														int location;
HXDLIN(  87)														if (pixelShape->useVirtualPos) {
HXLINE(  87)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  87)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if (pixelShape->transparent) {
HXLINE(  87)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int this3 = this2;
HXDLIN(  87)															int old;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  87)																old = this3;
            															}
HXDLIN(  87)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)															Float a1;
HXDLIN(  87)															int this4 = ((old >> 24) & 255);
HXDLIN(  87)															if ((this4 == 0)) {
HXLINE(  87)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r1;
HXDLIN(  87)															int this5 = ((old >> 16) & 255);
HXDLIN(  87)															if ((this5 == 0)) {
HXLINE(  87)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g1;
HXDLIN(  87)															int this6 = ((old >> 8) & 255);
HXDLIN(  87)															if ((this6 == 0)) {
HXLINE(  87)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b1;
HXDLIN(  87)															int this7 = (old & 255);
HXDLIN(  87)															if ((this7 == 0)) {
HXLINE(  87)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a2;
HXDLIN(  87)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  87)															if ((this8 == 0)) {
HXLINE(  87)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r2;
HXDLIN(  87)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  87)															if ((this9 == 0)) {
HXLINE(  87)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g2;
HXDLIN(  87)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  87)															if ((this10 == 0)) {
HXLINE(  87)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b2;
HXDLIN(  87)															int this11 = (rhs & 255);
HXDLIN(  87)															if ((this11 == 0)) {
HXLINE(  87)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  87)															{
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = blended;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((location >= 0)) {
HXLINE(  87)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  87)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)															int value;
HXDLIN(  87)															if (pixelShape->isLittle) {
HXLINE(  87)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  87)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((location >= 0)) {
HXLINE(  87)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  87)								if ((hasHit == false)) {
HXLINE(  87)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  87)									if (hasUndo1) {
HXLINE(  87)										v->undoImage = undoImage1;
HXDLIN(  87)										v->undoX = xIter31->start;
HXDLIN(  87)										v->undoY = yIter31->start;
            									}
            								}
            							}
HXDLIN(  87)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  87)							hitQuad = v;
            						}
            					}
            					else {
HXLINE(  87)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  87)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  87)						Float radius = (thick / ( (Float)(2) ));
HXDLIN(  87)						Float dx = ((Float)0.1);
HXDLIN(  87)						Float dy = radius;
HXDLIN(  87)						Float cx = h2;
HXDLIN(  87)						Float cy = radius;
HXDLIN(  87)						Float bx = h2;
HXDLIN(  87)						Float by = -(radius);
HXDLIN(  87)						Float ax = ((Float)0.1);
HXDLIN(  87)						Float ay = -(radius);
HXDLIN(  87)						Float temp = ((Float)0.);
HXLINE( 474)						temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 475)						ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 476)						ax = temp;
HXLINE( 478)						temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 479)						by = (py + ((by * cos) + (bx * sin)));
HXLINE( 480)						bx = temp;
HXLINE( 482)						temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 483)						cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 484)						cx = temp;
HXLINE( 486)						temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 487)						dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 488)						dx = temp;
HXLINE(  87)						{
HXLINE(  87)							bool hasUndo = false;
HXDLIN(  87)							int aA = ((color1 >> 24) & 255);
HXDLIN(  87)							int rA = ((color1 >> 16) & 255);
HXDLIN(  87)							int gA = ((color1 >> 8) & 255);
HXDLIN(  87)							int bA = (color1 & 255);
HXDLIN(  87)							int aB = ((color1 >> 24) & 255);
HXDLIN(  87)							int rB = ((color1 >> 16) & 255);
HXDLIN(  87)							int gB = ((color1 >> 8) & 255);
HXDLIN(  87)							int bB = (color1 & 255);
HXDLIN(  87)							int aC = ((color2 >> 24) & 255);
HXDLIN(  87)							int rC = ((color2 >> 16) & 255);
HXDLIN(  87)							int gC = ((color2 >> 8) & 255);
HXDLIN(  87)							int bC = (color2 & 255);
HXDLIN(  87)							Float bcx = (bx - dx);
HXDLIN(  87)							Float bcy = (by - dy);
HXDLIN(  87)							Float acx = (ax - dx);
HXDLIN(  87)							Float acy = (ay - dy);
HXDLIN(  87)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  87)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  87)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  87)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  87)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  87)							if ((ax > bx)) {
HXLINE(  87)								if ((ax > dx)) {
HXLINE(  87)									int min;
HXDLIN(  87)									if ((bx > dx)) {
HXLINE(  87)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  87)										min = ::Math_obj::floor(bx);
            									}
HXDLIN(  87)									int ii_min = min;
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									xIter3 = this1;
            								}
            								else {
HXLINE(  87)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  87)								if ((bx > dx)) {
HXLINE(  87)									int min;
HXDLIN(  87)									if ((ax > dx)) {
HXLINE(  87)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  87)										min = ::Math_obj::ceil(ax);
            									}
HXDLIN(  87)									int ii_min = min;
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									xIter3 = this1;
            								}
            								else {
HXLINE(  87)									int ii_min = ::Math_obj::floor(ax);
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									xIter3 = this1;
            								}
            							}
HXDLIN(  87)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  87)							if ((ay > by)) {
HXLINE(  87)								if ((ay > dy)) {
HXLINE(  87)									int min;
HXDLIN(  87)									if ((by > dy)) {
HXLINE(  87)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  87)										min = ::Math_obj::floor(by);
            									}
HXDLIN(  87)									int ii_min = min;
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									yIter3 = this1;
            								}
            								else {
HXLINE(  87)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  87)								if ((by > dy)) {
HXLINE(  87)									int min;
HXDLIN(  87)									if ((ay > dy)) {
HXLINE(  87)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  87)										min = ::Math_obj::ceil(ay);
            									}
HXDLIN(  87)									int ii_min = min;
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									yIter3 = this1;
            								}
            								else {
HXLINE(  87)									int ii_min = ::Math_obj::floor(ay);
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									yIter3 = this1;
            								}
            							}
HXDLIN(  87)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  87)							if (hasUndo) {
HXLINE(  87)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  87)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  87)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  87)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  87)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  87)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  87)								undoImage = this3;
HXDLIN(  87)								{
HXLINE(  87)									int rectLeft = xIter3->start;
HXDLIN(  87)									int rectTop = yIter3->start;
HXDLIN(  87)									int rectRight = xIter3->max;
HXDLIN(  87)									bool forceClear = false;
HXDLIN(  87)									{
HXLINE(  87)										int _g = rectTop;
HXDLIN(  87)										int _g1 = yIter3->max;
HXDLIN(  87)										while((_g < _g1)){
HXLINE(  87)											_g = (_g + 1);
HXDLIN(  87)											int dy = (_g - 1);
HXDLIN(  87)											{
HXLINE(  87)												int _g1 = rectLeft;
HXDLIN(  87)												int _g2 = rectRight;
HXDLIN(  87)												while((_g1 < _g2)){
HXLINE(  87)													_g1 = (_g1 + 1);
HXDLIN(  87)													int dx = (_g1 - 1);
HXDLIN(  87)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)													int index;
HXDLIN(  87)													if (pixelShape->useVirtualPos) {
HXLINE(  87)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  87)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  87)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)													int col;
HXDLIN(  87)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  87)														col = c;
            													}
HXDLIN(  87)													bool hitQuad;
HXDLIN(  87)													if (pixelShape->useMask) {
HXLINE(  87)														hitQuad = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  87)														hitQuad = false;
            													}
HXDLIN(  87)													if (hitQuad) {
HXLINE(  87)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  87)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  87)														int index;
HXDLIN(  87)														if (this1->useVirtualPos) {
HXLINE(  87)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  87)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  87)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  87)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  87)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)														int v;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  87)															v = c;
            														}
HXDLIN(  87)														int this3 = v;
HXDLIN(  87)														int maskPixel = this3;
HXDLIN(  87)														int this4 = col;
HXDLIN(  87)														int this5 = this4;
HXDLIN(  87)														if ((maskPixel == 0)) {
HXLINE(  87)															int this1 = this5;
HXDLIN(  87)															col = this1;
            														}
            														else {
HXLINE(  87)															Float m0;
HXDLIN(  87)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  87)															if ((this1 == 0)) {
HXLINE(  87)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float m1;
HXDLIN(  87)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  87)															if ((this2 == 0)) {
HXLINE(  87)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float m2;
HXDLIN(  87)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  87)															if ((this3 == 0)) {
HXLINE(  87)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float m3;
HXDLIN(  87)															int this4 = (maskPixel & 255);
HXDLIN(  87)															if ((this4 == 0)) {
HXLINE(  87)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  87)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  87)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  87)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  87)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  87)													if ((col != 0)) {
HXLINE(  87)														int x = (dx - rectLeft);
HXDLIN(  87)														int y = (dy - rectTop);
HXDLIN(  87)														int this1 = col;
HXDLIN(  87)														int c = this1;
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  87)															hitQuad = undoImage->transparent;
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															int location;
HXDLIN(  87)															if (undoImage->useVirtualPos) {
HXLINE(  87)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  87)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  87)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int this3 = this2;
HXDLIN(  87)															int this4;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  87)																this4 = this3;
            															}
HXDLIN(  87)															Float a1;
HXDLIN(  87)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  87)															if ((this5 == 0)) {
HXLINE(  87)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r1;
HXDLIN(  87)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  87)															if ((this6 == 0)) {
HXLINE(  87)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g1;
HXDLIN(  87)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  87)															if ((this7 == 0)) {
HXLINE(  87)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b1;
HXDLIN(  87)															int this8 = (this4 & 255);
HXDLIN(  87)															if ((this8 == 0)) {
HXLINE(  87)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a2;
HXDLIN(  87)															int this9 = ((col >> 24) & 255);
HXDLIN(  87)															if ((this9 == 0)) {
HXLINE(  87)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r2;
HXDLIN(  87)															int this10 = ((col >> 16) & 255);
HXDLIN(  87)															if ((this10 == 0)) {
HXLINE(  87)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g2;
HXDLIN(  87)															int this11 = ((col >> 8) & 255);
HXDLIN(  87)															if ((this11 == 0)) {
HXLINE(  87)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b2;
HXDLIN(  87)															int this12 = (col & 255);
HXDLIN(  87)															if ((this12 == 0)) {
HXLINE(  87)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)															{
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = blended;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((location >= 0)) {
HXLINE(  87)																	hitQuad = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  87)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)															int index;
HXDLIN(  87)															if (undoImage->useVirtualPos) {
HXLINE(  87)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  87)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  87)															int value;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  87)																value = c;
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((index >= 0)) {
HXLINE(  87)																hitQuad = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  87)														if (forceClear) {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)															int x = (dx - rectLeft);
HXDLIN(  87)															int y = (dy - rectTop);
HXDLIN(  87)															int index;
HXDLIN(  87)															if (undoImage->useVirtualPos) {
HXLINE(  87)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  87)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((index >= 0)) {
HXLINE(  87)																hitQuad = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  87)							{
HXLINE(  87)								int _g_min = xIter3->start;
HXDLIN(  87)								int _g_max = xIter3->max;
HXDLIN(  87)								while((_g_min < _g_max)){
HXLINE(  87)									_g_min = (_g_min + 1);
HXDLIN(  87)									int px = (_g_min - 1);
HXDLIN(  87)									Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  87)									{
HXLINE(  87)										int _g_min1 = yIter3->start;
HXDLIN(  87)										int _g_max = yIter3->max;
HXDLIN(  87)										while((_g_min1 < _g_max)){
HXLINE(  87)											_g_min1 = (_g_min1 + 1);
HXDLIN(  87)											int py = (_g_min1 - 1);
HXDLIN(  87)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  87)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  87)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  87)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  87)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  87)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  87)											bool hitQuad;
HXDLIN(  87)											bool hitQuad1;
HXDLIN(  87)											if ((ratioA >= 0)) {
HXLINE(  87)												hitQuad1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  87)												hitQuad1 = false;
            											}
HXDLIN(  87)											if (hitQuad1) {
HXLINE(  87)												hitQuad = (ratioC >= 0);
            											}
            											else {
HXLINE(  87)												hitQuad = false;
            											}
HXDLIN(  87)											if (hitQuad) {
HXLINE(  87)												int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  87)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  87)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  87)												int this1 = i;
HXDLIN(  87)												int a = this1;
HXDLIN(  87)												int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  87)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  87)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  87)												int this2 = i1;
HXDLIN(  87)												int r = this2;
HXDLIN(  87)												int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  87)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  87)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  87)												int this3 = i2;
HXDLIN(  87)												int g = this3;
HXDLIN(  87)												int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  87)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  87)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  87)												int this4 = i3;
HXDLIN(  87)												int b = this4;
HXDLIN(  87)												{
HXLINE(  87)													int location;
HXDLIN(  87)													if (pixelShape->useVirtualPos) {
HXLINE(  87)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  87)														location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            													}
HXDLIN(  87)													bool hitQuad;
HXDLIN(  87)													if (pixelShape->transparent) {
HXLINE(  87)														hitQuad = (a < 254);
            													}
            													else {
HXLINE(  87)														hitQuad = false;
            													}
HXDLIN(  87)													if (hitQuad) {
HXLINE(  87)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)														int this3 = this2;
HXDLIN(  87)														int old;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  87)															old = this3;
            														}
HXDLIN(  87)														int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)														Float a1;
HXDLIN(  87)														int this4 = ((old >> 24) & 255);
HXDLIN(  87)														if ((this4 == 0)) {
HXLINE(  87)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float r1;
HXDLIN(  87)														int this5 = ((old >> 16) & 255);
HXDLIN(  87)														if ((this5 == 0)) {
HXLINE(  87)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float g1;
HXDLIN(  87)														int this6 = ((old >> 8) & 255);
HXDLIN(  87)														if ((this6 == 0)) {
HXLINE(  87)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float b1;
HXDLIN(  87)														int this7 = (old & 255);
HXDLIN(  87)														if ((this7 == 0)) {
HXLINE(  87)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float a2;
HXDLIN(  87)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  87)														if ((this8 == 0)) {
HXLINE(  87)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float r2;
HXDLIN(  87)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  87)														if ((this9 == 0)) {
HXLINE(  87)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float g2;
HXDLIN(  87)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  87)														if ((this10 == 0)) {
HXLINE(  87)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float b2;
HXDLIN(  87)														int this11 = (rhs & 255);
HXDLIN(  87)														if ((this11 == 0)) {
HXLINE(  87)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)														int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)														int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  87)														{
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  87)															int value;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  87)																value = blended;
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((location >= 0)) {
HXLINE(  87)																hitQuad = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  87)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)														int value;
HXDLIN(  87)														if (pixelShape->isLittle) {
HXLINE(  87)															value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            														}
            														else {
HXLINE(  87)															value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if ((location >= 0)) {
HXLINE(  87)															hitQuad = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  87)						{
HXLINE(  87)							bool hasHit = false;
HXDLIN(  87)							bool hasUndo1 = false;
HXDLIN(  87)							int aA1 = ((color2 >> 24) & 255);
HXDLIN(  87)							int rA1 = ((color2 >> 16) & 255);
HXDLIN(  87)							int gA1 = ((color2 >> 8) & 255);
HXDLIN(  87)							int bA1 = (color2 & 255);
HXDLIN(  87)							int aB1 = ((color1 >> 24) & 255);
HXDLIN(  87)							int rB1 = ((color1 >> 16) & 255);
HXDLIN(  87)							int gB1 = ((color1 >> 8) & 255);
HXDLIN(  87)							int bB1 = (color1 & 255);
HXDLIN(  87)							int aC1 = ((color2 >> 24) & 255);
HXDLIN(  87)							int rC1 = ((color2 >> 16) & 255);
HXDLIN(  87)							int gC1 = ((color2 >> 8) & 255);
HXDLIN(  87)							int bC1 = (color2 & 255);
HXDLIN(  87)							Float bcx1 = (cx - dx);
HXDLIN(  87)							Float bcy1 = (cy - dy);
HXDLIN(  87)							Float acx1 = (bx - dx);
HXDLIN(  87)							Float acy1 = (by - dy);
HXDLIN(  87)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  87)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  87)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  87)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  87)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  87)							if ((bx > cx)) {
HXLINE(  87)								if ((bx > dx)) {
HXLINE(  87)									int min;
HXDLIN(  87)									if ((cx > dx)) {
HXLINE(  87)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  87)										min = ::Math_obj::floor(cx);
            									}
HXDLIN(  87)									int ii_min = min;
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									xIter31 = this1;
            								}
            								else {
HXLINE(  87)									int ii_min = ::Math_obj::floor(cx);
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  87)								if ((cx > dx)) {
HXLINE(  87)									int min;
HXDLIN(  87)									if ((bx > dx)) {
HXLINE(  87)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  87)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  87)									int ii_min = min;
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									xIter31 = this1;
            								}
            								else {
HXLINE(  87)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									xIter31 = this1;
            								}
            							}
HXDLIN(  87)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  87)							if ((by > cy)) {
HXLINE(  87)								if ((by > dy)) {
HXLINE(  87)									int min;
HXDLIN(  87)									if ((cy > dy)) {
HXLINE(  87)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  87)										min = ::Math_obj::floor(cy);
            									}
HXDLIN(  87)									int ii_min = min;
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									yIter31 = this1;
            								}
            								else {
HXLINE(  87)									int ii_min = ::Math_obj::floor(cy);
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  87)								if ((cy > dy)) {
HXLINE(  87)									int min;
HXDLIN(  87)									if ((by > dy)) {
HXLINE(  87)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  87)										min = ::Math_obj::ceil(by);
            									}
HXDLIN(  87)									int ii_min = min;
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									yIter31 = this1;
            								}
            								else {
HXLINE(  87)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  87)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  87)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)									yIter31 = this1;
            								}
            							}
HXDLIN(  87)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  87)							if (hasUndo1) {
HXLINE(  87)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  87)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  87)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  87)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  87)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  87)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  87)								undoImage1 = this3;
HXDLIN(  87)								{
HXLINE(  87)									int rectLeft = xIter31->start;
HXDLIN(  87)									int rectTop = yIter31->start;
HXDLIN(  87)									int rectRight = xIter31->max;
HXDLIN(  87)									bool forceClear = false;
HXDLIN(  87)									{
HXLINE(  87)										int _g = rectTop;
HXDLIN(  87)										int _g1 = yIter31->max;
HXDLIN(  87)										while((_g < _g1)){
HXLINE(  87)											_g = (_g + 1);
HXDLIN(  87)											int dy = (_g - 1);
HXDLIN(  87)											{
HXLINE(  87)												int _g1 = rectLeft;
HXDLIN(  87)												int _g2 = rectRight;
HXDLIN(  87)												while((_g1 < _g2)){
HXLINE(  87)													_g1 = (_g1 + 1);
HXDLIN(  87)													int dx = (_g1 - 1);
HXDLIN(  87)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)													int index;
HXDLIN(  87)													if (pixelShape->useVirtualPos) {
HXLINE(  87)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  87)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  87)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)													int col;
HXDLIN(  87)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  87)														col = c;
            													}
HXDLIN(  87)													bool hitQuad;
HXDLIN(  87)													if (pixelShape->useMask) {
HXLINE(  87)														hitQuad = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  87)														hitQuad = false;
            													}
HXDLIN(  87)													if (hitQuad) {
HXLINE(  87)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  87)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  87)														int index;
HXDLIN(  87)														if (this1->useVirtualPos) {
HXLINE(  87)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  87)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  87)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  87)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  87)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)														int v;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  87)															v = c;
            														}
HXDLIN(  87)														int this3 = v;
HXDLIN(  87)														int maskPixel = this3;
HXDLIN(  87)														int this4 = col;
HXDLIN(  87)														int this5 = this4;
HXDLIN(  87)														if ((maskPixel == 0)) {
HXLINE(  87)															int this1 = this5;
HXDLIN(  87)															col = this1;
            														}
            														else {
HXLINE(  87)															Float m0;
HXDLIN(  87)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  87)															if ((this1 == 0)) {
HXLINE(  87)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float m1;
HXDLIN(  87)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  87)															if ((this2 == 0)) {
HXLINE(  87)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float m2;
HXDLIN(  87)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  87)															if ((this3 == 0)) {
HXLINE(  87)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float m3;
HXDLIN(  87)															int this4 = (maskPixel & 255);
HXDLIN(  87)															if ((this4 == 0)) {
HXLINE(  87)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  87)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  87)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  87)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  87)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  87)													if ((col != 0)) {
HXLINE(  87)														int x = (dx - rectLeft);
HXDLIN(  87)														int y = (dy - rectTop);
HXDLIN(  87)														int this1 = col;
HXDLIN(  87)														int c = this1;
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  87)															hitQuad = undoImage1->transparent;
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															int location;
HXDLIN(  87)															if (undoImage1->useVirtualPos) {
HXLINE(  87)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  87)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  87)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)															int this3 = this2;
HXDLIN(  87)															int this4;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  87)																this4 = this3;
            															}
HXDLIN(  87)															Float a1;
HXDLIN(  87)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  87)															if ((this5 == 0)) {
HXLINE(  87)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r1;
HXDLIN(  87)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  87)															if ((this6 == 0)) {
HXLINE(  87)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g1;
HXDLIN(  87)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  87)															if ((this7 == 0)) {
HXLINE(  87)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b1;
HXDLIN(  87)															int this8 = (this4 & 255);
HXDLIN(  87)															if ((this8 == 0)) {
HXLINE(  87)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a2;
HXDLIN(  87)															int this9 = ((col >> 24) & 255);
HXDLIN(  87)															if ((this9 == 0)) {
HXLINE(  87)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float r2;
HXDLIN(  87)															int this10 = ((col >> 16) & 255);
HXDLIN(  87)															if ((this10 == 0)) {
HXLINE(  87)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float g2;
HXDLIN(  87)															int this11 = ((col >> 8) & 255);
HXDLIN(  87)															if ((this11 == 0)) {
HXLINE(  87)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float b2;
HXDLIN(  87)															int this12 = (col & 255);
HXDLIN(  87)															if ((this12 == 0)) {
HXLINE(  87)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  87)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  87)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)															{
HXLINE(  87)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  87)																int value;
HXDLIN(  87)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  87)																	value = blended;
            																}
HXDLIN(  87)																bool hitQuad;
HXDLIN(  87)																if ((location >= 0)) {
HXLINE(  87)																	hitQuad = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  87)																	hitQuad = false;
            																}
HXDLIN(  87)																if (hitQuad) {
HXLINE(  87)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  87)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  87)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)															int index;
HXDLIN(  87)															if (undoImage1->useVirtualPos) {
HXLINE(  87)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  87)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  87)															int value;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  87)																value = c;
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((index >= 0)) {
HXLINE(  87)																hitQuad = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  87)														if (forceClear) {
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  87)															int x = (dx - rectLeft);
HXDLIN(  87)															int y = (dy - rectTop);
HXDLIN(  87)															int index;
HXDLIN(  87)															if (undoImage1->useVirtualPos) {
HXLINE(  87)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  87)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((index >= 0)) {
HXLINE(  87)																hitQuad = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  87)							{
HXLINE(  87)								int _g_min1 = xIter31->start;
HXDLIN(  87)								int _g_max1 = xIter31->max;
HXDLIN(  87)								while((_g_min1 < _g_max1)){
HXLINE(  87)									_g_min1 = (_g_min1 + 1);
HXDLIN(  87)									int px = (_g_min1 - 1);
HXDLIN(  87)									Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  87)									{
HXLINE(  87)										int _g_min = yIter31->start;
HXDLIN(  87)										int _g_max = yIter31->max;
HXDLIN(  87)										while((_g_min < _g_max)){
HXLINE(  87)											_g_min = (_g_min + 1);
HXDLIN(  87)											int py = (_g_min - 1);
HXDLIN(  87)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  87)											Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  87)											Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  87)											Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  87)											Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  87)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  87)											bool hitQuad;
HXDLIN(  87)											bool hitQuad1;
HXDLIN(  87)											if ((ratioA >= 0)) {
HXLINE(  87)												hitQuad1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  87)												hitQuad1 = false;
            											}
HXDLIN(  87)											if (hitQuad1) {
HXLINE(  87)												hitQuad = (ratioC >= 0);
            											}
            											else {
HXLINE(  87)												hitQuad = false;
            											}
HXDLIN(  87)											if (hitQuad) {
HXLINE(  87)												int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  87)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  87)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  87)												int this1 = i;
HXDLIN(  87)												int a = this1;
HXDLIN(  87)												int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  87)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  87)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  87)												int this2 = i1;
HXDLIN(  87)												int r = this2;
HXDLIN(  87)												int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  87)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  87)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  87)												int this3 = i2;
HXDLIN(  87)												int g = this3;
HXDLIN(  87)												int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  87)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  87)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  87)												int this4 = i3;
HXDLIN(  87)												int b = this4;
HXDLIN(  87)												{
HXLINE(  87)													int location;
HXDLIN(  87)													if (pixelShape->useVirtualPos) {
HXLINE(  87)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  87)														location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            													}
HXDLIN(  87)													bool hitQuad;
HXDLIN(  87)													if (pixelShape->transparent) {
HXLINE(  87)														hitQuad = (a < 254);
            													}
            													else {
HXLINE(  87)														hitQuad = false;
            													}
HXDLIN(  87)													if (hitQuad) {
HXLINE(  87)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)														int this3 = this2;
HXDLIN(  87)														int old;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  87)															old = this3;
            														}
HXDLIN(  87)														int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)														Float a1;
HXDLIN(  87)														int this4 = ((old >> 24) & 255);
HXDLIN(  87)														if ((this4 == 0)) {
HXLINE(  87)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float r1;
HXDLIN(  87)														int this5 = ((old >> 16) & 255);
HXDLIN(  87)														if ((this5 == 0)) {
HXLINE(  87)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float g1;
HXDLIN(  87)														int this6 = ((old >> 8) & 255);
HXDLIN(  87)														if ((this6 == 0)) {
HXLINE(  87)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float b1;
HXDLIN(  87)														int this7 = (old & 255);
HXDLIN(  87)														if ((this7 == 0)) {
HXLINE(  87)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float a2;
HXDLIN(  87)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  87)														if ((this8 == 0)) {
HXLINE(  87)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float r2;
HXDLIN(  87)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  87)														if ((this9 == 0)) {
HXLINE(  87)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float g2;
HXDLIN(  87)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  87)														if ((this10 == 0)) {
HXLINE(  87)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float b2;
HXDLIN(  87)														int this11 = (rhs & 255);
HXDLIN(  87)														if ((this11 == 0)) {
HXLINE(  87)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  87)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  87)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)														int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)														int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  87)														{
HXLINE(  87)															::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  87)															int value;
HXDLIN(  87)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  87)																value = blended;
            															}
HXDLIN(  87)															bool hitQuad;
HXDLIN(  87)															if ((location >= 0)) {
HXLINE(  87)																hitQuad = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  87)																hitQuad = false;
            															}
HXDLIN(  87)															if (hitQuad) {
HXLINE(  87)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  87)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  87)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  87)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)														int value;
HXDLIN(  87)														if (pixelShape->isLittle) {
HXLINE(  87)															value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            														}
            														else {
HXLINE(  87)															value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            														}
HXDLIN(  87)														bool hitQuad;
HXDLIN(  87)														if ((location >= 0)) {
HXLINE(  87)															hitQuad = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  87)															hitQuad = false;
            														}
HXDLIN(  87)														if (hitQuad) {
HXLINE(  87)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  87)							if ((hasHit == false)) {
HXLINE(  87)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  87)								if (hasUndo1) {
HXLINE(  87)									v->undoImage = undoImage1;
HXDLIN(  87)									v->undoX = xIter31->start;
HXDLIN(  87)									v->undoY = yIter31->start;
            								}
            							}
            						}
HXDLIN(  87)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  87)						hitQuad = v;
            					}
HXDLIN(  87)					Float cx = h2;
HXDLIN(  87)					Float cy = radius2;
HXDLIN(  87)					Float bx = h2;
HXDLIN(  87)					Float by = -(radius2);
HXDLIN(  87)					Float temp = ((Float)0.);
HXLINE( 146)					temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 147)					by = (py + ((by * cos) + (bx * sin)));
HXLINE( 148)					bx = temp;
HXLINE( 149)					temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 150)					cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 151)					cx = temp;
HXLINE(  87)					::pixelimage::pixel::_TwoGrad::TwoGrad_ this1 = ::pixelimage::pixel::_TwoGrad::TwoGrad__obj::__alloc( HX_CTX ,color1,color2);
HXDLIN(  87)					::pixelimage::pixel::_TwoGrad::TwoGrad_ twoColors = this1;
HXDLIN(  87)					int a1 = twoColors->colorClock;
HXDLIN(  87)					int b = twoColors->colorAnti;
HXDLIN(  87)					int half = ((((::Math_obj::round(((((( (Float)(((a1 >> 24) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 24) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 24) | (::Math_obj::round(((((( (Float)(((a1 >> 16) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 16) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 16)) | (::Math_obj::round(((((( (Float)(((a1 >> 8) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 8) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 8)) | ::Math_obj::round(((((( (Float)((a1 & 255)) ) / ( (Float)(255) )) + (( (Float)((b & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))));
HXDLIN(  87)					bool hasUndo = false;
HXDLIN(  87)					int aA = ((color1 >> 24) & 255);
HXDLIN(  87)					int rA = ((color1 >> 16) & 255);
HXDLIN(  87)					int gA = ((color1 >> 8) & 255);
HXDLIN(  87)					int bA = (color1 & 255);
HXDLIN(  87)					int aB = ((half >> 24) & 255);
HXDLIN(  87)					int rB = ((half >> 16) & 255);
HXDLIN(  87)					int gB = ((half >> 8) & 255);
HXDLIN(  87)					int bB = (half & 255);
HXDLIN(  87)					int aC = ((color2 >> 24) & 255);
HXDLIN(  87)					int rC = ((color2 >> 16) & 255);
HXDLIN(  87)					int gC = ((color2 >> 8) & 255);
HXDLIN(  87)					int bC = (color2 & 255);
HXDLIN(  87)					Float bcx = (bx - cx);
HXDLIN(  87)					Float bcy = (by - cy);
HXDLIN(  87)					Float acx = (qx - cx);
HXDLIN(  87)					Float acy = (qy - cy);
HXDLIN(  87)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  87)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  87)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  87)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  87)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  87)					if ((qx > bx)) {
HXLINE(  87)						if ((qx > cx)) {
HXLINE(  87)							int min;
HXDLIN(  87)							if ((bx > cx)) {
HXLINE(  87)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE(  87)								min = ::Math_obj::floor(bx);
            							}
HXDLIN(  87)							int ii_min = min;
HXDLIN(  87)							int ii_max = ::Math_obj::ceil(qx);
HXDLIN(  87)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)							xIter3 = this1;
            						}
            						else {
HXLINE(  87)							int ii_min = ::Math_obj::floor(bx);
HXDLIN(  87)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  87)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE(  87)						if ((bx > cx)) {
HXLINE(  87)							int min;
HXDLIN(  87)							if ((qx > cx)) {
HXLINE(  87)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE(  87)								min = ::Math_obj::ceil(qx);
            							}
HXDLIN(  87)							int ii_min = min;
HXDLIN(  87)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  87)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)							xIter3 = this1;
            						}
            						else {
HXLINE(  87)							int ii_min = ::Math_obj::floor(qx);
HXDLIN(  87)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  87)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)							xIter3 = this1;
            						}
            					}
HXDLIN(  87)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  87)					if ((qy > by)) {
HXLINE(  87)						if ((qy > cy)) {
HXLINE(  87)							int min;
HXDLIN(  87)							if ((by > cy)) {
HXLINE(  87)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  87)								min = ::Math_obj::floor(by);
            							}
HXDLIN(  87)							int ii_min = min;
HXDLIN(  87)							int ii_max = ::Math_obj::ceil(qy);
HXDLIN(  87)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)							yIter3 = this1;
            						}
            						else {
HXLINE(  87)							int ii_min = ::Math_obj::floor(by);
HXDLIN(  87)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  87)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE(  87)						if ((by > cy)) {
HXLINE(  87)							int min;
HXDLIN(  87)							if ((qy > cy)) {
HXLINE(  87)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  87)								min = ::Math_obj::ceil(qy);
            							}
HXDLIN(  87)							int ii_min = min;
HXDLIN(  87)							int ii_max = ::Math_obj::ceil(by);
HXDLIN(  87)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)							yIter3 = this1;
            						}
            						else {
HXLINE(  87)							int ii_min = ::Math_obj::floor(qy);
HXDLIN(  87)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  87)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  87)							yIter3 = this1;
            						}
            					}
HXDLIN(  87)					::pixelimage::ImageStruct undoImage = null();
HXDLIN(  87)					if (hasUndo) {
HXLINE(  87)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  87)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  87)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  87)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  87)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  87)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  87)						undoImage = this3;
HXDLIN(  87)						{
HXLINE(  87)							int rectLeft = xIter3->start;
HXDLIN(  87)							int rectTop = yIter3->start;
HXDLIN(  87)							int rectRight = xIter3->max;
HXDLIN(  87)							bool forceClear = false;
HXDLIN(  87)							{
HXLINE(  87)								int _g = rectTop;
HXDLIN(  87)								int _g1 = yIter3->max;
HXDLIN(  87)								while((_g < _g1)){
HXLINE(  87)									_g = (_g + 1);
HXDLIN(  87)									int dy = (_g - 1);
HXDLIN(  87)									{
HXLINE(  87)										int _g1 = rectLeft;
HXDLIN(  87)										int _g2 = rectRight;
HXDLIN(  87)										while((_g1 < _g2)){
HXLINE(  87)											_g1 = (_g1 + 1);
HXDLIN(  87)											int dx = (_g1 - 1);
HXDLIN(  87)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)											int index;
HXDLIN(  87)											if (pixelShape->useVirtualPos) {
HXLINE(  87)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  87)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  87)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)											int col;
HXDLIN(  87)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  87)												col = c;
            											}
HXDLIN(  87)											bool _hx_tmp;
HXDLIN(  87)											if (pixelShape->useMask) {
HXLINE(  87)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  87)												_hx_tmp = false;
            											}
HXDLIN(  87)											if (_hx_tmp) {
HXLINE(  87)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  87)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  87)												int index;
HXDLIN(  87)												if (this1->useVirtualPos) {
HXLINE(  87)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  87)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  87)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  87)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  87)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)												int v;
HXDLIN(  87)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  87)													v = c;
            												}
HXDLIN(  87)												int this3 = v;
HXDLIN(  87)												int maskPixel = this3;
HXDLIN(  87)												int this4 = col;
HXDLIN(  87)												int this5 = this4;
HXDLIN(  87)												if ((maskPixel == 0)) {
HXLINE(  87)													int this1 = this5;
HXDLIN(  87)													col = this1;
            												}
            												else {
HXLINE(  87)													Float m0;
HXDLIN(  87)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  87)													if ((this1 == 0)) {
HXLINE(  87)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float m1;
HXDLIN(  87)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  87)													if ((this2 == 0)) {
HXLINE(  87)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float m2;
HXDLIN(  87)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  87)													if ((this3 == 0)) {
HXLINE(  87)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float m3;
HXDLIN(  87)													int this4 = (maskPixel & 255);
HXDLIN(  87)													if ((this4 == 0)) {
HXLINE(  87)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  87)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  87)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  87)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  87)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  87)											if ((col != 0)) {
HXLINE(  87)												int x = (dx - rectLeft);
HXDLIN(  87)												int y = (dy - rectTop);
HXDLIN(  87)												int this1 = col;
HXDLIN(  87)												int c = this1;
HXDLIN(  87)												bool _hx_tmp;
HXDLIN(  87)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  87)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE(  87)													_hx_tmp = false;
            												}
HXDLIN(  87)												if (_hx_tmp) {
HXLINE(  87)													int location;
HXDLIN(  87)													if (undoImage->useVirtualPos) {
HXLINE(  87)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  87)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  87)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)													int this3 = this2;
HXDLIN(  87)													int this4;
HXDLIN(  87)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  87)														this4 = this3;
            													}
HXDLIN(  87)													Float a1;
HXDLIN(  87)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  87)													if ((this5 == 0)) {
HXLINE(  87)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float r1;
HXDLIN(  87)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  87)													if ((this6 == 0)) {
HXLINE(  87)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float g1;
HXDLIN(  87)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  87)													if ((this7 == 0)) {
HXLINE(  87)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float b1;
HXDLIN(  87)													int this8 = (this4 & 255);
HXDLIN(  87)													if ((this8 == 0)) {
HXLINE(  87)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float a2;
HXDLIN(  87)													int this9 = ((col >> 24) & 255);
HXDLIN(  87)													if ((this9 == 0)) {
HXLINE(  87)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float r2;
HXDLIN(  87)													int this10 = ((col >> 16) & 255);
HXDLIN(  87)													if ((this10 == 0)) {
HXLINE(  87)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float g2;
HXDLIN(  87)													int this11 = ((col >> 8) & 255);
HXDLIN(  87)													if ((this11 == 0)) {
HXLINE(  87)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float b2;
HXDLIN(  87)													int this12 = (col & 255);
HXDLIN(  87)													if ((this12 == 0)) {
HXLINE(  87)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  87)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  87)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)													{
HXLINE(  87)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  87)														int value;
HXDLIN(  87)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  87)															value = blended;
            														}
HXDLIN(  87)														bool _hx_tmp;
HXDLIN(  87)														if ((location >= 0)) {
HXLINE(  87)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  87)															_hx_tmp = false;
            														}
HXDLIN(  87)														if (_hx_tmp) {
HXLINE(  87)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  87)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  87)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  87)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)													int index;
HXDLIN(  87)													if (undoImage->useVirtualPos) {
HXLINE(  87)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  87)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  87)													int value;
HXDLIN(  87)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  87)														value = c;
            													}
HXDLIN(  87)													bool _hx_tmp;
HXDLIN(  87)													if ((index >= 0)) {
HXLINE(  87)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  87)														_hx_tmp = false;
            													}
HXDLIN(  87)													if (_hx_tmp) {
HXLINE(  87)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  87)												if (forceClear) {
HXLINE(  87)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  87)													int x = (dx - rectLeft);
HXDLIN(  87)													int y = (dy - rectTop);
HXDLIN(  87)													int index;
HXDLIN(  87)													if (undoImage->useVirtualPos) {
HXLINE(  87)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  87)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  87)													bool _hx_tmp;
HXDLIN(  87)													if ((index >= 0)) {
HXLINE(  87)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  87)														_hx_tmp = false;
            													}
HXDLIN(  87)													if (_hx_tmp) {
HXLINE(  87)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  87)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  87)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  87)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  87)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  87)					{
HXLINE(  87)						int _g_min = xIter3->start;
HXDLIN(  87)						int _g_max = xIter3->max;
HXDLIN(  87)						while((_g_min < _g_max)){
HXLINE(  87)							_g_min = (_g_min + 1);
HXDLIN(  87)							int px = (_g_min - 1);
HXDLIN(  87)							Float pcx = (( (Float)(px) ) - cx);
HXDLIN(  87)							{
HXLINE(  87)								int _g_min1 = yIter3->start;
HXDLIN(  87)								int _g_max = yIter3->max;
HXDLIN(  87)								while((_g_min1 < _g_max)){
HXLINE(  87)									_g_min1 = (_g_min1 + 1);
HXDLIN(  87)									int py = (_g_min1 - 1);
HXDLIN(  87)									Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  87)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  87)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  87)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  87)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  87)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  87)									bool _hx_tmp;
HXDLIN(  87)									bool _hx_tmp1;
HXDLIN(  87)									if ((ratioA >= 0)) {
HXLINE(  87)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  87)										_hx_tmp1 = false;
            									}
HXDLIN(  87)									if (_hx_tmp1) {
HXLINE(  87)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  87)										_hx_tmp = false;
            									}
HXDLIN(  87)									if (_hx_tmp) {
HXLINE(  87)										int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  87)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  87)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  87)										int this1 = i;
HXDLIN(  87)										int a = this1;
HXDLIN(  87)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  87)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  87)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  87)										int this2 = i1;
HXDLIN(  87)										int r = this2;
HXDLIN(  87)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  87)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  87)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  87)										int this3 = i2;
HXDLIN(  87)										int g = this3;
HXDLIN(  87)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  87)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  87)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  87)										int this4 = i3;
HXDLIN(  87)										int b = this4;
HXDLIN(  87)										{
HXLINE(  87)											int location;
HXDLIN(  87)											if (pixelShape->useVirtualPos) {
HXLINE(  87)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  87)												location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            											}
HXDLIN(  87)											bool _hx_tmp;
HXDLIN(  87)											if (pixelShape->transparent) {
HXLINE(  87)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  87)												_hx_tmp = false;
            											}
HXDLIN(  87)											if (_hx_tmp) {
HXLINE(  87)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  87)												int this3 = this2;
HXDLIN(  87)												int old;
HXDLIN(  87)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  87)													old = this3;
            												}
HXDLIN(  87)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  87)												Float a1;
HXDLIN(  87)												int this4 = ((old >> 24) & 255);
HXDLIN(  87)												if ((this4 == 0)) {
HXLINE(  87)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  87)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  87)												Float r1;
HXDLIN(  87)												int this5 = ((old >> 16) & 255);
HXDLIN(  87)												if ((this5 == 0)) {
HXLINE(  87)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  87)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  87)												Float g1;
HXDLIN(  87)												int this6 = ((old >> 8) & 255);
HXDLIN(  87)												if ((this6 == 0)) {
HXLINE(  87)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  87)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  87)												Float b1;
HXDLIN(  87)												int this7 = (old & 255);
HXDLIN(  87)												if ((this7 == 0)) {
HXLINE(  87)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  87)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  87)												Float a2;
HXDLIN(  87)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  87)												if ((this8 == 0)) {
HXLINE(  87)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  87)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  87)												Float r2;
HXDLIN(  87)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  87)												if ((this9 == 0)) {
HXLINE(  87)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  87)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  87)												Float g2;
HXDLIN(  87)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  87)												if ((this10 == 0)) {
HXLINE(  87)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  87)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  87)												Float b2;
HXDLIN(  87)												int this11 = (rhs & 255);
HXDLIN(  87)												if ((this11 == 0)) {
HXLINE(  87)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  87)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  87)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  87)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  87)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  87)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  87)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  87)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  87)												{
HXLINE(  87)													::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  87)													int value;
HXDLIN(  87)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  87)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  87)														value = blended;
            													}
HXDLIN(  87)													bool _hx_tmp;
HXDLIN(  87)													if ((location >= 0)) {
HXLINE(  87)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  87)														_hx_tmp = false;
            													}
HXDLIN(  87)													if (_hx_tmp) {
HXLINE(  87)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  87)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  87)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  87)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  87)												int value;
HXDLIN(  87)												if (pixelShape->isLittle) {
HXLINE(  87)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  87)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  87)												bool _hx_tmp;
HXDLIN(  87)												if ((location >= 0)) {
HXLINE(  87)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  87)													_hx_tmp = false;
            												}
HXDLIN(  87)												if (_hx_tmp) {
HXLINE(  87)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  87)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  87)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  87)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  87)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  87)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  87)					::pixelimage::algo::HitTri hitTri;
HXDLIN(  87)					if ((hasHit == false)) {
HXLINE(  87)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx,by,cx,cy,true);
HXDLIN(  87)						if (hasUndo) {
HXLINE(  87)							v->undoImage = undoImage;
HXDLIN(  87)							v->undoX = xIter3->start;
HXDLIN(  87)							v->undoY = yIter3->start;
            						}
HXDLIN(  87)						hitTri = v;
            					}
            					else {
HXLINE(  87)						hitTri = null();
            					}
HXDLIN(  87)					if (hasHit) {
HXLINE(  87)						::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN(  87)						if (::hx::IsNotNull( hitQuad )) {
HXLINE(  87)							hitArr->triArr->push(hitQuad->triABD);
            						}
HXDLIN(  87)						hitArr->triArr->push(hitQuad->triBCD);
            					}
            				}
            			}
            		}
            		else {
HXLINE(  91)			bool _hx_tmp;
HXDLIN(  91)			if (!((this->arrowHeight > ((Float)0.)))) {
HXLINE(  91)				_hx_tmp = (this->arrowWidth > ((Float)0.));
            			}
            			else {
HXLINE(  91)				_hx_tmp = true;
            			}
HXDLIN(  91)			if (_hx_tmp) {
HXLINE(  92)				Float arrowWidth = this->arrowWidth;
HXDLIN(  92)				Float arrowHeight = this->arrowHeight;
HXDLIN(  92)				Float thick = this->strokeWidth;
HXDLIN(  92)				int color1 = this->strokeTopColor;
HXDLIN(  92)				int color2 = this->strokeBottomColor;
HXDLIN(  92)				bool hasHit = true;
HXDLIN(  92)				{
HXLINE(  92)					Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  92)					Float o = (qy - py);
HXDLIN(  92)					Float a = (qx - px);
HXDLIN(  92)					Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  92)					Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  92)					Float thicker;
HXDLIN(  92)					if ((arrowWidth > (thick * ((Float)1.1)))) {
HXLINE(  92)						thicker = arrowWidth;
            					}
            					else {
HXLINE(  92)						thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            					}
HXDLIN(  92)					Float sin = ::Math_obj::sin(theta);
HXDLIN(  92)					Float cos = ::Math_obj::cos(theta);
HXDLIN(  92)					Float radius = (thick / ( (Float)(2) ));
HXDLIN(  92)					Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  92)					Float h2;
HXDLIN(  92)					if ((arrowHeight < (h * ((Float)1.1)))) {
HXLINE(  92)						h2 = (h - arrowHeight);
            					}
            					else {
HXLINE(  92)						h2 = (h / goldenRatio);
            					}
HXDLIN(  92)					Float hSmall = (h - h2);
HXDLIN(  92)					Float px_ = hSmall;
HXDLIN(  92)					Float py_ = ((Float)0.);
HXDLIN(  92)					Float temp = ((Float)0.);
HXLINE( 729)					temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 730)					py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 731)					px_ = temp;
HXLINE(  92)					Float h1 = (h2 - hSmall);
HXDLIN(  92)					Float sin1 = ::Math_obj::sin(theta);
HXDLIN(  92)					Float cos1 = ::Math_obj::cos(theta);
HXDLIN(  92)					Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  92)					Float dx = ((Float)0.1);
HXDLIN(  92)					Float dy = radius1;
HXDLIN(  92)					Float cx = h1;
HXDLIN(  92)					Float cy = radius1;
HXDLIN(  92)					Float bx = h1;
HXDLIN(  92)					Float by = -(radius1);
HXDLIN(  92)					Float ax = ((Float)0.1);
HXDLIN(  92)					Float ay = -(radius1);
HXDLIN(  92)					Float temp1 = ((Float)0.);
HXLINE( 474)					temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE( 475)					ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE( 476)					ax = temp1;
HXLINE( 478)					temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE( 479)					by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE( 480)					bx = temp1;
HXLINE( 482)					temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE( 483)					cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE( 484)					cx = temp1;
HXLINE( 486)					temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE( 487)					dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE( 488)					dx = temp1;
HXLINE(  92)					{
HXLINE(  92)						bool hasUndo = false;
HXDLIN(  92)						int aA = ((color1 >> 24) & 255);
HXDLIN(  92)						int rA = ((color1 >> 16) & 255);
HXDLIN(  92)						int gA = ((color1 >> 8) & 255);
HXDLIN(  92)						int bA = (color1 & 255);
HXDLIN(  92)						int aB = ((color1 >> 24) & 255);
HXDLIN(  92)						int rB = ((color1 >> 16) & 255);
HXDLIN(  92)						int gB = ((color1 >> 8) & 255);
HXDLIN(  92)						int bB = (color1 & 255);
HXDLIN(  92)						int aC = ((color2 >> 24) & 255);
HXDLIN(  92)						int rC = ((color2 >> 16) & 255);
HXDLIN(  92)						int gC = ((color2 >> 8) & 255);
HXDLIN(  92)						int bC = (color2 & 255);
HXDLIN(  92)						Float bcx = (bx - dx);
HXDLIN(  92)						Float bcy = (by - dy);
HXDLIN(  92)						Float acx = (ax - dx);
HXDLIN(  92)						Float acy = (ay - dy);
HXDLIN(  92)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  92)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  92)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  92)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  92)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  92)						if ((ax > bx)) {
HXLINE(  92)							if ((ax > dx)) {
HXLINE(  92)								int min;
HXDLIN(  92)								if ((bx > dx)) {
HXLINE(  92)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  92)									min = ::Math_obj::floor(bx);
            								}
HXDLIN(  92)								int ii_min = min;
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								xIter3 = this1;
            							}
            							else {
HXLINE(  92)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  92)							if ((bx > dx)) {
HXLINE(  92)								int min;
HXDLIN(  92)								if ((ax > dx)) {
HXLINE(  92)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  92)									min = ::Math_obj::ceil(ax);
            								}
HXDLIN(  92)								int ii_min = min;
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								xIter3 = this1;
            							}
            							else {
HXLINE(  92)								int ii_min = ::Math_obj::floor(ax);
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								xIter3 = this1;
            							}
            						}
HXDLIN(  92)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  92)						if ((ay > by)) {
HXLINE(  92)							if ((ay > dy)) {
HXLINE(  92)								int min;
HXDLIN(  92)								if ((by > dy)) {
HXLINE(  92)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  92)									min = ::Math_obj::floor(by);
            								}
HXDLIN(  92)								int ii_min = min;
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								yIter3 = this1;
            							}
            							else {
HXLINE(  92)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  92)							if ((by > dy)) {
HXLINE(  92)								int min;
HXDLIN(  92)								if ((ay > dy)) {
HXLINE(  92)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  92)									min = ::Math_obj::ceil(ay);
            								}
HXDLIN(  92)								int ii_min = min;
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								yIter3 = this1;
            							}
            							else {
HXLINE(  92)								int ii_min = ::Math_obj::floor(ay);
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								yIter3 = this1;
            							}
            						}
HXDLIN(  92)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  92)						if (hasUndo) {
HXLINE(  92)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  92)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  92)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  92)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  92)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  92)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  92)							undoImage = this3;
HXDLIN(  92)							{
HXLINE(  92)								int rectLeft = xIter3->start;
HXDLIN(  92)								int rectTop = yIter3->start;
HXDLIN(  92)								int rectRight = xIter3->max;
HXDLIN(  92)								bool forceClear = false;
HXDLIN(  92)								{
HXLINE(  92)									int _g = rectTop;
HXDLIN(  92)									int _g1 = yIter3->max;
HXDLIN(  92)									while((_g < _g1)){
HXLINE(  92)										_g = (_g + 1);
HXDLIN(  92)										int dy = (_g - 1);
HXDLIN(  92)										{
HXLINE(  92)											int _g1 = rectLeft;
HXDLIN(  92)											int _g2 = rectRight;
HXDLIN(  92)											while((_g1 < _g2)){
HXLINE(  92)												_g1 = (_g1 + 1);
HXDLIN(  92)												int dx = (_g1 - 1);
HXDLIN(  92)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)												int index;
HXDLIN(  92)												if (pixelShape->useVirtualPos) {
HXLINE(  92)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  92)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            												}
HXDLIN(  92)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)												int col;
HXDLIN(  92)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  92)													col = c;
            												}
HXDLIN(  92)												bool _hx_tmp;
HXDLIN(  92)												if (pixelShape->useMask) {
HXLINE(  92)													_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            												}
            												else {
HXLINE(  92)													_hx_tmp = false;
            												}
HXDLIN(  92)												if (_hx_tmp) {
HXLINE(  92)													::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  92)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  92)													int index;
HXDLIN(  92)													if (this1->useVirtualPos) {
HXLINE(  92)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  92)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  92)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  92)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  92)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)													int v;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  92)														v = c;
            													}
HXDLIN(  92)													int this3 = v;
HXDLIN(  92)													int maskPixel = this3;
HXDLIN(  92)													int this4 = col;
HXDLIN(  92)													int this5 = this4;
HXDLIN(  92)													if ((maskPixel == 0)) {
HXLINE(  92)														int this1 = this5;
HXDLIN(  92)														col = this1;
            													}
            													else {
HXLINE(  92)														Float m0;
HXDLIN(  92)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  92)														if ((this1 == 0)) {
HXLINE(  92)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float m1;
HXDLIN(  92)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  92)														if ((this2 == 0)) {
HXLINE(  92)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float m2;
HXDLIN(  92)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  92)														if ((this3 == 0)) {
HXLINE(  92)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float m3;
HXDLIN(  92)														int this4 = (maskPixel & 255);
HXDLIN(  92)														if ((this4 == 0)) {
HXLINE(  92)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  92)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  92)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  92)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  92)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  92)												if ((col != 0)) {
HXLINE(  92)													int x = (dx - rectLeft);
HXDLIN(  92)													int y = (dy - rectTop);
HXDLIN(  92)													int this1 = col;
HXDLIN(  92)													int c = this1;
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  92)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														int location;
HXDLIN(  92)														if (undoImage->useVirtualPos) {
HXLINE(  92)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  92)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  92)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  92)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)														int this3 = this2;
HXDLIN(  92)														int this4;
HXDLIN(  92)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  92)															this4 = this3;
            														}
HXDLIN(  92)														Float a1;
HXDLIN(  92)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  92)														if ((this5 == 0)) {
HXLINE(  92)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float r1;
HXDLIN(  92)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  92)														if ((this6 == 0)) {
HXLINE(  92)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float g1;
HXDLIN(  92)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  92)														if ((this7 == 0)) {
HXLINE(  92)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float b1;
HXDLIN(  92)														int this8 = (this4 & 255);
HXDLIN(  92)														if ((this8 == 0)) {
HXLINE(  92)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float a2;
HXDLIN(  92)														int this9 = ((col >> 24) & 255);
HXDLIN(  92)														if ((this9 == 0)) {
HXLINE(  92)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float r2;
HXDLIN(  92)														int this10 = ((col >> 16) & 255);
HXDLIN(  92)														if ((this10 == 0)) {
HXLINE(  92)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float g2;
HXDLIN(  92)														int this11 = ((col >> 8) & 255);
HXDLIN(  92)														if ((this11 == 0)) {
HXLINE(  92)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float b2;
HXDLIN(  92)														int this12 = (col & 255);
HXDLIN(  92)														if ((this12 == 0)) {
HXLINE(  92)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  92)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  92)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  92)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  92)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  92)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  92)														{
HXLINE(  92)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  92)															int value;
HXDLIN(  92)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  92)																value = blended;
            															}
HXDLIN(  92)															bool _hx_tmp;
HXDLIN(  92)															if ((location >= 0)) {
HXLINE(  92)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  92)																_hx_tmp = false;
            															}
HXDLIN(  92)															if (_hx_tmp) {
HXLINE(  92)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  92)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  92)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  92)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  92)														int index;
HXDLIN(  92)														if (undoImage->useVirtualPos) {
HXLINE(  92)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  92)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  92)														int value;
HXDLIN(  92)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  92)															value = c;
            														}
HXDLIN(  92)														bool _hx_tmp;
HXDLIN(  92)														if ((index >= 0)) {
HXLINE(  92)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															_hx_tmp = false;
            														}
HXDLIN(  92)														if (_hx_tmp) {
HXLINE(  92)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  92)													if (forceClear) {
HXLINE(  92)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  92)														int x = (dx - rectLeft);
HXDLIN(  92)														int y = (dy - rectTop);
HXDLIN(  92)														int index;
HXDLIN(  92)														if (undoImage->useVirtualPos) {
HXLINE(  92)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  92)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  92)														bool _hx_tmp;
HXDLIN(  92)														if ((index >= 0)) {
HXLINE(  92)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															_hx_tmp = false;
            														}
HXDLIN(  92)														if (_hx_tmp) {
HXLINE(  92)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  92)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  92)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  92)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  92)						{
HXLINE(  92)							int _g_min = xIter3->start;
HXDLIN(  92)							int _g_max = xIter3->max;
HXDLIN(  92)							while((_g_min < _g_max)){
HXLINE(  92)								_g_min = (_g_min + 1);
HXDLIN(  92)								int px = (_g_min - 1);
HXDLIN(  92)								Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  92)								{
HXLINE(  92)									int _g_min1 = yIter3->start;
HXDLIN(  92)									int _g_max = yIter3->max;
HXDLIN(  92)									while((_g_min1 < _g_max)){
HXLINE(  92)										_g_min1 = (_g_min1 + 1);
HXDLIN(  92)										int py = (_g_min1 - 1);
HXDLIN(  92)										Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  92)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  92)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  92)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  92)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  92)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  92)										bool _hx_tmp;
HXDLIN(  92)										bool _hx_tmp1;
HXDLIN(  92)										if ((ratioA >= 0)) {
HXLINE(  92)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  92)											_hx_tmp1 = false;
            										}
HXDLIN(  92)										if (_hx_tmp1) {
HXLINE(  92)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  92)											_hx_tmp = false;
            										}
HXDLIN(  92)										if (_hx_tmp) {
HXLINE(  92)											int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  92)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  92)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  92)											int this1 = i;
HXDLIN(  92)											int a = this1;
HXDLIN(  92)											int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  92)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  92)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  92)											int this2 = i1;
HXDLIN(  92)											int r = this2;
HXDLIN(  92)											int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  92)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  92)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  92)											int this3 = i2;
HXDLIN(  92)											int g = this3;
HXDLIN(  92)											int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  92)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  92)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  92)											int this4 = i3;
HXDLIN(  92)											int b = this4;
HXDLIN(  92)											{
HXLINE(  92)												int location;
HXDLIN(  92)												if (pixelShape->useVirtualPos) {
HXLINE(  92)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  92)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            												}
HXDLIN(  92)												bool _hx_tmp;
HXDLIN(  92)												if (pixelShape->transparent) {
HXLINE(  92)													_hx_tmp = (a < 254);
            												}
            												else {
HXLINE(  92)													_hx_tmp = false;
            												}
HXDLIN(  92)												if (_hx_tmp) {
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)													int this3 = this2;
HXDLIN(  92)													int old;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  92)														old = this3;
            													}
HXDLIN(  92)													int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  92)													Float a1;
HXDLIN(  92)													int this4 = ((old >> 24) & 255);
HXDLIN(  92)													if ((this4 == 0)) {
HXLINE(  92)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float r1;
HXDLIN(  92)													int this5 = ((old >> 16) & 255);
HXDLIN(  92)													if ((this5 == 0)) {
HXLINE(  92)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float g1;
HXDLIN(  92)													int this6 = ((old >> 8) & 255);
HXDLIN(  92)													if ((this6 == 0)) {
HXLINE(  92)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float b1;
HXDLIN(  92)													int this7 = (old & 255);
HXDLIN(  92)													if ((this7 == 0)) {
HXLINE(  92)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float a2;
HXDLIN(  92)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  92)													if ((this8 == 0)) {
HXLINE(  92)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float r2;
HXDLIN(  92)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  92)													if ((this9 == 0)) {
HXLINE(  92)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float g2;
HXDLIN(  92)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  92)													if ((this10 == 0)) {
HXLINE(  92)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float b2;
HXDLIN(  92)													int this11 = (rhs & 255);
HXDLIN(  92)													if ((this11 == 0)) {
HXLINE(  92)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  92)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  92)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  92)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  92)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  92)													int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  92)													{
HXLINE(  92)														::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  92)														int value;
HXDLIN(  92)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  92)															value = blended;
            														}
HXDLIN(  92)														bool _hx_tmp;
HXDLIN(  92)														if ((location >= 0)) {
HXLINE(  92)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															_hx_tmp = false;
            														}
HXDLIN(  92)														if (_hx_tmp) {
HXLINE(  92)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  92)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  92)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)													int value;
HXDLIN(  92)													if (pixelShape->isLittle) {
HXLINE(  92)														value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  92)														value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((location >= 0)) {
HXLINE(  92)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  92)					{
HXLINE(  92)						bool hasHit1 = false;
HXDLIN(  92)						bool hasUndo1 = false;
HXDLIN(  92)						int aA1 = ((color2 >> 24) & 255);
HXDLIN(  92)						int rA1 = ((color2 >> 16) & 255);
HXDLIN(  92)						int gA1 = ((color2 >> 8) & 255);
HXDLIN(  92)						int bA1 = (color2 & 255);
HXDLIN(  92)						int aB1 = ((color1 >> 24) & 255);
HXDLIN(  92)						int rB1 = ((color1 >> 16) & 255);
HXDLIN(  92)						int gB1 = ((color1 >> 8) & 255);
HXDLIN(  92)						int bB1 = (color1 & 255);
HXDLIN(  92)						int aC1 = ((color2 >> 24) & 255);
HXDLIN(  92)						int rC1 = ((color2 >> 16) & 255);
HXDLIN(  92)						int gC1 = ((color2 >> 8) & 255);
HXDLIN(  92)						int bC1 = (color2 & 255);
HXDLIN(  92)						Float bcx1 = (cx - dx);
HXDLIN(  92)						Float bcy1 = (cy - dy);
HXDLIN(  92)						Float acx1 = (bx - dx);
HXDLIN(  92)						Float acy1 = (by - dy);
HXDLIN(  92)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  92)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  92)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  92)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  92)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  92)						if ((bx > cx)) {
HXLINE(  92)							if ((bx > dx)) {
HXLINE(  92)								int min;
HXDLIN(  92)								if ((cx > dx)) {
HXLINE(  92)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  92)									min = ::Math_obj::floor(cx);
            								}
HXDLIN(  92)								int ii_min = min;
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								xIter31 = this1;
            							}
            							else {
HXLINE(  92)								int ii_min = ::Math_obj::floor(cx);
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE(  92)							if ((cx > dx)) {
HXLINE(  92)								int min;
HXDLIN(  92)								if ((bx > dx)) {
HXLINE(  92)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  92)									min = ::Math_obj::ceil(bx);
            								}
HXDLIN(  92)								int ii_min = min;
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								xIter31 = this1;
            							}
            							else {
HXLINE(  92)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								xIter31 = this1;
            							}
            						}
HXDLIN(  92)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  92)						if ((by > cy)) {
HXLINE(  92)							if ((by > dy)) {
HXLINE(  92)								int min;
HXDLIN(  92)								if ((cy > dy)) {
HXLINE(  92)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  92)									min = ::Math_obj::floor(cy);
            								}
HXDLIN(  92)								int ii_min = min;
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								yIter31 = this1;
            							}
            							else {
HXLINE(  92)								int ii_min = ::Math_obj::floor(cy);
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE(  92)							if ((cy > dy)) {
HXLINE(  92)								int min;
HXDLIN(  92)								if ((by > dy)) {
HXLINE(  92)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  92)									min = ::Math_obj::ceil(by);
            								}
HXDLIN(  92)								int ii_min = min;
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								yIter31 = this1;
            							}
            							else {
HXLINE(  92)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  92)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  92)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)								yIter31 = this1;
            							}
            						}
HXDLIN(  92)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  92)						if (hasUndo1) {
HXLINE(  92)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  92)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  92)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  92)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  92)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  92)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  92)							undoImage1 = this3;
HXDLIN(  92)							{
HXLINE(  92)								int rectLeft = xIter31->start;
HXDLIN(  92)								int rectTop = yIter31->start;
HXDLIN(  92)								int rectRight = xIter31->max;
HXDLIN(  92)								bool forceClear = false;
HXDLIN(  92)								{
HXLINE(  92)									int _g = rectTop;
HXDLIN(  92)									int _g1 = yIter31->max;
HXDLIN(  92)									while((_g < _g1)){
HXLINE(  92)										_g = (_g + 1);
HXDLIN(  92)										int dy = (_g - 1);
HXDLIN(  92)										{
HXLINE(  92)											int _g1 = rectLeft;
HXDLIN(  92)											int _g2 = rectRight;
HXDLIN(  92)											while((_g1 < _g2)){
HXLINE(  92)												_g1 = (_g1 + 1);
HXDLIN(  92)												int dx = (_g1 - 1);
HXDLIN(  92)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)												int index;
HXDLIN(  92)												if (pixelShape->useVirtualPos) {
HXLINE(  92)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  92)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            												}
HXDLIN(  92)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)												int col;
HXDLIN(  92)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  92)													col = c;
            												}
HXDLIN(  92)												bool _hx_tmp;
HXDLIN(  92)												if (pixelShape->useMask) {
HXLINE(  92)													_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            												}
            												else {
HXLINE(  92)													_hx_tmp = false;
            												}
HXDLIN(  92)												if (_hx_tmp) {
HXLINE(  92)													::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  92)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  92)													int index;
HXDLIN(  92)													if (this1->useVirtualPos) {
HXLINE(  92)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  92)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  92)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  92)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  92)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)													int v;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  92)														v = c;
            													}
HXDLIN(  92)													int this3 = v;
HXDLIN(  92)													int maskPixel = this3;
HXDLIN(  92)													int this4 = col;
HXDLIN(  92)													int this5 = this4;
HXDLIN(  92)													if ((maskPixel == 0)) {
HXLINE(  92)														int this1 = this5;
HXDLIN(  92)														col = this1;
            													}
            													else {
HXLINE(  92)														Float m0;
HXDLIN(  92)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  92)														if ((this1 == 0)) {
HXLINE(  92)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float m1;
HXDLIN(  92)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  92)														if ((this2 == 0)) {
HXLINE(  92)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float m2;
HXDLIN(  92)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  92)														if ((this3 == 0)) {
HXLINE(  92)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float m3;
HXDLIN(  92)														int this4 = (maskPixel & 255);
HXDLIN(  92)														if ((this4 == 0)) {
HXLINE(  92)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  92)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  92)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  92)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  92)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  92)												if ((col != 0)) {
HXLINE(  92)													int x = (dx - rectLeft);
HXDLIN(  92)													int y = (dy - rectTop);
HXDLIN(  92)													int this1 = col;
HXDLIN(  92)													int c = this1;
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  92)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														int location;
HXDLIN(  92)														if (undoImage1->useVirtualPos) {
HXLINE(  92)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  92)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  92)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  92)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)														int this3 = this2;
HXDLIN(  92)														int this4;
HXDLIN(  92)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  92)															this4 = this3;
            														}
HXDLIN(  92)														Float a1;
HXDLIN(  92)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  92)														if ((this5 == 0)) {
HXLINE(  92)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float r1;
HXDLIN(  92)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  92)														if ((this6 == 0)) {
HXLINE(  92)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float g1;
HXDLIN(  92)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  92)														if ((this7 == 0)) {
HXLINE(  92)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float b1;
HXDLIN(  92)														int this8 = (this4 & 255);
HXDLIN(  92)														if ((this8 == 0)) {
HXLINE(  92)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float a2;
HXDLIN(  92)														int this9 = ((col >> 24) & 255);
HXDLIN(  92)														if ((this9 == 0)) {
HXLINE(  92)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float r2;
HXDLIN(  92)														int this10 = ((col >> 16) & 255);
HXDLIN(  92)														if ((this10 == 0)) {
HXLINE(  92)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float g2;
HXDLIN(  92)														int this11 = ((col >> 8) & 255);
HXDLIN(  92)														if ((this11 == 0)) {
HXLINE(  92)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float b2;
HXDLIN(  92)														int this12 = (col & 255);
HXDLIN(  92)														if ((this12 == 0)) {
HXLINE(  92)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  92)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  92)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  92)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  92)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  92)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  92)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  92)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  92)														{
HXLINE(  92)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  92)															int value;
HXDLIN(  92)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  92)																value = blended;
            															}
HXDLIN(  92)															bool _hx_tmp;
HXDLIN(  92)															if ((location >= 0)) {
HXLINE(  92)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  92)																_hx_tmp = false;
            															}
HXDLIN(  92)															if (_hx_tmp) {
HXLINE(  92)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  92)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  92)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  92)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  92)														int index;
HXDLIN(  92)														if (undoImage1->useVirtualPos) {
HXLINE(  92)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  92)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  92)														int value;
HXDLIN(  92)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  92)															value = c;
            														}
HXDLIN(  92)														bool _hx_tmp;
HXDLIN(  92)														if ((index >= 0)) {
HXLINE(  92)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															_hx_tmp = false;
            														}
HXDLIN(  92)														if (_hx_tmp) {
HXLINE(  92)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  92)													if (forceClear) {
HXLINE(  92)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  92)														int x = (dx - rectLeft);
HXDLIN(  92)														int y = (dy - rectTop);
HXDLIN(  92)														int index;
HXDLIN(  92)														if (undoImage1->useVirtualPos) {
HXLINE(  92)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  92)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  92)														bool _hx_tmp;
HXDLIN(  92)														if ((index >= 0)) {
HXLINE(  92)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															_hx_tmp = false;
            														}
HXDLIN(  92)														if (_hx_tmp) {
HXLINE(  92)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  92)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  92)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  92)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  92)						{
HXLINE(  92)							int _g_min1 = xIter31->start;
HXDLIN(  92)							int _g_max1 = xIter31->max;
HXDLIN(  92)							while((_g_min1 < _g_max1)){
HXLINE(  92)								_g_min1 = (_g_min1 + 1);
HXDLIN(  92)								int px = (_g_min1 - 1);
HXDLIN(  92)								Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  92)								{
HXLINE(  92)									int _g_min = yIter31->start;
HXDLIN(  92)									int _g_max = yIter31->max;
HXDLIN(  92)									while((_g_min < _g_max)){
HXLINE(  92)										_g_min = (_g_min + 1);
HXDLIN(  92)										int py = (_g_min - 1);
HXDLIN(  92)										Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  92)										Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  92)										Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  92)										Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  92)										Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  92)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  92)										bool _hx_tmp;
HXDLIN(  92)										bool _hx_tmp1;
HXDLIN(  92)										if ((ratioA >= 0)) {
HXLINE(  92)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  92)											_hx_tmp1 = false;
            										}
HXDLIN(  92)										if (_hx_tmp1) {
HXLINE(  92)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  92)											_hx_tmp = false;
            										}
HXDLIN(  92)										if (_hx_tmp) {
HXLINE(  92)											int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  92)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  92)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  92)											int this1 = i;
HXDLIN(  92)											int a = this1;
HXDLIN(  92)											int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  92)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  92)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  92)											int this2 = i1;
HXDLIN(  92)											int r = this2;
HXDLIN(  92)											int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  92)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  92)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  92)											int this3 = i2;
HXDLIN(  92)											int g = this3;
HXDLIN(  92)											int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  92)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  92)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  92)											int this4 = i3;
HXDLIN(  92)											int b = this4;
HXDLIN(  92)											{
HXLINE(  92)												int location;
HXDLIN(  92)												if (pixelShape->useVirtualPos) {
HXLINE(  92)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  92)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            												}
HXDLIN(  92)												bool _hx_tmp;
HXDLIN(  92)												if (pixelShape->transparent) {
HXLINE(  92)													_hx_tmp = (a < 254);
            												}
            												else {
HXLINE(  92)													_hx_tmp = false;
            												}
HXDLIN(  92)												if (_hx_tmp) {
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)													int this3 = this2;
HXDLIN(  92)													int old;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  92)														old = this3;
            													}
HXDLIN(  92)													int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  92)													Float a1;
HXDLIN(  92)													int this4 = ((old >> 24) & 255);
HXDLIN(  92)													if ((this4 == 0)) {
HXLINE(  92)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float r1;
HXDLIN(  92)													int this5 = ((old >> 16) & 255);
HXDLIN(  92)													if ((this5 == 0)) {
HXLINE(  92)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float g1;
HXDLIN(  92)													int this6 = ((old >> 8) & 255);
HXDLIN(  92)													if ((this6 == 0)) {
HXLINE(  92)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float b1;
HXDLIN(  92)													int this7 = (old & 255);
HXDLIN(  92)													if ((this7 == 0)) {
HXLINE(  92)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float a2;
HXDLIN(  92)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  92)													if ((this8 == 0)) {
HXLINE(  92)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float r2;
HXDLIN(  92)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  92)													if ((this9 == 0)) {
HXLINE(  92)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float g2;
HXDLIN(  92)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  92)													if ((this10 == 0)) {
HXLINE(  92)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float b2;
HXDLIN(  92)													int this11 = (rhs & 255);
HXDLIN(  92)													if ((this11 == 0)) {
HXLINE(  92)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  92)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  92)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  92)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  92)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  92)													int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  92)													{
HXLINE(  92)														::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  92)														int value;
HXDLIN(  92)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  92)															value = blended;
            														}
HXDLIN(  92)														bool _hx_tmp;
HXDLIN(  92)														if ((location >= 0)) {
HXLINE(  92)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															_hx_tmp = false;
            														}
HXDLIN(  92)														if (_hx_tmp) {
HXLINE(  92)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  92)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  92)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)													int value;
HXDLIN(  92)													if (pixelShape->isLittle) {
HXLINE(  92)														value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  92)														value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((location >= 0)) {
HXLINE(  92)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  92)						if ((hasHit1 == false)) {
HXLINE(  92)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  92)							if (hasUndo1) {
HXLINE(  92)								v->undoImage = undoImage1;
HXDLIN(  92)								v->undoX = xIter31->start;
HXDLIN(  92)								v->undoY = yIter31->start;
            							}
            						}
            					}
HXDLIN(  92)					::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  92)					::pixelimage::algo::HitQuad hitQuad = v;
HXDLIN(  92)					Float cx1 = h2;
HXDLIN(  92)					Float cy1 = radius2;
HXDLIN(  92)					Float bx1 = h2;
HXDLIN(  92)					Float by1 = -(radius2);
HXDLIN(  92)					Float dx1 = hSmall;
HXDLIN(  92)					Float dy1 = radius2;
HXDLIN(  92)					Float ax1 = hSmall;
HXDLIN(  92)					Float ay1 = -(radius2);
HXLINE( 744)					temp = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE( 745)					by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE( 746)					bx1 = temp;
HXLINE( 747)					temp = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE( 748)					cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE( 749)					cx1 = temp;
HXLINE( 751)					temp = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE( 752)					ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE( 753)					ax1 = temp;
HXLINE( 755)					temp = (px + ((dx1 * cos) - (dy1 * sin)));
HXLINE( 756)					dy1 = (py + ((dy1 * cos) + (dx1 * sin)));
HXLINE( 757)					dx1 = temp;
HXLINE(  92)					::pixelimage::pixel::_TwoGrad::TwoGrad_ this1 = ::pixelimage::pixel::_TwoGrad::TwoGrad__obj::__alloc( HX_CTX ,color1,color2);
HXDLIN(  92)					::pixelimage::pixel::_TwoGrad::TwoGrad_ twoColors = this1;
HXDLIN(  92)					int a1 = twoColors->colorClock;
HXDLIN(  92)					int b = twoColors->colorAnti;
HXDLIN(  92)					int half = ((((::Math_obj::round(((((( (Float)(((a1 >> 24) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 24) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 24) | (::Math_obj::round(((((( (Float)(((a1 >> 16) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 16) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 16)) | (::Math_obj::round(((((( (Float)(((a1 >> 8) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 8) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 8)) | ::Math_obj::round(((((( (Float)((a1 & 255)) ) / ( (Float)(255) )) + (( (Float)((b & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))));
HXDLIN(  92)					bool hasUndo2 = false;
HXDLIN(  92)					int aA2 = ((color1 >> 24) & 255);
HXDLIN(  92)					int rA2 = ((color1 >> 16) & 255);
HXDLIN(  92)					int gA2 = ((color1 >> 8) & 255);
HXDLIN(  92)					int bA2 = (color1 & 255);
HXDLIN(  92)					int aB2 = ((half >> 24) & 255);
HXDLIN(  92)					int rB2 = ((half >> 16) & 255);
HXDLIN(  92)					int gB2 = ((half >> 8) & 255);
HXDLIN(  92)					int bB2 = (half & 255);
HXDLIN(  92)					int aC2 = ((color2 >> 24) & 255);
HXDLIN(  92)					int rC2 = ((color2 >> 16) & 255);
HXDLIN(  92)					int gC2 = ((color2 >> 8) & 255);
HXDLIN(  92)					int bC2 = (color2 & 255);
HXDLIN(  92)					Float bcx2 = (bx1 - cx1);
HXDLIN(  92)					Float bcy2 = (by1 - cy1);
HXDLIN(  92)					Float acx2 = (qx - cx1);
HXDLIN(  92)					Float acy2 = (qy - cy1);
HXDLIN(  92)					Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  92)					Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  92)					Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  92)					Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  92)					::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  92)					if ((qx > bx1)) {
HXLINE(  92)						if ((qx > cx1)) {
HXLINE(  92)							int min;
HXDLIN(  92)							if ((bx1 > cx1)) {
HXLINE(  92)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE(  92)								min = ::Math_obj::floor(bx1);
            							}
HXDLIN(  92)							int ii_min = min;
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(qx);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							xIter32 = this1;
            						}
            						else {
HXLINE(  92)							int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							xIter32 = this1;
            						}
            					}
            					else {
HXLINE(  92)						if ((bx1 > cx1)) {
HXLINE(  92)							int min;
HXDLIN(  92)							if ((qx > cx1)) {
HXLINE(  92)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE(  92)								min = ::Math_obj::ceil(qx);
            							}
HXDLIN(  92)							int ii_min = min;
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							xIter32 = this1;
            						}
            						else {
HXLINE(  92)							int ii_min = ::Math_obj::floor(qx);
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							xIter32 = this1;
            						}
            					}
HXDLIN(  92)					::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  92)					if ((qy > by1)) {
HXLINE(  92)						if ((qy > cy1)) {
HXLINE(  92)							int min;
HXDLIN(  92)							if ((by1 > cy1)) {
HXLINE(  92)								min = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE(  92)								min = ::Math_obj::floor(by1);
            							}
HXDLIN(  92)							int ii_min = min;
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(qy);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							yIter32 = this1;
            						}
            						else {
HXLINE(  92)							int ii_min = ::Math_obj::floor(by1);
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							yIter32 = this1;
            						}
            					}
            					else {
HXLINE(  92)						if ((by1 > cy1)) {
HXLINE(  92)							int min;
HXDLIN(  92)							if ((qy > cy1)) {
HXLINE(  92)								min = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE(  92)								min = ::Math_obj::ceil(qy);
            							}
HXDLIN(  92)							int ii_min = min;
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							yIter32 = this1;
            						}
            						else {
HXLINE(  92)							int ii_min = ::Math_obj::floor(qy);
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							yIter32 = this1;
            						}
            					}
HXDLIN(  92)					::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  92)					if (hasUndo2) {
HXLINE(  92)						int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  92)						int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  92)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  92)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  92)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  92)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  92)						undoImage2 = this3;
HXDLIN(  92)						{
HXLINE(  92)							int rectLeft = xIter32->start;
HXDLIN(  92)							int rectTop = yIter32->start;
HXDLIN(  92)							int rectRight = xIter32->max;
HXDLIN(  92)							bool forceClear = false;
HXDLIN(  92)							{
HXLINE(  92)								int _g = rectTop;
HXDLIN(  92)								int _g1 = yIter32->max;
HXDLIN(  92)								while((_g < _g1)){
HXLINE(  92)									_g = (_g + 1);
HXDLIN(  92)									int dy = (_g - 1);
HXDLIN(  92)									{
HXLINE(  92)										int _g1 = rectLeft;
HXDLIN(  92)										int _g2 = rectRight;
HXDLIN(  92)										while((_g1 < _g2)){
HXLINE(  92)											_g1 = (_g1 + 1);
HXDLIN(  92)											int dx = (_g1 - 1);
HXDLIN(  92)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)											int index;
HXDLIN(  92)											if (pixelShape->useVirtualPos) {
HXLINE(  92)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  92)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  92)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)											int col;
HXDLIN(  92)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  92)												col = c;
            											}
HXDLIN(  92)											bool _hx_tmp;
HXDLIN(  92)											if (pixelShape->useMask) {
HXLINE(  92)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  92)												_hx_tmp = false;
            											}
HXDLIN(  92)											if (_hx_tmp) {
HXLINE(  92)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  92)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  92)												int index;
HXDLIN(  92)												if (this1->useVirtualPos) {
HXLINE(  92)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  92)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  92)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  92)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  92)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)												int v;
HXDLIN(  92)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  92)													v = c;
            												}
HXDLIN(  92)												int this3 = v;
HXDLIN(  92)												int maskPixel = this3;
HXDLIN(  92)												int this4 = col;
HXDLIN(  92)												int this5 = this4;
HXDLIN(  92)												if ((maskPixel == 0)) {
HXLINE(  92)													int this1 = this5;
HXDLIN(  92)													col = this1;
            												}
            												else {
HXLINE(  92)													Float m0;
HXDLIN(  92)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  92)													if ((this1 == 0)) {
HXLINE(  92)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float m1;
HXDLIN(  92)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  92)													if ((this2 == 0)) {
HXLINE(  92)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float m2;
HXDLIN(  92)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  92)													if ((this3 == 0)) {
HXLINE(  92)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float m3;
HXDLIN(  92)													int this4 = (maskPixel & 255);
HXDLIN(  92)													if ((this4 == 0)) {
HXLINE(  92)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  92)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  92)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  92)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  92)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  92)											if ((col != 0)) {
HXLINE(  92)												int x = (dx - rectLeft);
HXDLIN(  92)												int y = (dy - rectTop);
HXDLIN(  92)												int this1 = col;
HXDLIN(  92)												int c = this1;
HXDLIN(  92)												bool _hx_tmp;
HXDLIN(  92)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  92)													_hx_tmp = undoImage2->transparent;
            												}
            												else {
HXLINE(  92)													_hx_tmp = false;
            												}
HXDLIN(  92)												if (_hx_tmp) {
HXLINE(  92)													int location;
HXDLIN(  92)													if (undoImage2->useVirtualPos) {
HXLINE(  92)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  92)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  92)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  92)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)													int this3 = this2;
HXDLIN(  92)													int this4;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  92)														this4 = this3;
            													}
HXDLIN(  92)													Float a1;
HXDLIN(  92)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  92)													if ((this5 == 0)) {
HXLINE(  92)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float r1;
HXDLIN(  92)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  92)													if ((this6 == 0)) {
HXLINE(  92)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float g1;
HXDLIN(  92)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  92)													if ((this7 == 0)) {
HXLINE(  92)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float b1;
HXDLIN(  92)													int this8 = (this4 & 255);
HXDLIN(  92)													if ((this8 == 0)) {
HXLINE(  92)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float a2;
HXDLIN(  92)													int this9 = ((col >> 24) & 255);
HXDLIN(  92)													if ((this9 == 0)) {
HXLINE(  92)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float r2;
HXDLIN(  92)													int this10 = ((col >> 16) & 255);
HXDLIN(  92)													if ((this10 == 0)) {
HXLINE(  92)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float g2;
HXDLIN(  92)													int this11 = ((col >> 8) & 255);
HXDLIN(  92)													if ((this11 == 0)) {
HXLINE(  92)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float b2;
HXDLIN(  92)													int this12 = (col & 255);
HXDLIN(  92)													if ((this12 == 0)) {
HXLINE(  92)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  92)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  92)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  92)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  92)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  92)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  92)													{
HXLINE(  92)														::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  92)														int value;
HXDLIN(  92)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  92)															value = blended;
            														}
HXDLIN(  92)														bool _hx_tmp;
HXDLIN(  92)														if ((location >= 0)) {
HXLINE(  92)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															_hx_tmp = false;
            														}
HXDLIN(  92)														if (_hx_tmp) {
HXLINE(  92)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  92)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  92)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  92)													int index;
HXDLIN(  92)													if (undoImage2->useVirtualPos) {
HXLINE(  92)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  92)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  92)													int value;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  92)														value = c;
            													}
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((index >= 0)) {
HXLINE(  92)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  92)												if (forceClear) {
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  92)													int x = (dx - rectLeft);
HXDLIN(  92)													int y = (dy - rectTop);
HXDLIN(  92)													int index;
HXDLIN(  92)													if (undoImage2->useVirtualPos) {
HXLINE(  92)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  92)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((index >= 0)) {
HXLINE(  92)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  92)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  92)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  92)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  92)					{
HXLINE(  92)						int _g_min2 = xIter32->start;
HXDLIN(  92)						int _g_max2 = xIter32->max;
HXDLIN(  92)						while((_g_min2 < _g_max2)){
HXLINE(  92)							_g_min2 = (_g_min2 + 1);
HXDLIN(  92)							int px = (_g_min2 - 1);
HXDLIN(  92)							Float pcx = (( (Float)(px) ) - cx1);
HXDLIN(  92)							{
HXLINE(  92)								int _g_min = yIter32->start;
HXDLIN(  92)								int _g_max = yIter32->max;
HXDLIN(  92)								while((_g_min < _g_max)){
HXLINE(  92)									_g_min = (_g_min + 1);
HXDLIN(  92)									int py = (_g_min - 1);
HXDLIN(  92)									Float pcy = (( (Float)(py) ) - cy1);
HXDLIN(  92)									Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  92)									Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  92)									Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  92)									Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  92)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  92)									bool _hx_tmp;
HXDLIN(  92)									bool _hx_tmp1;
HXDLIN(  92)									if ((ratioA >= 0)) {
HXLINE(  92)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  92)										_hx_tmp1 = false;
            									}
HXDLIN(  92)									if (_hx_tmp1) {
HXLINE(  92)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  92)										_hx_tmp = false;
            									}
HXDLIN(  92)									if (_hx_tmp) {
HXLINE(  92)										int i = ::Std_obj::_hx_int((((( (Float)(aA2) ) * ratioA) + (( (Float)(aB2) ) * ratioB)) + (( (Float)(aC2) ) * ratioC)));
HXDLIN(  92)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  92)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  92)										int this1 = i;
HXDLIN(  92)										int a = this1;
HXDLIN(  92)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA2) ) * ratioA) + (( (Float)(rB2) ) * ratioB)) + (( (Float)(rC2) ) * ratioC)));
HXDLIN(  92)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  92)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  92)										int this2 = i1;
HXDLIN(  92)										int r = this2;
HXDLIN(  92)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA2) ) * ratioA) + (( (Float)(gB2) ) * ratioB)) + (( (Float)(gC2) ) * ratioC)));
HXDLIN(  92)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  92)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  92)										int this3 = i2;
HXDLIN(  92)										int g = this3;
HXDLIN(  92)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA2) ) * ratioA) + (( (Float)(bB2) ) * ratioB)) + (( (Float)(bC2) ) * ratioC)));
HXDLIN(  92)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  92)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  92)										int this4 = i3;
HXDLIN(  92)										int b = this4;
HXDLIN(  92)										{
HXLINE(  92)											int location;
HXDLIN(  92)											if (pixelShape->useVirtualPos) {
HXLINE(  92)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  92)												location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            											}
HXDLIN(  92)											bool _hx_tmp;
HXDLIN(  92)											if (pixelShape->transparent) {
HXLINE(  92)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  92)												_hx_tmp = false;
            											}
HXDLIN(  92)											if (_hx_tmp) {
HXLINE(  92)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)												int this3 = this2;
HXDLIN(  92)												int old;
HXDLIN(  92)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  92)													old = this3;
            												}
HXDLIN(  92)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  92)												Float a1;
HXDLIN(  92)												int this4 = ((old >> 24) & 255);
HXDLIN(  92)												if ((this4 == 0)) {
HXLINE(  92)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float r1;
HXDLIN(  92)												int this5 = ((old >> 16) & 255);
HXDLIN(  92)												if ((this5 == 0)) {
HXLINE(  92)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float g1;
HXDLIN(  92)												int this6 = ((old >> 8) & 255);
HXDLIN(  92)												if ((this6 == 0)) {
HXLINE(  92)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float b1;
HXDLIN(  92)												int this7 = (old & 255);
HXDLIN(  92)												if ((this7 == 0)) {
HXLINE(  92)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float a2;
HXDLIN(  92)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  92)												if ((this8 == 0)) {
HXLINE(  92)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float r2;
HXDLIN(  92)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  92)												if ((this9 == 0)) {
HXLINE(  92)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float g2;
HXDLIN(  92)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  92)												if ((this10 == 0)) {
HXLINE(  92)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float b2;
HXDLIN(  92)												int this11 = (rhs & 255);
HXDLIN(  92)												if ((this11 == 0)) {
HXLINE(  92)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  92)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  92)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  92)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  92)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  92)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  92)												{
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  92)													int value;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  92)														value = blended;
            													}
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((location >= 0)) {
HXLINE(  92)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  92)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  92)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  92)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)												int value;
HXDLIN(  92)												if (pixelShape->isLittle) {
HXLINE(  92)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  92)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  92)												bool _hx_tmp;
HXDLIN(  92)												if ((location >= 0)) {
HXLINE(  92)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  92)													_hx_tmp = false;
            												}
HXDLIN(  92)												if (_hx_tmp) {
HXLINE(  92)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  92)					::pixelimage::algo::HitTri hitTriTop;
HXDLIN(  92)					if ((hasHit == false)) {
HXLINE(  92)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx1,by1,cx1,cy1,true);
HXDLIN(  92)						if (hasUndo2) {
HXLINE(  92)							v->undoImage = undoImage2;
HXDLIN(  92)							v->undoX = xIter32->start;
HXDLIN(  92)							v->undoY = yIter32->start;
            						}
HXDLIN(  92)						hitTriTop = v;
            					}
            					else {
HXLINE(  92)						hitTriTop = null();
            					}
HXDLIN(  92)					bool hasUndo3 = false;
HXDLIN(  92)					int aA3 = ((color1 >> 24) & 255);
HXDLIN(  92)					int rA3 = ((color1 >> 16) & 255);
HXDLIN(  92)					int gA3 = ((color1 >> 8) & 255);
HXDLIN(  92)					int bA3 = (color1 & 255);
HXDLIN(  92)					int aB3 = ((half >> 24) & 255);
HXDLIN(  92)					int rB3 = ((half >> 16) & 255);
HXDLIN(  92)					int gB3 = ((half >> 8) & 255);
HXDLIN(  92)					int bB3 = (half & 255);
HXDLIN(  92)					int aC3 = ((color2 >> 24) & 255);
HXDLIN(  92)					int rC3 = ((color2 >> 16) & 255);
HXDLIN(  92)					int gC3 = ((color2 >> 8) & 255);
HXDLIN(  92)					int bC3 = (color2 & 255);
HXDLIN(  92)					Float bcx3 = (ax1 - dx1);
HXDLIN(  92)					Float bcy3 = (ay1 - dy1);
HXDLIN(  92)					Float acx3 = (px - dx1);
HXDLIN(  92)					Float acy3 = (py - dy1);
HXDLIN(  92)					Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  92)					Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  92)					Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  92)					Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  92)					::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  92)					if ((px > ax1)) {
HXLINE(  92)						if ((px > dx1)) {
HXLINE(  92)							int min;
HXDLIN(  92)							if ((ax1 > dx1)) {
HXLINE(  92)								min = ::Math_obj::floor(dx1);
            							}
            							else {
HXLINE(  92)								min = ::Math_obj::floor(ax1);
            							}
HXDLIN(  92)							int ii_min = min;
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(px);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							xIter33 = this1;
            						}
            						else {
HXLINE(  92)							int ii_min = ::Math_obj::floor(ax1);
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(dx1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							xIter33 = this1;
            						}
            					}
            					else {
HXLINE(  92)						if ((ax1 > dx1)) {
HXLINE(  92)							int min;
HXDLIN(  92)							if ((px > dx1)) {
HXLINE(  92)								min = ::Math_obj::floor(dx1);
            							}
            							else {
HXLINE(  92)								min = ::Math_obj::ceil(px);
            							}
HXDLIN(  92)							int ii_min = min;
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(ax1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							xIter33 = this1;
            						}
            						else {
HXLINE(  92)							int ii_min = ::Math_obj::floor(px);
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(dx1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							xIter33 = this1;
            						}
            					}
HXDLIN(  92)					::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  92)					if ((py > ay1)) {
HXLINE(  92)						if ((py > dy1)) {
HXLINE(  92)							int min;
HXDLIN(  92)							if ((ay1 > dy1)) {
HXLINE(  92)								min = ::Math_obj::floor(dy1);
            							}
            							else {
HXLINE(  92)								min = ::Math_obj::floor(ay1);
            							}
HXDLIN(  92)							int ii_min = min;
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(py);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							yIter33 = this1;
            						}
            						else {
HXLINE(  92)							int ii_min = ::Math_obj::floor(ay1);
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(dy1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							yIter33 = this1;
            						}
            					}
            					else {
HXLINE(  92)						if ((ay1 > dy1)) {
HXLINE(  92)							int min;
HXDLIN(  92)							if ((py > dy1)) {
HXLINE(  92)								min = ::Math_obj::floor(dy1);
            							}
            							else {
HXLINE(  92)								min = ::Math_obj::ceil(py);
            							}
HXDLIN(  92)							int ii_min = min;
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(ay1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							yIter33 = this1;
            						}
            						else {
HXLINE(  92)							int ii_min = ::Math_obj::floor(py);
HXDLIN(  92)							int ii_max = ::Math_obj::ceil(dy1);
HXDLIN(  92)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  92)							yIter33 = this1;
            						}
            					}
HXDLIN(  92)					::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  92)					if (hasUndo3) {
HXLINE(  92)						int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  92)						int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  92)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  92)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  92)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  92)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  92)						undoImage3 = this3;
HXDLIN(  92)						{
HXLINE(  92)							int rectLeft = xIter33->start;
HXDLIN(  92)							int rectTop = yIter33->start;
HXDLIN(  92)							int rectRight = xIter33->max;
HXDLIN(  92)							bool forceClear = false;
HXDLIN(  92)							{
HXLINE(  92)								int _g = rectTop;
HXDLIN(  92)								int _g1 = yIter33->max;
HXDLIN(  92)								while((_g < _g1)){
HXLINE(  92)									_g = (_g + 1);
HXDLIN(  92)									int dy = (_g - 1);
HXDLIN(  92)									{
HXLINE(  92)										int _g1 = rectLeft;
HXDLIN(  92)										int _g2 = rectRight;
HXDLIN(  92)										while((_g1 < _g2)){
HXLINE(  92)											_g1 = (_g1 + 1);
HXDLIN(  92)											int dx = (_g1 - 1);
HXDLIN(  92)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)											int index;
HXDLIN(  92)											if (pixelShape->useVirtualPos) {
HXLINE(  92)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  92)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  92)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)											int col;
HXDLIN(  92)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  92)												col = c;
            											}
HXDLIN(  92)											bool _hx_tmp;
HXDLIN(  92)											if (pixelShape->useMask) {
HXLINE(  92)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  92)												_hx_tmp = false;
            											}
HXDLIN(  92)											if (_hx_tmp) {
HXLINE(  92)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  92)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  92)												int index;
HXDLIN(  92)												if (this1->useVirtualPos) {
HXLINE(  92)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  92)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  92)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  92)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  92)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)												int v;
HXDLIN(  92)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  92)													v = c;
            												}
HXDLIN(  92)												int this3 = v;
HXDLIN(  92)												int maskPixel = this3;
HXDLIN(  92)												int this4 = col;
HXDLIN(  92)												int this5 = this4;
HXDLIN(  92)												if ((maskPixel == 0)) {
HXLINE(  92)													int this1 = this5;
HXDLIN(  92)													col = this1;
            												}
            												else {
HXLINE(  92)													Float m0;
HXDLIN(  92)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  92)													if ((this1 == 0)) {
HXLINE(  92)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float m1;
HXDLIN(  92)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  92)													if ((this2 == 0)) {
HXLINE(  92)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float m2;
HXDLIN(  92)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  92)													if ((this3 == 0)) {
HXLINE(  92)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float m3;
HXDLIN(  92)													int this4 = (maskPixel & 255);
HXDLIN(  92)													if ((this4 == 0)) {
HXLINE(  92)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  92)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  92)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  92)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  92)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  92)											if ((col != 0)) {
HXLINE(  92)												int x = (dx - rectLeft);
HXDLIN(  92)												int y = (dy - rectTop);
HXDLIN(  92)												int this1 = col;
HXDLIN(  92)												int c = this1;
HXDLIN(  92)												bool _hx_tmp;
HXDLIN(  92)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  92)													_hx_tmp = undoImage3->transparent;
            												}
            												else {
HXLINE(  92)													_hx_tmp = false;
            												}
HXDLIN(  92)												if (_hx_tmp) {
HXLINE(  92)													int location;
HXDLIN(  92)													if (undoImage3->useVirtualPos) {
HXLINE(  92)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  92)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  92)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  92)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)													int this3 = this2;
HXDLIN(  92)													int this4;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  92)														this4 = this3;
            													}
HXDLIN(  92)													Float a1;
HXDLIN(  92)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  92)													if ((this5 == 0)) {
HXLINE(  92)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float r1;
HXDLIN(  92)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  92)													if ((this6 == 0)) {
HXLINE(  92)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float g1;
HXDLIN(  92)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  92)													if ((this7 == 0)) {
HXLINE(  92)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float b1;
HXDLIN(  92)													int this8 = (this4 & 255);
HXDLIN(  92)													if ((this8 == 0)) {
HXLINE(  92)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float a2;
HXDLIN(  92)													int this9 = ((col >> 24) & 255);
HXDLIN(  92)													if ((this9 == 0)) {
HXLINE(  92)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float r2;
HXDLIN(  92)													int this10 = ((col >> 16) & 255);
HXDLIN(  92)													if ((this10 == 0)) {
HXLINE(  92)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float g2;
HXDLIN(  92)													int this11 = ((col >> 8) & 255);
HXDLIN(  92)													if ((this11 == 0)) {
HXLINE(  92)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float b2;
HXDLIN(  92)													int this12 = (col & 255);
HXDLIN(  92)													if ((this12 == 0)) {
HXLINE(  92)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  92)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  92)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  92)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  92)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  92)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  92)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  92)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  92)													{
HXLINE(  92)														::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  92)														int value;
HXDLIN(  92)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  92)															value = blended;
            														}
HXDLIN(  92)														bool _hx_tmp;
HXDLIN(  92)														if ((location >= 0)) {
HXLINE(  92)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															_hx_tmp = false;
            														}
HXDLIN(  92)														if (_hx_tmp) {
HXLINE(  92)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  92)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  92)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  92)													int index;
HXDLIN(  92)													if (undoImage3->useVirtualPos) {
HXLINE(  92)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  92)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  92)													int value;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  92)														value = c;
            													}
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((index >= 0)) {
HXLINE(  92)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  92)												if (forceClear) {
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  92)													int x = (dx - rectLeft);
HXDLIN(  92)													int y = (dy - rectTop);
HXDLIN(  92)													int index;
HXDLIN(  92)													if (undoImage3->useVirtualPos) {
HXLINE(  92)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  92)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((index >= 0)) {
HXLINE(  92)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  92)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  92)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  92)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  92)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  92)					{
HXLINE(  92)						int _g_min3 = xIter33->start;
HXDLIN(  92)						int _g_max3 = xIter33->max;
HXDLIN(  92)						while((_g_min3 < _g_max3)){
HXLINE(  92)							_g_min3 = (_g_min3 + 1);
HXDLIN(  92)							int px = (_g_min3 - 1);
HXDLIN(  92)							Float pcx = (( (Float)(px) ) - dx1);
HXDLIN(  92)							{
HXLINE(  92)								int _g_min = yIter33->start;
HXDLIN(  92)								int _g_max = yIter33->max;
HXDLIN(  92)								while((_g_min < _g_max)){
HXLINE(  92)									_g_min = (_g_min + 1);
HXDLIN(  92)									int py = (_g_min - 1);
HXDLIN(  92)									Float pcy = (( (Float)(py) ) - dy1);
HXDLIN(  92)									Float dot31 = ((pcx * bcx3) + (pcy * bcy3));
HXDLIN(  92)									Float dot32 = ((pcx * acx3) + (pcy * acy3));
HXDLIN(  92)									Float ratioA = (((dot223 * dot31) - (dot123 * dot32)) * denom13);
HXDLIN(  92)									Float ratioB = (((dot113 * dot32) - (dot123 * dot31)) * denom13);
HXDLIN(  92)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  92)									bool _hx_tmp;
HXDLIN(  92)									bool _hx_tmp1;
HXDLIN(  92)									if ((ratioA >= 0)) {
HXLINE(  92)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  92)										_hx_tmp1 = false;
            									}
HXDLIN(  92)									if (_hx_tmp1) {
HXLINE(  92)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  92)										_hx_tmp = false;
            									}
HXDLIN(  92)									if (_hx_tmp) {
HXLINE(  92)										int i = ::Std_obj::_hx_int((((( (Float)(aA3) ) * ratioA) + (( (Float)(aB3) ) * ratioB)) + (( (Float)(aC3) ) * ratioC)));
HXDLIN(  92)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  92)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  92)										int this1 = i;
HXDLIN(  92)										int a = this1;
HXDLIN(  92)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA3) ) * ratioA) + (( (Float)(rB3) ) * ratioB)) + (( (Float)(rC3) ) * ratioC)));
HXDLIN(  92)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  92)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  92)										int this2 = i1;
HXDLIN(  92)										int r = this2;
HXDLIN(  92)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA3) ) * ratioA) + (( (Float)(gB3) ) * ratioB)) + (( (Float)(gC3) ) * ratioC)));
HXDLIN(  92)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  92)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  92)										int this3 = i2;
HXDLIN(  92)										int g = this3;
HXDLIN(  92)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA3) ) * ratioA) + (( (Float)(bB3) ) * ratioB)) + (( (Float)(bC3) ) * ratioC)));
HXDLIN(  92)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  92)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  92)										int this4 = i3;
HXDLIN(  92)										int b = this4;
HXDLIN(  92)										{
HXLINE(  92)											int location;
HXDLIN(  92)											if (pixelShape->useVirtualPos) {
HXLINE(  92)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  92)												location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            											}
HXDLIN(  92)											bool _hx_tmp;
HXDLIN(  92)											if (pixelShape->transparent) {
HXLINE(  92)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  92)												_hx_tmp = false;
            											}
HXDLIN(  92)											if (_hx_tmp) {
HXLINE(  92)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  92)												int this3 = this2;
HXDLIN(  92)												int old;
HXDLIN(  92)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  92)													old = this3;
            												}
HXDLIN(  92)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  92)												Float a1;
HXDLIN(  92)												int this4 = ((old >> 24) & 255);
HXDLIN(  92)												if ((this4 == 0)) {
HXLINE(  92)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float r1;
HXDLIN(  92)												int this5 = ((old >> 16) & 255);
HXDLIN(  92)												if ((this5 == 0)) {
HXLINE(  92)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float g1;
HXDLIN(  92)												int this6 = ((old >> 8) & 255);
HXDLIN(  92)												if ((this6 == 0)) {
HXLINE(  92)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float b1;
HXDLIN(  92)												int this7 = (old & 255);
HXDLIN(  92)												if ((this7 == 0)) {
HXLINE(  92)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float a2;
HXDLIN(  92)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  92)												if ((this8 == 0)) {
HXLINE(  92)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float r2;
HXDLIN(  92)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  92)												if ((this9 == 0)) {
HXLINE(  92)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float g2;
HXDLIN(  92)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  92)												if ((this10 == 0)) {
HXLINE(  92)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float b2;
HXDLIN(  92)												int this11 = (rhs & 255);
HXDLIN(  92)												if ((this11 == 0)) {
HXLINE(  92)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  92)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  92)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  92)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  92)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  92)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  92)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  92)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  92)												{
HXLINE(  92)													::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  92)													int value;
HXDLIN(  92)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  92)														value = blended;
            													}
HXDLIN(  92)													bool _hx_tmp;
HXDLIN(  92)													if ((location >= 0)) {
HXLINE(  92)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  92)														_hx_tmp = false;
            													}
HXDLIN(  92)													if (_hx_tmp) {
HXLINE(  92)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  92)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  92)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  92)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  92)												int value;
HXDLIN(  92)												if (pixelShape->isLittle) {
HXLINE(  92)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  92)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  92)												bool _hx_tmp;
HXDLIN(  92)												if ((location >= 0)) {
HXLINE(  92)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  92)													_hx_tmp = false;
            												}
HXDLIN(  92)												if (_hx_tmp) {
HXLINE(  92)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  92)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  92)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  92)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  92)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  92)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  92)					::pixelimage::algo::HitTri hitTriBottom;
HXDLIN(  92)					if ((hasHit == false)) {
HXLINE(  92)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,ax1,ay1,dx1,dy1,true);
HXDLIN(  92)						if (hasUndo3) {
HXLINE(  92)							v->undoImage = undoImage3;
HXDLIN(  92)							v->undoX = xIter33->start;
HXDLIN(  92)							v->undoY = yIter33->start;
            						}
HXDLIN(  92)						hitTriBottom = v;
            					}
            					else {
HXLINE(  92)						hitTriBottom = null();
            					}
HXDLIN(  92)					if (hasHit) {
HXLINE(  92)						::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN(  92)						if (::hx::IsNotNull( hitQuad )) {
HXLINE(  92)							hitArr->triArr->push(hitQuad->triABD);
            						}
HXDLIN(  92)						hitArr->triArr->push(hitQuad->triBCD);
            					}
            				}
            			}
            			else {
HXLINE(  94)				Float thick = this->strokeWidth;
HXDLIN(  94)				int color1 = this->strokeTopColor;
HXDLIN(  94)				int color2 = this->strokeBottomColor;
HXDLIN(  94)				bool hasHit = true;
HXDLIN(  94)				{
HXLINE(  94)					Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  94)					Float o = (qy - py);
HXDLIN(  94)					Float a = (qx - px);
HXDLIN(  94)					Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  94)					Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  94)					Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN(  94)					Float sin = ::Math_obj::sin(theta);
HXDLIN(  94)					Float cos = ::Math_obj::cos(theta);
HXDLIN(  94)					Float radius = (thick / ( (Float)(2) ));
HXDLIN(  94)					Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  94)					Float h2 = (h / goldenRatio);
HXDLIN(  94)					Float hSmall = (h - h2);
HXDLIN(  94)					Float px_ = hSmall;
HXDLIN(  94)					Float py_ = ((Float)0.);
HXDLIN(  94)					Float temp = ((Float)0.);
HXLINE( 320)					temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 321)					py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 322)					px_ = temp;
HXLINE(  94)					Float h1 = (h2 - hSmall);
HXDLIN(  94)					Float sin1 = ::Math_obj::sin(theta);
HXDLIN(  94)					Float cos1 = ::Math_obj::cos(theta);
HXDLIN(  94)					Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  94)					Float dx = ((Float)0.1);
HXDLIN(  94)					Float dy = radius1;
HXDLIN(  94)					Float cx = h1;
HXDLIN(  94)					Float cy = radius1;
HXDLIN(  94)					Float bx = h1;
HXDLIN(  94)					Float by = -(radius1);
HXDLIN(  94)					Float ax = ((Float)0.1);
HXDLIN(  94)					Float ay = -(radius1);
HXDLIN(  94)					Float temp1 = ((Float)0.);
HXLINE( 474)					temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE( 475)					ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE( 476)					ax = temp1;
HXLINE( 478)					temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE( 479)					by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE( 480)					bx = temp1;
HXLINE( 482)					temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE( 483)					cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE( 484)					cx = temp1;
HXLINE( 486)					temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE( 487)					dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE( 488)					dx = temp1;
HXLINE(  94)					{
HXLINE(  94)						bool hasUndo = false;
HXDLIN(  94)						int aA = ((color1 >> 24) & 255);
HXDLIN(  94)						int rA = ((color1 >> 16) & 255);
HXDLIN(  94)						int gA = ((color1 >> 8) & 255);
HXDLIN(  94)						int bA = (color1 & 255);
HXDLIN(  94)						int aB = ((color1 >> 24) & 255);
HXDLIN(  94)						int rB = ((color1 >> 16) & 255);
HXDLIN(  94)						int gB = ((color1 >> 8) & 255);
HXDLIN(  94)						int bB = (color1 & 255);
HXDLIN(  94)						int aC = ((color2 >> 24) & 255);
HXDLIN(  94)						int rC = ((color2 >> 16) & 255);
HXDLIN(  94)						int gC = ((color2 >> 8) & 255);
HXDLIN(  94)						int bC = (color2 & 255);
HXDLIN(  94)						Float bcx = (bx - dx);
HXDLIN(  94)						Float bcy = (by - dy);
HXDLIN(  94)						Float acx = (ax - dx);
HXDLIN(  94)						Float acy = (ay - dy);
HXDLIN(  94)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  94)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  94)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  94)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  94)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  94)						if ((ax > bx)) {
HXLINE(  94)							if ((ax > dx)) {
HXLINE(  94)								int min;
HXDLIN(  94)								if ((bx > dx)) {
HXLINE(  94)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  94)									min = ::Math_obj::floor(bx);
            								}
HXDLIN(  94)								int ii_min = min;
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								xIter3 = this1;
            							}
            							else {
HXLINE(  94)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  94)							if ((bx > dx)) {
HXLINE(  94)								int min;
HXDLIN(  94)								if ((ax > dx)) {
HXLINE(  94)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  94)									min = ::Math_obj::ceil(ax);
            								}
HXDLIN(  94)								int ii_min = min;
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								xIter3 = this1;
            							}
            							else {
HXLINE(  94)								int ii_min = ::Math_obj::floor(ax);
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								xIter3 = this1;
            							}
            						}
HXDLIN(  94)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  94)						if ((ay > by)) {
HXLINE(  94)							if ((ay > dy)) {
HXLINE(  94)								int min;
HXDLIN(  94)								if ((by > dy)) {
HXLINE(  94)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  94)									min = ::Math_obj::floor(by);
            								}
HXDLIN(  94)								int ii_min = min;
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								yIter3 = this1;
            							}
            							else {
HXLINE(  94)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  94)							if ((by > dy)) {
HXLINE(  94)								int min;
HXDLIN(  94)								if ((ay > dy)) {
HXLINE(  94)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  94)									min = ::Math_obj::ceil(ay);
            								}
HXDLIN(  94)								int ii_min = min;
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								yIter3 = this1;
            							}
            							else {
HXLINE(  94)								int ii_min = ::Math_obj::floor(ay);
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								yIter3 = this1;
            							}
            						}
HXDLIN(  94)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  94)						if (hasUndo) {
HXLINE(  94)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  94)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  94)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  94)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  94)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  94)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  94)							undoImage = this3;
HXDLIN(  94)							{
HXLINE(  94)								int rectLeft = xIter3->start;
HXDLIN(  94)								int rectTop = yIter3->start;
HXDLIN(  94)								int rectRight = xIter3->max;
HXDLIN(  94)								bool forceClear = false;
HXDLIN(  94)								{
HXLINE(  94)									int _g = rectTop;
HXDLIN(  94)									int _g1 = yIter3->max;
HXDLIN(  94)									while((_g < _g1)){
HXLINE(  94)										_g = (_g + 1);
HXDLIN(  94)										int dy = (_g - 1);
HXDLIN(  94)										{
HXLINE(  94)											int _g1 = rectLeft;
HXDLIN(  94)											int _g2 = rectRight;
HXDLIN(  94)											while((_g1 < _g2)){
HXLINE(  94)												_g1 = (_g1 + 1);
HXDLIN(  94)												int dx = (_g1 - 1);
HXDLIN(  94)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)												int index;
HXDLIN(  94)												if (pixelShape->useVirtualPos) {
HXLINE(  94)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  94)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            												}
HXDLIN(  94)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)												int col;
HXDLIN(  94)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  94)													col = c;
            												}
HXDLIN(  94)												bool _hx_tmp;
HXDLIN(  94)												if (pixelShape->useMask) {
HXLINE(  94)													_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            												}
            												else {
HXLINE(  94)													_hx_tmp = false;
            												}
HXDLIN(  94)												if (_hx_tmp) {
HXLINE(  94)													::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  94)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  94)													int index;
HXDLIN(  94)													if (this1->useVirtualPos) {
HXLINE(  94)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  94)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  94)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  94)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  94)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)													int v;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  94)														v = c;
            													}
HXDLIN(  94)													int this3 = v;
HXDLIN(  94)													int maskPixel = this3;
HXDLIN(  94)													int this4 = col;
HXDLIN(  94)													int this5 = this4;
HXDLIN(  94)													if ((maskPixel == 0)) {
HXLINE(  94)														int this1 = this5;
HXDLIN(  94)														col = this1;
            													}
            													else {
HXLINE(  94)														Float m0;
HXDLIN(  94)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  94)														if ((this1 == 0)) {
HXLINE(  94)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float m1;
HXDLIN(  94)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  94)														if ((this2 == 0)) {
HXLINE(  94)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float m2;
HXDLIN(  94)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  94)														if ((this3 == 0)) {
HXLINE(  94)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float m3;
HXDLIN(  94)														int this4 = (maskPixel & 255);
HXDLIN(  94)														if ((this4 == 0)) {
HXLINE(  94)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  94)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  94)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  94)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  94)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  94)												if ((col != 0)) {
HXLINE(  94)													int x = (dx - rectLeft);
HXDLIN(  94)													int y = (dy - rectTop);
HXDLIN(  94)													int this1 = col;
HXDLIN(  94)													int c = this1;
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  94)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														int location;
HXDLIN(  94)														if (undoImage->useVirtualPos) {
HXLINE(  94)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  94)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  94)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  94)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)														int this3 = this2;
HXDLIN(  94)														int this4;
HXDLIN(  94)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  94)															this4 = this3;
            														}
HXDLIN(  94)														Float a1;
HXDLIN(  94)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  94)														if ((this5 == 0)) {
HXLINE(  94)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float r1;
HXDLIN(  94)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  94)														if ((this6 == 0)) {
HXLINE(  94)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float g1;
HXDLIN(  94)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  94)														if ((this7 == 0)) {
HXLINE(  94)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float b1;
HXDLIN(  94)														int this8 = (this4 & 255);
HXDLIN(  94)														if ((this8 == 0)) {
HXLINE(  94)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float a2;
HXDLIN(  94)														int this9 = ((col >> 24) & 255);
HXDLIN(  94)														if ((this9 == 0)) {
HXLINE(  94)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float r2;
HXDLIN(  94)														int this10 = ((col >> 16) & 255);
HXDLIN(  94)														if ((this10 == 0)) {
HXLINE(  94)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float g2;
HXDLIN(  94)														int this11 = ((col >> 8) & 255);
HXDLIN(  94)														if ((this11 == 0)) {
HXLINE(  94)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float b2;
HXDLIN(  94)														int this12 = (col & 255);
HXDLIN(  94)														if ((this12 == 0)) {
HXLINE(  94)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  94)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  94)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  94)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  94)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  94)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  94)														{
HXLINE(  94)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  94)															int value;
HXDLIN(  94)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  94)																value = blended;
            															}
HXDLIN(  94)															bool _hx_tmp;
HXDLIN(  94)															if ((location >= 0)) {
HXLINE(  94)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  94)																_hx_tmp = false;
            															}
HXDLIN(  94)															if (_hx_tmp) {
HXLINE(  94)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  94)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  94)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  94)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  94)														int index;
HXDLIN(  94)														if (undoImage->useVirtualPos) {
HXLINE(  94)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  94)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  94)														int value;
HXDLIN(  94)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  94)															value = c;
            														}
HXDLIN(  94)														bool _hx_tmp;
HXDLIN(  94)														if ((index >= 0)) {
HXLINE(  94)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  94)															_hx_tmp = false;
            														}
HXDLIN(  94)														if (_hx_tmp) {
HXLINE(  94)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  94)													if (forceClear) {
HXLINE(  94)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  94)														int x = (dx - rectLeft);
HXDLIN(  94)														int y = (dy - rectTop);
HXDLIN(  94)														int index;
HXDLIN(  94)														if (undoImage->useVirtualPos) {
HXLINE(  94)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  94)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  94)														bool _hx_tmp;
HXDLIN(  94)														if ((index >= 0)) {
HXLINE(  94)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  94)															_hx_tmp = false;
            														}
HXDLIN(  94)														if (_hx_tmp) {
HXLINE(  94)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  94)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  94)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  94)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  94)						{
HXLINE(  94)							int _g_min = xIter3->start;
HXDLIN(  94)							int _g_max = xIter3->max;
HXDLIN(  94)							while((_g_min < _g_max)){
HXLINE(  94)								_g_min = (_g_min + 1);
HXDLIN(  94)								int px = (_g_min - 1);
HXDLIN(  94)								Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  94)								{
HXLINE(  94)									int _g_min1 = yIter3->start;
HXDLIN(  94)									int _g_max = yIter3->max;
HXDLIN(  94)									while((_g_min1 < _g_max)){
HXLINE(  94)										_g_min1 = (_g_min1 + 1);
HXDLIN(  94)										int py = (_g_min1 - 1);
HXDLIN(  94)										Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  94)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  94)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  94)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  94)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  94)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  94)										bool _hx_tmp;
HXDLIN(  94)										bool _hx_tmp1;
HXDLIN(  94)										if ((ratioA >= 0)) {
HXLINE(  94)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  94)											_hx_tmp1 = false;
            										}
HXDLIN(  94)										if (_hx_tmp1) {
HXLINE(  94)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  94)											_hx_tmp = false;
            										}
HXDLIN(  94)										if (_hx_tmp) {
HXLINE(  94)											int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  94)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  94)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  94)											int this1 = i;
HXDLIN(  94)											int a = this1;
HXDLIN(  94)											int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  94)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  94)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  94)											int this2 = i1;
HXDLIN(  94)											int r = this2;
HXDLIN(  94)											int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  94)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  94)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  94)											int this3 = i2;
HXDLIN(  94)											int g = this3;
HXDLIN(  94)											int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  94)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  94)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  94)											int this4 = i3;
HXDLIN(  94)											int b = this4;
HXDLIN(  94)											{
HXLINE(  94)												int location;
HXDLIN(  94)												if (pixelShape->useVirtualPos) {
HXLINE(  94)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  94)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            												}
HXDLIN(  94)												bool _hx_tmp;
HXDLIN(  94)												if (pixelShape->transparent) {
HXLINE(  94)													_hx_tmp = (a < 254);
            												}
            												else {
HXLINE(  94)													_hx_tmp = false;
            												}
HXDLIN(  94)												if (_hx_tmp) {
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)													int this3 = this2;
HXDLIN(  94)													int old;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  94)														old = this3;
            													}
HXDLIN(  94)													int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  94)													Float a1;
HXDLIN(  94)													int this4 = ((old >> 24) & 255);
HXDLIN(  94)													if ((this4 == 0)) {
HXLINE(  94)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float r1;
HXDLIN(  94)													int this5 = ((old >> 16) & 255);
HXDLIN(  94)													if ((this5 == 0)) {
HXLINE(  94)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float g1;
HXDLIN(  94)													int this6 = ((old >> 8) & 255);
HXDLIN(  94)													if ((this6 == 0)) {
HXLINE(  94)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float b1;
HXDLIN(  94)													int this7 = (old & 255);
HXDLIN(  94)													if ((this7 == 0)) {
HXLINE(  94)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float a2;
HXDLIN(  94)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  94)													if ((this8 == 0)) {
HXLINE(  94)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float r2;
HXDLIN(  94)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  94)													if ((this9 == 0)) {
HXLINE(  94)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float g2;
HXDLIN(  94)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  94)													if ((this10 == 0)) {
HXLINE(  94)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float b2;
HXDLIN(  94)													int this11 = (rhs & 255);
HXDLIN(  94)													if ((this11 == 0)) {
HXLINE(  94)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  94)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  94)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  94)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  94)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  94)													int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  94)													{
HXLINE(  94)														::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  94)														int value;
HXDLIN(  94)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  94)															value = blended;
            														}
HXDLIN(  94)														bool _hx_tmp;
HXDLIN(  94)														if ((location >= 0)) {
HXLINE(  94)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  94)															_hx_tmp = false;
            														}
HXDLIN(  94)														if (_hx_tmp) {
HXLINE(  94)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  94)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  94)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)													int value;
HXDLIN(  94)													if (pixelShape->isLittle) {
HXLINE(  94)														value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  94)														value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((location >= 0)) {
HXLINE(  94)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  94)					{
HXLINE(  94)						bool hasHit1 = false;
HXDLIN(  94)						bool hasUndo1 = false;
HXDLIN(  94)						int aA1 = ((color2 >> 24) & 255);
HXDLIN(  94)						int rA1 = ((color2 >> 16) & 255);
HXDLIN(  94)						int gA1 = ((color2 >> 8) & 255);
HXDLIN(  94)						int bA1 = (color2 & 255);
HXDLIN(  94)						int aB1 = ((color1 >> 24) & 255);
HXDLIN(  94)						int rB1 = ((color1 >> 16) & 255);
HXDLIN(  94)						int gB1 = ((color1 >> 8) & 255);
HXDLIN(  94)						int bB1 = (color1 & 255);
HXDLIN(  94)						int aC1 = ((color2 >> 24) & 255);
HXDLIN(  94)						int rC1 = ((color2 >> 16) & 255);
HXDLIN(  94)						int gC1 = ((color2 >> 8) & 255);
HXDLIN(  94)						int bC1 = (color2 & 255);
HXDLIN(  94)						Float bcx1 = (cx - dx);
HXDLIN(  94)						Float bcy1 = (cy - dy);
HXDLIN(  94)						Float acx1 = (bx - dx);
HXDLIN(  94)						Float acy1 = (by - dy);
HXDLIN(  94)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  94)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  94)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  94)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  94)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  94)						if ((bx > cx)) {
HXLINE(  94)							if ((bx > dx)) {
HXLINE(  94)								int min;
HXDLIN(  94)								if ((cx > dx)) {
HXLINE(  94)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  94)									min = ::Math_obj::floor(cx);
            								}
HXDLIN(  94)								int ii_min = min;
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								xIter31 = this1;
            							}
            							else {
HXLINE(  94)								int ii_min = ::Math_obj::floor(cx);
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE(  94)							if ((cx > dx)) {
HXLINE(  94)								int min;
HXDLIN(  94)								if ((bx > dx)) {
HXLINE(  94)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  94)									min = ::Math_obj::ceil(bx);
            								}
HXDLIN(  94)								int ii_min = min;
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								xIter31 = this1;
            							}
            							else {
HXLINE(  94)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								xIter31 = this1;
            							}
            						}
HXDLIN(  94)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  94)						if ((by > cy)) {
HXLINE(  94)							if ((by > dy)) {
HXLINE(  94)								int min;
HXDLIN(  94)								if ((cy > dy)) {
HXLINE(  94)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  94)									min = ::Math_obj::floor(cy);
            								}
HXDLIN(  94)								int ii_min = min;
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								yIter31 = this1;
            							}
            							else {
HXLINE(  94)								int ii_min = ::Math_obj::floor(cy);
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE(  94)							if ((cy > dy)) {
HXLINE(  94)								int min;
HXDLIN(  94)								if ((by > dy)) {
HXLINE(  94)									min = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  94)									min = ::Math_obj::ceil(by);
            								}
HXDLIN(  94)								int ii_min = min;
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								yIter31 = this1;
            							}
            							else {
HXLINE(  94)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  94)								int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  94)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)								yIter31 = this1;
            							}
            						}
HXDLIN(  94)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  94)						if (hasUndo1) {
HXLINE(  94)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  94)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  94)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  94)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  94)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  94)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  94)							undoImage1 = this3;
HXDLIN(  94)							{
HXLINE(  94)								int rectLeft = xIter31->start;
HXDLIN(  94)								int rectTop = yIter31->start;
HXDLIN(  94)								int rectRight = xIter31->max;
HXDLIN(  94)								bool forceClear = false;
HXDLIN(  94)								{
HXLINE(  94)									int _g = rectTop;
HXDLIN(  94)									int _g1 = yIter31->max;
HXDLIN(  94)									while((_g < _g1)){
HXLINE(  94)										_g = (_g + 1);
HXDLIN(  94)										int dy = (_g - 1);
HXDLIN(  94)										{
HXLINE(  94)											int _g1 = rectLeft;
HXDLIN(  94)											int _g2 = rectRight;
HXDLIN(  94)											while((_g1 < _g2)){
HXLINE(  94)												_g1 = (_g1 + 1);
HXDLIN(  94)												int dx = (_g1 - 1);
HXDLIN(  94)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)												int index;
HXDLIN(  94)												if (pixelShape->useVirtualPos) {
HXLINE(  94)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  94)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            												}
HXDLIN(  94)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)												int col;
HXDLIN(  94)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  94)													col = c;
            												}
HXDLIN(  94)												bool _hx_tmp;
HXDLIN(  94)												if (pixelShape->useMask) {
HXLINE(  94)													_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            												}
            												else {
HXLINE(  94)													_hx_tmp = false;
            												}
HXDLIN(  94)												if (_hx_tmp) {
HXLINE(  94)													::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  94)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  94)													int index;
HXDLIN(  94)													if (this1->useVirtualPos) {
HXLINE(  94)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  94)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  94)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  94)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  94)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)													int v;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  94)														v = c;
            													}
HXDLIN(  94)													int this3 = v;
HXDLIN(  94)													int maskPixel = this3;
HXDLIN(  94)													int this4 = col;
HXDLIN(  94)													int this5 = this4;
HXDLIN(  94)													if ((maskPixel == 0)) {
HXLINE(  94)														int this1 = this5;
HXDLIN(  94)														col = this1;
            													}
            													else {
HXLINE(  94)														Float m0;
HXDLIN(  94)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  94)														if ((this1 == 0)) {
HXLINE(  94)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float m1;
HXDLIN(  94)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  94)														if ((this2 == 0)) {
HXLINE(  94)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float m2;
HXDLIN(  94)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  94)														if ((this3 == 0)) {
HXLINE(  94)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float m3;
HXDLIN(  94)														int this4 = (maskPixel & 255);
HXDLIN(  94)														if ((this4 == 0)) {
HXLINE(  94)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  94)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  94)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  94)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  94)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  94)												if ((col != 0)) {
HXLINE(  94)													int x = (dx - rectLeft);
HXDLIN(  94)													int y = (dy - rectTop);
HXDLIN(  94)													int this1 = col;
HXDLIN(  94)													int c = this1;
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  94)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														int location;
HXDLIN(  94)														if (undoImage1->useVirtualPos) {
HXLINE(  94)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  94)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  94)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  94)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)														int this3 = this2;
HXDLIN(  94)														int this4;
HXDLIN(  94)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  94)															this4 = this3;
            														}
HXDLIN(  94)														Float a1;
HXDLIN(  94)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  94)														if ((this5 == 0)) {
HXLINE(  94)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float r1;
HXDLIN(  94)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  94)														if ((this6 == 0)) {
HXLINE(  94)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float g1;
HXDLIN(  94)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  94)														if ((this7 == 0)) {
HXLINE(  94)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float b1;
HXDLIN(  94)														int this8 = (this4 & 255);
HXDLIN(  94)														if ((this8 == 0)) {
HXLINE(  94)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float a2;
HXDLIN(  94)														int this9 = ((col >> 24) & 255);
HXDLIN(  94)														if ((this9 == 0)) {
HXLINE(  94)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float r2;
HXDLIN(  94)														int this10 = ((col >> 16) & 255);
HXDLIN(  94)														if ((this10 == 0)) {
HXLINE(  94)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float g2;
HXDLIN(  94)														int this11 = ((col >> 8) & 255);
HXDLIN(  94)														if ((this11 == 0)) {
HXLINE(  94)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float b2;
HXDLIN(  94)														int this12 = (col & 255);
HXDLIN(  94)														if ((this12 == 0)) {
HXLINE(  94)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  94)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  94)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  94)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  94)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  94)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  94)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  94)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  94)														{
HXLINE(  94)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  94)															int value;
HXDLIN(  94)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  94)																value = blended;
            															}
HXDLIN(  94)															bool _hx_tmp;
HXDLIN(  94)															if ((location >= 0)) {
HXLINE(  94)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  94)																_hx_tmp = false;
            															}
HXDLIN(  94)															if (_hx_tmp) {
HXLINE(  94)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  94)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  94)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  94)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  94)														int index;
HXDLIN(  94)														if (undoImage1->useVirtualPos) {
HXLINE(  94)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  94)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  94)														int value;
HXDLIN(  94)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  94)															value = c;
            														}
HXDLIN(  94)														bool _hx_tmp;
HXDLIN(  94)														if ((index >= 0)) {
HXLINE(  94)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  94)															_hx_tmp = false;
            														}
HXDLIN(  94)														if (_hx_tmp) {
HXLINE(  94)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  94)													if (forceClear) {
HXLINE(  94)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  94)														int x = (dx - rectLeft);
HXDLIN(  94)														int y = (dy - rectTop);
HXDLIN(  94)														int index;
HXDLIN(  94)														if (undoImage1->useVirtualPos) {
HXLINE(  94)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE(  94)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN(  94)														bool _hx_tmp;
HXDLIN(  94)														if ((index >= 0)) {
HXLINE(  94)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  94)															_hx_tmp = false;
            														}
HXDLIN(  94)														if (_hx_tmp) {
HXLINE(  94)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  94)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  94)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  94)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  94)						{
HXLINE(  94)							int _g_min1 = xIter31->start;
HXDLIN(  94)							int _g_max1 = xIter31->max;
HXDLIN(  94)							while((_g_min1 < _g_max1)){
HXLINE(  94)								_g_min1 = (_g_min1 + 1);
HXDLIN(  94)								int px = (_g_min1 - 1);
HXDLIN(  94)								Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  94)								{
HXLINE(  94)									int _g_min = yIter31->start;
HXDLIN(  94)									int _g_max = yIter31->max;
HXDLIN(  94)									while((_g_min < _g_max)){
HXLINE(  94)										_g_min = (_g_min + 1);
HXDLIN(  94)										int py = (_g_min - 1);
HXDLIN(  94)										Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  94)										Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  94)										Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  94)										Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  94)										Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  94)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  94)										bool _hx_tmp;
HXDLIN(  94)										bool _hx_tmp1;
HXDLIN(  94)										if ((ratioA >= 0)) {
HXLINE(  94)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  94)											_hx_tmp1 = false;
            										}
HXDLIN(  94)										if (_hx_tmp1) {
HXLINE(  94)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  94)											_hx_tmp = false;
            										}
HXDLIN(  94)										if (_hx_tmp) {
HXLINE(  94)											int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  94)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  94)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  94)											int this1 = i;
HXDLIN(  94)											int a = this1;
HXDLIN(  94)											int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  94)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  94)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  94)											int this2 = i1;
HXDLIN(  94)											int r = this2;
HXDLIN(  94)											int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  94)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  94)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  94)											int this3 = i2;
HXDLIN(  94)											int g = this3;
HXDLIN(  94)											int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  94)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  94)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  94)											int this4 = i3;
HXDLIN(  94)											int b = this4;
HXDLIN(  94)											{
HXLINE(  94)												int location;
HXDLIN(  94)												if (pixelShape->useVirtualPos) {
HXLINE(  94)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  94)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            												}
HXDLIN(  94)												bool _hx_tmp;
HXDLIN(  94)												if (pixelShape->transparent) {
HXLINE(  94)													_hx_tmp = (a < 254);
            												}
            												else {
HXLINE(  94)													_hx_tmp = false;
            												}
HXDLIN(  94)												if (_hx_tmp) {
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)													int this3 = this2;
HXDLIN(  94)													int old;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  94)														old = this3;
            													}
HXDLIN(  94)													int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  94)													Float a1;
HXDLIN(  94)													int this4 = ((old >> 24) & 255);
HXDLIN(  94)													if ((this4 == 0)) {
HXLINE(  94)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float r1;
HXDLIN(  94)													int this5 = ((old >> 16) & 255);
HXDLIN(  94)													if ((this5 == 0)) {
HXLINE(  94)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float g1;
HXDLIN(  94)													int this6 = ((old >> 8) & 255);
HXDLIN(  94)													if ((this6 == 0)) {
HXLINE(  94)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float b1;
HXDLIN(  94)													int this7 = (old & 255);
HXDLIN(  94)													if ((this7 == 0)) {
HXLINE(  94)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float a2;
HXDLIN(  94)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  94)													if ((this8 == 0)) {
HXLINE(  94)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float r2;
HXDLIN(  94)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  94)													if ((this9 == 0)) {
HXLINE(  94)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float g2;
HXDLIN(  94)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  94)													if ((this10 == 0)) {
HXLINE(  94)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float b2;
HXDLIN(  94)													int this11 = (rhs & 255);
HXDLIN(  94)													if ((this11 == 0)) {
HXLINE(  94)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  94)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  94)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  94)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  94)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  94)													int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  94)													{
HXLINE(  94)														::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  94)														int value;
HXDLIN(  94)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  94)															value = blended;
            														}
HXDLIN(  94)														bool _hx_tmp;
HXDLIN(  94)														if ((location >= 0)) {
HXLINE(  94)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  94)															_hx_tmp = false;
            														}
HXDLIN(  94)														if (_hx_tmp) {
HXLINE(  94)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  94)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  94)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)													int value;
HXDLIN(  94)													if (pixelShape->isLittle) {
HXLINE(  94)														value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  94)														value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((location >= 0)) {
HXLINE(  94)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  94)						if ((hasHit1 == false)) {
HXLINE(  94)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  94)							if (hasUndo1) {
HXLINE(  94)								v->undoImage = undoImage1;
HXDLIN(  94)								v->undoX = xIter31->start;
HXDLIN(  94)								v->undoY = yIter31->start;
            							}
            						}
            					}
HXDLIN(  94)					::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  94)					::pixelimage::algo::HitQuad hitQuad = v;
HXDLIN(  94)					Float cx1 = h2;
HXDLIN(  94)					Float cy1 = radius2;
HXDLIN(  94)					Float bx1 = h2;
HXDLIN(  94)					Float by1 = -(radius2);
HXDLIN(  94)					Float dx1 = hSmall;
HXDLIN(  94)					Float dy1 = radius2;
HXDLIN(  94)					Float ax1 = hSmall;
HXDLIN(  94)					Float ay1 = -(radius2);
HXLINE( 335)					temp = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE( 336)					by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE( 337)					bx1 = temp;
HXLINE( 338)					temp = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE( 339)					cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE( 340)					cx1 = temp;
HXLINE( 342)					temp = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE( 343)					ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE( 344)					ax1 = temp;
HXLINE( 346)					temp = (px + ((dx1 * cos) - (dy1 * sin)));
HXLINE( 347)					dy1 = (py + ((dy1 * cos) + (dx1 * sin)));
HXLINE( 348)					dx1 = temp;
HXLINE(  94)					::pixelimage::pixel::_TwoGrad::TwoGrad_ this1 = ::pixelimage::pixel::_TwoGrad::TwoGrad__obj::__alloc( HX_CTX ,color1,color2);
HXDLIN(  94)					::pixelimage::pixel::_TwoGrad::TwoGrad_ twoColors = this1;
HXDLIN(  94)					int a1 = twoColors->colorClock;
HXDLIN(  94)					int b = twoColors->colorAnti;
HXDLIN(  94)					int half = ((((::Math_obj::round(((((( (Float)(((a1 >> 24) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 24) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 24) | (::Math_obj::round(((((( (Float)(((a1 >> 16) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 16) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 16)) | (::Math_obj::round(((((( (Float)(((a1 >> 8) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b >> 8) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 8)) | ::Math_obj::round(((((( (Float)((a1 & 255)) ) / ( (Float)(255) )) + (( (Float)((b & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))));
HXDLIN(  94)					bool hasUndo2 = false;
HXDLIN(  94)					int aA2 = ((color1 >> 24) & 255);
HXDLIN(  94)					int rA2 = ((color1 >> 16) & 255);
HXDLIN(  94)					int gA2 = ((color1 >> 8) & 255);
HXDLIN(  94)					int bA2 = (color1 & 255);
HXDLIN(  94)					int aB2 = ((half >> 24) & 255);
HXDLIN(  94)					int rB2 = ((half >> 16) & 255);
HXDLIN(  94)					int gB2 = ((half >> 8) & 255);
HXDLIN(  94)					int bB2 = (half & 255);
HXDLIN(  94)					int aC2 = ((color2 >> 24) & 255);
HXDLIN(  94)					int rC2 = ((color2 >> 16) & 255);
HXDLIN(  94)					int gC2 = ((color2 >> 8) & 255);
HXDLIN(  94)					int bC2 = (color2 & 255);
HXDLIN(  94)					Float bcx2 = (bx1 - cx1);
HXDLIN(  94)					Float bcy2 = (by1 - cy1);
HXDLIN(  94)					Float acx2 = (qx - cx1);
HXDLIN(  94)					Float acy2 = (qy - cy1);
HXDLIN(  94)					Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  94)					Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  94)					Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  94)					Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  94)					::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  94)					if ((qx > bx1)) {
HXLINE(  94)						if ((qx > cx1)) {
HXLINE(  94)							int min;
HXDLIN(  94)							if ((bx1 > cx1)) {
HXLINE(  94)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE(  94)								min = ::Math_obj::floor(bx1);
            							}
HXDLIN(  94)							int ii_min = min;
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(qx);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							xIter32 = this1;
            						}
            						else {
HXLINE(  94)							int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							xIter32 = this1;
            						}
            					}
            					else {
HXLINE(  94)						if ((bx1 > cx1)) {
HXLINE(  94)							int min;
HXDLIN(  94)							if ((qx > cx1)) {
HXLINE(  94)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE(  94)								min = ::Math_obj::ceil(qx);
            							}
HXDLIN(  94)							int ii_min = min;
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							xIter32 = this1;
            						}
            						else {
HXLINE(  94)							int ii_min = ::Math_obj::floor(qx);
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							xIter32 = this1;
            						}
            					}
HXDLIN(  94)					::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  94)					if ((qy > by1)) {
HXLINE(  94)						if ((qy > cy1)) {
HXLINE(  94)							int min;
HXDLIN(  94)							if ((by1 > cy1)) {
HXLINE(  94)								min = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE(  94)								min = ::Math_obj::floor(by1);
            							}
HXDLIN(  94)							int ii_min = min;
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(qy);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							yIter32 = this1;
            						}
            						else {
HXLINE(  94)							int ii_min = ::Math_obj::floor(by1);
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							yIter32 = this1;
            						}
            					}
            					else {
HXLINE(  94)						if ((by1 > cy1)) {
HXLINE(  94)							int min;
HXDLIN(  94)							if ((qy > cy1)) {
HXLINE(  94)								min = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE(  94)								min = ::Math_obj::ceil(qy);
            							}
HXDLIN(  94)							int ii_min = min;
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							yIter32 = this1;
            						}
            						else {
HXLINE(  94)							int ii_min = ::Math_obj::floor(qy);
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							yIter32 = this1;
            						}
            					}
HXDLIN(  94)					::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  94)					if (hasUndo2) {
HXLINE(  94)						int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  94)						int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  94)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  94)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  94)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  94)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  94)						undoImage2 = this3;
HXDLIN(  94)						{
HXLINE(  94)							int rectLeft = xIter32->start;
HXDLIN(  94)							int rectTop = yIter32->start;
HXDLIN(  94)							int rectRight = xIter32->max;
HXDLIN(  94)							bool forceClear = false;
HXDLIN(  94)							{
HXLINE(  94)								int _g = rectTop;
HXDLIN(  94)								int _g1 = yIter32->max;
HXDLIN(  94)								while((_g < _g1)){
HXLINE(  94)									_g = (_g + 1);
HXDLIN(  94)									int dy = (_g - 1);
HXDLIN(  94)									{
HXLINE(  94)										int _g1 = rectLeft;
HXDLIN(  94)										int _g2 = rectRight;
HXDLIN(  94)										while((_g1 < _g2)){
HXLINE(  94)											_g1 = (_g1 + 1);
HXDLIN(  94)											int dx = (_g1 - 1);
HXDLIN(  94)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)											int index;
HXDLIN(  94)											if (pixelShape->useVirtualPos) {
HXLINE(  94)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  94)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  94)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)											int col;
HXDLIN(  94)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  94)												col = c;
            											}
HXDLIN(  94)											bool _hx_tmp;
HXDLIN(  94)											if (pixelShape->useMask) {
HXLINE(  94)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  94)												_hx_tmp = false;
            											}
HXDLIN(  94)											if (_hx_tmp) {
HXLINE(  94)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  94)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  94)												int index;
HXDLIN(  94)												if (this1->useVirtualPos) {
HXLINE(  94)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  94)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  94)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  94)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  94)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)												int v;
HXDLIN(  94)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  94)													v = c;
            												}
HXDLIN(  94)												int this3 = v;
HXDLIN(  94)												int maskPixel = this3;
HXDLIN(  94)												int this4 = col;
HXDLIN(  94)												int this5 = this4;
HXDLIN(  94)												if ((maskPixel == 0)) {
HXLINE(  94)													int this1 = this5;
HXDLIN(  94)													col = this1;
            												}
            												else {
HXLINE(  94)													Float m0;
HXDLIN(  94)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  94)													if ((this1 == 0)) {
HXLINE(  94)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float m1;
HXDLIN(  94)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  94)													if ((this2 == 0)) {
HXLINE(  94)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float m2;
HXDLIN(  94)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  94)													if ((this3 == 0)) {
HXLINE(  94)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float m3;
HXDLIN(  94)													int this4 = (maskPixel & 255);
HXDLIN(  94)													if ((this4 == 0)) {
HXLINE(  94)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  94)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  94)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  94)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  94)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  94)											if ((col != 0)) {
HXLINE(  94)												int x = (dx - rectLeft);
HXDLIN(  94)												int y = (dy - rectTop);
HXDLIN(  94)												int this1 = col;
HXDLIN(  94)												int c = this1;
HXDLIN(  94)												bool _hx_tmp;
HXDLIN(  94)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  94)													_hx_tmp = undoImage2->transparent;
            												}
            												else {
HXLINE(  94)													_hx_tmp = false;
            												}
HXDLIN(  94)												if (_hx_tmp) {
HXLINE(  94)													int location;
HXDLIN(  94)													if (undoImage2->useVirtualPos) {
HXLINE(  94)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  94)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  94)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  94)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)													int this3 = this2;
HXDLIN(  94)													int this4;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  94)														this4 = this3;
            													}
HXDLIN(  94)													Float a1;
HXDLIN(  94)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  94)													if ((this5 == 0)) {
HXLINE(  94)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float r1;
HXDLIN(  94)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  94)													if ((this6 == 0)) {
HXLINE(  94)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float g1;
HXDLIN(  94)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  94)													if ((this7 == 0)) {
HXLINE(  94)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float b1;
HXDLIN(  94)													int this8 = (this4 & 255);
HXDLIN(  94)													if ((this8 == 0)) {
HXLINE(  94)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float a2;
HXDLIN(  94)													int this9 = ((col >> 24) & 255);
HXDLIN(  94)													if ((this9 == 0)) {
HXLINE(  94)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float r2;
HXDLIN(  94)													int this10 = ((col >> 16) & 255);
HXDLIN(  94)													if ((this10 == 0)) {
HXLINE(  94)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float g2;
HXDLIN(  94)													int this11 = ((col >> 8) & 255);
HXDLIN(  94)													if ((this11 == 0)) {
HXLINE(  94)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float b2;
HXDLIN(  94)													int this12 = (col & 255);
HXDLIN(  94)													if ((this12 == 0)) {
HXLINE(  94)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  94)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  94)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  94)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  94)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  94)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  94)													{
HXLINE(  94)														::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  94)														int value;
HXDLIN(  94)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  94)															value = blended;
            														}
HXDLIN(  94)														bool _hx_tmp;
HXDLIN(  94)														if ((location >= 0)) {
HXLINE(  94)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  94)															_hx_tmp = false;
            														}
HXDLIN(  94)														if (_hx_tmp) {
HXLINE(  94)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  94)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  94)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  94)													int index;
HXDLIN(  94)													if (undoImage2->useVirtualPos) {
HXLINE(  94)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  94)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  94)													int value;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  94)														value = c;
            													}
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((index >= 0)) {
HXLINE(  94)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  94)												if (forceClear) {
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  94)													int x = (dx - rectLeft);
HXDLIN(  94)													int y = (dy - rectTop);
HXDLIN(  94)													int index;
HXDLIN(  94)													if (undoImage2->useVirtualPos) {
HXLINE(  94)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  94)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((index >= 0)) {
HXLINE(  94)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  94)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  94)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  94)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  94)					{
HXLINE(  94)						int _g_min2 = xIter32->start;
HXDLIN(  94)						int _g_max2 = xIter32->max;
HXDLIN(  94)						while((_g_min2 < _g_max2)){
HXLINE(  94)							_g_min2 = (_g_min2 + 1);
HXDLIN(  94)							int px = (_g_min2 - 1);
HXDLIN(  94)							Float pcx = (( (Float)(px) ) - cx1);
HXDLIN(  94)							{
HXLINE(  94)								int _g_min = yIter32->start;
HXDLIN(  94)								int _g_max = yIter32->max;
HXDLIN(  94)								while((_g_min < _g_max)){
HXLINE(  94)									_g_min = (_g_min + 1);
HXDLIN(  94)									int py = (_g_min - 1);
HXDLIN(  94)									Float pcy = (( (Float)(py) ) - cy1);
HXDLIN(  94)									Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  94)									Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  94)									Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  94)									Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  94)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  94)									bool _hx_tmp;
HXDLIN(  94)									bool _hx_tmp1;
HXDLIN(  94)									if ((ratioA >= 0)) {
HXLINE(  94)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  94)										_hx_tmp1 = false;
            									}
HXDLIN(  94)									if (_hx_tmp1) {
HXLINE(  94)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  94)										_hx_tmp = false;
            									}
HXDLIN(  94)									if (_hx_tmp) {
HXLINE(  94)										int i = ::Std_obj::_hx_int((((( (Float)(aA2) ) * ratioA) + (( (Float)(aB2) ) * ratioB)) + (( (Float)(aC2) ) * ratioC)));
HXDLIN(  94)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  94)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  94)										int this1 = i;
HXDLIN(  94)										int a = this1;
HXDLIN(  94)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA2) ) * ratioA) + (( (Float)(rB2) ) * ratioB)) + (( (Float)(rC2) ) * ratioC)));
HXDLIN(  94)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  94)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  94)										int this2 = i1;
HXDLIN(  94)										int r = this2;
HXDLIN(  94)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA2) ) * ratioA) + (( (Float)(gB2) ) * ratioB)) + (( (Float)(gC2) ) * ratioC)));
HXDLIN(  94)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  94)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  94)										int this3 = i2;
HXDLIN(  94)										int g = this3;
HXDLIN(  94)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA2) ) * ratioA) + (( (Float)(bB2) ) * ratioB)) + (( (Float)(bC2) ) * ratioC)));
HXDLIN(  94)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  94)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  94)										int this4 = i3;
HXDLIN(  94)										int b = this4;
HXDLIN(  94)										{
HXLINE(  94)											int location;
HXDLIN(  94)											if (pixelShape->useVirtualPos) {
HXLINE(  94)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  94)												location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            											}
HXDLIN(  94)											bool _hx_tmp;
HXDLIN(  94)											if (pixelShape->transparent) {
HXLINE(  94)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  94)												_hx_tmp = false;
            											}
HXDLIN(  94)											if (_hx_tmp) {
HXLINE(  94)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)												int this3 = this2;
HXDLIN(  94)												int old;
HXDLIN(  94)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  94)													old = this3;
            												}
HXDLIN(  94)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  94)												Float a1;
HXDLIN(  94)												int this4 = ((old >> 24) & 255);
HXDLIN(  94)												if ((this4 == 0)) {
HXLINE(  94)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float r1;
HXDLIN(  94)												int this5 = ((old >> 16) & 255);
HXDLIN(  94)												if ((this5 == 0)) {
HXLINE(  94)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float g1;
HXDLIN(  94)												int this6 = ((old >> 8) & 255);
HXDLIN(  94)												if ((this6 == 0)) {
HXLINE(  94)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float b1;
HXDLIN(  94)												int this7 = (old & 255);
HXDLIN(  94)												if ((this7 == 0)) {
HXLINE(  94)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float a2;
HXDLIN(  94)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  94)												if ((this8 == 0)) {
HXLINE(  94)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float r2;
HXDLIN(  94)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  94)												if ((this9 == 0)) {
HXLINE(  94)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float g2;
HXDLIN(  94)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  94)												if ((this10 == 0)) {
HXLINE(  94)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float b2;
HXDLIN(  94)												int this11 = (rhs & 255);
HXDLIN(  94)												if ((this11 == 0)) {
HXLINE(  94)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  94)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  94)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  94)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  94)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  94)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  94)												{
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  94)													int value;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  94)														value = blended;
            													}
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((location >= 0)) {
HXLINE(  94)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  94)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  94)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  94)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)												int value;
HXDLIN(  94)												if (pixelShape->isLittle) {
HXLINE(  94)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  94)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  94)												bool _hx_tmp;
HXDLIN(  94)												if ((location >= 0)) {
HXLINE(  94)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  94)													_hx_tmp = false;
            												}
HXDLIN(  94)												if (_hx_tmp) {
HXLINE(  94)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  94)					::pixelimage::algo::HitTri hitTriTop;
HXDLIN(  94)					if ((hasHit == false)) {
HXLINE(  94)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx1,by1,cx1,cy1,true);
HXDLIN(  94)						if (hasUndo2) {
HXLINE(  94)							v->undoImage = undoImage2;
HXDLIN(  94)							v->undoX = xIter32->start;
HXDLIN(  94)							v->undoY = yIter32->start;
            						}
HXDLIN(  94)						hitTriTop = v;
            					}
            					else {
HXLINE(  94)						hitTriTop = null();
            					}
HXDLIN(  94)					bool hasUndo3 = false;
HXDLIN(  94)					int aA3 = ((color1 >> 24) & 255);
HXDLIN(  94)					int rA3 = ((color1 >> 16) & 255);
HXDLIN(  94)					int gA3 = ((color1 >> 8) & 255);
HXDLIN(  94)					int bA3 = (color1 & 255);
HXDLIN(  94)					int aB3 = ((half >> 24) & 255);
HXDLIN(  94)					int rB3 = ((half >> 16) & 255);
HXDLIN(  94)					int gB3 = ((half >> 8) & 255);
HXDLIN(  94)					int bB3 = (half & 255);
HXDLIN(  94)					int aC3 = ((color2 >> 24) & 255);
HXDLIN(  94)					int rC3 = ((color2 >> 16) & 255);
HXDLIN(  94)					int gC3 = ((color2 >> 8) & 255);
HXDLIN(  94)					int bC3 = (color2 & 255);
HXDLIN(  94)					Float bcx3 = (ax1 - dx1);
HXDLIN(  94)					Float bcy3 = (ay1 - dy1);
HXDLIN(  94)					Float acx3 = (px - dx1);
HXDLIN(  94)					Float acy3 = (py - dy1);
HXDLIN(  94)					Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  94)					Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  94)					Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  94)					Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  94)					::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  94)					if ((px > ax1)) {
HXLINE(  94)						if ((px > dx1)) {
HXLINE(  94)							int min;
HXDLIN(  94)							if ((ax1 > dx1)) {
HXLINE(  94)								min = ::Math_obj::floor(dx1);
            							}
            							else {
HXLINE(  94)								min = ::Math_obj::floor(ax1);
            							}
HXDLIN(  94)							int ii_min = min;
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(px);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							xIter33 = this1;
            						}
            						else {
HXLINE(  94)							int ii_min = ::Math_obj::floor(ax1);
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(dx1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							xIter33 = this1;
            						}
            					}
            					else {
HXLINE(  94)						if ((ax1 > dx1)) {
HXLINE(  94)							int min;
HXDLIN(  94)							if ((px > dx1)) {
HXLINE(  94)								min = ::Math_obj::floor(dx1);
            							}
            							else {
HXLINE(  94)								min = ::Math_obj::ceil(px);
            							}
HXDLIN(  94)							int ii_min = min;
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(ax1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							xIter33 = this1;
            						}
            						else {
HXLINE(  94)							int ii_min = ::Math_obj::floor(px);
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(dx1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							xIter33 = this1;
            						}
            					}
HXDLIN(  94)					::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  94)					if ((py > ay1)) {
HXLINE(  94)						if ((py > dy1)) {
HXLINE(  94)							int min;
HXDLIN(  94)							if ((ay1 > dy1)) {
HXLINE(  94)								min = ::Math_obj::floor(dy1);
            							}
            							else {
HXLINE(  94)								min = ::Math_obj::floor(ay1);
            							}
HXDLIN(  94)							int ii_min = min;
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(py);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							yIter33 = this1;
            						}
            						else {
HXLINE(  94)							int ii_min = ::Math_obj::floor(ay1);
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(dy1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							yIter33 = this1;
            						}
            					}
            					else {
HXLINE(  94)						if ((ay1 > dy1)) {
HXLINE(  94)							int min;
HXDLIN(  94)							if ((py > dy1)) {
HXLINE(  94)								min = ::Math_obj::floor(dy1);
            							}
            							else {
HXLINE(  94)								min = ::Math_obj::ceil(py);
            							}
HXDLIN(  94)							int ii_min = min;
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(ay1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							yIter33 = this1;
            						}
            						else {
HXLINE(  94)							int ii_min = ::Math_obj::floor(py);
HXDLIN(  94)							int ii_max = ::Math_obj::ceil(dy1);
HXDLIN(  94)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  94)							yIter33 = this1;
            						}
            					}
HXDLIN(  94)					::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  94)					if (hasUndo3) {
HXLINE(  94)						int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  94)						int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  94)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  94)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  94)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  94)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  94)						undoImage3 = this3;
HXDLIN(  94)						{
HXLINE(  94)							int rectLeft = xIter33->start;
HXDLIN(  94)							int rectTop = yIter33->start;
HXDLIN(  94)							int rectRight = xIter33->max;
HXDLIN(  94)							bool forceClear = false;
HXDLIN(  94)							{
HXLINE(  94)								int _g = rectTop;
HXDLIN(  94)								int _g1 = yIter33->max;
HXDLIN(  94)								while((_g < _g1)){
HXLINE(  94)									_g = (_g + 1);
HXDLIN(  94)									int dy = (_g - 1);
HXDLIN(  94)									{
HXLINE(  94)										int _g1 = rectLeft;
HXDLIN(  94)										int _g2 = rectRight;
HXDLIN(  94)										while((_g1 < _g2)){
HXLINE(  94)											_g1 = (_g1 + 1);
HXDLIN(  94)											int dx = (_g1 - 1);
HXDLIN(  94)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)											int index;
HXDLIN(  94)											if (pixelShape->useVirtualPos) {
HXLINE(  94)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  94)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  94)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)											int col;
HXDLIN(  94)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  94)												col = c;
            											}
HXDLIN(  94)											bool _hx_tmp;
HXDLIN(  94)											if (pixelShape->useMask) {
HXLINE(  94)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  94)												_hx_tmp = false;
            											}
HXDLIN(  94)											if (_hx_tmp) {
HXLINE(  94)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  94)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  94)												int index;
HXDLIN(  94)												if (this1->useVirtualPos) {
HXLINE(  94)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  94)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  94)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  94)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  94)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)												int v;
HXDLIN(  94)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  94)													v = c;
            												}
HXDLIN(  94)												int this3 = v;
HXDLIN(  94)												int maskPixel = this3;
HXDLIN(  94)												int this4 = col;
HXDLIN(  94)												int this5 = this4;
HXDLIN(  94)												if ((maskPixel == 0)) {
HXLINE(  94)													int this1 = this5;
HXDLIN(  94)													col = this1;
            												}
            												else {
HXLINE(  94)													Float m0;
HXDLIN(  94)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  94)													if ((this1 == 0)) {
HXLINE(  94)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float m1;
HXDLIN(  94)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  94)													if ((this2 == 0)) {
HXLINE(  94)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float m2;
HXDLIN(  94)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  94)													if ((this3 == 0)) {
HXLINE(  94)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float m3;
HXDLIN(  94)													int this4 = (maskPixel & 255);
HXDLIN(  94)													if ((this4 == 0)) {
HXLINE(  94)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  94)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  94)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  94)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  94)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  94)											if ((col != 0)) {
HXLINE(  94)												int x = (dx - rectLeft);
HXDLIN(  94)												int y = (dy - rectTop);
HXDLIN(  94)												int this1 = col;
HXDLIN(  94)												int c = this1;
HXDLIN(  94)												bool _hx_tmp;
HXDLIN(  94)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  94)													_hx_tmp = undoImage3->transparent;
            												}
            												else {
HXLINE(  94)													_hx_tmp = false;
            												}
HXDLIN(  94)												if (_hx_tmp) {
HXLINE(  94)													int location;
HXDLIN(  94)													if (undoImage3->useVirtualPos) {
HXLINE(  94)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  94)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  94)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  94)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)													int this3 = this2;
HXDLIN(  94)													int this4;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  94)														this4 = this3;
            													}
HXDLIN(  94)													Float a1;
HXDLIN(  94)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  94)													if ((this5 == 0)) {
HXLINE(  94)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float r1;
HXDLIN(  94)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  94)													if ((this6 == 0)) {
HXLINE(  94)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float g1;
HXDLIN(  94)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  94)													if ((this7 == 0)) {
HXLINE(  94)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float b1;
HXDLIN(  94)													int this8 = (this4 & 255);
HXDLIN(  94)													if ((this8 == 0)) {
HXLINE(  94)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float a2;
HXDLIN(  94)													int this9 = ((col >> 24) & 255);
HXDLIN(  94)													if ((this9 == 0)) {
HXLINE(  94)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float r2;
HXDLIN(  94)													int this10 = ((col >> 16) & 255);
HXDLIN(  94)													if ((this10 == 0)) {
HXLINE(  94)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float g2;
HXDLIN(  94)													int this11 = ((col >> 8) & 255);
HXDLIN(  94)													if ((this11 == 0)) {
HXLINE(  94)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float b2;
HXDLIN(  94)													int this12 = (col & 255);
HXDLIN(  94)													if ((this12 == 0)) {
HXLINE(  94)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  94)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  94)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  94)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  94)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  94)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  94)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  94)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  94)													{
HXLINE(  94)														::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  94)														int value;
HXDLIN(  94)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  94)															value = blended;
            														}
HXDLIN(  94)														bool _hx_tmp;
HXDLIN(  94)														if ((location >= 0)) {
HXLINE(  94)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  94)															_hx_tmp = false;
            														}
HXDLIN(  94)														if (_hx_tmp) {
HXLINE(  94)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  94)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  94)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  94)													int index;
HXDLIN(  94)													if (undoImage3->useVirtualPos) {
HXLINE(  94)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  94)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  94)													int value;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  94)														value = c;
            													}
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((index >= 0)) {
HXLINE(  94)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  94)												if (forceClear) {
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  94)													int x = (dx - rectLeft);
HXDLIN(  94)													int y = (dy - rectTop);
HXDLIN(  94)													int index;
HXDLIN(  94)													if (undoImage3->useVirtualPos) {
HXLINE(  94)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  94)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((index >= 0)) {
HXLINE(  94)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  94)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  94)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  94)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  94)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  94)					{
HXLINE(  94)						int _g_min3 = xIter33->start;
HXDLIN(  94)						int _g_max3 = xIter33->max;
HXDLIN(  94)						while((_g_min3 < _g_max3)){
HXLINE(  94)							_g_min3 = (_g_min3 + 1);
HXDLIN(  94)							int px = (_g_min3 - 1);
HXDLIN(  94)							Float pcx = (( (Float)(px) ) - dx1);
HXDLIN(  94)							{
HXLINE(  94)								int _g_min = yIter33->start;
HXDLIN(  94)								int _g_max = yIter33->max;
HXDLIN(  94)								while((_g_min < _g_max)){
HXLINE(  94)									_g_min = (_g_min + 1);
HXDLIN(  94)									int py = (_g_min - 1);
HXDLIN(  94)									Float pcy = (( (Float)(py) ) - dy1);
HXDLIN(  94)									Float dot31 = ((pcx * bcx3) + (pcy * bcy3));
HXDLIN(  94)									Float dot32 = ((pcx * acx3) + (pcy * acy3));
HXDLIN(  94)									Float ratioA = (((dot223 * dot31) - (dot123 * dot32)) * denom13);
HXDLIN(  94)									Float ratioB = (((dot113 * dot32) - (dot123 * dot31)) * denom13);
HXDLIN(  94)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  94)									bool _hx_tmp;
HXDLIN(  94)									bool _hx_tmp1;
HXDLIN(  94)									if ((ratioA >= 0)) {
HXLINE(  94)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  94)										_hx_tmp1 = false;
            									}
HXDLIN(  94)									if (_hx_tmp1) {
HXLINE(  94)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  94)										_hx_tmp = false;
            									}
HXDLIN(  94)									if (_hx_tmp) {
HXLINE(  94)										int i = ::Std_obj::_hx_int((((( (Float)(aA3) ) * ratioA) + (( (Float)(aB3) ) * ratioB)) + (( (Float)(aC3) ) * ratioC)));
HXDLIN(  94)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  94)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  94)										int this1 = i;
HXDLIN(  94)										int a = this1;
HXDLIN(  94)										int i1 = ::Std_obj::_hx_int((((( (Float)(rA3) ) * ratioA) + (( (Float)(rB3) ) * ratioB)) + (( (Float)(rC3) ) * ratioC)));
HXDLIN(  94)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  94)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  94)										int this2 = i1;
HXDLIN(  94)										int r = this2;
HXDLIN(  94)										int i2 = ::Std_obj::_hx_int((((( (Float)(gA3) ) * ratioA) + (( (Float)(gB3) ) * ratioB)) + (( (Float)(gC3) ) * ratioC)));
HXDLIN(  94)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  94)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  94)										int this3 = i2;
HXDLIN(  94)										int g = this3;
HXDLIN(  94)										int i3 = ::Std_obj::_hx_int((((( (Float)(bA3) ) * ratioA) + (( (Float)(bB3) ) * ratioB)) + (( (Float)(bC3) ) * ratioC)));
HXDLIN(  94)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  94)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  94)										int this4 = i3;
HXDLIN(  94)										int b = this4;
HXDLIN(  94)										{
HXLINE(  94)											int location;
HXDLIN(  94)											if (pixelShape->useVirtualPos) {
HXLINE(  94)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  94)												location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            											}
HXDLIN(  94)											bool _hx_tmp;
HXDLIN(  94)											if (pixelShape->transparent) {
HXLINE(  94)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  94)												_hx_tmp = false;
            											}
HXDLIN(  94)											if (_hx_tmp) {
HXLINE(  94)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  94)												int this3 = this2;
HXDLIN(  94)												int old;
HXDLIN(  94)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  94)													old = this3;
            												}
HXDLIN(  94)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  94)												Float a1;
HXDLIN(  94)												int this4 = ((old >> 24) & 255);
HXDLIN(  94)												if ((this4 == 0)) {
HXLINE(  94)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float r1;
HXDLIN(  94)												int this5 = ((old >> 16) & 255);
HXDLIN(  94)												if ((this5 == 0)) {
HXLINE(  94)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float g1;
HXDLIN(  94)												int this6 = ((old >> 8) & 255);
HXDLIN(  94)												if ((this6 == 0)) {
HXLINE(  94)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float b1;
HXDLIN(  94)												int this7 = (old & 255);
HXDLIN(  94)												if ((this7 == 0)) {
HXLINE(  94)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float a2;
HXDLIN(  94)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  94)												if ((this8 == 0)) {
HXLINE(  94)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float r2;
HXDLIN(  94)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  94)												if ((this9 == 0)) {
HXLINE(  94)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float g2;
HXDLIN(  94)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  94)												if ((this10 == 0)) {
HXLINE(  94)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float b2;
HXDLIN(  94)												int this11 = (rhs & 255);
HXDLIN(  94)												if ((this11 == 0)) {
HXLINE(  94)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  94)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  94)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  94)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  94)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  94)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  94)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  94)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  94)												{
HXLINE(  94)													::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  94)													int value;
HXDLIN(  94)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  94)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  94)														value = blended;
            													}
HXDLIN(  94)													bool _hx_tmp;
HXDLIN(  94)													if ((location >= 0)) {
HXLINE(  94)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  94)														_hx_tmp = false;
            													}
HXDLIN(  94)													if (_hx_tmp) {
HXLINE(  94)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  94)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  94)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  94)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  94)												int value;
HXDLIN(  94)												if (pixelShape->isLittle) {
HXLINE(  94)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  94)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  94)												bool _hx_tmp;
HXDLIN(  94)												if ((location >= 0)) {
HXLINE(  94)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  94)													_hx_tmp = false;
            												}
HXDLIN(  94)												if (_hx_tmp) {
HXLINE(  94)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  94)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  94)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  94)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  94)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  94)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  94)					::pixelimage::algo::HitTri hitTriBottom;
HXDLIN(  94)					if ((hasHit == false)) {
HXLINE(  94)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,ax1,ay1,dx1,dy1,true);
HXDLIN(  94)						if (hasUndo3) {
HXLINE(  94)							v->undoImage = undoImage3;
HXDLIN(  94)							v->undoX = xIter33->start;
HXDLIN(  94)							v->undoY = yIter33->start;
            						}
HXDLIN(  94)						hitTriBottom = v;
            					}
            					else {
HXLINE(  94)						hitTriBottom = null();
            					}
HXDLIN(  94)					if (hasHit) {
HXLINE(  94)						::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN(  94)						if (::hx::IsNotNull( hitQuad )) {
HXLINE(  94)							hitArr->triArr->push(hitQuad->triABD);
            						}
HXDLIN(  94)						hitArr->triArr->push(hitQuad->triBCD);
            					}
            				}
            			}
            		}
HXLINE(  97)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< ArrowThickGradient_obj > ArrowThickGradient_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeTopColor,::hx::Null< int >  __o_strokeBottomColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< bool >  __o_both,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_arrowWidth,::hx::Null< Float >  __o_arrowHeight) {
	::hx::ObjectPtr< ArrowThickGradient_obj > __this = new ArrowThickGradient_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeTopColor,__o_strokeBottomColor,__o_strokeWidth,strokeDashGapArray,__o_both,__o_flare,__o_reverseFlare,__o_x1,__o_y1,__o_x2,__o_y2,__o_arrowWidth,__o_arrowHeight);
	return __this;
}

::hx::ObjectPtr< ArrowThickGradient_obj > ArrowThickGradient_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeTopColor,::hx::Null< int >  __o_strokeBottomColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< bool >  __o_both,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_arrowWidth,::hx::Null< Float >  __o_arrowHeight) {
	ArrowThickGradient_obj *__this = (ArrowThickGradient_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ArrowThickGradient_obj), true, "pixelimage.triangleGML.gradient.ArrowThickGradient"));
	*(void **)__this = ArrowThickGradient_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeTopColor,__o_strokeBottomColor,__o_strokeWidth,strokeDashGapArray,__o_both,__o_flare,__o_reverseFlare,__o_x1,__o_y1,__o_x2,__o_y2,__o_arrowWidth,__o_arrowHeight);
	return __this;
}

ArrowThickGradient_obj::ArrowThickGradient_obj()
{
}

::hx::Val ArrowThickGradient_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { return ::hx::Val( x1 ); }
		if (HX_FIELD_EQ(inName,"y1") ) { return ::hx::Val( y1 ); }
		if (HX_FIELD_EQ(inName,"x2") ) { return ::hx::Val( x2 ); }
		if (HX_FIELD_EQ(inName,"y2") ) { return ::hx::Val( y2 ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"both") ) { return ::hx::Val( both ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"flare") ) { return ::hx::Val( flare ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"arrowWidth") ) { return ::hx::Val( arrowWidth ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"arrowHeight") ) { return ::hx::Val( arrowHeight ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"reverseFlare") ) { return ::hx::Val( reverseFlare ); }
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"strokeTopColor") ) { return ::hx::Val( strokeTopColor ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"strokeBottomColor") ) { return ::hx::Val( strokeBottomColor ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ArrowThickGradient_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { x1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y1") ) { y1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x2") ) { x2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y2") ) { y2=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"both") ) { both=inValue.Cast< bool >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"flare") ) { flare=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"arrowWidth") ) { arrowWidth=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"arrowHeight") ) { arrowHeight=inValue.Cast< Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"reverseFlare") ) { reverseFlare=inValue.Cast< bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"strokeTopColor") ) { strokeTopColor=inValue.Cast< int >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"strokeBottomColor") ) { strokeBottomColor=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ArrowThickGradient_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x1",b9,68,00,00));
	outFields->push(HX_("y1",98,69,00,00));
	outFields->push(HX_("x2",ba,68,00,00));
	outFields->push(HX_("y2",99,69,00,00));
	outFields->push(HX_("both",81,88,1b,41));
	outFields->push(HX_("flare",ce,34,8c,02));
	outFields->push(HX_("reverseFlare",4c,10,f1,18));
	outFields->push(HX_("arrowWidth",7d,93,05,3e));
	outFields->push(HX_("arrowHeight",90,f2,2a,bd));
	outFields->push(HX_("strokeTopColor",66,66,01,41));
	outFields->push(HX_("strokeBottomColor",a0,95,a8,82));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ArrowThickGradient_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(ArrowThickGradient_obj,x1),HX_("x1",b9,68,00,00)},
	{::hx::fsFloat,(int)offsetof(ArrowThickGradient_obj,y1),HX_("y1",98,69,00,00)},
	{::hx::fsFloat,(int)offsetof(ArrowThickGradient_obj,x2),HX_("x2",ba,68,00,00)},
	{::hx::fsFloat,(int)offsetof(ArrowThickGradient_obj,y2),HX_("y2",99,69,00,00)},
	{::hx::fsBool,(int)offsetof(ArrowThickGradient_obj,both),HX_("both",81,88,1b,41)},
	{::hx::fsBool,(int)offsetof(ArrowThickGradient_obj,flare),HX_("flare",ce,34,8c,02)},
	{::hx::fsBool,(int)offsetof(ArrowThickGradient_obj,reverseFlare),HX_("reverseFlare",4c,10,f1,18)},
	{::hx::fsFloat,(int)offsetof(ArrowThickGradient_obj,arrowWidth),HX_("arrowWidth",7d,93,05,3e)},
	{::hx::fsFloat,(int)offsetof(ArrowThickGradient_obj,arrowHeight),HX_("arrowHeight",90,f2,2a,bd)},
	{::hx::fsInt,(int)offsetof(ArrowThickGradient_obj,strokeTopColor),HX_("strokeTopColor",66,66,01,41)},
	{::hx::fsInt,(int)offsetof(ArrowThickGradient_obj,strokeBottomColor),HX_("strokeBottomColor",a0,95,a8,82)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ArrowThickGradient_obj_sStaticStorageInfo = 0;
#endif

static ::String ArrowThickGradient_obj_sMemberFields[] = {
	HX_("x1",b9,68,00,00),
	HX_("y1",98,69,00,00),
	HX_("x2",ba,68,00,00),
	HX_("y2",99,69,00,00),
	HX_("both",81,88,1b,41),
	HX_("flare",ce,34,8c,02),
	HX_("reverseFlare",4c,10,f1,18),
	HX_("arrowWidth",7d,93,05,3e),
	HX_("arrowHeight",90,f2,2a,bd),
	HX_("strokeTopColor",66,66,01,41),
	HX_("strokeBottomColor",a0,95,a8,82),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class ArrowThickGradient_obj::__mClass;

void ArrowThickGradient_obj::__register()
{
	ArrowThickGradient_obj _hx_dummy;
	ArrowThickGradient_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.gradient.ArrowThickGradient",99,b0,d8,16);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ArrowThickGradient_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ArrowThickGradient_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ArrowThickGradient_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ArrowThickGradient_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace gradient
