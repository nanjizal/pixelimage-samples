// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_PatternShape
#include <pixelimage/triangleGML/coreShape/PatternShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_patternShape_RectanglePattern
#include <pixelimage/triangleGML/patternShape/RectanglePattern.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ab82dc3afbc001a4_42_new,"pixelimage.triangleGML.patternShape.RectanglePattern","new",0xc5502e67,"pixelimage.triangleGML.patternShape.RectanglePattern.new","pixelimage/triangleGML/patternShape/RectanglePattern.hx",42,0x9976450a)
HX_LOCAL_STACK_FRAME(_hx_pos_ab82dc3afbc001a4_54_setParameter,"pixelimage.triangleGML.patternShape.RectanglePattern","setParameter",0xc2911ec0,"pixelimage.triangleGML.patternShape.RectanglePattern.setParameter","pixelimage/triangleGML/patternShape/RectanglePattern.hx",54,0x9976450a)
HX_LOCAL_STACK_FRAME(_hx_pos_ab82dc3afbc001a4_69_render,"pixelimage.triangleGML.patternShape.RectanglePattern","render",0xac5c4baf,"pixelimage.triangleGML.patternShape.RectanglePattern.render","pixelimage/triangleGML/patternShape/RectanglePattern.hx",69,0x9976450a)
HX_LOCAL_STACK_FRAME(_hx_pos_ab82dc3afbc001a4_82_buildRectangles,"pixelimage.triangleGML.patternShape.RectanglePattern","buildRectangles",0xc0e486b9,"pixelimage.triangleGML.patternShape.RectanglePattern.buildRectangles","pixelimage/triangleGML/patternShape/RectanglePattern.hx",82,0x9976450a)
namespace pixelimage{
namespace triangleGML{
namespace patternShape{

void RectanglePattern_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< bool >  __o_rounded){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int strokeColor0 = __o_strokeColor0.Default(0);
            		int strokeColor1 = __o_strokeColor1.Default(0);
            		int fillColor0 = __o_fillColor0.Default(0);
            		int fillColor1 = __o_fillColor1.Default(0);
            		bool strokePatternAcross = __o_strokePatternAcross.Default(true);
            		int strokePatternScale = __o_strokePatternScale.Default(1);
            		int fillPatternWidth = __o_fillPatternWidth.Default(16);
            		int fillPatternHeight = __o_fillPatternHeight.Default(16);
            		bool fillPatternAcross = __o_fillPatternAcross.Default(true);
            		int fillPatternScale = __o_fillPatternScale.Default(1);
            		Float left = __o_left.Default(((Float)0.));
            		Float top = __o_top.Default(((Float)0.));
            		Float width = __o_width.Default(((Float)1.));
            		Float height = __o_height.Default(((Float)1.));
            		bool rounded = __o_rounded.Default(false);
            	HX_STACKFRAME(&_hx_pos_ab82dc3afbc001a4_42_new)
HXLINE(  43)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,strokeColor0,strokeColor1,fillColor0,fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,strokePatternAcross,strokePatternScale,fillPatternFill,fillPatternWidth,fillPatternHeight,fillPatternAcross,fillPatternScale);
HXLINE(  47)		this->left = left;
HXLINE(  48)		this->top = top;
HXLINE(  49)		this->width = width;
HXLINE(  50)		this->height = height;
HXLINE(  51)		this->rounded = rounded;
            	}

Dynamic RectanglePattern_obj::__CreateEmpty() { return new RectanglePattern_obj; }

void *RectanglePattern_obj::_hx_vtable = 0;

Dynamic RectanglePattern_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< RectanglePattern_obj > _hx_result = new RectanglePattern_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14],inArgs[15],inArgs[16],inArgs[17],inArgs[18],inArgs[19],inArgs[20],inArgs[21],inArgs[22],inArgs[23]);
	return _hx_result;
}

bool RectanglePattern_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2091632c) {
		if (inClassId<=(int)0x0aa075e7) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0aa075e7;
		} else {
			return inClassId==(int)0x2091632c;
		}
	} else {
		return inClassId==(int)0x24e92cfb || inClassId==(int)0x6e596dee;
	}
}

void RectanglePattern_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_ab82dc3afbc001a4_54_setParameter)
HXDLIN(  54)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("height",e7,07,4c,02)) ){
HXLINE(  62)			this->height = ::Std_obj::parseFloat(value);
HXDLIN(  62)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("left",07,08,b0,47)) ){
HXLINE(  56)			this->left = ::Std_obj::parseFloat(value);
HXDLIN(  56)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("rounded",2d,80,0f,8d)) ){
HXLINE(  64)			bool _hx_tmp;
HXDLIN(  64)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  64)				_hx_tmp = true;
            			}
            			else {
HXLINE(  64)				_hx_tmp = false;
            			}
HXDLIN(  64)			this->rounded = _hx_tmp;
HXDLIN(  64)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("top",95,66,58,00)) ){
HXLINE(  58)			this->top = ::Std_obj::parseFloat(value);
HXDLIN(  58)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("width",06,b6,62,ca)) ){
HXLINE(  60)			this->width = ::Std_obj::parseFloat(value);
HXDLIN(  60)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  66)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct RectanglePattern_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_ab82dc3afbc001a4_69_render)
HXLINE(  70)		int w = ::Math_obj::ceil(this->width);
HXDLIN(  70)		int h = ::Math_obj::ceil(this->height);
HXDLIN(  70)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  70)		::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  70)		::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  70)		::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  70)		::pixelimage::ImageStruct this4 = this3;
HXDLIN(  70)		::pixelimage::ImageStruct temp = this4;
HXLINE(  71)		temp->transparent = false;
HXLINE(  73)		this->buildPatternTemplates();
HXLINE(  74)		this->buildRectangles(temp);
HXLINE(  76)		{
HXLINE(  76)			int x = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  76)			int y = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  76)			bool forceClear = false;
HXDLIN(  76)			{
HXLINE(  76)				int _g = 0;
HXDLIN(  76)				int _g1 = temp->height;
HXDLIN(  76)				while((_g < _g1)){
HXLINE(  76)					_g = (_g + 1);
HXDLIN(  76)					int dy = (_g - 1);
HXDLIN(  76)					{
HXLINE(  76)						int _g1 = 0;
HXDLIN(  76)						int _g2 = temp->width;
HXDLIN(  76)						while((_g1 < _g2)){
HXLINE(  76)							_g1 = (_g1 + 1);
HXDLIN(  76)							int dx = (_g1 - 1);
HXDLIN(  76)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  76)							int index;
HXDLIN(  76)							if (temp->useVirtualPos) {
HXLINE(  76)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  76)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  76)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  76)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  76)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  76)							int col;
HXDLIN(  76)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  76)								col = c;
            							}
HXDLIN(  76)							bool _hx_tmp;
HXDLIN(  76)							if (temp->useMask) {
HXLINE(  76)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  76)								_hx_tmp = false;
            							}
HXDLIN(  76)							if (_hx_tmp) {
HXLINE(  76)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  76)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  76)								int index;
HXDLIN(  76)								if (this1->useVirtualPos) {
HXLINE(  76)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  76)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  76)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  76)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  76)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  76)								int v;
HXDLIN(  76)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  76)									v = c;
            								}
HXDLIN(  76)								int this3 = v;
HXDLIN(  76)								int maskPixel = this3;
HXDLIN(  76)								int this4 = col;
HXDLIN(  76)								int this5 = this4;
HXDLIN(  76)								if ((maskPixel == 0)) {
HXLINE(  76)									int this1 = this5;
HXDLIN(  76)									col = this1;
            								}
            								else {
HXLINE(  76)									Float m0;
HXDLIN(  76)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  76)									if ((this1 == 0)) {
HXLINE(  76)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float m1;
HXDLIN(  76)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  76)									if ((this2 == 0)) {
HXLINE(  76)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float m2;
HXDLIN(  76)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  76)									if ((this3 == 0)) {
HXLINE(  76)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float m3;
HXDLIN(  76)									int this4 = (maskPixel & 255);
HXDLIN(  76)									if ((this4 == 0)) {
HXLINE(  76)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  76)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  76)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  76)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  76)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  76)							if ((col != 0)) {
HXLINE(  76)								int x1 = (x + dx);
HXDLIN(  76)								int y1 = (y + dy);
HXDLIN(  76)								int this1 = col;
HXDLIN(  76)								int c = this1;
HXDLIN(  76)								bool _hx_tmp;
HXDLIN(  76)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  76)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  76)									_hx_tmp = false;
            								}
HXDLIN(  76)								if (_hx_tmp) {
HXLINE(  76)									int location;
HXDLIN(  76)									if (pixelShape->useVirtualPos) {
HXLINE(  76)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  76)										location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  76)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  76)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  76)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  76)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  76)									int this3 = this2;
HXDLIN(  76)									int this4;
HXDLIN(  76)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  76)										this4 = this3;
            									}
HXDLIN(  76)									Float a1;
HXDLIN(  76)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  76)									if ((this5 == 0)) {
HXLINE(  76)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float r1;
HXDLIN(  76)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  76)									if ((this6 == 0)) {
HXLINE(  76)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float g1;
HXDLIN(  76)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  76)									if ((this7 == 0)) {
HXLINE(  76)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float b1;
HXDLIN(  76)									int this8 = (this4 & 255);
HXDLIN(  76)									if ((this8 == 0)) {
HXLINE(  76)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float a2;
HXDLIN(  76)									int this9 = ((col >> 24) & 255);
HXDLIN(  76)									if ((this9 == 0)) {
HXLINE(  76)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float r2;
HXDLIN(  76)									int this10 = ((col >> 16) & 255);
HXDLIN(  76)									if ((this10 == 0)) {
HXLINE(  76)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float g2;
HXDLIN(  76)									int this11 = ((col >> 8) & 255);
HXDLIN(  76)									if ((this11 == 0)) {
HXLINE(  76)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float b2;
HXDLIN(  76)									int this12 = (col & 255);
HXDLIN(  76)									if ((this12 == 0)) {
HXLINE(  76)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  76)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  76)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  76)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  76)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  76)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  76)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  76)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  76)									{
HXLINE(  76)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  76)										int value;
HXDLIN(  76)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  76)											value = blended;
            										}
HXDLIN(  76)										bool _hx_tmp;
HXDLIN(  76)										if ((location >= 0)) {
HXLINE(  76)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  76)											_hx_tmp = false;
            										}
HXDLIN(  76)										if (_hx_tmp) {
HXLINE(  76)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  76)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  76)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  76)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  76)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  76)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  76)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  76)									int index;
HXDLIN(  76)									if (pixelShape->useVirtualPos) {
HXLINE(  76)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  76)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  76)									int value;
HXDLIN(  76)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  76)										value = c;
            									}
HXDLIN(  76)									bool _hx_tmp;
HXDLIN(  76)									if ((index >= 0)) {
HXLINE(  76)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  76)										_hx_tmp = false;
            									}
HXDLIN(  76)									if (_hx_tmp) {
HXLINE(  76)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  76)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  76)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  76)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  76)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  76)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  76)								if (forceClear) {
HXLINE(  76)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  76)									int x1 = (x + dx);
HXDLIN(  76)									int y1 = (y + dy);
HXDLIN(  76)									int index;
HXDLIN(  76)									if (pixelShape->useVirtualPos) {
HXLINE(  76)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  76)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  76)									bool _hx_tmp;
HXDLIN(  76)									if ((index >= 0)) {
HXLINE(  76)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  76)										_hx_tmp = false;
            									}
HXDLIN(  76)									if (_hx_tmp) {
HXLINE(  76)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  76)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  76)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  76)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  76)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  76)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  77)		temp = null();
HXLINE(  79)		return this->super::render(pixelShape);
            	}


void RectanglePattern_obj::buildRectangles(::pixelimage::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_ab82dc3afbc001a4_82_buildRectangles)
HXDLIN(  82)		if ((this->rounded == false)) {
HXLINE(  83)			if (this->tiledBorder) {
HXLINE(  84)				::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN(  84)				bool hasHit = false;
HXDLIN(  84)				Float bx = this->width;
HXDLIN(  84)				Float cy = this->height;
HXDLIN(  84)				{
HXLINE(  84)					{
HXLINE(  84)						Float bx1 = bx;
HXDLIN(  84)						Float by = ( (Float)(0) );
HXDLIN(  84)						Float cx = ( (Float)(0) );
HXDLIN(  84)						Float cy1 = cy;
HXDLIN(  84)						bool adjustWinding = (((((( (Float)(0) ) * by) - (bx1 * ( (Float)(0) ))) + ((bx1 * cy1) - (cx * by))) + ((cx * ( (Float)(0) )) - (( (Float)(0) ) * cy1))) > 0);
HXDLIN(  84)						if (!(adjustWinding)) {
HXLINE(  84)							Float bx_ = bx1;
HXDLIN(  84)							Float by_ = by;
HXLINE( 188)							bx1 = cx;
HXLINE( 189)							by = cy1;
HXLINE( 190)							cx = bx_;
HXLINE( 191)							cy1 = by_;
            						}
HXLINE(  84)						{
HXLINE(  84)							bool hasUndo = false;
HXDLIN(  84)							Float s0 = ((( (Float)(0) ) * cx) - (( (Float)(0) ) * cy1));
HXDLIN(  84)							Float sx = cy1;
HXDLIN(  84)							Float sy = (( (Float)(0) ) - cx);
HXDLIN(  84)							Float t0 = ((( (Float)(0) ) * by) - (( (Float)(0) ) * bx1));
HXDLIN(  84)							Float tx = (( (Float)(0) ) - by);
HXDLIN(  84)							Float ty = bx1;
HXDLIN(  84)							Float A = ((((-(by) * cx) + (( (Float)(0) ) * (-(bx1) + cx))) + (( (Float)(0) ) * (by - cy1))) + (bx1 * cy1));
HXDLIN(  84)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  84)							if ((0 > bx1)) {
HXLINE(  84)								if ((0 > cx)) {
HXLINE(  84)									int min;
HXDLIN(  84)									if ((bx1 > cx)) {
HXLINE(  84)										min = ::Math_obj::floor(cx);
            									}
            									else {
HXLINE(  84)										min = ::Math_obj::floor(bx1);
            									}
HXDLIN(  84)									int ii_min = min;
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									xIter3 = this1;
            								}
            								else {
HXLINE(  84)									int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  84)								if ((bx1 > cx)) {
HXLINE(  84)									int min;
HXDLIN(  84)									if ((0 > cx)) {
HXLINE(  84)										min = ::Math_obj::floor(cx);
            									}
            									else {
HXLINE(  84)										min = ::Math_obj::ceil(( (Float)(0) ));
            									}
HXDLIN(  84)									int ii_min = min;
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									xIter3 = this1;
            								}
            								else {
HXLINE(  84)									int ii_min = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									xIter3 = this1;
            								}
            							}
HXDLIN(  84)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  84)							if ((0 > by)) {
HXLINE(  84)								if ((0 > cy1)) {
HXLINE(  84)									int min;
HXDLIN(  84)									if ((by > cy1)) {
HXLINE(  84)										min = ::Math_obj::floor(cy1);
            									}
            									else {
HXLINE(  84)										min = ::Math_obj::floor(by);
            									}
HXDLIN(  84)									int ii_min = min;
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									yIter3 = this1;
            								}
            								else {
HXLINE(  84)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  84)								if ((by > cy1)) {
HXLINE(  84)									int min;
HXDLIN(  84)									if ((0 > cy1)) {
HXLINE(  84)										min = ::Math_obj::floor(cy1);
            									}
            									else {
HXLINE(  84)										min = ::Math_obj::ceil(( (Float)(0) ));
            									}
HXDLIN(  84)									int ii_min = min;
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									yIter3 = this1;
            								}
            								else {
HXLINE(  84)									int ii_min = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									yIter3 = this1;
            								}
            							}
HXDLIN(  84)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  84)							if (hasUndo) {
HXLINE(  84)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  84)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  84)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  84)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  84)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  84)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  84)								undoImage = this3;
HXDLIN(  84)								{
HXLINE(  84)									int rectLeft = xIter3->start;
HXDLIN(  84)									int rectTop = yIter3->start;
HXDLIN(  84)									int rectRight = xIter3->max;
HXDLIN(  84)									bool forceClear = false;
HXDLIN(  84)									{
HXLINE(  84)										int _g = rectTop;
HXDLIN(  84)										int _g1 = yIter3->max;
HXDLIN(  84)										while((_g < _g1)){
HXLINE(  84)											_g = (_g + 1);
HXDLIN(  84)											int dy = (_g - 1);
HXDLIN(  84)											{
HXLINE(  84)												int _g1 = rectLeft;
HXDLIN(  84)												int _g2 = rectRight;
HXDLIN(  84)												while((_g1 < _g2)){
HXLINE(  84)													_g1 = (_g1 + 1);
HXDLIN(  84)													int dx = (_g1 - 1);
HXDLIN(  84)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)													int index;
HXDLIN(  84)													if (temp->useVirtualPos) {
HXLINE(  84)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE(  84)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN(  84)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)													int col;
HXDLIN(  84)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  84)														col = c;
            													}
HXDLIN(  84)													bool _hx_tmp;
HXDLIN(  84)													if (temp->useMask) {
HXLINE(  84)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE(  84)														_hx_tmp = false;
            													}
HXDLIN(  84)													if (_hx_tmp) {
HXLINE(  84)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  84)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  84)														int index;
HXDLIN(  84)														if (this1->useVirtualPos) {
HXLINE(  84)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  84)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  84)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  84)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  84)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)														int v;
HXDLIN(  84)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  84)															v = c;
            														}
HXDLIN(  84)														int this3 = v;
HXDLIN(  84)														int maskPixel = this3;
HXDLIN(  84)														int this4 = col;
HXDLIN(  84)														int this5 = this4;
HXDLIN(  84)														if ((maskPixel == 0)) {
HXLINE(  84)															int this1 = this5;
HXDLIN(  84)															col = this1;
            														}
            														else {
HXLINE(  84)															Float m0;
HXDLIN(  84)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  84)															if ((this1 == 0)) {
HXLINE(  84)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float m1;
HXDLIN(  84)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  84)															if ((this2 == 0)) {
HXLINE(  84)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float m2;
HXDLIN(  84)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  84)															if ((this3 == 0)) {
HXLINE(  84)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float m3;
HXDLIN(  84)															int this4 = (maskPixel & 255);
HXDLIN(  84)															if ((this4 == 0)) {
HXLINE(  84)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  84)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  84)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  84)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  84)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  84)													if ((col != 0)) {
HXLINE(  84)														int x = (dx - rectLeft);
HXDLIN(  84)														int y = (dy - rectTop);
HXDLIN(  84)														int this1 = col;
HXDLIN(  84)														int c = this1;
HXDLIN(  84)														bool _hx_tmp;
HXDLIN(  84)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  84)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE(  84)															_hx_tmp = false;
            														}
HXDLIN(  84)														if (_hx_tmp) {
HXLINE(  84)															int location;
HXDLIN(  84)															if (undoImage->useVirtualPos) {
HXLINE(  84)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  84)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  84)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  84)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)															int this3 = this2;
HXDLIN(  84)															int this4;
HXDLIN(  84)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  84)																this4 = this3;
            															}
HXDLIN(  84)															Float a1;
HXDLIN(  84)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  84)															if ((this5 == 0)) {
HXLINE(  84)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float r1;
HXDLIN(  84)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  84)															if ((this6 == 0)) {
HXLINE(  84)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float g1;
HXDLIN(  84)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  84)															if ((this7 == 0)) {
HXLINE(  84)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float b1;
HXDLIN(  84)															int this8 = (this4 & 255);
HXDLIN(  84)															if ((this8 == 0)) {
HXLINE(  84)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float a2;
HXDLIN(  84)															int this9 = ((col >> 24) & 255);
HXDLIN(  84)															if ((this9 == 0)) {
HXLINE(  84)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float r2;
HXDLIN(  84)															int this10 = ((col >> 16) & 255);
HXDLIN(  84)															if ((this10 == 0)) {
HXLINE(  84)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float g2;
HXDLIN(  84)															int this11 = ((col >> 8) & 255);
HXDLIN(  84)															if ((this11 == 0)) {
HXLINE(  84)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float b2;
HXDLIN(  84)															int this12 = (col & 255);
HXDLIN(  84)															if ((this12 == 0)) {
HXLINE(  84)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  84)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  84)															{
HXLINE(  84)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  84)																int value;
HXDLIN(  84)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	value = blended;
            																}
HXDLIN(  84)																bool _hx_tmp;
HXDLIN(  84)																if ((location >= 0)) {
HXLINE(  84)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  84)																	_hx_tmp = false;
            																}
HXDLIN(  84)																if (_hx_tmp) {
HXLINE(  84)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  84)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  84)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  84)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)															int index;
HXDLIN(  84)															if (undoImage->useVirtualPos) {
HXLINE(  84)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  84)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  84)															int value;
HXDLIN(  84)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  84)																value = c;
            															}
HXDLIN(  84)															bool _hx_tmp;
HXDLIN(  84)															if ((index >= 0)) {
HXLINE(  84)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  84)																_hx_tmp = false;
            															}
HXDLIN(  84)															if (_hx_tmp) {
HXLINE(  84)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  84)														if (forceClear) {
HXLINE(  84)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)															int x = (dx - rectLeft);
HXDLIN(  84)															int y = (dy - rectTop);
HXDLIN(  84)															int index;
HXDLIN(  84)															if (undoImage->useVirtualPos) {
HXLINE(  84)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  84)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  84)															bool _hx_tmp;
HXDLIN(  84)															if ((index >= 0)) {
HXLINE(  84)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  84)																_hx_tmp = false;
            															}
HXDLIN(  84)															if (_hx_tmp) {
HXLINE(  84)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  84)							bool foundY = false;
HXDLIN(  84)							Float s = ((Float)0.);
HXDLIN(  84)							Float t = ((Float)0.);
HXDLIN(  84)							Float sxx = ((Float)0.);
HXDLIN(  84)							Float txx = ((Float)0.);
HXDLIN(  84)							{
HXLINE(  84)								int _g_min = xIter3->start;
HXDLIN(  84)								int _g_max = xIter3->max;
HXDLIN(  84)								while((_g_min < _g_max)){
HXLINE(  84)									_g_min = (_g_min + 1);
HXDLIN(  84)									int x = (_g_min - 1);
HXLINE( 223)									sxx = (sx * ( (Float)(x) ));
HXLINE( 224)									txx = (tx * ( (Float)(x) ));
HXLINE( 225)									foundY = false;
HXLINE(  84)									{
HXLINE(  84)										int _g_min1 = yIter3->start;
HXDLIN(  84)										int _g_max = yIter3->max;
HXDLIN(  84)										while((_g_min1 < _g_max)){
HXLINE(  84)											_g_min1 = (_g_min1 + 1);
HXDLIN(  84)											int y = (_g_min1 - 1);
HXLINE( 227)											s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)											t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  84)											bool _hx_tmp;
HXDLIN(  84)											if (!((s <= 0))) {
HXLINE(  84)												_hx_tmp = (t <= 0);
            											}
            											else {
HXLINE(  84)												_hx_tmp = true;
            											}
HXDLIN(  84)											if (_hx_tmp) {
HXLINE(  84)												if (foundY) {
HXLINE(  84)													goto _hx_goto_9;
            												}
            											}
            											else {
HXLINE(  84)												if (((s + t) < A)) {
HXLINE(  84)													int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  84)													int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  84)													::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  84)													int index;
HXDLIN(  84)													if (tileImage->useVirtualPos) {
HXLINE(  84)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            													}
            													else {
HXLINE(  84)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            													}
HXDLIN(  84)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)													int color;
HXDLIN(  84)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  84)														color = c;
            													}
HXDLIN(  84)													{
HXLINE(  84)														int this2 = color;
HXDLIN(  84)														int c1 = this2;
HXDLIN(  84)														bool _hx_tmp;
HXDLIN(  84)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  84)															_hx_tmp = temp->transparent;
            														}
            														else {
HXLINE(  84)															_hx_tmp = false;
            														}
HXDLIN(  84)														if (_hx_tmp) {
HXLINE(  84)															int location;
HXDLIN(  84)															if (temp->useVirtualPos) {
HXLINE(  84)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE(  84)																location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN(  84)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  84)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)															int this3 = this2;
HXDLIN(  84)															int this4;
HXDLIN(  84)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  84)																this4 = this3;
            															}
HXDLIN(  84)															Float a1;
HXDLIN(  84)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  84)															if ((this5 == 0)) {
HXLINE(  84)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float r1;
HXDLIN(  84)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  84)															if ((this6 == 0)) {
HXLINE(  84)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float g1;
HXDLIN(  84)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  84)															if ((this7 == 0)) {
HXLINE(  84)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float b1;
HXDLIN(  84)															int this8 = (this4 & 255);
HXDLIN(  84)															if ((this8 == 0)) {
HXLINE(  84)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float a2;
HXDLIN(  84)															int this9 = ((color >> 24) & 255);
HXDLIN(  84)															if ((this9 == 0)) {
HXLINE(  84)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float r2;
HXDLIN(  84)															int this10 = ((color >> 16) & 255);
HXDLIN(  84)															if ((this10 == 0)) {
HXLINE(  84)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float g2;
HXDLIN(  84)															int this11 = ((color >> 8) & 255);
HXDLIN(  84)															if ((this11 == 0)) {
HXLINE(  84)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float b2;
HXDLIN(  84)															int this12 = (color & 255);
HXDLIN(  84)															if ((this12 == 0)) {
HXLINE(  84)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  84)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  84)															{
HXLINE(  84)																::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  84)																int value;
HXDLIN(  84)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	value = blended;
            																}
HXDLIN(  84)																bool _hx_tmp;
HXDLIN(  84)																if ((location >= 0)) {
HXLINE(  84)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  84)																	_hx_tmp = false;
            																}
HXDLIN(  84)																if (_hx_tmp) {
HXLINE(  84)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  84)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  84)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  84)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)															int index;
HXDLIN(  84)															if (temp->useVirtualPos) {
HXLINE(  84)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE(  84)																index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN(  84)															int value;
HXDLIN(  84)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  84)																value = c1;
            															}
HXDLIN(  84)															bool _hx_tmp;
HXDLIN(  84)															if ((index >= 0)) {
HXLINE(  84)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  84)																_hx_tmp = false;
            															}
HXDLIN(  84)															if (_hx_tmp) {
HXLINE(  84)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY = true;
            												}
            												else {
HXLINE(  84)													if (foundY) {
HXLINE(  84)														goto _hx_goto_9;
            													}
            												}
            											}
            										}
            										_hx_goto_9:;
            									}
            								}
            							}
HXDLIN(  84)							if ((hasHit == false)) {
HXLINE(  84)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),bx1,by,cx,cy1,true);
HXDLIN(  84)								if (hasUndo) {
HXLINE(  84)									v->undoImage = undoImage;
HXDLIN(  84)									v->undoX = xIter3->start;
HXDLIN(  84)									v->undoY = yIter3->start;
            								}
            							}
            						}
            					}
HXDLIN(  84)					{
HXLINE(  84)						Float bx2 = bx;
HXDLIN(  84)						Float by1 = cy;
HXDLIN(  84)						Float cx1 = ( (Float)(0) );
HXDLIN(  84)						Float cy2 = cy;
HXDLIN(  84)						bool adjustWinding1 = (((((bx * by1) - (bx2 * ( (Float)(0) ))) + ((bx2 * cy2) - (cx1 * by1))) + ((cx1 * ( (Float)(0) )) - (bx * cy2))) > 0);
HXDLIN(  84)						if (!(adjustWinding1)) {
HXLINE(  84)							Float bx_ = bx2;
HXDLIN(  84)							Float by_ = by1;
HXLINE( 188)							bx2 = cx1;
HXLINE( 189)							by1 = cy2;
HXLINE( 190)							cx1 = bx_;
HXLINE( 191)							cy2 = by_;
            						}
HXLINE(  84)						{
HXLINE(  84)							bool hasUndo1 = false;
HXDLIN(  84)							Float s01 = ((( (Float)(0) ) * cx1) - (bx * cy2));
HXDLIN(  84)							Float sx1 = cy2;
HXDLIN(  84)							Float sy1 = (bx - cx1);
HXDLIN(  84)							Float t01 = ((bx * by1) - (( (Float)(0) ) * bx2));
HXDLIN(  84)							Float tx1 = (( (Float)(0) ) - by1);
HXDLIN(  84)							Float ty1 = (bx2 - bx);
HXDLIN(  84)							Float A1 = ((((-(by1) * cx1) + (( (Float)(0) ) * (-(bx2) + cx1))) + (bx * (by1 - cy2))) + (bx2 * cy2));
HXDLIN(  84)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  84)							if ((bx > bx2)) {
HXLINE(  84)								if ((bx > cx1)) {
HXLINE(  84)									int min;
HXDLIN(  84)									if ((bx2 > cx1)) {
HXLINE(  84)										min = ::Math_obj::floor(cx1);
            									}
            									else {
HXLINE(  84)										min = ::Math_obj::floor(bx2);
            									}
HXDLIN(  84)									int ii_min = min;
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									xIter31 = this1;
            								}
            								else {
HXLINE(  84)									int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  84)								if ((bx2 > cx1)) {
HXLINE(  84)									int min;
HXDLIN(  84)									if ((bx > cx1)) {
HXLINE(  84)										min = ::Math_obj::floor(cx1);
            									}
            									else {
HXLINE(  84)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  84)									int ii_min = min;
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									xIter31 = this1;
            								}
            								else {
HXLINE(  84)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									xIter31 = this1;
            								}
            							}
HXDLIN(  84)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  84)							if ((0 > by1)) {
HXLINE(  84)								if ((0 > cy2)) {
HXLINE(  84)									int min;
HXDLIN(  84)									if ((by1 > cy2)) {
HXLINE(  84)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  84)										min = ::Math_obj::floor(by1);
            									}
HXDLIN(  84)									int ii_min = min;
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									yIter31 = this1;
            								}
            								else {
HXLINE(  84)									int ii_min = ::Math_obj::floor(by1);
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  84)								if ((by1 > cy2)) {
HXLINE(  84)									int min;
HXDLIN(  84)									if ((0 > cy2)) {
HXLINE(  84)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  84)										min = ::Math_obj::ceil(( (Float)(0) ));
            									}
HXDLIN(  84)									int ii_min = min;
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									yIter31 = this1;
            								}
            								else {
HXLINE(  84)									int ii_min = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  84)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  84)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)									yIter31 = this1;
            								}
            							}
HXDLIN(  84)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  84)							if (hasUndo1) {
HXLINE(  84)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  84)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  84)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  84)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  84)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  84)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  84)								undoImage1 = this3;
HXDLIN(  84)								{
HXLINE(  84)									int rectLeft = xIter31->start;
HXDLIN(  84)									int rectTop = yIter31->start;
HXDLIN(  84)									int rectRight = xIter31->max;
HXDLIN(  84)									bool forceClear = false;
HXDLIN(  84)									{
HXLINE(  84)										int _g = rectTop;
HXDLIN(  84)										int _g1 = yIter31->max;
HXDLIN(  84)										while((_g < _g1)){
HXLINE(  84)											_g = (_g + 1);
HXDLIN(  84)											int dy = (_g - 1);
HXDLIN(  84)											{
HXLINE(  84)												int _g1 = rectLeft;
HXDLIN(  84)												int _g2 = rectRight;
HXDLIN(  84)												while((_g1 < _g2)){
HXLINE(  84)													_g1 = (_g1 + 1);
HXDLIN(  84)													int dx = (_g1 - 1);
HXDLIN(  84)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)													int index;
HXDLIN(  84)													if (temp->useVirtualPos) {
HXLINE(  84)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE(  84)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN(  84)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)													int col;
HXDLIN(  84)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  84)														col = c;
            													}
HXDLIN(  84)													bool _hx_tmp;
HXDLIN(  84)													if (temp->useMask) {
HXLINE(  84)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE(  84)														_hx_tmp = false;
            													}
HXDLIN(  84)													if (_hx_tmp) {
HXLINE(  84)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  84)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  84)														int index;
HXDLIN(  84)														if (this1->useVirtualPos) {
HXLINE(  84)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  84)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  84)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  84)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  84)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)														int v;
HXDLIN(  84)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  84)															v = c;
            														}
HXDLIN(  84)														int this3 = v;
HXDLIN(  84)														int maskPixel = this3;
HXDLIN(  84)														int this4 = col;
HXDLIN(  84)														int this5 = this4;
HXDLIN(  84)														if ((maskPixel == 0)) {
HXLINE(  84)															int this1 = this5;
HXDLIN(  84)															col = this1;
            														}
            														else {
HXLINE(  84)															Float m0;
HXDLIN(  84)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  84)															if ((this1 == 0)) {
HXLINE(  84)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float m1;
HXDLIN(  84)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  84)															if ((this2 == 0)) {
HXLINE(  84)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float m2;
HXDLIN(  84)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  84)															if ((this3 == 0)) {
HXLINE(  84)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float m3;
HXDLIN(  84)															int this4 = (maskPixel & 255);
HXDLIN(  84)															if ((this4 == 0)) {
HXLINE(  84)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  84)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  84)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  84)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  84)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  84)													if ((col != 0)) {
HXLINE(  84)														int x = (dx - rectLeft);
HXDLIN(  84)														int y = (dy - rectTop);
HXDLIN(  84)														int this1 = col;
HXDLIN(  84)														int c = this1;
HXDLIN(  84)														bool _hx_tmp;
HXDLIN(  84)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  84)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE(  84)															_hx_tmp = false;
            														}
HXDLIN(  84)														if (_hx_tmp) {
HXLINE(  84)															int location;
HXDLIN(  84)															if (undoImage1->useVirtualPos) {
HXLINE(  84)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  84)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  84)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  84)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  84)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)															int this3 = this2;
HXDLIN(  84)															int this4;
HXDLIN(  84)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  84)																this4 = this3;
            															}
HXDLIN(  84)															Float a1;
HXDLIN(  84)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  84)															if ((this5 == 0)) {
HXLINE(  84)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float r1;
HXDLIN(  84)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  84)															if ((this6 == 0)) {
HXLINE(  84)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float g1;
HXDLIN(  84)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  84)															if ((this7 == 0)) {
HXLINE(  84)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float b1;
HXDLIN(  84)															int this8 = (this4 & 255);
HXDLIN(  84)															if ((this8 == 0)) {
HXLINE(  84)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float a2;
HXDLIN(  84)															int this9 = ((col >> 24) & 255);
HXDLIN(  84)															if ((this9 == 0)) {
HXLINE(  84)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float r2;
HXDLIN(  84)															int this10 = ((col >> 16) & 255);
HXDLIN(  84)															if ((this10 == 0)) {
HXLINE(  84)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float g2;
HXDLIN(  84)															int this11 = ((col >> 8) & 255);
HXDLIN(  84)															if ((this11 == 0)) {
HXLINE(  84)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float b2;
HXDLIN(  84)															int this12 = (col & 255);
HXDLIN(  84)															if ((this12 == 0)) {
HXLINE(  84)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  84)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  84)															{
HXLINE(  84)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  84)																int value;
HXDLIN(  84)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	value = blended;
            																}
HXDLIN(  84)																bool _hx_tmp;
HXDLIN(  84)																if ((location >= 0)) {
HXLINE(  84)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  84)																	_hx_tmp = false;
            																}
HXDLIN(  84)																if (_hx_tmp) {
HXLINE(  84)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  84)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  84)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  84)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  84)															int index;
HXDLIN(  84)															if (undoImage1->useVirtualPos) {
HXLINE(  84)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  84)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  84)															int value;
HXDLIN(  84)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  84)																value = c;
            															}
HXDLIN(  84)															bool _hx_tmp;
HXDLIN(  84)															if ((index >= 0)) {
HXLINE(  84)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  84)																_hx_tmp = false;
            															}
HXDLIN(  84)															if (_hx_tmp) {
HXLINE(  84)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  84)														if (forceClear) {
HXLINE(  84)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  84)															int x = (dx - rectLeft);
HXDLIN(  84)															int y = (dy - rectTop);
HXDLIN(  84)															int index;
HXDLIN(  84)															if (undoImage1->useVirtualPos) {
HXLINE(  84)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  84)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  84)															bool _hx_tmp;
HXDLIN(  84)															if ((index >= 0)) {
HXLINE(  84)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  84)																_hx_tmp = false;
            															}
HXDLIN(  84)															if (_hx_tmp) {
HXLINE(  84)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  84)							bool foundY1 = false;
HXDLIN(  84)							Float s1 = ((Float)0.);
HXDLIN(  84)							Float t1 = ((Float)0.);
HXDLIN(  84)							Float sxx1 = ((Float)0.);
HXDLIN(  84)							Float txx1 = ((Float)0.);
HXDLIN(  84)							{
HXLINE(  84)								int _g_min1 = xIter31->start;
HXDLIN(  84)								int _g_max1 = xIter31->max;
HXDLIN(  84)								while((_g_min1 < _g_max1)){
HXLINE(  84)									_g_min1 = (_g_min1 + 1);
HXDLIN(  84)									int x = (_g_min1 - 1);
HXLINE( 223)									sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)									txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)									foundY1 = false;
HXLINE(  84)									{
HXLINE(  84)										int _g_min = yIter31->start;
HXDLIN(  84)										int _g_max = yIter31->max;
HXDLIN(  84)										while((_g_min < _g_max)){
HXLINE(  84)											_g_min = (_g_min + 1);
HXDLIN(  84)											int y = (_g_min - 1);
HXLINE( 227)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  84)											bool _hx_tmp;
HXDLIN(  84)											if (!((s1 <= 0))) {
HXLINE(  84)												_hx_tmp = (t1 <= 0);
            											}
            											else {
HXLINE(  84)												_hx_tmp = true;
            											}
HXDLIN(  84)											if (_hx_tmp) {
HXLINE(  84)												if (foundY1) {
HXLINE(  84)													goto _hx_goto_13;
            												}
            											}
            											else {
HXLINE(  84)												if (((s1 + t1) < A1)) {
HXLINE(  84)													int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  84)													int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  84)													::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  84)													int index;
HXDLIN(  84)													if (tileImage->useVirtualPos) {
HXLINE(  84)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            													}
            													else {
HXLINE(  84)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            													}
HXDLIN(  84)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)													int color;
HXDLIN(  84)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  84)														color = c;
            													}
HXDLIN(  84)													{
HXLINE(  84)														int this2 = color;
HXDLIN(  84)														int c1 = this2;
HXDLIN(  84)														bool _hx_tmp;
HXDLIN(  84)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  84)															_hx_tmp = temp->transparent;
            														}
            														else {
HXLINE(  84)															_hx_tmp = false;
            														}
HXDLIN(  84)														if (_hx_tmp) {
HXLINE(  84)															int location;
HXDLIN(  84)															if (temp->useVirtualPos) {
HXLINE(  84)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE(  84)																location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN(  84)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  84)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)															int this3 = this2;
HXDLIN(  84)															int this4;
HXDLIN(  84)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  84)																this4 = this3;
            															}
HXDLIN(  84)															Float a1;
HXDLIN(  84)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  84)															if ((this5 == 0)) {
HXLINE(  84)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float r1;
HXDLIN(  84)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  84)															if ((this6 == 0)) {
HXLINE(  84)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float g1;
HXDLIN(  84)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  84)															if ((this7 == 0)) {
HXLINE(  84)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float b1;
HXDLIN(  84)															int this8 = (this4 & 255);
HXDLIN(  84)															if ((this8 == 0)) {
HXLINE(  84)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float a2;
HXDLIN(  84)															int this9 = ((color >> 24) & 255);
HXDLIN(  84)															if ((this9 == 0)) {
HXLINE(  84)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float r2;
HXDLIN(  84)															int this10 = ((color >> 16) & 255);
HXDLIN(  84)															if ((this10 == 0)) {
HXLINE(  84)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float g2;
HXDLIN(  84)															int this11 = ((color >> 8) & 255);
HXDLIN(  84)															if ((this11 == 0)) {
HXLINE(  84)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float b2;
HXDLIN(  84)															int this12 = (color & 255);
HXDLIN(  84)															if ((this12 == 0)) {
HXLINE(  84)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  84)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  84)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  84)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  84)															{
HXLINE(  84)																::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  84)																int value;
HXDLIN(  84)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	value = blended;
            																}
HXDLIN(  84)																bool _hx_tmp;
HXDLIN(  84)																if ((location >= 0)) {
HXLINE(  84)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  84)																	_hx_tmp = false;
            																}
HXDLIN(  84)																if (_hx_tmp) {
HXLINE(  84)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  84)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  84)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  84)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)															int index;
HXDLIN(  84)															if (temp->useVirtualPos) {
HXLINE(  84)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE(  84)																index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN(  84)															int value;
HXDLIN(  84)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  84)																value = c1;
            															}
HXDLIN(  84)															bool _hx_tmp;
HXDLIN(  84)															if ((index >= 0)) {
HXLINE(  84)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  84)																_hx_tmp = false;
            															}
HXDLIN(  84)															if (_hx_tmp) {
HXLINE(  84)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY1 = true;
            												}
            												else {
HXLINE(  84)													if (foundY1) {
HXLINE(  84)														goto _hx_goto_13;
            													}
            												}
            											}
            										}
            										_hx_goto_13:;
            									}
            								}
            							}
HXDLIN(  84)							if ((hasHit == false)) {
HXLINE(  84)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,( (Float)(0) ),bx2,by1,cx1,cy2,true);
HXDLIN(  84)								if (hasUndo1) {
HXLINE(  84)									v->undoImage = undoImage1;
HXDLIN(  84)									v->undoX = xIter31->start;
HXDLIN(  84)									v->undoY = yIter31->start;
            								}
            							}
            						}
            					}
HXDLIN(  84)					if ((hasHit == true)) {
HXLINE(  84)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),bx,( (Float)(0) ),bx,cy,( (Float)(0) ),cy,true);
            					}
            				}
            			}
            			else {
HXLINE(  86)				Float h = this->height;
HXDLIN(  86)				int color = this->strokeColor;
HXDLIN(  86)				int p = 0;
HXDLIN(  86)				int xx = p;
HXDLIN(  86)				int q = 0;
HXDLIN(  86)				int maxX = ::Std_obj::_hx_int(this->width);
HXDLIN(  86)				int maxY = ::Std_obj::_hx_int(h);
HXDLIN(  86)				while(true){
HXLINE(  86)					{
HXLINE(  86)						p = (p + 1);
HXDLIN(  86)						int x = (p - 1);
HXDLIN(  86)						int this1 = color;
HXDLIN(  86)						int c = this1;
HXDLIN(  86)						bool _hx_tmp;
HXDLIN(  86)						if ((((c >> 24) & 255) < 254)) {
HXLINE(  86)							_hx_tmp = temp->transparent;
            						}
            						else {
HXLINE(  86)							_hx_tmp = false;
            						}
HXDLIN(  86)						if (_hx_tmp) {
HXLINE(  86)							int location;
HXDLIN(  86)							if (temp->useVirtualPos) {
HXLINE(  86)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            							}
            							else {
HXLINE(  86)								location = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            							}
HXDLIN(  86)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  86)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  86)							int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  86)							int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  86)							int this3 = this2;
HXDLIN(  86)							int this4;
HXDLIN(  86)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)								this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            							}
            							else {
HXLINE(  86)								this4 = this3;
            							}
HXDLIN(  86)							Float a1;
HXDLIN(  86)							int this5 = ((this4 >> 24) & 255);
HXDLIN(  86)							if ((this5 == 0)) {
HXLINE(  86)								a1 = ((Float)0.);
            							}
            							else {
HXLINE(  86)								a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            							}
HXDLIN(  86)							Float r1;
HXDLIN(  86)							int this6 = ((this4 >> 16) & 255);
HXDLIN(  86)							if ((this6 == 0)) {
HXLINE(  86)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  86)								r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN(  86)							Float g1;
HXDLIN(  86)							int this7 = ((this4 >> 8) & 255);
HXDLIN(  86)							if ((this7 == 0)) {
HXLINE(  86)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  86)								g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN(  86)							Float b1;
HXDLIN(  86)							int this8 = (this4 & 255);
HXDLIN(  86)							if ((this8 == 0)) {
HXLINE(  86)								b1 = ((Float)0.);
            							}
            							else {
HXLINE(  86)								b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN(  86)							Float a2;
HXDLIN(  86)							int this9 = ((color >> 24) & 255);
HXDLIN(  86)							if ((this9 == 0)) {
HXLINE(  86)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  86)								a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  86)							Float r2;
HXDLIN(  86)							int this10 = ((color >> 16) & 255);
HXDLIN(  86)							if ((this10 == 0)) {
HXLINE(  86)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  86)								r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  86)							Float g2;
HXDLIN(  86)							int this11 = ((color >> 8) & 255);
HXDLIN(  86)							if ((this11 == 0)) {
HXLINE(  86)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  86)								g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  86)							Float b2;
HXDLIN(  86)							int this12 = (color & 255);
HXDLIN(  86)							if ((this12 == 0)) {
HXLINE(  86)								b2 = ((Float)0.);
            							}
            							else {
HXLINE(  86)								b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  86)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  86)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  86)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  86)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  86)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  86)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  86)							{
HXLINE(  86)								::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  86)								int value;
HXDLIN(  86)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  86)									value = blended;
            								}
HXDLIN(  86)								bool _hx_tmp;
HXDLIN(  86)								if ((location >= 0)) {
HXLINE(  86)									_hx_tmp = (location < (this13->byteLength >> 2));
            								}
            								else {
HXLINE(  86)									_hx_tmp = false;
            								}
HXDLIN(  86)								if (_hx_tmp) {
HXLINE(  86)									::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  86)									int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  86)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE(  86)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  86)							int index;
HXDLIN(  86)							if (temp->useVirtualPos) {
HXLINE(  86)								index = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            							}
            							else {
HXLINE(  86)								index = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            							}
HXDLIN(  86)							int value;
HXDLIN(  86)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  86)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  86)								value = c;
            							}
HXDLIN(  86)							bool _hx_tmp;
HXDLIN(  86)							if ((index >= 0)) {
HXLINE(  86)								_hx_tmp = (index < (this1->byteLength >> 2));
            							}
            							else {
HXLINE(  86)								_hx_tmp = false;
            							}
HXDLIN(  86)							if (_hx_tmp) {
HXLINE(  86)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  86)								int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  86)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  86)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  86)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  86)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN(  86)					if ((p > maxX)) {
HXLINE( 247)						p = xx;
HXLINE(  86)						q = (q + 1);
            					}
HXDLIN(  86)					if ((q > maxY)) {
HXLINE(  86)						goto _hx_goto_14;
            					}
            				}
            				_hx_goto_14:;
            			}
HXLINE(  88)			{
HXLINE(  88)				Float x = this->strokeWidth;
HXDLIN(  88)				Float y = this->strokeWidth;
HXDLIN(  88)				::pixelimage::ImageStruct tileImage = this->tileImageFill;
HXDLIN(  88)				bool hasHit = false;
HXDLIN(  88)				Float bx = (x + (this->width - (( (Float)(2) ) * this->strokeWidth)));
HXDLIN(  88)				Float cy = (y + (this->height - (( (Float)(2) ) * this->strokeWidth)));
HXDLIN(  88)				{
HXLINE(  88)					{
HXLINE(  88)						Float bx1 = bx;
HXDLIN(  88)						Float by = y;
HXDLIN(  88)						Float cx = x;
HXDLIN(  88)						Float cy1 = cy;
HXDLIN(  88)						bool adjustWinding = (((((x * by) - (bx1 * y)) + ((bx1 * cy1) - (cx * by))) + ((cx * y) - (x * cy1))) > 0);
HXDLIN(  88)						if (!(adjustWinding)) {
HXLINE(  88)							Float bx_ = bx1;
HXDLIN(  88)							Float by_ = by;
HXLINE( 188)							bx1 = cx;
HXLINE( 189)							by = cy1;
HXLINE( 190)							cx = bx_;
HXLINE( 191)							cy1 = by_;
            						}
HXLINE(  88)						{
HXLINE(  88)							bool hasUndo = false;
HXDLIN(  88)							Float s0 = ((y * cx) - (x * cy1));
HXDLIN(  88)							Float sx = (cy1 - y);
HXDLIN(  88)							Float sy = (x - cx);
HXDLIN(  88)							Float t0 = ((x * by) - (y * bx1));
HXDLIN(  88)							Float tx = (y - by);
HXDLIN(  88)							Float ty = (bx1 - x);
HXDLIN(  88)							Float A = ((((-(by) * cx) + (y * (-(bx1) + cx))) + (x * (by - cy1))) + (bx1 * cy1));
HXDLIN(  88)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  88)							if ((x > bx1)) {
HXLINE(  88)								if ((x > cx)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((bx1 > cx)) {
HXLINE(  88)										min = ::Math_obj::floor(cx);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::floor(bx1);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(x);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter3 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  88)								if ((bx1 > cx)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((x > cx)) {
HXLINE(  88)										min = ::Math_obj::floor(cx);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::ceil(x);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter3 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(x);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter3 = this1;
            								}
            							}
HXDLIN(  88)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  88)							if ((y > by)) {
HXLINE(  88)								if ((y > cy1)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((by > cy1)) {
HXLINE(  88)										min = ::Math_obj::floor(cy1);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::floor(by);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(y);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter3 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  88)								if ((by > cy1)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((y > cy1)) {
HXLINE(  88)										min = ::Math_obj::floor(cy1);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::ceil(y);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter3 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(y);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter3 = this1;
            								}
            							}
HXDLIN(  88)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  88)							if (hasUndo) {
HXLINE(  88)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  88)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  88)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  88)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  88)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  88)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  88)								undoImage = this3;
HXDLIN(  88)								{
HXLINE(  88)									int rectLeft = xIter3->start;
HXDLIN(  88)									int rectTop = yIter3->start;
HXDLIN(  88)									int rectRight = xIter3->max;
HXDLIN(  88)									bool forceClear = false;
HXDLIN(  88)									{
HXLINE(  88)										int _g = rectTop;
HXDLIN(  88)										int _g1 = yIter3->max;
HXDLIN(  88)										while((_g < _g1)){
HXLINE(  88)											_g = (_g + 1);
HXDLIN(  88)											int dy = (_g - 1);
HXDLIN(  88)											{
HXLINE(  88)												int _g1 = rectLeft;
HXDLIN(  88)												int _g2 = rectRight;
HXDLIN(  88)												while((_g1 < _g2)){
HXLINE(  88)													_g1 = (_g1 + 1);
HXDLIN(  88)													int dx = (_g1 - 1);
HXDLIN(  88)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  88)													int index;
HXDLIN(  88)													if (temp->useVirtualPos) {
HXLINE(  88)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE(  88)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN(  88)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int col;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  88)														col = c;
            													}
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if (temp->useMask) {
HXLINE(  88)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  88)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  88)														int index;
HXDLIN(  88)														if (this1->useVirtualPos) {
HXLINE(  88)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  88)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  88)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  88)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  88)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)														int v;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  88)															v = c;
            														}
HXDLIN(  88)														int this3 = v;
HXDLIN(  88)														int maskPixel = this3;
HXDLIN(  88)														int this4 = col;
HXDLIN(  88)														int this5 = this4;
HXDLIN(  88)														if ((maskPixel == 0)) {
HXLINE(  88)															int this1 = this5;
HXDLIN(  88)															col = this1;
            														}
            														else {
HXLINE(  88)															Float m0;
HXDLIN(  88)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  88)															if ((this1 == 0)) {
HXLINE(  88)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m1;
HXDLIN(  88)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  88)															if ((this2 == 0)) {
HXLINE(  88)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m2;
HXDLIN(  88)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  88)															if ((this3 == 0)) {
HXLINE(  88)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m3;
HXDLIN(  88)															int this4 = (maskPixel & 255);
HXDLIN(  88)															if ((this4 == 0)) {
HXLINE(  88)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  88)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  88)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  88)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  88)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  88)													if ((col != 0)) {
HXLINE(  88)														int x = (dx - rectLeft);
HXDLIN(  88)														int y = (dy - rectTop);
HXDLIN(  88)														int this1 = col;
HXDLIN(  88)														int c = this1;
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  88)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															int location;
HXDLIN(  88)															if (undoImage->useVirtualPos) {
HXLINE(  88)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  88)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)															int this3 = this2;
HXDLIN(  88)															int this4;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  88)																this4 = this3;
            															}
HXDLIN(  88)															Float a1;
HXDLIN(  88)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  88)															if ((this5 == 0)) {
HXLINE(  88)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r1;
HXDLIN(  88)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  88)															if ((this6 == 0)) {
HXLINE(  88)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g1;
HXDLIN(  88)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  88)															if ((this7 == 0)) {
HXLINE(  88)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b1;
HXDLIN(  88)															int this8 = (this4 & 255);
HXDLIN(  88)															if ((this8 == 0)) {
HXLINE(  88)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a2;
HXDLIN(  88)															int this9 = ((col >> 24) & 255);
HXDLIN(  88)															if ((this9 == 0)) {
HXLINE(  88)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r2;
HXDLIN(  88)															int this10 = ((col >> 16) & 255);
HXDLIN(  88)															if ((this10 == 0)) {
HXLINE(  88)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g2;
HXDLIN(  88)															int this11 = ((col >> 8) & 255);
HXDLIN(  88)															if ((this11 == 0)) {
HXLINE(  88)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b2;
HXDLIN(  88)															int this12 = (col & 255);
HXDLIN(  88)															if ((this12 == 0)) {
HXLINE(  88)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)															{
HXLINE(  88)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  88)																int value;
HXDLIN(  88)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  88)																	value = blended;
            																}
HXDLIN(  88)																bool _hx_tmp;
HXDLIN(  88)																if ((location >= 0)) {
HXLINE(  88)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  88)																	_hx_tmp = false;
            																}
HXDLIN(  88)																if (_hx_tmp) {
HXLINE(  88)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  88)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  88)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  88)															int index;
HXDLIN(  88)															if (undoImage->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = c;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  88)														if (forceClear) {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  88)															int x = (dx - rectLeft);
HXDLIN(  88)															int y = (dy - rectTop);
HXDLIN(  88)															int index;
HXDLIN(  88)															if (undoImage->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  88)							bool foundY = false;
HXDLIN(  88)							Float s = ((Float)0.);
HXDLIN(  88)							Float t = ((Float)0.);
HXDLIN(  88)							Float sxx = ((Float)0.);
HXDLIN(  88)							Float txx = ((Float)0.);
HXDLIN(  88)							{
HXLINE(  88)								int _g_min = xIter3->start;
HXDLIN(  88)								int _g_max = xIter3->max;
HXDLIN(  88)								while((_g_min < _g_max)){
HXLINE(  88)									_g_min = (_g_min + 1);
HXDLIN(  88)									int x = (_g_min - 1);
HXLINE( 223)									sxx = (sx * ( (Float)(x) ));
HXLINE( 224)									txx = (tx * ( (Float)(x) ));
HXLINE( 225)									foundY = false;
HXLINE(  88)									{
HXLINE(  88)										int _g_min1 = yIter3->start;
HXDLIN(  88)										int _g_max = yIter3->max;
HXDLIN(  88)										while((_g_min1 < _g_max)){
HXLINE(  88)											_g_min1 = (_g_min1 + 1);
HXDLIN(  88)											int y = (_g_min1 - 1);
HXLINE( 227)											s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)											t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  88)											bool _hx_tmp;
HXDLIN(  88)											if (!((s <= 0))) {
HXLINE(  88)												_hx_tmp = (t <= 0);
            											}
            											else {
HXLINE(  88)												_hx_tmp = true;
            											}
HXDLIN(  88)											if (_hx_tmp) {
HXLINE(  88)												if (foundY) {
HXLINE(  88)													goto _hx_goto_18;
            												}
            											}
            											else {
HXLINE(  88)												if (((s + t) < A)) {
HXLINE(  88)													int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  88)													int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  88)													::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  88)													int index;
HXDLIN(  88)													if (tileImage->useVirtualPos) {
HXLINE(  88)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            													}
            													else {
HXLINE(  88)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            													}
HXDLIN(  88)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int color;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  88)														color = c;
            													}
HXDLIN(  88)													{
HXLINE(  88)														int this2 = color;
HXDLIN(  88)														int c1 = this2;
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  88)															_hx_tmp = temp->transparent;
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															int location;
HXDLIN(  88)															if (temp->useVirtualPos) {
HXLINE(  88)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE(  88)																location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN(  88)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)															int this3 = this2;
HXDLIN(  88)															int this4;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  88)																this4 = this3;
            															}
HXDLIN(  88)															Float a1;
HXDLIN(  88)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  88)															if ((this5 == 0)) {
HXLINE(  88)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r1;
HXDLIN(  88)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  88)															if ((this6 == 0)) {
HXLINE(  88)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g1;
HXDLIN(  88)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  88)															if ((this7 == 0)) {
HXLINE(  88)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b1;
HXDLIN(  88)															int this8 = (this4 & 255);
HXDLIN(  88)															if ((this8 == 0)) {
HXLINE(  88)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a2;
HXDLIN(  88)															int this9 = ((color >> 24) & 255);
HXDLIN(  88)															if ((this9 == 0)) {
HXLINE(  88)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r2;
HXDLIN(  88)															int this10 = ((color >> 16) & 255);
HXDLIN(  88)															if ((this10 == 0)) {
HXLINE(  88)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g2;
HXDLIN(  88)															int this11 = ((color >> 8) & 255);
HXDLIN(  88)															if ((this11 == 0)) {
HXLINE(  88)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b2;
HXDLIN(  88)															int this12 = (color & 255);
HXDLIN(  88)															if ((this12 == 0)) {
HXLINE(  88)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)															{
HXLINE(  88)																::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  88)																int value;
HXDLIN(  88)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  88)																	value = blended;
            																}
HXDLIN(  88)																bool _hx_tmp;
HXDLIN(  88)																if ((location >= 0)) {
HXLINE(  88)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  88)																	_hx_tmp = false;
            																}
HXDLIN(  88)																if (_hx_tmp) {
HXLINE(  88)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  88)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  88)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  88)															int index;
HXDLIN(  88)															if (temp->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = c1;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY = true;
            												}
            												else {
HXLINE(  88)													if (foundY) {
HXLINE(  88)														goto _hx_goto_18;
            													}
            												}
            											}
            										}
            										_hx_goto_18:;
            									}
            								}
            							}
HXDLIN(  88)							if ((hasHit == false)) {
HXLINE(  88)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x,y,bx1,by,cx,cy1,true);
HXDLIN(  88)								if (hasUndo) {
HXLINE(  88)									v->undoImage = undoImage;
HXDLIN(  88)									v->undoX = xIter3->start;
HXDLIN(  88)									v->undoY = yIter3->start;
            								}
            							}
            						}
            					}
HXDLIN(  88)					{
HXLINE(  88)						Float bx2 = bx;
HXDLIN(  88)						Float by1 = cy;
HXDLIN(  88)						Float cx1 = x;
HXDLIN(  88)						Float cy2 = cy;
HXDLIN(  88)						bool adjustWinding1 = (((((bx * by1) - (bx2 * y)) + ((bx2 * cy2) - (cx1 * by1))) + ((cx1 * y) - (bx * cy2))) > 0);
HXDLIN(  88)						if (!(adjustWinding1)) {
HXLINE(  88)							Float bx_ = bx2;
HXDLIN(  88)							Float by_ = by1;
HXLINE( 188)							bx2 = cx1;
HXLINE( 189)							by1 = cy2;
HXLINE( 190)							cx1 = bx_;
HXLINE( 191)							cy2 = by_;
            						}
HXLINE(  88)						{
HXLINE(  88)							bool hasUndo1 = false;
HXDLIN(  88)							Float s01 = ((y * cx1) - (bx * cy2));
HXDLIN(  88)							Float sx1 = (cy2 - y);
HXDLIN(  88)							Float sy1 = (bx - cx1);
HXDLIN(  88)							Float t01 = ((bx * by1) - (y * bx2));
HXDLIN(  88)							Float tx1 = (y - by1);
HXDLIN(  88)							Float ty1 = (bx2 - bx);
HXDLIN(  88)							Float A1 = ((((-(by1) * cx1) + (y * (-(bx2) + cx1))) + (bx * (by1 - cy2))) + (bx2 * cy2));
HXDLIN(  88)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  88)							if ((bx > bx2)) {
HXLINE(  88)								if ((bx > cx1)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((bx2 > cx1)) {
HXLINE(  88)										min = ::Math_obj::floor(cx1);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::floor(bx2);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter31 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  88)								if ((bx2 > cx1)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((bx > cx1)) {
HXLINE(  88)										min = ::Math_obj::floor(cx1);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter31 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter31 = this1;
            								}
            							}
HXDLIN(  88)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  88)							if ((y > by1)) {
HXLINE(  88)								if ((y > cy2)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((by1 > cy2)) {
HXLINE(  88)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::floor(by1);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(y);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter31 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(by1);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  88)								if ((by1 > cy2)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((y > cy2)) {
HXLINE(  88)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::ceil(y);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter31 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(y);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter31 = this1;
            								}
            							}
HXDLIN(  88)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  88)							if (hasUndo1) {
HXLINE(  88)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  88)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  88)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  88)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  88)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  88)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  88)								undoImage1 = this3;
HXDLIN(  88)								{
HXLINE(  88)									int rectLeft = xIter31->start;
HXDLIN(  88)									int rectTop = yIter31->start;
HXDLIN(  88)									int rectRight = xIter31->max;
HXDLIN(  88)									bool forceClear = false;
HXDLIN(  88)									{
HXLINE(  88)										int _g = rectTop;
HXDLIN(  88)										int _g1 = yIter31->max;
HXDLIN(  88)										while((_g < _g1)){
HXLINE(  88)											_g = (_g + 1);
HXDLIN(  88)											int dy = (_g - 1);
HXDLIN(  88)											{
HXLINE(  88)												int _g1 = rectLeft;
HXDLIN(  88)												int _g2 = rectRight;
HXDLIN(  88)												while((_g1 < _g2)){
HXLINE(  88)													_g1 = (_g1 + 1);
HXDLIN(  88)													int dx = (_g1 - 1);
HXDLIN(  88)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  88)													int index;
HXDLIN(  88)													if (temp->useVirtualPos) {
HXLINE(  88)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE(  88)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN(  88)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int col;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  88)														col = c;
            													}
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if (temp->useMask) {
HXLINE(  88)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  88)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  88)														int index;
HXDLIN(  88)														if (this1->useVirtualPos) {
HXLINE(  88)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  88)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  88)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  88)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  88)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)														int v;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  88)															v = c;
            														}
HXDLIN(  88)														int this3 = v;
HXDLIN(  88)														int maskPixel = this3;
HXDLIN(  88)														int this4 = col;
HXDLIN(  88)														int this5 = this4;
HXDLIN(  88)														if ((maskPixel == 0)) {
HXLINE(  88)															int this1 = this5;
HXDLIN(  88)															col = this1;
            														}
            														else {
HXLINE(  88)															Float m0;
HXDLIN(  88)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  88)															if ((this1 == 0)) {
HXLINE(  88)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m1;
HXDLIN(  88)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  88)															if ((this2 == 0)) {
HXLINE(  88)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m2;
HXDLIN(  88)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  88)															if ((this3 == 0)) {
HXLINE(  88)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m3;
HXDLIN(  88)															int this4 = (maskPixel & 255);
HXDLIN(  88)															if ((this4 == 0)) {
HXLINE(  88)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  88)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  88)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  88)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  88)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  88)													if ((col != 0)) {
HXLINE(  88)														int x = (dx - rectLeft);
HXDLIN(  88)														int y = (dy - rectTop);
HXDLIN(  88)														int this1 = col;
HXDLIN(  88)														int c = this1;
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  88)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															int location;
HXDLIN(  88)															if (undoImage1->useVirtualPos) {
HXLINE(  88)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  88)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)															int this3 = this2;
HXDLIN(  88)															int this4;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  88)																this4 = this3;
            															}
HXDLIN(  88)															Float a1;
HXDLIN(  88)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  88)															if ((this5 == 0)) {
HXLINE(  88)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r1;
HXDLIN(  88)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  88)															if ((this6 == 0)) {
HXLINE(  88)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g1;
HXDLIN(  88)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  88)															if ((this7 == 0)) {
HXLINE(  88)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b1;
HXDLIN(  88)															int this8 = (this4 & 255);
HXDLIN(  88)															if ((this8 == 0)) {
HXLINE(  88)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a2;
HXDLIN(  88)															int this9 = ((col >> 24) & 255);
HXDLIN(  88)															if ((this9 == 0)) {
HXLINE(  88)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r2;
HXDLIN(  88)															int this10 = ((col >> 16) & 255);
HXDLIN(  88)															if ((this10 == 0)) {
HXLINE(  88)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g2;
HXDLIN(  88)															int this11 = ((col >> 8) & 255);
HXDLIN(  88)															if ((this11 == 0)) {
HXLINE(  88)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b2;
HXDLIN(  88)															int this12 = (col & 255);
HXDLIN(  88)															if ((this12 == 0)) {
HXLINE(  88)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)															{
HXLINE(  88)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  88)																int value;
HXDLIN(  88)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  88)																	value = blended;
            																}
HXDLIN(  88)																bool _hx_tmp;
HXDLIN(  88)																if ((location >= 0)) {
HXLINE(  88)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  88)																	_hx_tmp = false;
            																}
HXDLIN(  88)																if (_hx_tmp) {
HXLINE(  88)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  88)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  88)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  88)															int index;
HXDLIN(  88)															if (undoImage1->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = c;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  88)														if (forceClear) {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  88)															int x = (dx - rectLeft);
HXDLIN(  88)															int y = (dy - rectTop);
HXDLIN(  88)															int index;
HXDLIN(  88)															if (undoImage1->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  88)							bool foundY1 = false;
HXDLIN(  88)							Float s1 = ((Float)0.);
HXDLIN(  88)							Float t1 = ((Float)0.);
HXDLIN(  88)							Float sxx1 = ((Float)0.);
HXDLIN(  88)							Float txx1 = ((Float)0.);
HXDLIN(  88)							{
HXLINE(  88)								int _g_min1 = xIter31->start;
HXDLIN(  88)								int _g_max1 = xIter31->max;
HXDLIN(  88)								while((_g_min1 < _g_max1)){
HXLINE(  88)									_g_min1 = (_g_min1 + 1);
HXDLIN(  88)									int x = (_g_min1 - 1);
HXLINE( 223)									sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)									txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)									foundY1 = false;
HXLINE(  88)									{
HXLINE(  88)										int _g_min = yIter31->start;
HXDLIN(  88)										int _g_max = yIter31->max;
HXDLIN(  88)										while((_g_min < _g_max)){
HXLINE(  88)											_g_min = (_g_min + 1);
HXDLIN(  88)											int y = (_g_min - 1);
HXLINE( 227)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  88)											bool _hx_tmp;
HXDLIN(  88)											if (!((s1 <= 0))) {
HXLINE(  88)												_hx_tmp = (t1 <= 0);
            											}
            											else {
HXLINE(  88)												_hx_tmp = true;
            											}
HXDLIN(  88)											if (_hx_tmp) {
HXLINE(  88)												if (foundY1) {
HXLINE(  88)													goto _hx_goto_22;
            												}
            											}
            											else {
HXLINE(  88)												if (((s1 + t1) < A1)) {
HXLINE(  88)													int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  88)													int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  88)													::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  88)													int index;
HXDLIN(  88)													if (tileImage->useVirtualPos) {
HXLINE(  88)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            													}
            													else {
HXLINE(  88)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            													}
HXDLIN(  88)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int color;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  88)														color = c;
            													}
HXDLIN(  88)													{
HXLINE(  88)														int this2 = color;
HXDLIN(  88)														int c1 = this2;
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  88)															_hx_tmp = temp->transparent;
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															int location;
HXDLIN(  88)															if (temp->useVirtualPos) {
HXLINE(  88)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE(  88)																location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN(  88)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)															int this3 = this2;
HXDLIN(  88)															int this4;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  88)																this4 = this3;
            															}
HXDLIN(  88)															Float a1;
HXDLIN(  88)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  88)															if ((this5 == 0)) {
HXLINE(  88)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r1;
HXDLIN(  88)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  88)															if ((this6 == 0)) {
HXLINE(  88)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g1;
HXDLIN(  88)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  88)															if ((this7 == 0)) {
HXLINE(  88)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b1;
HXDLIN(  88)															int this8 = (this4 & 255);
HXDLIN(  88)															if ((this8 == 0)) {
HXLINE(  88)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a2;
HXDLIN(  88)															int this9 = ((color >> 24) & 255);
HXDLIN(  88)															if ((this9 == 0)) {
HXLINE(  88)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r2;
HXDLIN(  88)															int this10 = ((color >> 16) & 255);
HXDLIN(  88)															if ((this10 == 0)) {
HXLINE(  88)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g2;
HXDLIN(  88)															int this11 = ((color >> 8) & 255);
HXDLIN(  88)															if ((this11 == 0)) {
HXLINE(  88)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b2;
HXDLIN(  88)															int this12 = (color & 255);
HXDLIN(  88)															if ((this12 == 0)) {
HXLINE(  88)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)															{
HXLINE(  88)																::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  88)																int value;
HXDLIN(  88)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  88)																	value = blended;
            																}
HXDLIN(  88)																bool _hx_tmp;
HXDLIN(  88)																if ((location >= 0)) {
HXLINE(  88)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  88)																	_hx_tmp = false;
            																}
HXDLIN(  88)																if (_hx_tmp) {
HXLINE(  88)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  88)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  88)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  88)															int index;
HXDLIN(  88)															if (temp->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = c1;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY1 = true;
            												}
            												else {
HXLINE(  88)													if (foundY1) {
HXLINE(  88)														goto _hx_goto_22;
            													}
            												}
            											}
            										}
            										_hx_goto_22:;
            									}
            								}
            							}
HXDLIN(  88)							if ((hasHit == false)) {
HXLINE(  88)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,y,bx2,by1,cx1,cy2,true);
HXDLIN(  88)								if (hasUndo1) {
HXLINE(  88)									v->undoImage = undoImage1;
HXDLIN(  88)									v->undoX = xIter31->start;
HXDLIN(  88)									v->undoY = yIter31->start;
            								}
            							}
            						}
            					}
HXDLIN(  88)					if ((hasHit == true)) {
HXLINE(  88)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x,y,bx,y,bx,cy,x,cy,true);
            					}
            				}
            			}
            		}
            		else {
HXLINE(  92)			if (this->tiledBorder) {
HXLINE(  93)				::pixelimage::ImageStruct pixelshape = temp;
HXDLIN(  93)				Float wid = this->width;
HXDLIN(  93)				Float hi = this->height;
HXDLIN(  93)				::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN(  93)				 ::Dynamic dx = ((Float)-1.);
HXDLIN(  93)				 ::Dynamic dy = ((Float)-1.);
HXDLIN(  93)				 ::Dynamic fat = ((Float)-1.);
HXDLIN(  93)				 ::Dynamic tall = ((Float)-1.);
HXDLIN(  93)				if (::hx::IsLess( dx,((Float)0.) )) {
HXLINE(  93)					Float smallest;
HXDLIN(  93)					if ((hi < wid)) {
HXLINE(  93)						smallest = hi;
            					}
            					else {
HXLINE(  93)						smallest = wid;
            					}
HXDLIN(  93)					Float goldenRatio = ((Float)1.61803398875);
HXLINE(  67)					dx = (smallest / (goldenRatio + 2));
            				}
HXLINE(  93)				if (::hx::IsLess( dy,((Float)0.) )) {
HXLINE(  69)					dy = dx;
            				}
HXLINE(  93)				if (::hx::IsLess( fat,((Float)0.) )) {
HXLINE(  70)					fat = (wid - (( (Float)(2) ) * ( (Float)(dx) )));
            				}
HXLINE(  93)				if (::hx::IsLess( tall,((Float)0.) )) {
HXLINE(  71)					tall = (hi - (( (Float)(2) ) * ( (Float)(dy) )));
            				}
HXLINE(  93)				Float rightRadius = ((wid - ( (Float)(fat) )) - ( (Float)(dx) ));
HXDLIN(  93)				Float bottomRadius = ((hi - ( (Float)(tall) )) - ( (Float)(dy) ));
HXDLIN(  93)				Float farX = (dx + fat);
HXDLIN(  93)				Float lowerY = (dy + tall);
HXDLIN(  93)				{
HXLINE(  93)					Float cx = ( (Float)(dx) );
HXDLIN(  93)					Float cy = ( (Float)(dy) );
HXDLIN(  93)					Float rx = ( (Float)(dx) );
HXDLIN(  93)					Float ry = ( (Float)(dy) );
HXDLIN(  93)					{
HXLINE(  93)						 ::Dynamic targetError = ((Float)1.05);
HXDLIN(  93)						if (::hx::IsNull( targetError )) {
HXLINE( 850)							targetError = ((Float)1.05);
            						}
HXLINE(  93)						Float rSmall;
HXDLIN(  93)						if ((rx > ry)) {
HXLINE(  93)							rSmall = ry;
            						}
            						else {
HXLINE(  93)							rSmall = rx;
            						}
HXDLIN(  93)						 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN(  93)						if (::hx::IsNull( targetE )) {
HXLINE(  20)							targetE = ((Float)1.05);
            						}
HXLINE(  93)						int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  93)						int noSides;
HXDLIN(  93)						if ((result < 12)) {
HXLINE(  93)							noSides = 12;
            						}
            						else {
HXLINE(  93)							if ((result > 500)) {
HXLINE(  93)								noSides = 500;
            							}
            							else {
HXLINE(  93)								noSides = result;
            							}
            						}
HXDLIN(  93)						int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN(  93)						Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN(  93)						Float omega = ::Math_obj::PI;
HXDLIN(  93)						int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN(  93)						Float lastX = ((Float)0.);
HXDLIN(  93)						Float lastY = ((Float)0.);
HXDLIN(  93)						{
HXLINE(  73)							lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  74)							lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            						}
HXLINE(  93)						{
HXLINE(  93)							int _g = 0;
HXDLIN(  93)							int _g1 = (quarter + 1);
HXDLIN(  93)							while((_g < _g1)){
HXLINE(  93)								_g = (_g + 1);
HXDLIN(  93)								int i = (_g - 1);
HXDLIN(  93)								Float nextX = (cx + (rx * ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  93)								Float nextY = (cy + (ry * ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  93)								{
HXLINE(  93)									bool hasHit = false;
HXDLIN(  93)									{
HXLINE(  93)										Float bx = lastX;
HXDLIN(  93)										Float by = lastY;
HXDLIN(  93)										Float cx1 = nextX;
HXDLIN(  93)										Float cy1 = nextY;
HXDLIN(  93)										bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  93)										if (!(adjustWinding)) {
HXLINE(  93)											Float bx_ = bx;
HXDLIN(  93)											Float by_ = by;
HXLINE( 188)											bx = cx1;
HXLINE( 189)											by = cy1;
HXLINE( 190)											cx1 = bx_;
HXLINE( 191)											cy1 = by_;
            										}
HXLINE(  93)										{
HXLINE(  93)											bool hasUndo = false;
HXDLIN(  93)											Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  93)											Float sx = (cy1 - cy);
HXDLIN(  93)											Float sy = (cx - cx1);
HXDLIN(  93)											Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  93)											Float tx = (cy - by);
HXDLIN(  93)											Float ty = (bx - cx);
HXDLIN(  93)											Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  93)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  93)											if ((cx > bx)) {
HXLINE(  93)												if ((cx > cx1)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((bx > cx1)) {
HXLINE(  93)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  93)												if ((bx > cx1)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((cx > cx1)) {
HXLINE(  93)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::ceil(cx);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(cx);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            											}
HXDLIN(  93)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  93)											if ((cy > by)) {
HXLINE(  93)												if ((cy > cy1)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((by > cy1)) {
HXLINE(  93)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  93)												if ((by > cy1)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((cy > cy1)) {
HXLINE(  93)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::ceil(cy);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(cy);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            											}
HXDLIN(  93)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  93)											if (hasUndo) {
HXLINE(  93)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  93)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  93)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)												undoImage = this3;
HXDLIN(  93)												{
HXLINE(  93)													int rectLeft = xIter3->start;
HXDLIN(  93)													int rectTop = yIter3->start;
HXDLIN(  93)													int rectRight = xIter3->max;
HXDLIN(  93)													bool forceClear = false;
HXDLIN(  93)													{
HXLINE(  93)														int _g = rectTop;
HXDLIN(  93)														int _g1 = yIter3->max;
HXDLIN(  93)														while((_g < _g1)){
HXLINE(  93)															_g = (_g + 1);
HXDLIN(  93)															int dy = (_g - 1);
HXDLIN(  93)															{
HXLINE(  93)																int _g1 = rectLeft;
HXDLIN(  93)																int _g2 = rectRight;
HXDLIN(  93)																while((_g1 < _g2)){
HXLINE(  93)																	_g1 = (_g1 + 1);
HXDLIN(  93)																	int dx = (_g1 - 1);
HXDLIN(  93)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																	int index;
HXDLIN(  93)																	if (pixelshape->useVirtualPos) {
HXLINE(  93)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  93)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																	int col;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		col = c;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if (pixelshape->useMask) {
HXLINE(  93)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)																		int index;
HXDLIN(  93)																		if (this1->useVirtualPos) {
HXLINE(  93)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  93)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  93)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																		int v;
HXDLIN(  93)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  93)																			v = c;
            																		}
HXDLIN(  93)																		int this3 = v;
HXDLIN(  93)																		int maskPixel = this3;
HXDLIN(  93)																		int this4 = col;
HXDLIN(  93)																		int this5 = this4;
HXDLIN(  93)																		if ((maskPixel == 0)) {
HXLINE(  93)																			int this1 = this5;
HXDLIN(  93)																			col = this1;
            																		}
            																		else {
HXLINE(  93)																			Float m0;
HXDLIN(  93)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																			if ((this1 == 0)) {
HXLINE(  93)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m1;
HXDLIN(  93)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																			if ((this2 == 0)) {
HXLINE(  93)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m2;
HXDLIN(  93)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																			if ((this3 == 0)) {
HXLINE(  93)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m3;
HXDLIN(  93)																			int this4 = (maskPixel & 255);
HXDLIN(  93)																			if ((this4 == 0)) {
HXLINE(  93)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  93)																	if ((col != 0)) {
HXLINE(  93)																		int x = (dx - rectLeft);
HXDLIN(  93)																		int y = (dy - rectTop);
HXDLIN(  93)																		int this1 = col;
HXDLIN(  93)																		int c = this1;
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			int location;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																			int this3 = this2;
HXDLIN(  93)																			int this4;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				this4 = this3;
            																			}
HXDLIN(  93)																			Float a1;
HXDLIN(  93)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																			if ((this5 == 0)) {
HXLINE(  93)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r1;
HXDLIN(  93)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																			if ((this6 == 0)) {
HXLINE(  93)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g1;
HXDLIN(  93)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																			if ((this7 == 0)) {
HXLINE(  93)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b1;
HXDLIN(  93)																			int this8 = (this4 & 255);
HXDLIN(  93)																			if ((this8 == 0)) {
HXLINE(  93)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a2;
HXDLIN(  93)																			int this9 = ((col >> 24) & 255);
HXDLIN(  93)																			if ((this9 == 0)) {
HXLINE(  93)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r2;
HXDLIN(  93)																			int this10 = ((col >> 16) & 255);
HXDLIN(  93)																			if ((this10 == 0)) {
HXLINE(  93)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g2;
HXDLIN(  93)																			int this11 = ((col >> 8) & 255);
HXDLIN(  93)																			if ((this11 == 0)) {
HXLINE(  93)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b2;
HXDLIN(  93)																			int this12 = (col & 255);
HXDLIN(  93)																			if ((this12 == 0)) {
HXLINE(  93)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																			{
HXLINE(  93)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  93)																				int value;
HXDLIN(  93)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  93)																					value = blended;
            																				}
HXDLIN(  93)																				bool _hx_tmp;
HXDLIN(  93)																				if ((location >= 0)) {
HXLINE(  93)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  93)																					_hx_tmp = false;
            																				}
HXDLIN(  93)																				if (_hx_tmp) {
HXLINE(  93)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			int value;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				value = c;
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  93)																		if (forceClear) {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			int x = (dx - rectLeft);
HXDLIN(  93)																			int y = (dy - rectTop);
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  93)											bool foundY = false;
HXDLIN(  93)											Float s = ((Float)0.);
HXDLIN(  93)											Float t = ((Float)0.);
HXDLIN(  93)											Float sxx = ((Float)0.);
HXDLIN(  93)											Float txx = ((Float)0.);
HXDLIN(  93)											{
HXLINE(  93)												int _g_min = xIter3->start;
HXDLIN(  93)												int _g_max = xIter3->max;
HXDLIN(  93)												while((_g_min < _g_max)){
HXLINE(  93)													_g_min = (_g_min + 1);
HXDLIN(  93)													int x = (_g_min - 1);
HXLINE( 223)													sxx = (sx * ( (Float)(x) ));
HXLINE( 224)													txx = (tx * ( (Float)(x) ));
HXLINE( 225)													foundY = false;
HXLINE(  93)													{
HXLINE(  93)														int _g_min1 = yIter3->start;
HXDLIN(  93)														int _g_max = yIter3->max;
HXDLIN(  93)														while((_g_min1 < _g_max)){
HXLINE(  93)															_g_min1 = (_g_min1 + 1);
HXDLIN(  93)															int y = (_g_min1 - 1);
HXLINE( 227)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  93)															bool _hx_tmp;
HXDLIN(  93)															if (!((s <= 0))) {
HXLINE(  93)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  93)																_hx_tmp = true;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																if (foundY) {
HXLINE(  93)																	goto _hx_goto_27;
            																}
            															}
            															else {
HXLINE(  93)																if (((s + t) < A)) {
HXLINE(  93)																	int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)																	int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)																	::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)																	int index;
HXDLIN(  93)																	if (tileImage->useVirtualPos) {
HXLINE(  93)																		index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																	}
            																	else {
HXLINE(  93)																		index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																	}
HXDLIN(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																	int color;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		color = c;
            																	}
HXDLIN(  93)																	{
HXLINE(  93)																		int this2 = color;
HXDLIN(  93)																		int c1 = this2;
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			int location;
HXDLIN(  93)																			if (pixelshape->useVirtualPos) {
HXLINE(  93)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  93)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  93)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																			int this3 = this2;
HXDLIN(  93)																			int this4;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				this4 = this3;
            																			}
HXDLIN(  93)																			Float a1;
HXDLIN(  93)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																			if ((this5 == 0)) {
HXLINE(  93)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r1;
HXDLIN(  93)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																			if ((this6 == 0)) {
HXLINE(  93)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g1;
HXDLIN(  93)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																			if ((this7 == 0)) {
HXLINE(  93)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b1;
HXDLIN(  93)																			int this8 = (this4 & 255);
HXDLIN(  93)																			if ((this8 == 0)) {
HXLINE(  93)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a2;
HXDLIN(  93)																			int this9 = ((color >> 24) & 255);
HXDLIN(  93)																			if ((this9 == 0)) {
HXLINE(  93)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r2;
HXDLIN(  93)																			int this10 = ((color >> 16) & 255);
HXDLIN(  93)																			if ((this10 == 0)) {
HXLINE(  93)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g2;
HXDLIN(  93)																			int this11 = ((color >> 8) & 255);
HXDLIN(  93)																			if ((this11 == 0)) {
HXLINE(  93)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b2;
HXDLIN(  93)																			int this12 = (color & 255);
HXDLIN(  93)																			if ((this12 == 0)) {
HXLINE(  93)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																			{
HXLINE(  93)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																				int value;
HXDLIN(  93)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  93)																					value = blended;
            																				}
HXDLIN(  93)																				bool _hx_tmp;
HXDLIN(  93)																				if ((location >= 0)) {
HXLINE(  93)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  93)																					_hx_tmp = false;
            																				}
HXDLIN(  93)																				if (_hx_tmp) {
HXLINE(  93)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (pixelshape->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  93)																			int value;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				value = c1;
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE( 237)																	foundY = true;
            																}
            																else {
HXLINE(  93)																	if (foundY) {
HXLINE(  93)																		goto _hx_goto_27;
            																	}
            																}
            															}
            														}
            														_hx_goto_27:;
            													}
            												}
            											}
HXDLIN(  93)											if ((hasHit == false)) {
HXLINE(  93)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  93)												if (hasUndo) {
HXLINE(  93)													v->undoImage = undoImage;
HXDLIN(  93)													v->undoX = xIter3->start;
HXDLIN(  93)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								lastX = nextX;
HXLINE(  94)								lastY = nextY;
            							}
            						}
            					}
            				}
HXLINE(  93)				{
HXLINE(  93)					Float x = ( (Float)(dx) );
HXDLIN(  93)					bool hasHit = false;
HXDLIN(  93)					Float bx = (x + ( (Float)(fat) ));
HXDLIN(  93)					Float cy1 = ( (Float)(dy) );
HXDLIN(  93)					{
HXLINE(  93)						{
HXLINE(  93)							Float bx1 = bx;
HXDLIN(  93)							Float by = ( (Float)(0) );
HXDLIN(  93)							Float cx1 = x;
HXDLIN(  93)							Float cy2 = cy1;
HXDLIN(  93)							bool adjustWinding = (((((x * by) - (bx1 * ( (Float)(0) ))) + ((bx1 * cy2) - (cx1 * by))) + ((cx1 * ( (Float)(0) )) - (x * cy2))) > 0);
HXDLIN(  93)							if (!(adjustWinding)) {
HXLINE(  93)								Float bx_ = bx1;
HXDLIN(  93)								Float by_ = by;
HXLINE( 188)								bx1 = cx1;
HXLINE( 189)								by = cy2;
HXLINE( 190)								cx1 = bx_;
HXLINE( 191)								cy2 = by_;
            							}
HXLINE(  93)							{
HXLINE(  93)								bool hasUndo = false;
HXDLIN(  93)								Float s0 = ((( (Float)(0) ) * cx1) - (x * cy2));
HXDLIN(  93)								Float sx = cy2;
HXDLIN(  93)								Float sy = (x - cx1);
HXDLIN(  93)								Float t0 = ((x * by) - (( (Float)(0) ) * bx1));
HXDLIN(  93)								Float tx = (( (Float)(0) ) - by);
HXDLIN(  93)								Float ty = (bx1 - x);
HXDLIN(  93)								Float A = ((((-(by) * cx1) + (( (Float)(0) ) * (-(bx1) + cx1))) + (x * (by - cy2))) + (bx1 * cy2));
HXDLIN(  93)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  93)								if ((x > bx1)) {
HXLINE(  93)									if ((x > cx1)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx1 > cx1)) {
HXLINE(  93)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(bx1);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(x);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter3 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((bx1 > cx1)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((x > cx1)) {
HXLINE(  93)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(x);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter3 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(x);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter3 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  93)								if ((0 > by)) {
HXLINE(  93)									if ((0 > cy2)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((by > cy2)) {
HXLINE(  93)											min = ::Math_obj::floor(cy2);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter3 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((by > cy2)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((0 > cy2)) {
HXLINE(  93)											min = ::Math_obj::floor(cy2);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(( (Float)(0) ));
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter3 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter3 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  93)								if (hasUndo) {
HXLINE(  93)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  93)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  93)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)									undoImage = this3;
HXDLIN(  93)									{
HXLINE(  93)										int rectLeft = xIter3->start;
HXDLIN(  93)										int rectTop = yIter3->start;
HXDLIN(  93)										int rectRight = xIter3->max;
HXDLIN(  93)										bool forceClear = false;
HXDLIN(  93)										{
HXLINE(  93)											int _g = rectTop;
HXDLIN(  93)											int _g1 = yIter3->max;
HXDLIN(  93)											while((_g < _g1)){
HXLINE(  93)												_g = (_g + 1);
HXDLIN(  93)												int dy = (_g - 1);
HXDLIN(  93)												{
HXLINE(  93)													int _g1 = rectLeft;
HXDLIN(  93)													int _g2 = rectRight;
HXDLIN(  93)													while((_g1 < _g2)){
HXLINE(  93)														_g1 = (_g1 + 1);
HXDLIN(  93)														int dx = (_g1 - 1);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (pixelshape->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int col;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															col = c;
            														}
HXDLIN(  93)														bool _hx_tmp;
HXDLIN(  93)														if (pixelshape->useMask) {
HXLINE(  93)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  93)															_hx_tmp = false;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)															int index;
HXDLIN(  93)															if (this1->useVirtualPos) {
HXLINE(  93)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  93)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  93)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)															int v;
HXDLIN(  93)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  93)																v = c;
            															}
HXDLIN(  93)															int this3 = v;
HXDLIN(  93)															int maskPixel = this3;
HXDLIN(  93)															int this4 = col;
HXDLIN(  93)															int this5 = this4;
HXDLIN(  93)															if ((maskPixel == 0)) {
HXLINE(  93)																int this1 = this5;
HXDLIN(  93)																col = this1;
            															}
            															else {
HXLINE(  93)																Float m0;
HXDLIN(  93)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																if ((this1 == 0)) {
HXLINE(  93)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m1;
HXDLIN(  93)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																if ((this2 == 0)) {
HXLINE(  93)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m2;
HXDLIN(  93)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																if ((this3 == 0)) {
HXLINE(  93)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m3;
HXDLIN(  93)																int this4 = (maskPixel & 255);
HXDLIN(  93)																if ((this4 == 0)) {
HXLINE(  93)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  93)														if ((col != 0)) {
HXLINE(  93)															int x = (dx - rectLeft);
HXDLIN(  93)															int y = (dy - rectTop);
HXDLIN(  93)															int this1 = col;
HXDLIN(  93)															int c = this1;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = undoImage->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (undoImage->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((col >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((col >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((col >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (col & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  93)															if (forceClear) {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																int x = (dx - rectLeft);
HXDLIN(  93)																int y = (dy - rectTop);
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								bool foundY = false;
HXDLIN(  93)								Float s = ((Float)0.);
HXDLIN(  93)								Float t = ((Float)0.);
HXDLIN(  93)								Float sxx = ((Float)0.);
HXDLIN(  93)								Float txx = ((Float)0.);
HXDLIN(  93)								{
HXLINE(  93)									int _g_min = xIter3->start;
HXDLIN(  93)									int _g_max = xIter3->max;
HXDLIN(  93)									while((_g_min < _g_max)){
HXLINE(  93)										_g_min = (_g_min + 1);
HXDLIN(  93)										int x = (_g_min - 1);
HXLINE( 223)										sxx = (sx * ( (Float)(x) ));
HXLINE( 224)										txx = (tx * ( (Float)(x) ));
HXLINE( 225)										foundY = false;
HXLINE(  93)										{
HXLINE(  93)											int _g_min1 = yIter3->start;
HXDLIN(  93)											int _g_max = yIter3->max;
HXDLIN(  93)											while((_g_min1 < _g_max)){
HXLINE(  93)												_g_min1 = (_g_min1 + 1);
HXDLIN(  93)												int y = (_g_min1 - 1);
HXLINE( 227)												s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)												t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  93)												bool _hx_tmp;
HXDLIN(  93)												if (!((s <= 0))) {
HXLINE(  93)													_hx_tmp = (t <= 0);
            												}
            												else {
HXLINE(  93)													_hx_tmp = true;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													if (foundY) {
HXLINE(  93)														goto _hx_goto_31;
            													}
            												}
            												else {
HXLINE(  93)													if (((s + t) < A)) {
HXLINE(  93)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (tileImage->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int color;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															color = c;
            														}
HXDLIN(  93)														{
HXLINE(  93)															int this2 = color;
HXDLIN(  93)															int c1 = this2;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((color >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((color >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((color >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (color & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c1;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY = true;
            													}
            													else {
HXLINE(  93)														if (foundY) {
HXLINE(  93)															goto _hx_goto_31;
            														}
            													}
            												}
            											}
            											_hx_goto_31:;
            										}
            									}
            								}
HXDLIN(  93)								if ((hasHit == false)) {
HXLINE(  93)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x,( (Float)(0) ),bx1,by,cx1,cy2,true);
HXDLIN(  93)									if (hasUndo) {
HXLINE(  93)										v->undoImage = undoImage;
HXDLIN(  93)										v->undoX = xIter3->start;
HXDLIN(  93)										v->undoY = yIter3->start;
            									}
            								}
            							}
            						}
HXDLIN(  93)						{
HXLINE(  93)							Float bx2 = bx;
HXDLIN(  93)							Float by1 = cy1;
HXDLIN(  93)							Float cx2 = x;
HXDLIN(  93)							Float cy3 = cy1;
HXDLIN(  93)							bool adjustWinding1 = (((((bx * by1) - (bx2 * ( (Float)(0) ))) + ((bx2 * cy3) - (cx2 * by1))) + ((cx2 * ( (Float)(0) )) - (bx * cy3))) > 0);
HXDLIN(  93)							if (!(adjustWinding1)) {
HXLINE(  93)								Float bx_ = bx2;
HXDLIN(  93)								Float by_ = by1;
HXLINE( 188)								bx2 = cx2;
HXLINE( 189)								by1 = cy3;
HXLINE( 190)								cx2 = bx_;
HXLINE( 191)								cy3 = by_;
            							}
HXLINE(  93)							{
HXLINE(  93)								bool hasUndo1 = false;
HXDLIN(  93)								Float s01 = ((( (Float)(0) ) * cx2) - (bx * cy3));
HXDLIN(  93)								Float sx1 = cy3;
HXDLIN(  93)								Float sy1 = (bx - cx2);
HXDLIN(  93)								Float t01 = ((bx * by1) - (( (Float)(0) ) * bx2));
HXDLIN(  93)								Float tx1 = (( (Float)(0) ) - by1);
HXDLIN(  93)								Float ty1 = (bx2 - bx);
HXDLIN(  93)								Float A1 = ((((-(by1) * cx2) + (( (Float)(0) ) * (-(bx2) + cx2))) + (bx * (by1 - cy3))) + (bx2 * cy3));
HXDLIN(  93)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  93)								if ((bx > bx2)) {
HXLINE(  93)									if ((bx > cx2)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx2 > cx2)) {
HXLINE(  93)											min = ::Math_obj::floor(cx2);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(bx2);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter31 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((bx2 > cx2)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx > cx2)) {
HXLINE(  93)											min = ::Math_obj::floor(cx2);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter31 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter31 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  93)								if ((0 > by1)) {
HXLINE(  93)									if ((0 > cy3)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((by1 > cy3)) {
HXLINE(  93)											min = ::Math_obj::floor(cy3);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(by1);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter31 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(by1);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((by1 > cy3)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((0 > cy3)) {
HXLINE(  93)											min = ::Math_obj::floor(cy3);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(( (Float)(0) ));
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter31 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter31 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  93)								if (hasUndo1) {
HXLINE(  93)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  93)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  93)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)									undoImage1 = this3;
HXDLIN(  93)									{
HXLINE(  93)										int rectLeft = xIter31->start;
HXDLIN(  93)										int rectTop = yIter31->start;
HXDLIN(  93)										int rectRight = xIter31->max;
HXDLIN(  93)										bool forceClear = false;
HXDLIN(  93)										{
HXLINE(  93)											int _g = rectTop;
HXDLIN(  93)											int _g1 = yIter31->max;
HXDLIN(  93)											while((_g < _g1)){
HXLINE(  93)												_g = (_g + 1);
HXDLIN(  93)												int dy = (_g - 1);
HXDLIN(  93)												{
HXLINE(  93)													int _g1 = rectLeft;
HXDLIN(  93)													int _g2 = rectRight;
HXDLIN(  93)													while((_g1 < _g2)){
HXLINE(  93)														_g1 = (_g1 + 1);
HXDLIN(  93)														int dx = (_g1 - 1);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (pixelshape->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int col;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															col = c;
            														}
HXDLIN(  93)														bool _hx_tmp;
HXDLIN(  93)														if (pixelshape->useMask) {
HXLINE(  93)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  93)															_hx_tmp = false;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)															int index;
HXDLIN(  93)															if (this1->useVirtualPos) {
HXLINE(  93)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  93)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  93)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)															int v;
HXDLIN(  93)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  93)																v = c;
            															}
HXDLIN(  93)															int this3 = v;
HXDLIN(  93)															int maskPixel = this3;
HXDLIN(  93)															int this4 = col;
HXDLIN(  93)															int this5 = this4;
HXDLIN(  93)															if ((maskPixel == 0)) {
HXLINE(  93)																int this1 = this5;
HXDLIN(  93)																col = this1;
            															}
            															else {
HXLINE(  93)																Float m0;
HXDLIN(  93)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																if ((this1 == 0)) {
HXLINE(  93)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m1;
HXDLIN(  93)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																if ((this2 == 0)) {
HXLINE(  93)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m2;
HXDLIN(  93)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																if ((this3 == 0)) {
HXLINE(  93)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m3;
HXDLIN(  93)																int this4 = (maskPixel & 255);
HXDLIN(  93)																if ((this4 == 0)) {
HXLINE(  93)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  93)														if ((col != 0)) {
HXLINE(  93)															int x = (dx - rectLeft);
HXDLIN(  93)															int y = (dy - rectTop);
HXDLIN(  93)															int this1 = col;
HXDLIN(  93)															int c = this1;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = undoImage1->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (undoImage1->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((col >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((col >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((col >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (col & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage1->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  93)															if (forceClear) {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  93)																int x = (dx - rectLeft);
HXDLIN(  93)																int y = (dy - rectTop);
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage1->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								bool foundY1 = false;
HXDLIN(  93)								Float s1 = ((Float)0.);
HXDLIN(  93)								Float t1 = ((Float)0.);
HXDLIN(  93)								Float sxx1 = ((Float)0.);
HXDLIN(  93)								Float txx1 = ((Float)0.);
HXDLIN(  93)								{
HXLINE(  93)									int _g_min1 = xIter31->start;
HXDLIN(  93)									int _g_max1 = xIter31->max;
HXDLIN(  93)									while((_g_min1 < _g_max1)){
HXLINE(  93)										_g_min1 = (_g_min1 + 1);
HXDLIN(  93)										int x = (_g_min1 - 1);
HXLINE( 223)										sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)										txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)										foundY1 = false;
HXLINE(  93)										{
HXLINE(  93)											int _g_min = yIter31->start;
HXDLIN(  93)											int _g_max = yIter31->max;
HXDLIN(  93)											while((_g_min < _g_max)){
HXLINE(  93)												_g_min = (_g_min + 1);
HXDLIN(  93)												int y = (_g_min - 1);
HXLINE( 227)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  93)												bool _hx_tmp;
HXDLIN(  93)												if (!((s1 <= 0))) {
HXLINE(  93)													_hx_tmp = (t1 <= 0);
            												}
            												else {
HXLINE(  93)													_hx_tmp = true;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													if (foundY1) {
HXLINE(  93)														goto _hx_goto_35;
            													}
            												}
            												else {
HXLINE(  93)													if (((s1 + t1) < A1)) {
HXLINE(  93)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (tileImage->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int color;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															color = c;
            														}
HXDLIN(  93)														{
HXLINE(  93)															int this2 = color;
HXDLIN(  93)															int c1 = this2;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((color >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((color >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((color >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (color & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c1;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY1 = true;
            													}
            													else {
HXLINE(  93)														if (foundY1) {
HXLINE(  93)															goto _hx_goto_35;
            														}
            													}
            												}
            											}
            											_hx_goto_35:;
            										}
            									}
            								}
HXDLIN(  93)								if ((hasHit == false)) {
HXLINE(  93)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,( (Float)(0) ),bx2,by1,cx2,cy3,true);
HXDLIN(  93)									if (hasUndo1) {
HXLINE(  93)										v->undoImage = undoImage1;
HXDLIN(  93)										v->undoX = xIter31->start;
HXDLIN(  93)										v->undoY = yIter31->start;
            									}
            								}
            							}
            						}
HXDLIN(  93)						if ((hasHit == true)) {
HXLINE(  93)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x,( (Float)(0) ),bx,( (Float)(0) ),bx,cy1,x,cy1,true);
            						}
            					}
            				}
HXDLIN(  93)				{
HXLINE(  93)					Float cy4 = ( (Float)(dy) );
HXDLIN(  93)					Float ry1 = ( (Float)(dy) );
HXDLIN(  93)					{
HXLINE(  93)						 ::Dynamic targetError1 = ((Float)1.05);
HXDLIN(  93)						if (::hx::IsNull( targetError1 )) {
HXLINE( 850)							targetError1 = ((Float)1.05);
            						}
HXLINE(  93)						Float rSmall1;
HXDLIN(  93)						if ((rightRadius > ry1)) {
HXLINE(  93)							rSmall1 = ry1;
            						}
            						else {
HXLINE(  93)							rSmall1 = rightRadius;
            						}
HXDLIN(  93)						 ::Dynamic targetE1 = ( (Float)(targetError1) );
HXDLIN(  93)						if (::hx::IsNull( targetE1 )) {
HXLINE(  20)							targetE1 = ((Float)1.05);
            						}
HXLINE(  93)						int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN(  93)						int noSides1;
HXDLIN(  93)						if ((result1 < 12)) {
HXLINE(  93)							noSides1 = 12;
            						}
            						else {
HXLINE(  93)							if ((result1 > 500)) {
HXLINE(  93)								noSides1 = 500;
            							}
            							else {
HXLINE(  93)								noSides1 = result1;
            							}
            						}
HXDLIN(  93)						int sides1 = (::Math_obj::ceil((( (Float)(noSides1) ) / ( (Float)(4) ))) * 4);
HXDLIN(  93)						Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  93)						Float omega1 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN(  93)						int quarter1 = ::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(4) )));
HXDLIN(  93)						Float lastX1 = ((Float)0.);
HXDLIN(  93)						Float lastY1 = ((Float)0.);
HXDLIN(  93)						{
HXLINE(  73)							lastX1 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides1) ) * theta1) + omega1))));
HXLINE(  74)							lastY1 = (cy4 + (ry1 * ::Math_obj::sin(((( (Float)(sides1) ) * theta1) + omega1))));
            						}
HXLINE(  93)						{
HXLINE(  93)							int _g2 = 0;
HXDLIN(  93)							int _g3 = (quarter1 + 1);
HXDLIN(  93)							while((_g2 < _g3)){
HXLINE(  93)								_g2 = (_g2 + 1);
HXDLIN(  93)								int i = (_g2 - 1);
HXDLIN(  93)								Float nextX = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  93)								Float nextY = (cy4 + (ry1 * ::Math_obj::sin((((( (Float)(i) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  93)								{
HXLINE(  93)									bool hasHit = false;
HXDLIN(  93)									{
HXLINE(  93)										Float bx = lastX1;
HXDLIN(  93)										Float by = lastY1;
HXDLIN(  93)										Float cx = nextX;
HXDLIN(  93)										Float cy = nextY;
HXDLIN(  93)										bool adjustWinding = (((((farX * by) - (bx * cy4)) + ((bx * cy) - (cx * by))) + ((cx * cy4) - (farX * cy))) > 0);
HXDLIN(  93)										if (!(adjustWinding)) {
HXLINE(  93)											Float bx_ = bx;
HXDLIN(  93)											Float by_ = by;
HXLINE( 188)											bx = cx;
HXLINE( 189)											by = cy;
HXLINE( 190)											cx = bx_;
HXLINE( 191)											cy = by_;
            										}
HXLINE(  93)										{
HXLINE(  93)											bool hasUndo = false;
HXDLIN(  93)											Float s0 = ((cy4 * cx) - (farX * cy));
HXDLIN(  93)											Float sx = (cy - cy4);
HXDLIN(  93)											Float sy = (farX - cx);
HXDLIN(  93)											Float t0 = ((farX * by) - (cy4 * bx));
HXDLIN(  93)											Float tx = (cy4 - by);
HXDLIN(  93)											Float ty = (bx - farX);
HXDLIN(  93)											Float A = ((((-(by) * cx) + (cy4 * (-(bx) + cx))) + (farX * (by - cy))) + (bx * cy));
HXDLIN(  93)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  93)											if ((farX > bx)) {
HXLINE(  93)												if ((farX > cx)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((bx > cx)) {
HXLINE(  93)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(farX);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  93)												if ((bx > cx)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((farX > cx)) {
HXLINE(  93)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::ceil(farX);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(farX);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            											}
HXDLIN(  93)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  93)											if ((cy4 > by)) {
HXLINE(  93)												if ((cy4 > cy)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((by > cy)) {
HXLINE(  93)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cy4);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  93)												if ((by > cy)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((cy4 > cy)) {
HXLINE(  93)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::ceil(cy4);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(cy4);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            											}
HXDLIN(  93)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  93)											if (hasUndo) {
HXLINE(  93)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  93)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  93)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)												undoImage = this3;
HXDLIN(  93)												{
HXLINE(  93)													int rectLeft = xIter3->start;
HXDLIN(  93)													int rectTop = yIter3->start;
HXDLIN(  93)													int rectRight = xIter3->max;
HXDLIN(  93)													bool forceClear = false;
HXDLIN(  93)													{
HXLINE(  93)														int _g = rectTop;
HXDLIN(  93)														int _g1 = yIter3->max;
HXDLIN(  93)														while((_g < _g1)){
HXLINE(  93)															_g = (_g + 1);
HXDLIN(  93)															int dy = (_g - 1);
HXDLIN(  93)															{
HXLINE(  93)																int _g1 = rectLeft;
HXDLIN(  93)																int _g2 = rectRight;
HXDLIN(  93)																while((_g1 < _g2)){
HXLINE(  93)																	_g1 = (_g1 + 1);
HXDLIN(  93)																	int dx = (_g1 - 1);
HXDLIN(  93)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																	int index;
HXDLIN(  93)																	if (pixelshape->useVirtualPos) {
HXLINE(  93)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  93)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																	int col;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		col = c;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if (pixelshape->useMask) {
HXLINE(  93)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)																		int index;
HXDLIN(  93)																		if (this1->useVirtualPos) {
HXLINE(  93)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  93)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  93)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																		int v;
HXDLIN(  93)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  93)																			v = c;
            																		}
HXDLIN(  93)																		int this3 = v;
HXDLIN(  93)																		int maskPixel = this3;
HXDLIN(  93)																		int this4 = col;
HXDLIN(  93)																		int this5 = this4;
HXDLIN(  93)																		if ((maskPixel == 0)) {
HXLINE(  93)																			int this1 = this5;
HXDLIN(  93)																			col = this1;
            																		}
            																		else {
HXLINE(  93)																			Float m0;
HXDLIN(  93)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																			if ((this1 == 0)) {
HXLINE(  93)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m1;
HXDLIN(  93)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																			if ((this2 == 0)) {
HXLINE(  93)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m2;
HXDLIN(  93)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																			if ((this3 == 0)) {
HXLINE(  93)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m3;
HXDLIN(  93)																			int this4 = (maskPixel & 255);
HXDLIN(  93)																			if ((this4 == 0)) {
HXLINE(  93)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  93)																	if ((col != 0)) {
HXLINE(  93)																		int x = (dx - rectLeft);
HXDLIN(  93)																		int y = (dy - rectTop);
HXDLIN(  93)																		int this1 = col;
HXDLIN(  93)																		int c = this1;
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			int location;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																			int this3 = this2;
HXDLIN(  93)																			int this4;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				this4 = this3;
            																			}
HXDLIN(  93)																			Float a1;
HXDLIN(  93)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																			if ((this5 == 0)) {
HXLINE(  93)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r1;
HXDLIN(  93)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																			if ((this6 == 0)) {
HXLINE(  93)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g1;
HXDLIN(  93)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																			if ((this7 == 0)) {
HXLINE(  93)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b1;
HXDLIN(  93)																			int this8 = (this4 & 255);
HXDLIN(  93)																			if ((this8 == 0)) {
HXLINE(  93)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a2;
HXDLIN(  93)																			int this9 = ((col >> 24) & 255);
HXDLIN(  93)																			if ((this9 == 0)) {
HXLINE(  93)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r2;
HXDLIN(  93)																			int this10 = ((col >> 16) & 255);
HXDLIN(  93)																			if ((this10 == 0)) {
HXLINE(  93)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g2;
HXDLIN(  93)																			int this11 = ((col >> 8) & 255);
HXDLIN(  93)																			if ((this11 == 0)) {
HXLINE(  93)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b2;
HXDLIN(  93)																			int this12 = (col & 255);
HXDLIN(  93)																			if ((this12 == 0)) {
HXLINE(  93)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																			{
HXLINE(  93)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  93)																				int value;
HXDLIN(  93)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  93)																					value = blended;
            																				}
HXDLIN(  93)																				bool _hx_tmp;
HXDLIN(  93)																				if ((location >= 0)) {
HXLINE(  93)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  93)																					_hx_tmp = false;
            																				}
HXDLIN(  93)																				if (_hx_tmp) {
HXLINE(  93)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			int value;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				value = c;
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  93)																		if (forceClear) {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			int x = (dx - rectLeft);
HXDLIN(  93)																			int y = (dy - rectTop);
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  93)											bool foundY = false;
HXDLIN(  93)											Float s = ((Float)0.);
HXDLIN(  93)											Float t = ((Float)0.);
HXDLIN(  93)											Float sxx = ((Float)0.);
HXDLIN(  93)											Float txx = ((Float)0.);
HXDLIN(  93)											{
HXLINE(  93)												int _g_min = xIter3->start;
HXDLIN(  93)												int _g_max = xIter3->max;
HXDLIN(  93)												while((_g_min < _g_max)){
HXLINE(  93)													_g_min = (_g_min + 1);
HXDLIN(  93)													int x = (_g_min - 1);
HXLINE( 223)													sxx = (sx * ( (Float)(x) ));
HXLINE( 224)													txx = (tx * ( (Float)(x) ));
HXLINE( 225)													foundY = false;
HXLINE(  93)													{
HXLINE(  93)														int _g_min1 = yIter3->start;
HXDLIN(  93)														int _g_max = yIter3->max;
HXDLIN(  93)														while((_g_min1 < _g_max)){
HXLINE(  93)															_g_min1 = (_g_min1 + 1);
HXDLIN(  93)															int y = (_g_min1 - 1);
HXLINE( 227)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  93)															bool _hx_tmp;
HXDLIN(  93)															if (!((s <= 0))) {
HXLINE(  93)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  93)																_hx_tmp = true;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																if (foundY) {
HXLINE(  93)																	goto _hx_goto_40;
            																}
            															}
            															else {
HXLINE(  93)																if (((s + t) < A)) {
HXLINE(  93)																	int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)																	int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)																	::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)																	int index;
HXDLIN(  93)																	if (tileImage->useVirtualPos) {
HXLINE(  93)																		index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																	}
            																	else {
HXLINE(  93)																		index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																	}
HXDLIN(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																	int color;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		color = c;
            																	}
HXDLIN(  93)																	{
HXLINE(  93)																		int this2 = color;
HXDLIN(  93)																		int c1 = this2;
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			int location;
HXDLIN(  93)																			if (pixelshape->useVirtualPos) {
HXLINE(  93)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  93)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  93)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																			int this3 = this2;
HXDLIN(  93)																			int this4;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				this4 = this3;
            																			}
HXDLIN(  93)																			Float a1;
HXDLIN(  93)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																			if ((this5 == 0)) {
HXLINE(  93)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r1;
HXDLIN(  93)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																			if ((this6 == 0)) {
HXLINE(  93)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g1;
HXDLIN(  93)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																			if ((this7 == 0)) {
HXLINE(  93)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b1;
HXDLIN(  93)																			int this8 = (this4 & 255);
HXDLIN(  93)																			if ((this8 == 0)) {
HXLINE(  93)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a2;
HXDLIN(  93)																			int this9 = ((color >> 24) & 255);
HXDLIN(  93)																			if ((this9 == 0)) {
HXLINE(  93)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r2;
HXDLIN(  93)																			int this10 = ((color >> 16) & 255);
HXDLIN(  93)																			if ((this10 == 0)) {
HXLINE(  93)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g2;
HXDLIN(  93)																			int this11 = ((color >> 8) & 255);
HXDLIN(  93)																			if ((this11 == 0)) {
HXLINE(  93)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b2;
HXDLIN(  93)																			int this12 = (color & 255);
HXDLIN(  93)																			if ((this12 == 0)) {
HXLINE(  93)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																			{
HXLINE(  93)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																				int value;
HXDLIN(  93)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  93)																					value = blended;
            																				}
HXDLIN(  93)																				bool _hx_tmp;
HXDLIN(  93)																				if ((location >= 0)) {
HXLINE(  93)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  93)																					_hx_tmp = false;
            																				}
HXDLIN(  93)																				if (_hx_tmp) {
HXLINE(  93)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (pixelshape->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  93)																			int value;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				value = c1;
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE( 237)																	foundY = true;
            																}
            																else {
HXLINE(  93)																	if (foundY) {
HXLINE(  93)																		goto _hx_goto_40;
            																	}
            																}
            															}
            														}
            														_hx_goto_40:;
            													}
            												}
            											}
HXDLIN(  93)											if ((hasHit == false)) {
HXLINE(  93)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX,cy4,bx,by,cx,cy,true);
HXDLIN(  93)												if (hasUndo) {
HXLINE(  93)													v->undoImage = undoImage;
HXDLIN(  93)													v->undoX = xIter3->start;
HXDLIN(  93)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								lastX1 = nextX;
HXLINE(  94)								lastY1 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  93)				{
HXLINE(  93)					Float y = ( (Float)(dy) );
HXDLIN(  93)					bool hasHit1 = false;
HXDLIN(  93)					Float bx3 = wid;
HXDLIN(  93)					Float cy5 = (y + ( (Float)(tall) ));
HXDLIN(  93)					{
HXLINE(  93)						{
HXLINE(  93)							Float bx4 = bx3;
HXDLIN(  93)							Float by2 = y;
HXDLIN(  93)							Float cx3 = ( (Float)(0) );
HXDLIN(  93)							Float cy6 = cy5;
HXDLIN(  93)							bool adjustWinding2 = (((((( (Float)(0) ) * by2) - (bx4 * y)) + ((bx4 * cy6) - (cx3 * by2))) + ((cx3 * y) - (( (Float)(0) ) * cy6))) > 0);
HXDLIN(  93)							if (!(adjustWinding2)) {
HXLINE(  93)								Float bx_ = bx4;
HXDLIN(  93)								Float by_ = by2;
HXLINE( 188)								bx4 = cx3;
HXLINE( 189)								by2 = cy6;
HXLINE( 190)								cx3 = bx_;
HXLINE( 191)								cy6 = by_;
            							}
HXLINE(  93)							{
HXLINE(  93)								bool hasUndo2 = false;
HXDLIN(  93)								Float s02 = ((y * cx3) - (( (Float)(0) ) * cy6));
HXDLIN(  93)								Float sx2 = (cy6 - y);
HXDLIN(  93)								Float sy2 = (( (Float)(0) ) - cx3);
HXDLIN(  93)								Float t02 = ((( (Float)(0) ) * by2) - (y * bx4));
HXDLIN(  93)								Float tx2 = (y - by2);
HXDLIN(  93)								Float ty2 = bx4;
HXDLIN(  93)								Float A2 = ((((-(by2) * cx3) + (y * (-(bx4) + cx3))) + (( (Float)(0) ) * (by2 - cy6))) + (bx4 * cy6));
HXDLIN(  93)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  93)								if ((0 > bx4)) {
HXLINE(  93)									if ((0 > cx3)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx4 > cx3)) {
HXLINE(  93)											min = ::Math_obj::floor(cx3);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(bx4);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter32 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx4);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((bx4 > cx3)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((0 > cx3)) {
HXLINE(  93)											min = ::Math_obj::floor(cx3);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(( (Float)(0) ));
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx4);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter32 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter32 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  93)								if ((y > by2)) {
HXLINE(  93)									if ((y > cy6)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((by2 > cy6)) {
HXLINE(  93)											min = ::Math_obj::floor(cy6);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(by2);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(y);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter32 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(by2);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy6);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((by2 > cy6)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((y > cy6)) {
HXLINE(  93)											min = ::Math_obj::floor(cy6);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(y);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter32 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(y);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy6);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter32 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  93)								if (hasUndo2) {
HXLINE(  93)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  93)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  93)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)									undoImage2 = this3;
HXDLIN(  93)									{
HXLINE(  93)										int rectLeft = xIter32->start;
HXDLIN(  93)										int rectTop = yIter32->start;
HXDLIN(  93)										int rectRight = xIter32->max;
HXDLIN(  93)										bool forceClear = false;
HXDLIN(  93)										{
HXLINE(  93)											int _g = rectTop;
HXDLIN(  93)											int _g1 = yIter32->max;
HXDLIN(  93)											while((_g < _g1)){
HXLINE(  93)												_g = (_g + 1);
HXDLIN(  93)												int dy = (_g - 1);
HXDLIN(  93)												{
HXLINE(  93)													int _g1 = rectLeft;
HXDLIN(  93)													int _g2 = rectRight;
HXDLIN(  93)													while((_g1 < _g2)){
HXLINE(  93)														_g1 = (_g1 + 1);
HXDLIN(  93)														int dx = (_g1 - 1);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (pixelshape->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int col;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															col = c;
            														}
HXDLIN(  93)														bool _hx_tmp;
HXDLIN(  93)														if (pixelshape->useMask) {
HXLINE(  93)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  93)															_hx_tmp = false;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)															int index;
HXDLIN(  93)															if (this1->useVirtualPos) {
HXLINE(  93)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  93)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  93)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)															int v;
HXDLIN(  93)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  93)																v = c;
            															}
HXDLIN(  93)															int this3 = v;
HXDLIN(  93)															int maskPixel = this3;
HXDLIN(  93)															int this4 = col;
HXDLIN(  93)															int this5 = this4;
HXDLIN(  93)															if ((maskPixel == 0)) {
HXLINE(  93)																int this1 = this5;
HXDLIN(  93)																col = this1;
            															}
            															else {
HXLINE(  93)																Float m0;
HXDLIN(  93)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																if ((this1 == 0)) {
HXLINE(  93)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m1;
HXDLIN(  93)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																if ((this2 == 0)) {
HXLINE(  93)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m2;
HXDLIN(  93)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																if ((this3 == 0)) {
HXLINE(  93)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m3;
HXDLIN(  93)																int this4 = (maskPixel & 255);
HXDLIN(  93)																if ((this4 == 0)) {
HXLINE(  93)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  93)														if ((col != 0)) {
HXLINE(  93)															int x = (dx - rectLeft);
HXDLIN(  93)															int y = (dy - rectTop);
HXDLIN(  93)															int this1 = col;
HXDLIN(  93)															int c = this1;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = undoImage2->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (undoImage2->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((col >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((col >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((col >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (col & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage2->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  93)															if (forceClear) {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  93)																int x = (dx - rectLeft);
HXDLIN(  93)																int y = (dy - rectTop);
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage2->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								bool foundY2 = false;
HXDLIN(  93)								Float s2 = ((Float)0.);
HXDLIN(  93)								Float t2 = ((Float)0.);
HXDLIN(  93)								Float sxx2 = ((Float)0.);
HXDLIN(  93)								Float txx2 = ((Float)0.);
HXDLIN(  93)								{
HXLINE(  93)									int _g_min2 = xIter32->start;
HXDLIN(  93)									int _g_max2 = xIter32->max;
HXDLIN(  93)									while((_g_min2 < _g_max2)){
HXLINE(  93)										_g_min2 = (_g_min2 + 1);
HXDLIN(  93)										int x = (_g_min2 - 1);
HXLINE( 223)										sxx2 = (sx2 * ( (Float)(x) ));
HXLINE( 224)										txx2 = (tx2 * ( (Float)(x) ));
HXLINE( 225)										foundY2 = false;
HXLINE(  93)										{
HXLINE(  93)											int _g_min = yIter32->start;
HXDLIN(  93)											int _g_max = yIter32->max;
HXDLIN(  93)											while((_g_min < _g_max)){
HXLINE(  93)												_g_min = (_g_min + 1);
HXDLIN(  93)												int y = (_g_min - 1);
HXLINE( 227)												s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE( 228)												t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE(  93)												bool _hx_tmp;
HXDLIN(  93)												if (!((s2 <= 0))) {
HXLINE(  93)													_hx_tmp = (t2 <= 0);
            												}
            												else {
HXLINE(  93)													_hx_tmp = true;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													if (foundY2) {
HXLINE(  93)														goto _hx_goto_44;
            													}
            												}
            												else {
HXLINE(  93)													if (((s2 + t2) < A2)) {
HXLINE(  93)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (tileImage->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int color;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															color = c;
            														}
HXDLIN(  93)														{
HXLINE(  93)															int this2 = color;
HXDLIN(  93)															int c1 = this2;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((color >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((color >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((color >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (color & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c1;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY2 = true;
            													}
            													else {
HXLINE(  93)														if (foundY2) {
HXLINE(  93)															goto _hx_goto_44;
            														}
            													}
            												}
            											}
            											_hx_goto_44:;
            										}
            									}
            								}
HXDLIN(  93)								if ((hasHit1 == false)) {
HXLINE(  93)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,( (Float)(0) ),y,bx4,by2,cx3,cy6,true);
HXDLIN(  93)									if (hasUndo2) {
HXLINE(  93)										v->undoImage = undoImage2;
HXDLIN(  93)										v->undoX = xIter32->start;
HXDLIN(  93)										v->undoY = yIter32->start;
            									}
            								}
            							}
            						}
HXDLIN(  93)						{
HXLINE(  93)							Float bx5 = bx3;
HXDLIN(  93)							Float by3 = cy5;
HXDLIN(  93)							Float cx4 = ( (Float)(0) );
HXDLIN(  93)							Float cy7 = cy5;
HXDLIN(  93)							bool adjustWinding3 = (((((bx3 * by3) - (bx5 * y)) + ((bx5 * cy7) - (cx4 * by3))) + ((cx4 * y) - (bx3 * cy7))) > 0);
HXDLIN(  93)							if (!(adjustWinding3)) {
HXLINE(  93)								Float bx_ = bx5;
HXDLIN(  93)								Float by_ = by3;
HXLINE( 188)								bx5 = cx4;
HXLINE( 189)								by3 = cy7;
HXLINE( 190)								cx4 = bx_;
HXLINE( 191)								cy7 = by_;
            							}
HXLINE(  93)							{
HXLINE(  93)								bool hasUndo3 = false;
HXDLIN(  93)								Float s03 = ((y * cx4) - (bx3 * cy7));
HXDLIN(  93)								Float sx3 = (cy7 - y);
HXDLIN(  93)								Float sy3 = (bx3 - cx4);
HXDLIN(  93)								Float t03 = ((bx3 * by3) - (y * bx5));
HXDLIN(  93)								Float tx3 = (y - by3);
HXDLIN(  93)								Float ty3 = (bx5 - bx3);
HXDLIN(  93)								Float A3 = ((((-(by3) * cx4) + (y * (-(bx5) + cx4))) + (bx3 * (by3 - cy7))) + (bx5 * cy7));
HXDLIN(  93)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  93)								if ((bx3 > bx5)) {
HXLINE(  93)									if ((bx3 > cx4)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx5 > cx4)) {
HXLINE(  93)											min = ::Math_obj::floor(cx4);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(bx5);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx3);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter33 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx5);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx4);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((bx5 > cx4)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx3 > cx4)) {
HXLINE(  93)											min = ::Math_obj::floor(cx4);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(bx3);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx5);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter33 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx3);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx4);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter33 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  93)								if ((y > by3)) {
HXLINE(  93)									if ((y > cy7)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((by3 > cy7)) {
HXLINE(  93)											min = ::Math_obj::floor(cy7);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(by3);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(y);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter33 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(by3);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy7);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((by3 > cy7)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((y > cy7)) {
HXLINE(  93)											min = ::Math_obj::floor(cy7);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(y);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(by3);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter33 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(y);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy7);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter33 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  93)								if (hasUndo3) {
HXLINE(  93)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  93)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  93)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)									undoImage3 = this3;
HXDLIN(  93)									{
HXLINE(  93)										int rectLeft = xIter33->start;
HXDLIN(  93)										int rectTop = yIter33->start;
HXDLIN(  93)										int rectRight = xIter33->max;
HXDLIN(  93)										bool forceClear = false;
HXDLIN(  93)										{
HXLINE(  93)											int _g = rectTop;
HXDLIN(  93)											int _g1 = yIter33->max;
HXDLIN(  93)											while((_g < _g1)){
HXLINE(  93)												_g = (_g + 1);
HXDLIN(  93)												int dy = (_g - 1);
HXDLIN(  93)												{
HXLINE(  93)													int _g1 = rectLeft;
HXDLIN(  93)													int _g2 = rectRight;
HXDLIN(  93)													while((_g1 < _g2)){
HXLINE(  93)														_g1 = (_g1 + 1);
HXDLIN(  93)														int dx = (_g1 - 1);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (pixelshape->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int col;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															col = c;
            														}
HXDLIN(  93)														bool _hx_tmp;
HXDLIN(  93)														if (pixelshape->useMask) {
HXLINE(  93)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  93)															_hx_tmp = false;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)															int index;
HXDLIN(  93)															if (this1->useVirtualPos) {
HXLINE(  93)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  93)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  93)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)															int v;
HXDLIN(  93)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  93)																v = c;
            															}
HXDLIN(  93)															int this3 = v;
HXDLIN(  93)															int maskPixel = this3;
HXDLIN(  93)															int this4 = col;
HXDLIN(  93)															int this5 = this4;
HXDLIN(  93)															if ((maskPixel == 0)) {
HXLINE(  93)																int this1 = this5;
HXDLIN(  93)																col = this1;
            															}
            															else {
HXLINE(  93)																Float m0;
HXDLIN(  93)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																if ((this1 == 0)) {
HXLINE(  93)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m1;
HXDLIN(  93)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																if ((this2 == 0)) {
HXLINE(  93)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m2;
HXDLIN(  93)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																if ((this3 == 0)) {
HXLINE(  93)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m3;
HXDLIN(  93)																int this4 = (maskPixel & 255);
HXDLIN(  93)																if ((this4 == 0)) {
HXLINE(  93)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  93)														if ((col != 0)) {
HXLINE(  93)															int x = (dx - rectLeft);
HXDLIN(  93)															int y = (dy - rectTop);
HXDLIN(  93)															int this1 = col;
HXDLIN(  93)															int c = this1;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = undoImage3->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (undoImage3->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((col >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((col >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((col >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (col & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage3->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  93)															if (forceClear) {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  93)																int x = (dx - rectLeft);
HXDLIN(  93)																int y = (dy - rectTop);
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage3->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								bool foundY3 = false;
HXDLIN(  93)								Float s3 = ((Float)0.);
HXDLIN(  93)								Float t3 = ((Float)0.);
HXDLIN(  93)								Float sxx3 = ((Float)0.);
HXDLIN(  93)								Float txx3 = ((Float)0.);
HXDLIN(  93)								{
HXLINE(  93)									int _g_min3 = xIter33->start;
HXDLIN(  93)									int _g_max3 = xIter33->max;
HXDLIN(  93)									while((_g_min3 < _g_max3)){
HXLINE(  93)										_g_min3 = (_g_min3 + 1);
HXDLIN(  93)										int x = (_g_min3 - 1);
HXLINE( 223)										sxx3 = (sx3 * ( (Float)(x) ));
HXLINE( 224)										txx3 = (tx3 * ( (Float)(x) ));
HXLINE( 225)										foundY3 = false;
HXLINE(  93)										{
HXLINE(  93)											int _g_min = yIter33->start;
HXDLIN(  93)											int _g_max = yIter33->max;
HXDLIN(  93)											while((_g_min < _g_max)){
HXLINE(  93)												_g_min = (_g_min + 1);
HXDLIN(  93)												int y = (_g_min - 1);
HXLINE( 227)												s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE( 228)												t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE(  93)												bool _hx_tmp;
HXDLIN(  93)												if (!((s3 <= 0))) {
HXLINE(  93)													_hx_tmp = (t3 <= 0);
            												}
            												else {
HXLINE(  93)													_hx_tmp = true;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													if (foundY3) {
HXLINE(  93)														goto _hx_goto_48;
            													}
            												}
            												else {
HXLINE(  93)													if (((s3 + t3) < A3)) {
HXLINE(  93)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (tileImage->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int color;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															color = c;
            														}
HXDLIN(  93)														{
HXLINE(  93)															int this2 = color;
HXDLIN(  93)															int c1 = this2;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((color >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((color >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((color >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (color & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c1;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY3 = true;
            													}
            													else {
HXLINE(  93)														if (foundY3) {
HXLINE(  93)															goto _hx_goto_48;
            														}
            													}
            												}
            											}
            											_hx_goto_48:;
            										}
            									}
            								}
HXDLIN(  93)								if ((hasHit1 == false)) {
HXLINE(  93)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx3,y,bx5,by3,cx4,cy7,true);
HXDLIN(  93)									if (hasUndo3) {
HXLINE(  93)										v->undoImage = undoImage3;
HXDLIN(  93)										v->undoX = xIter33->start;
HXDLIN(  93)										v->undoY = yIter33->start;
            									}
            								}
            							}
            						}
HXDLIN(  93)						if ((hasHit1 == true)) {
HXLINE(  93)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,( (Float)(0) ),y,bx3,y,bx3,cy5,( (Float)(0) ),cy5,true);
            						}
            					}
            				}
HXDLIN(  93)				{
HXLINE(  93)					Float cx5 = ( (Float)(dx) );
HXDLIN(  93)					Float rx1 = ( (Float)(dx) );
HXDLIN(  93)					{
HXLINE(  93)						 ::Dynamic targetError2 = ((Float)1.05);
HXDLIN(  93)						if (::hx::IsNull( targetError2 )) {
HXLINE( 850)							targetError2 = ((Float)1.05);
            						}
HXLINE(  93)						Float rSmall2;
HXDLIN(  93)						if ((rx1 > bottomRadius)) {
HXLINE(  93)							rSmall2 = bottomRadius;
            						}
            						else {
HXLINE(  93)							rSmall2 = rx1;
            						}
HXDLIN(  93)						 ::Dynamic targetE2 = ( (Float)(targetError2) );
HXDLIN(  93)						if (::hx::IsNull( targetE2 )) {
HXLINE(  20)							targetE2 = ((Float)1.05);
            						}
HXLINE(  93)						int result2 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE2) ) / rSmall2)))));
HXDLIN(  93)						int noSides2;
HXDLIN(  93)						if ((result2 < 12)) {
HXLINE(  93)							noSides2 = 12;
            						}
            						else {
HXLINE(  93)							if ((result2 > 500)) {
HXLINE(  93)								noSides2 = 500;
            							}
            							else {
HXLINE(  93)								noSides2 = result2;
            							}
            						}
HXDLIN(  93)						int sides2 = (::Math_obj::ceil((( (Float)(noSides2) ) / ( (Float)(4) ))) * 4);
HXDLIN(  93)						Float theta2 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides2) ));
HXDLIN(  93)						Float omega2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  93)						int quarter2 = ::Std_obj::_hx_int((( (Float)(sides2) ) / ( (Float)(4) )));
HXDLIN(  93)						Float lastX2 = ((Float)0.);
HXDLIN(  93)						Float lastY2 = ((Float)0.);
HXDLIN(  93)						{
HXLINE(  73)							lastX2 = (cx5 + (rx1 * ::Math_obj::cos(((( (Float)(sides2) ) * theta2) + omega2))));
HXLINE(  74)							lastY2 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides2) ) * theta2) + omega2))));
            						}
HXLINE(  93)						{
HXLINE(  93)							int _g4 = 0;
HXDLIN(  93)							int _g5 = (quarter2 + 1);
HXDLIN(  93)							while((_g4 < _g5)){
HXLINE(  93)								_g4 = (_g4 + 1);
HXDLIN(  93)								int i = (_g4 - 1);
HXDLIN(  93)								Float nextX = (cx5 + (rx1 * ::Math_obj::cos((((( (Float)(i) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  93)								Float nextY = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  93)								{
HXLINE(  93)									bool hasHit = false;
HXDLIN(  93)									{
HXLINE(  93)										Float bx = lastX2;
HXDLIN(  93)										Float by = lastY2;
HXDLIN(  93)										Float cx = nextX;
HXDLIN(  93)										Float cy = nextY;
HXDLIN(  93)										bool adjustWinding = (((((cx5 * by) - (bx * lowerY)) + ((bx * cy) - (cx * by))) + ((cx * lowerY) - (cx5 * cy))) > 0);
HXDLIN(  93)										if (!(adjustWinding)) {
HXLINE(  93)											Float bx_ = bx;
HXDLIN(  93)											Float by_ = by;
HXLINE( 188)											bx = cx;
HXLINE( 189)											by = cy;
HXLINE( 190)											cx = bx_;
HXLINE( 191)											cy = by_;
            										}
HXLINE(  93)										{
HXLINE(  93)											bool hasUndo = false;
HXDLIN(  93)											Float s0 = ((lowerY * cx) - (cx5 * cy));
HXDLIN(  93)											Float sx = (cy - lowerY);
HXDLIN(  93)											Float sy = (cx5 - cx);
HXDLIN(  93)											Float t0 = ((cx5 * by) - (lowerY * bx));
HXDLIN(  93)											Float tx = (lowerY - by);
HXDLIN(  93)											Float ty = (bx - cx5);
HXDLIN(  93)											Float A = ((((-(by) * cx) + (lowerY * (-(bx) + cx))) + (cx5 * (by - cy))) + (bx * cy));
HXDLIN(  93)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  93)											if ((cx5 > bx)) {
HXLINE(  93)												if ((cx5 > cx)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((bx > cx)) {
HXLINE(  93)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cx5);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  93)												if ((bx > cx)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((cx5 > cx)) {
HXLINE(  93)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::ceil(cx5);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(cx5);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													xIter3 = this1;
            												}
            											}
HXDLIN(  93)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  93)											if ((lowerY > by)) {
HXLINE(  93)												if ((lowerY > cy)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((by > cy)) {
HXLINE(  93)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  93)												if ((by > cy)) {
HXLINE(  93)													int min;
HXDLIN(  93)													if ((lowerY > cy)) {
HXLINE(  93)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  93)														min = ::Math_obj::ceil(lowerY);
            													}
HXDLIN(  93)													int ii_min = min;
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            												else {
HXLINE(  93)													int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  93)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  93)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)													yIter3 = this1;
            												}
            											}
HXDLIN(  93)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  93)											if (hasUndo) {
HXLINE(  93)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  93)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  93)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)												undoImage = this3;
HXDLIN(  93)												{
HXLINE(  93)													int rectLeft = xIter3->start;
HXDLIN(  93)													int rectTop = yIter3->start;
HXDLIN(  93)													int rectRight = xIter3->max;
HXDLIN(  93)													bool forceClear = false;
HXDLIN(  93)													{
HXLINE(  93)														int _g = rectTop;
HXDLIN(  93)														int _g1 = yIter3->max;
HXDLIN(  93)														while((_g < _g1)){
HXLINE(  93)															_g = (_g + 1);
HXDLIN(  93)															int dy = (_g - 1);
HXDLIN(  93)															{
HXLINE(  93)																int _g1 = rectLeft;
HXDLIN(  93)																int _g2 = rectRight;
HXDLIN(  93)																while((_g1 < _g2)){
HXLINE(  93)																	_g1 = (_g1 + 1);
HXDLIN(  93)																	int dx = (_g1 - 1);
HXDLIN(  93)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																	int index;
HXDLIN(  93)																	if (pixelshape->useVirtualPos) {
HXLINE(  93)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  93)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																	int col;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		col = c;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if (pixelshape->useMask) {
HXLINE(  93)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)																		int index;
HXDLIN(  93)																		if (this1->useVirtualPos) {
HXLINE(  93)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  93)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  93)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																		int v;
HXDLIN(  93)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  93)																			v = c;
            																		}
HXDLIN(  93)																		int this3 = v;
HXDLIN(  93)																		int maskPixel = this3;
HXDLIN(  93)																		int this4 = col;
HXDLIN(  93)																		int this5 = this4;
HXDLIN(  93)																		if ((maskPixel == 0)) {
HXLINE(  93)																			int this1 = this5;
HXDLIN(  93)																			col = this1;
            																		}
            																		else {
HXLINE(  93)																			Float m0;
HXDLIN(  93)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																			if ((this1 == 0)) {
HXLINE(  93)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m1;
HXDLIN(  93)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																			if ((this2 == 0)) {
HXLINE(  93)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m2;
HXDLIN(  93)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																			if ((this3 == 0)) {
HXLINE(  93)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float m3;
HXDLIN(  93)																			int this4 = (maskPixel & 255);
HXDLIN(  93)																			if ((this4 == 0)) {
HXLINE(  93)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  93)																	if ((col != 0)) {
HXLINE(  93)																		int x = (dx - rectLeft);
HXDLIN(  93)																		int y = (dy - rectTop);
HXDLIN(  93)																		int this1 = col;
HXDLIN(  93)																		int c = this1;
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			int location;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																			int this3 = this2;
HXDLIN(  93)																			int this4;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				this4 = this3;
            																			}
HXDLIN(  93)																			Float a1;
HXDLIN(  93)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																			if ((this5 == 0)) {
HXLINE(  93)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r1;
HXDLIN(  93)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																			if ((this6 == 0)) {
HXLINE(  93)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g1;
HXDLIN(  93)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																			if ((this7 == 0)) {
HXLINE(  93)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b1;
HXDLIN(  93)																			int this8 = (this4 & 255);
HXDLIN(  93)																			if ((this8 == 0)) {
HXLINE(  93)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a2;
HXDLIN(  93)																			int this9 = ((col >> 24) & 255);
HXDLIN(  93)																			if ((this9 == 0)) {
HXLINE(  93)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r2;
HXDLIN(  93)																			int this10 = ((col >> 16) & 255);
HXDLIN(  93)																			if ((this10 == 0)) {
HXLINE(  93)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g2;
HXDLIN(  93)																			int this11 = ((col >> 8) & 255);
HXDLIN(  93)																			if ((this11 == 0)) {
HXLINE(  93)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b2;
HXDLIN(  93)																			int this12 = (col & 255);
HXDLIN(  93)																			if ((this12 == 0)) {
HXLINE(  93)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																			{
HXLINE(  93)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  93)																				int value;
HXDLIN(  93)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  93)																					value = blended;
            																				}
HXDLIN(  93)																				bool _hx_tmp;
HXDLIN(  93)																				if ((location >= 0)) {
HXLINE(  93)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  93)																					_hx_tmp = false;
            																				}
HXDLIN(  93)																				if (_hx_tmp) {
HXLINE(  93)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			int value;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				value = c;
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  93)																		if (forceClear) {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																			int x = (dx - rectLeft);
HXDLIN(  93)																			int y = (dy - rectTop);
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (undoImage->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  93)											bool foundY = false;
HXDLIN(  93)											Float s = ((Float)0.);
HXDLIN(  93)											Float t = ((Float)0.);
HXDLIN(  93)											Float sxx = ((Float)0.);
HXDLIN(  93)											Float txx = ((Float)0.);
HXDLIN(  93)											{
HXLINE(  93)												int _g_min = xIter3->start;
HXDLIN(  93)												int _g_max = xIter3->max;
HXDLIN(  93)												while((_g_min < _g_max)){
HXLINE(  93)													_g_min = (_g_min + 1);
HXDLIN(  93)													int x = (_g_min - 1);
HXLINE( 223)													sxx = (sx * ( (Float)(x) ));
HXLINE( 224)													txx = (tx * ( (Float)(x) ));
HXLINE( 225)													foundY = false;
HXLINE(  93)													{
HXLINE(  93)														int _g_min1 = yIter3->start;
HXDLIN(  93)														int _g_max = yIter3->max;
HXDLIN(  93)														while((_g_min1 < _g_max)){
HXLINE(  93)															_g_min1 = (_g_min1 + 1);
HXDLIN(  93)															int y = (_g_min1 - 1);
HXLINE( 227)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  93)															bool _hx_tmp;
HXDLIN(  93)															if (!((s <= 0))) {
HXLINE(  93)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  93)																_hx_tmp = true;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																if (foundY) {
HXLINE(  93)																	goto _hx_goto_53;
            																}
            															}
            															else {
HXLINE(  93)																if (((s + t) < A)) {
HXLINE(  93)																	int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)																	int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)																	::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)																	int index;
HXDLIN(  93)																	if (tileImage->useVirtualPos) {
HXLINE(  93)																		index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																	}
            																	else {
HXLINE(  93)																		index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																	}
HXDLIN(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																	int color;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		color = c;
            																	}
HXDLIN(  93)																	{
HXLINE(  93)																		int this2 = color;
HXDLIN(  93)																		int c1 = this2;
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			int location;
HXDLIN(  93)																			if (pixelshape->useVirtualPos) {
HXLINE(  93)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  93)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  93)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																			int this3 = this2;
HXDLIN(  93)																			int this4;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				this4 = this3;
            																			}
HXDLIN(  93)																			Float a1;
HXDLIN(  93)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																			if ((this5 == 0)) {
HXLINE(  93)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r1;
HXDLIN(  93)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																			if ((this6 == 0)) {
HXLINE(  93)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g1;
HXDLIN(  93)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																			if ((this7 == 0)) {
HXLINE(  93)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b1;
HXDLIN(  93)																			int this8 = (this4 & 255);
HXDLIN(  93)																			if ((this8 == 0)) {
HXLINE(  93)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a2;
HXDLIN(  93)																			int this9 = ((color >> 24) & 255);
HXDLIN(  93)																			if ((this9 == 0)) {
HXLINE(  93)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float r2;
HXDLIN(  93)																			int this10 = ((color >> 16) & 255);
HXDLIN(  93)																			if ((this10 == 0)) {
HXLINE(  93)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float g2;
HXDLIN(  93)																			int this11 = ((color >> 8) & 255);
HXDLIN(  93)																			if ((this11 == 0)) {
HXLINE(  93)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float b2;
HXDLIN(  93)																			int this12 = (color & 255);
HXDLIN(  93)																			if ((this12 == 0)) {
HXLINE(  93)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  93)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  93)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																			{
HXLINE(  93)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																				int value;
HXDLIN(  93)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  93)																					value = blended;
            																				}
HXDLIN(  93)																				bool _hx_tmp;
HXDLIN(  93)																				if ((location >= 0)) {
HXLINE(  93)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  93)																					_hx_tmp = false;
            																				}
HXDLIN(  93)																				if (_hx_tmp) {
HXLINE(  93)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																			int index;
HXDLIN(  93)																			if (pixelshape->useVirtualPos) {
HXLINE(  93)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  93)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  93)																			int value;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				value = c1;
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((index >= 0)) {
HXLINE(  93)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE( 237)																	foundY = true;
            																}
            																else {
HXLINE(  93)																	if (foundY) {
HXLINE(  93)																		goto _hx_goto_53;
            																	}
            																}
            															}
            														}
            														_hx_goto_53:;
            													}
            												}
            											}
HXDLIN(  93)											if ((hasHit == false)) {
HXLINE(  93)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx5,lowerY,bx,by,cx,cy,true);
HXDLIN(  93)												if (hasUndo) {
HXLINE(  93)													v->undoImage = undoImage;
HXDLIN(  93)													v->undoX = xIter3->start;
HXDLIN(  93)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								lastX2 = nextX;
HXLINE(  94)								lastY2 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  93)				{
HXLINE(  93)					Float x1 = ( (Float)(dx) );
HXDLIN(  93)					bool hasHit2 = false;
HXDLIN(  93)					Float bx6 = (x1 + ( (Float)(fat) ));
HXDLIN(  93)					Float cy8 = (lowerY + bottomRadius);
HXDLIN(  93)					{
HXLINE(  93)						{
HXLINE(  93)							Float bx7 = bx6;
HXDLIN(  93)							Float by4 = lowerY;
HXDLIN(  93)							Float cx6 = x1;
HXDLIN(  93)							Float cy9 = cy8;
HXDLIN(  93)							bool adjustWinding4 = (((((x1 * by4) - (bx7 * lowerY)) + ((bx7 * cy9) - (cx6 * by4))) + ((cx6 * lowerY) - (x1 * cy9))) > 0);
HXDLIN(  93)							if (!(adjustWinding4)) {
HXLINE(  93)								Float bx_ = bx7;
HXDLIN(  93)								Float by_ = by4;
HXLINE( 188)								bx7 = cx6;
HXLINE( 189)								by4 = cy9;
HXLINE( 190)								cx6 = bx_;
HXLINE( 191)								cy9 = by_;
            							}
HXLINE(  93)							{
HXLINE(  93)								bool hasUndo4 = false;
HXDLIN(  93)								Float s04 = ((lowerY * cx6) - (x1 * cy9));
HXDLIN(  93)								Float sx4 = (cy9 - lowerY);
HXDLIN(  93)								Float sy4 = (x1 - cx6);
HXDLIN(  93)								Float t04 = ((x1 * by4) - (lowerY * bx7));
HXDLIN(  93)								Float tx4 = (lowerY - by4);
HXDLIN(  93)								Float ty4 = (bx7 - x1);
HXDLIN(  93)								Float A4 = ((((-(by4) * cx6) + (lowerY * (-(bx7) + cx6))) + (x1 * (by4 - cy9))) + (bx7 * cy9));
HXDLIN(  93)								::pixelimage::iter::IntIterStart xIter34;
HXDLIN(  93)								if ((x1 > bx7)) {
HXLINE(  93)									if ((x1 > cx6)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx7 > cx6)) {
HXLINE(  93)											min = ::Math_obj::floor(cx6);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(bx7);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(x1);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter34 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx7);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx6);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter34 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((bx7 > cx6)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((x1 > cx6)) {
HXLINE(  93)											min = ::Math_obj::floor(cx6);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(x1);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx7);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter34 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(x1);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx6);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter34 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::iter::IntIterStart yIter34;
HXDLIN(  93)								if ((lowerY > by4)) {
HXLINE(  93)									if ((lowerY > cy9)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((by4 > cy9)) {
HXLINE(  93)											min = ::Math_obj::floor(cy9);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(by4);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter34 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(by4);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy9);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter34 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((by4 > cy9)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((lowerY > cy9)) {
HXLINE(  93)											min = ::Math_obj::floor(cy9);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(lowerY);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(by4);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter34 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy9);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter34 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::ImageStruct undoImage4 = null();
HXDLIN(  93)								if (hasUndo4) {
HXLINE(  93)									int w = ((xIter34->max - xIter34->start) + 1);
HXDLIN(  93)									int h = ((yIter34->max - yIter34->start) + 1);
HXDLIN(  93)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)									undoImage4 = this3;
HXDLIN(  93)									{
HXLINE(  93)										int rectLeft = xIter34->start;
HXDLIN(  93)										int rectTop = yIter34->start;
HXDLIN(  93)										int rectRight = xIter34->max;
HXDLIN(  93)										bool forceClear = false;
HXDLIN(  93)										{
HXLINE(  93)											int _g = rectTop;
HXDLIN(  93)											int _g1 = yIter34->max;
HXDLIN(  93)											while((_g < _g1)){
HXLINE(  93)												_g = (_g + 1);
HXDLIN(  93)												int dy = (_g - 1);
HXDLIN(  93)												{
HXLINE(  93)													int _g1 = rectLeft;
HXDLIN(  93)													int _g2 = rectRight;
HXDLIN(  93)													while((_g1 < _g2)){
HXLINE(  93)														_g1 = (_g1 + 1);
HXDLIN(  93)														int dx = (_g1 - 1);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (pixelshape->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int col;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															col = c;
            														}
HXDLIN(  93)														bool _hx_tmp;
HXDLIN(  93)														if (pixelshape->useMask) {
HXLINE(  93)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  93)															_hx_tmp = false;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)															int index;
HXDLIN(  93)															if (this1->useVirtualPos) {
HXLINE(  93)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  93)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  93)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)															int v;
HXDLIN(  93)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  93)																v = c;
            															}
HXDLIN(  93)															int this3 = v;
HXDLIN(  93)															int maskPixel = this3;
HXDLIN(  93)															int this4 = col;
HXDLIN(  93)															int this5 = this4;
HXDLIN(  93)															if ((maskPixel == 0)) {
HXLINE(  93)																int this1 = this5;
HXDLIN(  93)																col = this1;
            															}
            															else {
HXLINE(  93)																Float m0;
HXDLIN(  93)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																if ((this1 == 0)) {
HXLINE(  93)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m1;
HXDLIN(  93)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																if ((this2 == 0)) {
HXLINE(  93)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m2;
HXDLIN(  93)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																if ((this3 == 0)) {
HXLINE(  93)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m3;
HXDLIN(  93)																int this4 = (maskPixel & 255);
HXDLIN(  93)																if ((this4 == 0)) {
HXLINE(  93)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  93)														if ((col != 0)) {
HXLINE(  93)															int x = (dx - rectLeft);
HXDLIN(  93)															int y = (dy - rectTop);
HXDLIN(  93)															int this1 = col;
HXDLIN(  93)															int c = this1;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = undoImage4->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (undoImage4->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((col >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((col >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((col >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (col & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage4->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage4->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  93)															if (forceClear) {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  93)																int x = (dx - rectLeft);
HXDLIN(  93)																int y = (dy - rectTop);
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage4->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								bool foundY4 = false;
HXDLIN(  93)								Float s4 = ((Float)0.);
HXDLIN(  93)								Float t4 = ((Float)0.);
HXDLIN(  93)								Float sxx4 = ((Float)0.);
HXDLIN(  93)								Float txx4 = ((Float)0.);
HXDLIN(  93)								{
HXLINE(  93)									int _g_min4 = xIter34->start;
HXDLIN(  93)									int _g_max4 = xIter34->max;
HXDLIN(  93)									while((_g_min4 < _g_max4)){
HXLINE(  93)										_g_min4 = (_g_min4 + 1);
HXDLIN(  93)										int x = (_g_min4 - 1);
HXLINE( 223)										sxx4 = (sx4 * ( (Float)(x) ));
HXLINE( 224)										txx4 = (tx4 * ( (Float)(x) ));
HXLINE( 225)										foundY4 = false;
HXLINE(  93)										{
HXLINE(  93)											int _g_min = yIter34->start;
HXDLIN(  93)											int _g_max = yIter34->max;
HXDLIN(  93)											while((_g_min < _g_max)){
HXLINE(  93)												_g_min = (_g_min + 1);
HXDLIN(  93)												int y = (_g_min - 1);
HXLINE( 227)												s4 = ((s04 + sxx4) + (sy4 * ( (Float)(y) )));
HXLINE( 228)												t4 = ((t04 + txx4) + (ty4 * ( (Float)(y) )));
HXLINE(  93)												bool _hx_tmp;
HXDLIN(  93)												if (!((s4 <= 0))) {
HXLINE(  93)													_hx_tmp = (t4 <= 0);
            												}
            												else {
HXLINE(  93)													_hx_tmp = true;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													if (foundY4) {
HXLINE(  93)														goto _hx_goto_57;
            													}
            												}
            												else {
HXLINE(  93)													if (((s4 + t4) < A4)) {
HXLINE(  93)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (tileImage->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int color;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															color = c;
            														}
HXDLIN(  93)														{
HXLINE(  93)															int this2 = color;
HXDLIN(  93)															int c1 = this2;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((color >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((color >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((color >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (color & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c1;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY4 = true;
            													}
            													else {
HXLINE(  93)														if (foundY4) {
HXLINE(  93)															goto _hx_goto_57;
            														}
            													}
            												}
            											}
            											_hx_goto_57:;
            										}
            									}
            								}
HXDLIN(  93)								if ((hasHit2 == false)) {
HXLINE(  93)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x1,lowerY,bx7,by4,cx6,cy9,true);
HXDLIN(  93)									if (hasUndo4) {
HXLINE(  93)										v->undoImage = undoImage4;
HXDLIN(  93)										v->undoX = xIter34->start;
HXDLIN(  93)										v->undoY = yIter34->start;
            									}
            								}
            							}
            						}
HXDLIN(  93)						{
HXLINE(  93)							Float bx8 = bx6;
HXDLIN(  93)							Float by5 = cy8;
HXDLIN(  93)							Float cx7 = x1;
HXDLIN(  93)							Float cy10 = cy8;
HXDLIN(  93)							bool adjustWinding5 = (((((bx6 * by5) - (bx8 * lowerY)) + ((bx8 * cy10) - (cx7 * by5))) + ((cx7 * lowerY) - (bx6 * cy10))) > 0);
HXDLIN(  93)							if (!(adjustWinding5)) {
HXLINE(  93)								Float bx_ = bx8;
HXDLIN(  93)								Float by_ = by5;
HXLINE( 188)								bx8 = cx7;
HXLINE( 189)								by5 = cy10;
HXLINE( 190)								cx7 = bx_;
HXLINE( 191)								cy10 = by_;
            							}
HXLINE(  93)							{
HXLINE(  93)								bool hasUndo5 = false;
HXDLIN(  93)								Float s05 = ((lowerY * cx7) - (bx6 * cy10));
HXDLIN(  93)								Float sx5 = (cy10 - lowerY);
HXDLIN(  93)								Float sy5 = (bx6 - cx7);
HXDLIN(  93)								Float t05 = ((bx6 * by5) - (lowerY * bx8));
HXDLIN(  93)								Float tx5 = (lowerY - by5);
HXDLIN(  93)								Float ty5 = (bx8 - bx6);
HXDLIN(  93)								Float A5 = ((((-(by5) * cx7) + (lowerY * (-(bx8) + cx7))) + (bx6 * (by5 - cy10))) + (bx8 * cy10));
HXDLIN(  93)								::pixelimage::iter::IntIterStart xIter35;
HXDLIN(  93)								if ((bx6 > bx8)) {
HXLINE(  93)									if ((bx6 > cx7)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx8 > cx7)) {
HXLINE(  93)											min = ::Math_obj::floor(cx7);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(bx8);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx6);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter35 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx8);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx7);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter35 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((bx8 > cx7)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((bx6 > cx7)) {
HXLINE(  93)											min = ::Math_obj::floor(cx7);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(bx6);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(bx8);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter35 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(bx6);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cx7);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										xIter35 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::iter::IntIterStart yIter35;
HXDLIN(  93)								if ((lowerY > by5)) {
HXLINE(  93)									if ((lowerY > cy10)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((by5 > cy10)) {
HXLINE(  93)											min = ::Math_obj::floor(cy10);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::floor(by5);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter35 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(by5);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy10);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter35 = this1;
            									}
            								}
            								else {
HXLINE(  93)									if ((by5 > cy10)) {
HXLINE(  93)										int min;
HXDLIN(  93)										if ((lowerY > cy10)) {
HXLINE(  93)											min = ::Math_obj::floor(cy10);
            										}
            										else {
HXLINE(  93)											min = ::Math_obj::ceil(lowerY);
            										}
HXDLIN(  93)										int ii_min = min;
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(by5);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter35 = this1;
            									}
            									else {
HXLINE(  93)										int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  93)										int ii_max = ::Math_obj::ceil(cy10);
HXDLIN(  93)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)										yIter35 = this1;
            									}
            								}
HXDLIN(  93)								::pixelimage::ImageStruct undoImage5 = null();
HXDLIN(  93)								if (hasUndo5) {
HXLINE(  93)									int w = ((xIter35->max - xIter35->start) + 1);
HXDLIN(  93)									int h = ((yIter35->max - yIter35->start) + 1);
HXDLIN(  93)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)									undoImage5 = this3;
HXDLIN(  93)									{
HXLINE(  93)										int rectLeft = xIter35->start;
HXDLIN(  93)										int rectTop = yIter35->start;
HXDLIN(  93)										int rectRight = xIter35->max;
HXDLIN(  93)										bool forceClear = false;
HXDLIN(  93)										{
HXLINE(  93)											int _g = rectTop;
HXDLIN(  93)											int _g1 = yIter35->max;
HXDLIN(  93)											while((_g < _g1)){
HXLINE(  93)												_g = (_g + 1);
HXDLIN(  93)												int dy = (_g - 1);
HXDLIN(  93)												{
HXLINE(  93)													int _g1 = rectLeft;
HXDLIN(  93)													int _g2 = rectRight;
HXDLIN(  93)													while((_g1 < _g2)){
HXLINE(  93)														_g1 = (_g1 + 1);
HXDLIN(  93)														int dx = (_g1 - 1);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (pixelshape->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int col;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															col = c;
            														}
HXDLIN(  93)														bool _hx_tmp;
HXDLIN(  93)														if (pixelshape->useMask) {
HXLINE(  93)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  93)															_hx_tmp = false;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)															int index;
HXDLIN(  93)															if (this1->useVirtualPos) {
HXLINE(  93)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  93)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  93)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)															int v;
HXDLIN(  93)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  93)																v = c;
            															}
HXDLIN(  93)															int this3 = v;
HXDLIN(  93)															int maskPixel = this3;
HXDLIN(  93)															int this4 = col;
HXDLIN(  93)															int this5 = this4;
HXDLIN(  93)															if ((maskPixel == 0)) {
HXLINE(  93)																int this1 = this5;
HXDLIN(  93)																col = this1;
            															}
            															else {
HXLINE(  93)																Float m0;
HXDLIN(  93)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																if ((this1 == 0)) {
HXLINE(  93)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m1;
HXDLIN(  93)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																if ((this2 == 0)) {
HXLINE(  93)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m2;
HXDLIN(  93)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																if ((this3 == 0)) {
HXLINE(  93)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float m3;
HXDLIN(  93)																int this4 = (maskPixel & 255);
HXDLIN(  93)																if ((this4 == 0)) {
HXLINE(  93)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  93)														if ((col != 0)) {
HXLINE(  93)															int x = (dx - rectLeft);
HXDLIN(  93)															int y = (dy - rectTop);
HXDLIN(  93)															int this1 = col;
HXDLIN(  93)															int c = this1;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = undoImage5->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (undoImage5->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((col >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((col >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((col >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (col & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage5->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage5->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  93)															if (forceClear) {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  93)																int x = (dx - rectLeft);
HXDLIN(  93)																int y = (dy - rectTop);
HXDLIN(  93)																int index;
HXDLIN(  93)																if (undoImage5->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  93)								bool foundY5 = false;
HXDLIN(  93)								Float s5 = ((Float)0.);
HXDLIN(  93)								Float t5 = ((Float)0.);
HXDLIN(  93)								Float sxx5 = ((Float)0.);
HXDLIN(  93)								Float txx5 = ((Float)0.);
HXDLIN(  93)								{
HXLINE(  93)									int _g_min5 = xIter35->start;
HXDLIN(  93)									int _g_max5 = xIter35->max;
HXDLIN(  93)									while((_g_min5 < _g_max5)){
HXLINE(  93)										_g_min5 = (_g_min5 + 1);
HXDLIN(  93)										int x = (_g_min5 - 1);
HXLINE( 223)										sxx5 = (sx5 * ( (Float)(x) ));
HXLINE( 224)										txx5 = (tx5 * ( (Float)(x) ));
HXLINE( 225)										foundY5 = false;
HXLINE(  93)										{
HXLINE(  93)											int _g_min = yIter35->start;
HXDLIN(  93)											int _g_max = yIter35->max;
HXDLIN(  93)											while((_g_min < _g_max)){
HXLINE(  93)												_g_min = (_g_min + 1);
HXDLIN(  93)												int y = (_g_min - 1);
HXLINE( 227)												s5 = ((s05 + sxx5) + (sy5 * ( (Float)(y) )));
HXLINE( 228)												t5 = ((t05 + txx5) + (ty5 * ( (Float)(y) )));
HXLINE(  93)												bool _hx_tmp;
HXDLIN(  93)												if (!((s5 <= 0))) {
HXLINE(  93)													_hx_tmp = (t5 <= 0);
            												}
            												else {
HXLINE(  93)													_hx_tmp = true;
            												}
HXDLIN(  93)												if (_hx_tmp) {
HXLINE(  93)													if (foundY5) {
HXLINE(  93)														goto _hx_goto_61;
            													}
            												}
            												else {
HXLINE(  93)													if (((s5 + t5) < A5)) {
HXLINE(  93)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)														int index;
HXDLIN(  93)														if (tileImage->useVirtualPos) {
HXLINE(  93)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  93)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  93)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)														int color;
HXDLIN(  93)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  93)															color = c;
            														}
HXDLIN(  93)														{
HXLINE(  93)															int this2 = color;
HXDLIN(  93)															int c1 = this2;
HXDLIN(  93)															bool _hx_tmp;
HXDLIN(  93)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  93)																_hx_tmp = false;
            															}
HXDLIN(  93)															if (_hx_tmp) {
HXLINE(  93)																int location;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int this3 = this2;
HXDLIN(  93)																int this4;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	this4 = this3;
            																}
HXDLIN(  93)																Float a1;
HXDLIN(  93)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																if ((this5 == 0)) {
HXLINE(  93)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r1;
HXDLIN(  93)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																if ((this6 == 0)) {
HXLINE(  93)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g1;
HXDLIN(  93)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																if ((this7 == 0)) {
HXLINE(  93)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b1;
HXDLIN(  93)																int this8 = (this4 & 255);
HXDLIN(  93)																if ((this8 == 0)) {
HXLINE(  93)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a2;
HXDLIN(  93)																int this9 = ((color >> 24) & 255);
HXDLIN(  93)																if ((this9 == 0)) {
HXLINE(  93)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float r2;
HXDLIN(  93)																int this10 = ((color >> 16) & 255);
HXDLIN(  93)																if ((this10 == 0)) {
HXLINE(  93)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float g2;
HXDLIN(  93)																int this11 = ((color >> 8) & 255);
HXDLIN(  93)																if ((this11 == 0)) {
HXLINE(  93)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float b2;
HXDLIN(  93)																int this12 = (color & 255);
HXDLIN(  93)																if ((this12 == 0)) {
HXLINE(  93)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  93)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  93)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																{
HXLINE(  93)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																	int value;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		value = blended;
            																	}
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((location >= 0)) {
HXLINE(  93)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  93)																int value;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	value = c1;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if ((index >= 0)) {
HXLINE(  93)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY5 = true;
            													}
            													else {
HXLINE(  93)														if (foundY5) {
HXLINE(  93)															goto _hx_goto_61;
            														}
            													}
            												}
            											}
            											_hx_goto_61:;
            										}
            									}
            								}
HXDLIN(  93)								if ((hasHit2 == false)) {
HXLINE(  93)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx6,lowerY,bx8,by5,cx7,cy10,true);
HXDLIN(  93)									if (hasUndo5) {
HXLINE(  93)										v->undoImage = undoImage5;
HXDLIN(  93)										v->undoX = xIter35->start;
HXDLIN(  93)										v->undoY = yIter35->start;
            									}
            								}
            							}
            						}
HXDLIN(  93)						if ((hasHit2 == true)) {
HXLINE(  93)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x1,lowerY,bx6,lowerY,bx6,cy8,x1,cy8,true);
            						}
            					}
            				}
HXDLIN(  93)				{
HXLINE(  93)					 ::Dynamic targetError3 = ((Float)1.05);
HXDLIN(  93)					if (::hx::IsNull( targetError3 )) {
HXLINE( 850)						targetError3 = ((Float)1.05);
            					}
HXLINE(  93)					Float rSmall3;
HXDLIN(  93)					if ((rightRadius > bottomRadius)) {
HXLINE(  93)						rSmall3 = bottomRadius;
            					}
            					else {
HXLINE(  93)						rSmall3 = rightRadius;
            					}
HXDLIN(  93)					 ::Dynamic targetE3 = ( (Float)(targetError3) );
HXDLIN(  93)					if (::hx::IsNull( targetE3 )) {
HXLINE(  20)						targetE3 = ((Float)1.05);
            					}
HXLINE(  93)					int result3 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE3) ) / rSmall3)))));
HXDLIN(  93)					int noSides3;
HXDLIN(  93)					if ((result3 < 12)) {
HXLINE(  93)						noSides3 = 12;
            					}
            					else {
HXLINE(  93)						if ((result3 > 500)) {
HXLINE(  93)							noSides3 = 500;
            						}
            						else {
HXLINE(  93)							noSides3 = result3;
            						}
            					}
HXDLIN(  93)					int sides3 = (::Math_obj::ceil((( (Float)(noSides3) ) / ( (Float)(4) ))) * 4);
HXDLIN(  93)					Float theta3 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN(  93)					Float omega3 = ( (Float)(0) );
HXDLIN(  93)					int quarter3 = ::Std_obj::_hx_int((( (Float)(sides3) ) / ( (Float)(4) )));
HXDLIN(  93)					Float lastX3 = ((Float)0.);
HXDLIN(  93)					Float lastY3 = ((Float)0.);
HXDLIN(  93)					{
HXLINE(  73)						lastX3 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides3) ) * theta3) + omega3))));
HXLINE(  74)						lastY3 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides3) ) * theta3) + omega3))));
            					}
HXLINE(  93)					{
HXLINE(  93)						int _g6 = 0;
HXDLIN(  93)						int _g7 = (quarter3 + 1);
HXDLIN(  93)						while((_g6 < _g7)){
HXLINE(  93)							_g6 = (_g6 + 1);
HXDLIN(  93)							int i = (_g6 - 1);
HXDLIN(  93)							Float nextX = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  93)							Float nextY = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  93)							{
HXLINE(  93)								bool hasHit = false;
HXDLIN(  93)								{
HXLINE(  93)									Float bx = lastX3;
HXDLIN(  93)									Float by = lastY3;
HXDLIN(  93)									Float cx = nextX;
HXDLIN(  93)									Float cy = nextY;
HXDLIN(  93)									bool adjustWinding = (((((farX * by) - (bx * lowerY)) + ((bx * cy) - (cx * by))) + ((cx * lowerY) - (farX * cy))) > 0);
HXDLIN(  93)									if (!(adjustWinding)) {
HXLINE(  93)										Float bx_ = bx;
HXDLIN(  93)										Float by_ = by;
HXLINE( 188)										bx = cx;
HXLINE( 189)										by = cy;
HXLINE( 190)										cx = bx_;
HXLINE( 191)										cy = by_;
            									}
HXLINE(  93)									{
HXLINE(  93)										bool hasUndo = false;
HXDLIN(  93)										Float s0 = ((lowerY * cx) - (farX * cy));
HXDLIN(  93)										Float sx = (cy - lowerY);
HXDLIN(  93)										Float sy = (farX - cx);
HXDLIN(  93)										Float t0 = ((farX * by) - (lowerY * bx));
HXDLIN(  93)										Float tx = (lowerY - by);
HXDLIN(  93)										Float ty = (bx - farX);
HXDLIN(  93)										Float A = ((((-(by) * cx) + (lowerY * (-(bx) + cx))) + (farX * (by - cy))) + (bx * cy));
HXDLIN(  93)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  93)										if ((farX > bx)) {
HXLINE(  93)											if ((farX > cx)) {
HXLINE(  93)												int min;
HXDLIN(  93)												if ((bx > cx)) {
HXLINE(  93)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  93)													min = ::Math_obj::floor(bx);
            												}
HXDLIN(  93)												int ii_min = min;
HXDLIN(  93)												int ii_max = ::Math_obj::ceil(farX);
HXDLIN(  93)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)												xIter3 = this1;
            											}
            											else {
HXLINE(  93)												int ii_min = ::Math_obj::floor(bx);
HXDLIN(  93)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  93)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  93)											if ((bx > cx)) {
HXLINE(  93)												int min;
HXDLIN(  93)												if ((farX > cx)) {
HXLINE(  93)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  93)													min = ::Math_obj::ceil(farX);
            												}
HXDLIN(  93)												int ii_min = min;
HXDLIN(  93)												int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  93)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)												xIter3 = this1;
            											}
            											else {
HXLINE(  93)												int ii_min = ::Math_obj::floor(farX);
HXDLIN(  93)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  93)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)												xIter3 = this1;
            											}
            										}
HXDLIN(  93)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  93)										if ((lowerY > by)) {
HXLINE(  93)											if ((lowerY > cy)) {
HXLINE(  93)												int min;
HXDLIN(  93)												if ((by > cy)) {
HXLINE(  93)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  93)													min = ::Math_obj::floor(by);
            												}
HXDLIN(  93)												int ii_min = min;
HXDLIN(  93)												int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  93)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)												yIter3 = this1;
            											}
            											else {
HXLINE(  93)												int ii_min = ::Math_obj::floor(by);
HXDLIN(  93)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  93)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  93)											if ((by > cy)) {
HXLINE(  93)												int min;
HXDLIN(  93)												if ((lowerY > cy)) {
HXLINE(  93)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  93)													min = ::Math_obj::ceil(lowerY);
            												}
HXDLIN(  93)												int ii_min = min;
HXDLIN(  93)												int ii_max = ::Math_obj::ceil(by);
HXDLIN(  93)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)												yIter3 = this1;
            											}
            											else {
HXLINE(  93)												int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  93)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  93)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)												yIter3 = this1;
            											}
            										}
HXDLIN(  93)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  93)										if (hasUndo) {
HXLINE(  93)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  93)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  93)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  93)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  93)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  93)											undoImage = this3;
HXDLIN(  93)											{
HXLINE(  93)												int rectLeft = xIter3->start;
HXDLIN(  93)												int rectTop = yIter3->start;
HXDLIN(  93)												int rectRight = xIter3->max;
HXDLIN(  93)												bool forceClear = false;
HXDLIN(  93)												{
HXLINE(  93)													int _g = rectTop;
HXDLIN(  93)													int _g1 = yIter3->max;
HXDLIN(  93)													while((_g < _g1)){
HXLINE(  93)														_g = (_g + 1);
HXDLIN(  93)														int dy = (_g - 1);
HXDLIN(  93)														{
HXLINE(  93)															int _g1 = rectLeft;
HXDLIN(  93)															int _g2 = rectRight;
HXDLIN(  93)															while((_g1 < _g2)){
HXLINE(  93)																_g1 = (_g1 + 1);
HXDLIN(  93)																int dx = (_g1 - 1);
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (pixelshape->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																}
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int col;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	col = c;
            																}
HXDLIN(  93)																bool _hx_tmp;
HXDLIN(  93)																if (pixelshape->useMask) {
HXLINE(  93)																	_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																}
            																else {
HXLINE(  93)																	_hx_tmp = false;
            																}
HXDLIN(  93)																if (_hx_tmp) {
HXLINE(  93)																	::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  93)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  93)																	int index;
HXDLIN(  93)																	if (this1->useVirtualPos) {
HXLINE(  93)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  93)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  93)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  93)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  93)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																	int v;
HXDLIN(  93)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  93)																		v = c;
            																	}
HXDLIN(  93)																	int this3 = v;
HXDLIN(  93)																	int maskPixel = this3;
HXDLIN(  93)																	int this4 = col;
HXDLIN(  93)																	int this5 = this4;
HXDLIN(  93)																	if ((maskPixel == 0)) {
HXLINE(  93)																		int this1 = this5;
HXDLIN(  93)																		col = this1;
            																	}
            																	else {
HXLINE(  93)																		Float m0;
HXDLIN(  93)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  93)																		if ((this1 == 0)) {
HXLINE(  93)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float m1;
HXDLIN(  93)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  93)																		if ((this2 == 0)) {
HXLINE(  93)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float m2;
HXDLIN(  93)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  93)																		if ((this3 == 0)) {
HXLINE(  93)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float m3;
HXDLIN(  93)																		int this4 = (maskPixel & 255);
HXDLIN(  93)																		if ((this4 == 0)) {
HXLINE(  93)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  93)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  93)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  93)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  93)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  93)																if ((col != 0)) {
HXLINE(  93)																	int x = (dx - rectLeft);
HXDLIN(  93)																	int y = (dy - rectTop);
HXDLIN(  93)																	int this1 = col;
HXDLIN(  93)																	int c = this1;
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  93)																		_hx_tmp = undoImage->transparent;
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		int location;
HXDLIN(  93)																		if (undoImage->useVirtualPos) {
HXLINE(  93)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  93)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  93)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																		int this3 = this2;
HXDLIN(  93)																		int this4;
HXDLIN(  93)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  93)																			this4 = this3;
            																		}
HXDLIN(  93)																		Float a1;
HXDLIN(  93)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																		if ((this5 == 0)) {
HXLINE(  93)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float r1;
HXDLIN(  93)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																		if ((this6 == 0)) {
HXLINE(  93)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float g1;
HXDLIN(  93)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																		if ((this7 == 0)) {
HXLINE(  93)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float b1;
HXDLIN(  93)																		int this8 = (this4 & 255);
HXDLIN(  93)																		if ((this8 == 0)) {
HXLINE(  93)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float a2;
HXDLIN(  93)																		int this9 = ((col >> 24) & 255);
HXDLIN(  93)																		if ((this9 == 0)) {
HXLINE(  93)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float r2;
HXDLIN(  93)																		int this10 = ((col >> 16) & 255);
HXDLIN(  93)																		if ((this10 == 0)) {
HXLINE(  93)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float g2;
HXDLIN(  93)																		int this11 = ((col >> 8) & 255);
HXDLIN(  93)																		if ((this11 == 0)) {
HXLINE(  93)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float b2;
HXDLIN(  93)																		int this12 = (col & 255);
HXDLIN(  93)																		if ((this12 == 0)) {
HXLINE(  93)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																		{
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  93)																			int value;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				value = blended;
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((location >= 0)) {
HXLINE(  93)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  93)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																		int index;
HXDLIN(  93)																		if (undoImage->useVirtualPos) {
HXLINE(  93)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  93)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  93)																		int value;
HXDLIN(  93)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  93)																			value = c;
            																		}
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((index >= 0)) {
HXLINE(  93)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  93)																	if (forceClear) {
HXLINE(  93)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  93)																		int x = (dx - rectLeft);
HXDLIN(  93)																		int y = (dy - rectTop);
HXDLIN(  93)																		int index;
HXDLIN(  93)																		if (undoImage->useVirtualPos) {
HXLINE(  93)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  93)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((index >= 0)) {
HXLINE(  93)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  93)										bool foundY = false;
HXDLIN(  93)										Float s = ((Float)0.);
HXDLIN(  93)										Float t = ((Float)0.);
HXDLIN(  93)										Float sxx = ((Float)0.);
HXDLIN(  93)										Float txx = ((Float)0.);
HXDLIN(  93)										{
HXLINE(  93)											int _g_min = xIter3->start;
HXDLIN(  93)											int _g_max = xIter3->max;
HXDLIN(  93)											while((_g_min < _g_max)){
HXLINE(  93)												_g_min = (_g_min + 1);
HXDLIN(  93)												int x = (_g_min - 1);
HXLINE( 223)												sxx = (sx * ( (Float)(x) ));
HXLINE( 224)												txx = (tx * ( (Float)(x) ));
HXLINE( 225)												foundY = false;
HXLINE(  93)												{
HXLINE(  93)													int _g_min1 = yIter3->start;
HXDLIN(  93)													int _g_max = yIter3->max;
HXDLIN(  93)													while((_g_min1 < _g_max)){
HXLINE(  93)														_g_min1 = (_g_min1 + 1);
HXDLIN(  93)														int y = (_g_min1 - 1);
HXLINE( 227)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  93)														bool _hx_tmp;
HXDLIN(  93)														if (!((s <= 0))) {
HXLINE(  93)															_hx_tmp = (t <= 0);
            														}
            														else {
HXLINE(  93)															_hx_tmp = true;
            														}
HXDLIN(  93)														if (_hx_tmp) {
HXLINE(  93)															if (foundY) {
HXLINE(  93)																goto _hx_goto_66;
            															}
            														}
            														else {
HXLINE(  93)															if (((s + t) < A)) {
HXLINE(  93)																int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  93)																int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  93)																::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  93)																int index;
HXDLIN(  93)																if (tileImage->useVirtualPos) {
HXLINE(  93)																	index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																}
            																else {
HXLINE(  93)																	index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																}
HXDLIN(  93)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																int color;
HXDLIN(  93)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																	color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  93)																	color = c;
            																}
HXDLIN(  93)																{
HXLINE(  93)																	int this2 = color;
HXDLIN(  93)																	int c1 = this2;
HXDLIN(  93)																	bool _hx_tmp;
HXDLIN(  93)																	if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  93)																		_hx_tmp = pixelshape->transparent;
            																	}
            																	else {
HXLINE(  93)																		_hx_tmp = false;
            																	}
HXDLIN(  93)																	if (_hx_tmp) {
HXLINE(  93)																		int location;
HXDLIN(  93)																		if (pixelshape->useVirtualPos) {
HXLINE(  93)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																		}
            																		else {
HXLINE(  93)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																		}
HXDLIN(  93)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  93)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  93)																		int this3 = this2;
HXDLIN(  93)																		int this4;
HXDLIN(  93)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  93)																			this4 = this3;
            																		}
HXDLIN(  93)																		Float a1;
HXDLIN(  93)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  93)																		if ((this5 == 0)) {
HXLINE(  93)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float r1;
HXDLIN(  93)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  93)																		if ((this6 == 0)) {
HXLINE(  93)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float g1;
HXDLIN(  93)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  93)																		if ((this7 == 0)) {
HXLINE(  93)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float b1;
HXDLIN(  93)																		int this8 = (this4 & 255);
HXDLIN(  93)																		if ((this8 == 0)) {
HXLINE(  93)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float a2;
HXDLIN(  93)																		int this9 = ((color >> 24) & 255);
HXDLIN(  93)																		if ((this9 == 0)) {
HXLINE(  93)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float r2;
HXDLIN(  93)																		int this10 = ((color >> 16) & 255);
HXDLIN(  93)																		if ((this10 == 0)) {
HXLINE(  93)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float g2;
HXDLIN(  93)																		int this11 = ((color >> 8) & 255);
HXDLIN(  93)																		if ((this11 == 0)) {
HXLINE(  93)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float b2;
HXDLIN(  93)																		int this12 = (color & 255);
HXDLIN(  93)																		if ((this12 == 0)) {
HXLINE(  93)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  93)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  93)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  93)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  93)																		{
HXLINE(  93)																			::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  93)																			int value;
HXDLIN(  93)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  93)																				value = blended;
            																			}
HXDLIN(  93)																			bool _hx_tmp;
HXDLIN(  93)																			if ((location >= 0)) {
HXLINE(  93)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  93)																				_hx_tmp = false;
            																			}
HXDLIN(  93)																			if (_hx_tmp) {
HXLINE(  93)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  93)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  93)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  93)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  93)																		int index;
HXDLIN(  93)																		if (pixelshape->useVirtualPos) {
HXLINE(  93)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																		}
            																		else {
HXLINE(  93)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																		}
HXDLIN(  93)																		int value;
HXDLIN(  93)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  93)																			value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																		}
            																		else {
HXLINE(  93)																			value = c1;
            																		}
HXDLIN(  93)																		bool _hx_tmp;
HXDLIN(  93)																		if ((index >= 0)) {
HXLINE(  93)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  93)																			_hx_tmp = false;
            																		}
HXDLIN(  93)																		if (_hx_tmp) {
HXLINE(  93)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  93)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  93)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  93)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  93)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  93)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE( 237)																foundY = true;
            															}
            															else {
HXLINE(  93)																if (foundY) {
HXLINE(  93)																	goto _hx_goto_66;
            																}
            															}
            														}
            													}
            													_hx_goto_66:;
            												}
            											}
            										}
HXDLIN(  93)										if ((hasHit == false)) {
HXLINE(  93)											::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX,lowerY,bx,by,cx,cy,true);
HXDLIN(  93)											if (hasUndo) {
HXLINE(  93)												v->undoImage = undoImage;
HXDLIN(  93)												v->undoX = xIter3->start;
HXDLIN(  93)												v->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							lastX3 = nextX;
HXLINE(  94)							lastY3 = nextY;
            						}
            					}
            				}
            			}
            			else {
HXLINE(  95)				::pixelimage::ImageStruct pixelshape = temp;
HXDLIN(  95)				Float wid = this->width;
HXDLIN(  95)				Float hi = this->height;
HXDLIN(  95)				int color = this->strokeColor;
HXDLIN(  95)				 ::Dynamic dx = ((Float)-1.);
HXDLIN(  95)				 ::Dynamic dy = ((Float)-1.);
HXDLIN(  95)				 ::Dynamic fat = ((Float)-1.);
HXDLIN(  95)				 ::Dynamic tall = ((Float)-1.);
HXDLIN(  95)				if (::hx::IsLess( dx,((Float)0.) )) {
HXLINE(  95)					Float smallest;
HXDLIN(  95)					if ((hi < wid)) {
HXLINE(  95)						smallest = hi;
            					}
            					else {
HXLINE(  95)						smallest = wid;
            					}
HXDLIN(  95)					Float goldenRatio = ((Float)1.61803398875);
HXLINE(  27)					dx = (smallest / (goldenRatio + 2));
            				}
HXLINE(  95)				if (::hx::IsLess( dy,((Float)0.) )) {
HXLINE(  29)					dy = dx;
            				}
HXLINE(  95)				if (::hx::IsLess( fat,((Float)0.) )) {
HXLINE(  30)					fat = (wid - (( (Float)(2) ) * ( (Float)(dx) )));
            				}
HXLINE(  95)				if (::hx::IsLess( tall,((Float)0.) )) {
HXLINE(  31)					tall = (hi - (( (Float)(2) ) * ( (Float)(dy) )));
            				}
HXLINE(  95)				Float rightRadius = ((wid - ( (Float)(fat) )) - ( (Float)(dx) ));
HXDLIN(  95)				Float bottomRadius = ((hi - ( (Float)(tall) )) - ( (Float)(dy) ));
HXDLIN(  95)				Float farX = (dx + fat);
HXDLIN(  95)				Float lowerY = (dy + tall);
HXDLIN(  95)				{
HXLINE(  95)					Float cx = ( (Float)(dx) );
HXDLIN(  95)					Float cy = ( (Float)(dy) );
HXDLIN(  95)					Float rx = ( (Float)(dx) );
HXDLIN(  95)					Float ry = ( (Float)(dy) );
HXDLIN(  95)					{
HXLINE(  95)						 ::Dynamic targetError = ((Float)1.05);
HXDLIN(  95)						if (::hx::IsNull( targetError )) {
HXLINE( 840)							targetError = ((Float)1.05);
            						}
HXLINE(  95)						Float rSmall;
HXDLIN(  95)						if ((rx > ry)) {
HXLINE(  95)							rSmall = ry;
            						}
            						else {
HXLINE(  95)							rSmall = rx;
            						}
HXDLIN(  95)						 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN(  95)						if (::hx::IsNull( targetE )) {
HXLINE(  20)							targetE = ((Float)1.05);
            						}
HXLINE(  95)						int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  95)						int noSides;
HXDLIN(  95)						if ((result < 12)) {
HXLINE(  95)							noSides = 12;
            						}
            						else {
HXLINE(  95)							if ((result > 500)) {
HXLINE(  95)								noSides = 500;
            							}
            							else {
HXLINE(  95)								noSides = result;
            							}
            						}
HXDLIN(  95)						int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN(  95)						Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN(  95)						Float omega = ::Math_obj::PI;
HXDLIN(  95)						int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN(  95)						Float lastX = ((Float)0.);
HXDLIN(  95)						Float lastY = ((Float)0.);
HXDLIN(  95)						{
HXLINE(  26)							lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)							lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            						}
HXLINE(  95)						{
HXLINE(  95)							int _g = 0;
HXDLIN(  95)							int _g1 = (quarter + 1);
HXDLIN(  95)							while((_g < _g1)){
HXLINE(  95)								_g = (_g + 1);
HXDLIN(  95)								int i = (_g - 1);
HXDLIN(  95)								Float nextX = (cx + (rx * ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  95)								Float nextY = (cy + (ry * ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  95)								{
HXLINE(  95)									bool hasHit = false;
HXDLIN(  95)									bool hasUndo = false;
HXDLIN(  95)									{
HXLINE(  95)										Float bx = lastX;
HXDLIN(  95)										Float by = lastY;
HXDLIN(  95)										Float cx1 = nextX;
HXDLIN(  95)										Float cy1 = nextY;
HXDLIN(  95)										bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  95)										if (!(adjustWinding)) {
HXLINE(  95)											Float bx_ = bx;
HXDLIN(  95)											Float by_ = by;
HXLINE(  26)											bx = cx1;
HXLINE(  27)											by = cy1;
HXLINE(  28)											cx1 = bx_;
HXLINE(  29)											cy1 = by_;
            										}
HXLINE(  95)										{
HXLINE(  95)											Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  95)											Float sx = (cy1 - cy);
HXDLIN(  95)											Float sy = (cx - cx1);
HXDLIN(  95)											Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  95)											Float tx = (cy - by);
HXDLIN(  95)											Float ty = (bx - cx);
HXDLIN(  95)											Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  95)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  95)											if ((cx > bx)) {
HXLINE(  95)												if ((cx > cx1)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((bx > cx1)) {
HXLINE(  95)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  95)												if ((bx > cx1)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((cx > cx1)) {
HXLINE(  95)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::ceil(cx);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(cx);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            											}
HXDLIN(  95)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  95)											if ((cy > by)) {
HXLINE(  95)												if ((cy > cy1)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((by > cy1)) {
HXLINE(  95)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  95)												if ((by > cy1)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((cy > cy1)) {
HXLINE(  95)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::ceil(cy);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(cy);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            											}
HXDLIN(  95)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  95)											if (hasUndo) {
HXLINE(  95)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  95)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  95)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  95)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  95)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  95)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  95)												undoImage = this3;
HXDLIN(  95)												{
HXLINE(  95)													int rectLeft = xIter3->start;
HXDLIN(  95)													int rectTop = yIter3->start;
HXDLIN(  95)													int rectRight = xIter3->max;
HXDLIN(  95)													bool forceClear = false;
HXDLIN(  95)													{
HXLINE(  95)														int _g = rectTop;
HXDLIN(  95)														int _g1 = yIter3->max;
HXDLIN(  95)														while((_g < _g1)){
HXLINE(  95)															_g = (_g + 1);
HXDLIN(  95)															int dy = (_g - 1);
HXDLIN(  95)															{
HXLINE(  95)																int _g1 = rectLeft;
HXDLIN(  95)																int _g2 = rectRight;
HXDLIN(  95)																while((_g1 < _g2)){
HXLINE(  95)																	_g1 = (_g1 + 1);
HXDLIN(  95)																	int dx = (_g1 - 1);
HXDLIN(  95)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																	int index;
HXDLIN(  95)																	if (pixelshape->useVirtualPos) {
HXLINE(  95)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  95)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  95)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																	int col;
HXDLIN(  95)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  95)																		col = c;
            																	}
HXDLIN(  95)																	bool _hx_tmp;
HXDLIN(  95)																	if (pixelshape->useMask) {
HXLINE(  95)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  95)																		_hx_tmp = false;
            																	}
HXDLIN(  95)																	if (_hx_tmp) {
HXLINE(  95)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  95)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  95)																		int index;
HXDLIN(  95)																		if (this1->useVirtualPos) {
HXLINE(  95)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  95)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  95)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  95)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  95)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																		int v;
HXDLIN(  95)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  95)																			v = c;
            																		}
HXDLIN(  95)																		int this3 = v;
HXDLIN(  95)																		int maskPixel = this3;
HXDLIN(  95)																		int this4 = col;
HXDLIN(  95)																		int this5 = this4;
HXDLIN(  95)																		if ((maskPixel == 0)) {
HXLINE(  95)																			int this1 = this5;
HXDLIN(  95)																			col = this1;
            																		}
            																		else {
HXLINE(  95)																			Float m0;
HXDLIN(  95)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  95)																			if ((this1 == 0)) {
HXLINE(  95)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m1;
HXDLIN(  95)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  95)																			if ((this2 == 0)) {
HXLINE(  95)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m2;
HXDLIN(  95)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  95)																			if ((this3 == 0)) {
HXLINE(  95)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m3;
HXDLIN(  95)																			int this4 = (maskPixel & 255);
HXDLIN(  95)																			if ((this4 == 0)) {
HXLINE(  95)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  95)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  95)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  95)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  95)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  95)																	if ((col != 0)) {
HXLINE(  95)																		int x = (dx - rectLeft);
HXDLIN(  95)																		int y = (dy - rectTop);
HXDLIN(  95)																		int this1 = col;
HXDLIN(  95)																		int c = this1;
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			int location;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																			int this3 = this2;
HXDLIN(  95)																			int this4;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				this4 = this3;
            																			}
HXDLIN(  95)																			Float a1;
HXDLIN(  95)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)																			if ((this5 == 0)) {
HXLINE(  95)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r1;
HXDLIN(  95)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)																			if ((this6 == 0)) {
HXLINE(  95)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g1;
HXDLIN(  95)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)																			if ((this7 == 0)) {
HXLINE(  95)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b1;
HXDLIN(  95)																			int this8 = (this4 & 255);
HXDLIN(  95)																			if ((this8 == 0)) {
HXLINE(  95)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a2;
HXDLIN(  95)																			int this9 = ((col >> 24) & 255);
HXDLIN(  95)																			if ((this9 == 0)) {
HXLINE(  95)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r2;
HXDLIN(  95)																			int this10 = ((col >> 16) & 255);
HXDLIN(  95)																			if ((this10 == 0)) {
HXLINE(  95)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g2;
HXDLIN(  95)																			int this11 = ((col >> 8) & 255);
HXDLIN(  95)																			if ((this11 == 0)) {
HXLINE(  95)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b2;
HXDLIN(  95)																			int this12 = (col & 255);
HXDLIN(  95)																			if ((this12 == 0)) {
HXLINE(  95)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)																			{
HXLINE(  95)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  95)																				int value;
HXDLIN(  95)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  95)																					value = blended;
            																				}
HXDLIN(  95)																				bool _hx_tmp;
HXDLIN(  95)																				if ((location >= 0)) {
HXLINE(  95)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  95)																					_hx_tmp = false;
            																				}
HXDLIN(  95)																				if (_hx_tmp) {
HXLINE(  95)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			int value;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				value = c;
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  95)																		if (forceClear) {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			int x = (dx - rectLeft);
HXDLIN(  95)																			int y = (dy - rectTop);
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  95)											bool found = false;
HXDLIN(  95)											Float s = ((Float)0.);
HXDLIN(  95)											Float t = ((Float)0.);
HXDLIN(  95)											Float sxx = ((Float)0.);
HXDLIN(  95)											Float txx = ((Float)0.);
HXDLIN(  95)											{
HXLINE(  95)												int _g_min = xIter3->start;
HXDLIN(  95)												int _g_max = xIter3->max;
HXDLIN(  95)												while((_g_min < _g_max)){
HXLINE(  95)													_g_min = (_g_min + 1);
HXDLIN(  95)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXLINE(  95)													{
HXLINE(  95)														int _g_min1 = yIter3->start;
HXDLIN(  95)														int _g_max = yIter3->max;
HXDLIN(  95)														while((_g_min1 < _g_max)){
HXLINE(  95)															_g_min1 = (_g_min1 + 1);
HXDLIN(  95)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  95)															bool _hx_tmp;
HXDLIN(  95)															if (!((s <= 0))) {
HXLINE(  95)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  95)																_hx_tmp = true;
            															}
HXDLIN(  95)															if (_hx_tmp) {
HXLINE(  95)																if (found) {
HXLINE(  95)																	goto _hx_goto_71;
            																}
            															}
            															else {
HXLINE(  95)																if (((s + t) < A)) {
HXLINE(  95)																	{
HXLINE(  95)																		int this1 = color;
HXDLIN(  95)																		int c = this1;
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			int location;
HXDLIN(  95)																			if (pixelshape->useVirtualPos) {
HXLINE(  95)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  95)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  95)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																			int this3 = this2;
HXDLIN(  95)																			int this4;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				this4 = this3;
            																			}
HXDLIN(  95)																			Float a1;
HXDLIN(  95)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)																			if ((this5 == 0)) {
HXLINE(  95)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r1;
HXDLIN(  95)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)																			if ((this6 == 0)) {
HXLINE(  95)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g1;
HXDLIN(  95)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)																			if ((this7 == 0)) {
HXLINE(  95)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b1;
HXDLIN(  95)																			int this8 = (this4 & 255);
HXDLIN(  95)																			if ((this8 == 0)) {
HXLINE(  95)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a2;
HXDLIN(  95)																			int this9 = ((color >> 24) & 255);
HXDLIN(  95)																			if ((this9 == 0)) {
HXLINE(  95)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r2;
HXDLIN(  95)																			int this10 = ((color >> 16) & 255);
HXDLIN(  95)																			if ((this10 == 0)) {
HXLINE(  95)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g2;
HXDLIN(  95)																			int this11 = ((color >> 8) & 255);
HXDLIN(  95)																			if ((this11 == 0)) {
HXLINE(  95)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b2;
HXDLIN(  95)																			int this12 = (color & 255);
HXDLIN(  95)																			if ((this12 == 0)) {
HXLINE(  95)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)																			{
HXLINE(  95)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  95)																				int value;
HXDLIN(  95)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  95)																					value = blended;
            																				}
HXDLIN(  95)																				bool _hx_tmp;
HXDLIN(  95)																				if ((location >= 0)) {
HXLINE(  95)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  95)																					_hx_tmp = false;
            																				}
HXDLIN(  95)																				if (_hx_tmp) {
HXLINE(  95)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (pixelshape->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  95)																			int value;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				value = c;
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  95)																	if (found) {
HXLINE(  95)																		goto _hx_goto_71;
            																	}
            																}
            															}
            														}
            														_hx_goto_71:;
            													}
            												}
            											}
HXDLIN(  95)											if ((hasHit == true)) {
HXLINE(  95)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  95)												if (hasUndo) {
HXLINE(  95)													v->undoImage = undoImage;
HXDLIN(  95)													v->undoX = xIter3->start;
HXDLIN(  95)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX = nextX;
HXLINE(  47)								lastY = nextY;
            							}
            						}
            					}
            				}
HXLINE(  95)				{
HXLINE(  95)					Float x = ( (Float)(dx) );
HXDLIN(  95)					int p = ::Std_obj::_hx_int(x);
HXDLIN(  95)					int xx = p;
HXDLIN(  95)					int q = 0;
HXDLIN(  95)					int maxX = ::Std_obj::_hx_int((x + ( (Float)(fat) )));
HXDLIN(  95)					int maxY = ::Std_obj::_hx_int(( (Float)(dy) ));
HXDLIN(  95)					while(true){
HXLINE(  95)						{
HXLINE(  95)							p = (p + 1);
HXDLIN(  95)							int x = (p - 1);
HXDLIN(  95)							int this1 = color;
HXDLIN(  95)							int c = this1;
HXDLIN(  95)							bool _hx_tmp;
HXDLIN(  95)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)								_hx_tmp = pixelshape->transparent;
            							}
            							else {
HXLINE(  95)								_hx_tmp = false;
            							}
HXDLIN(  95)							if (_hx_tmp) {
HXLINE(  95)								int location;
HXDLIN(  95)								if (pixelshape->useVirtualPos) {
HXLINE(  95)									location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  95)									location = ::Std_obj::_hx_int(( (Float)(((q * pixelshape->width) + x)) ));
            								}
HXDLIN(  95)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)								int this3 = this2;
HXDLIN(  95)								int this4;
HXDLIN(  95)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  95)									this4 = this3;
            								}
HXDLIN(  95)								Float a1;
HXDLIN(  95)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)								if ((this5 == 0)) {
HXLINE(  95)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float r1;
HXDLIN(  95)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)								if ((this6 == 0)) {
HXLINE(  95)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float g1;
HXDLIN(  95)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)								if ((this7 == 0)) {
HXLINE(  95)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float b1;
HXDLIN(  95)								int this8 = (this4 & 255);
HXDLIN(  95)								if ((this8 == 0)) {
HXLINE(  95)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float a2;
HXDLIN(  95)								int this9 = ((color >> 24) & 255);
HXDLIN(  95)								if ((this9 == 0)) {
HXLINE(  95)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float r2;
HXDLIN(  95)								int this10 = ((color >> 16) & 255);
HXDLIN(  95)								if ((this10 == 0)) {
HXLINE(  95)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float g2;
HXDLIN(  95)								int this11 = ((color >> 8) & 255);
HXDLIN(  95)								if ((this11 == 0)) {
HXLINE(  95)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float b2;
HXDLIN(  95)								int this12 = (color & 255);
HXDLIN(  95)								if ((this12 == 0)) {
HXLINE(  95)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)								{
HXLINE(  95)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  95)									int value;
HXDLIN(  95)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  95)										value = blended;
            									}
HXDLIN(  95)									bool _hx_tmp;
HXDLIN(  95)									if ((location >= 0)) {
HXLINE(  95)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  95)										_hx_tmp = false;
            									}
HXDLIN(  95)									if (_hx_tmp) {
HXLINE(  95)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  95)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)								int index;
HXDLIN(  95)								if (pixelshape->useVirtualPos) {
HXLINE(  95)									index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  95)									index = ::Std_obj::_hx_int(( (Float)(((q * pixelshape->width) + x)) ));
            								}
HXDLIN(  95)								int value;
HXDLIN(  95)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  95)									value = c;
            								}
HXDLIN(  95)								bool _hx_tmp;
HXDLIN(  95)								if ((index >= 0)) {
HXLINE(  95)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  95)									_hx_tmp = false;
            								}
HXDLIN(  95)								if (_hx_tmp) {
HXLINE(  95)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  95)						if ((p > maxX)) {
HXLINE( 247)							p = xx;
HXLINE(  95)							q = (q + 1);
            						}
HXDLIN(  95)						if ((q > maxY)) {
HXLINE(  95)							goto _hx_goto_72;
            						}
            					}
            					_hx_goto_72:;
            				}
HXDLIN(  95)				{
HXLINE(  95)					Float cy1 = ( (Float)(dy) );
HXDLIN(  95)					Float ry1 = ( (Float)(dy) );
HXDLIN(  95)					{
HXLINE(  95)						 ::Dynamic targetError1 = ((Float)1.05);
HXDLIN(  95)						if (::hx::IsNull( targetError1 )) {
HXLINE( 840)							targetError1 = ((Float)1.05);
            						}
HXLINE(  95)						Float rSmall1;
HXDLIN(  95)						if ((rightRadius > ry1)) {
HXLINE(  95)							rSmall1 = ry1;
            						}
            						else {
HXLINE(  95)							rSmall1 = rightRadius;
            						}
HXDLIN(  95)						 ::Dynamic targetE1 = ( (Float)(targetError1) );
HXDLIN(  95)						if (::hx::IsNull( targetE1 )) {
HXLINE(  20)							targetE1 = ((Float)1.05);
            						}
HXLINE(  95)						int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN(  95)						int noSides1;
HXDLIN(  95)						if ((result1 < 12)) {
HXLINE(  95)							noSides1 = 12;
            						}
            						else {
HXLINE(  95)							if ((result1 > 500)) {
HXLINE(  95)								noSides1 = 500;
            							}
            							else {
HXLINE(  95)								noSides1 = result1;
            							}
            						}
HXDLIN(  95)						int sides1 = (::Math_obj::ceil((( (Float)(noSides1) ) / ( (Float)(4) ))) * 4);
HXDLIN(  95)						Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  95)						Float omega1 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN(  95)						int quarter1 = ::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(4) )));
HXDLIN(  95)						Float lastX1 = ((Float)0.);
HXDLIN(  95)						Float lastY1 = ((Float)0.);
HXDLIN(  95)						{
HXLINE(  26)							lastX1 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides1) ) * theta1) + omega1))));
HXLINE(  27)							lastY1 = (cy1 + (ry1 * ::Math_obj::sin(((( (Float)(sides1) ) * theta1) + omega1))));
            						}
HXLINE(  95)						{
HXLINE(  95)							int _g2 = 0;
HXDLIN(  95)							int _g3 = (quarter1 + 1);
HXDLIN(  95)							while((_g2 < _g3)){
HXLINE(  95)								_g2 = (_g2 + 1);
HXDLIN(  95)								int i = (_g2 - 1);
HXDLIN(  95)								Float nextX = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  95)								Float nextY = (cy1 + (ry1 * ::Math_obj::sin((((( (Float)(i) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  95)								{
HXLINE(  95)									bool hasHit = false;
HXDLIN(  95)									bool hasUndo = false;
HXDLIN(  95)									{
HXLINE(  95)										Float bx = lastX1;
HXDLIN(  95)										Float by = lastY1;
HXDLIN(  95)										Float cx = nextX;
HXDLIN(  95)										Float cy = nextY;
HXDLIN(  95)										bool adjustWinding = (((((farX * by) - (bx * cy1)) + ((bx * cy) - (cx * by))) + ((cx * cy1) - (farX * cy))) > 0);
HXDLIN(  95)										if (!(adjustWinding)) {
HXLINE(  95)											Float bx_ = bx;
HXDLIN(  95)											Float by_ = by;
HXLINE(  26)											bx = cx;
HXLINE(  27)											by = cy;
HXLINE(  28)											cx = bx_;
HXLINE(  29)											cy = by_;
            										}
HXLINE(  95)										{
HXLINE(  95)											Float s0 = ((cy1 * cx) - (farX * cy));
HXDLIN(  95)											Float sx = (cy - cy1);
HXDLIN(  95)											Float sy = (farX - cx);
HXDLIN(  95)											Float t0 = ((farX * by) - (cy1 * bx));
HXDLIN(  95)											Float tx = (cy1 - by);
HXDLIN(  95)											Float ty = (bx - farX);
HXDLIN(  95)											Float A = ((((-(by) * cx) + (cy1 * (-(bx) + cx))) + (farX * (by - cy))) + (bx * cy));
HXDLIN(  95)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  95)											if ((farX > bx)) {
HXLINE(  95)												if ((farX > cx)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((bx > cx)) {
HXLINE(  95)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(farX);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  95)												if ((bx > cx)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((farX > cx)) {
HXLINE(  95)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::ceil(farX);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(farX);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            											}
HXDLIN(  95)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  95)											if ((cy1 > by)) {
HXLINE(  95)												if ((cy1 > cy)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((by > cy)) {
HXLINE(  95)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  95)												if ((by > cy)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((cy1 > cy)) {
HXLINE(  95)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::ceil(cy1);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(cy1);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            											}
HXDLIN(  95)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  95)											if (hasUndo) {
HXLINE(  95)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  95)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  95)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  95)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  95)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  95)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  95)												undoImage = this3;
HXDLIN(  95)												{
HXLINE(  95)													int rectLeft = xIter3->start;
HXDLIN(  95)													int rectTop = yIter3->start;
HXDLIN(  95)													int rectRight = xIter3->max;
HXDLIN(  95)													bool forceClear = false;
HXDLIN(  95)													{
HXLINE(  95)														int _g = rectTop;
HXDLIN(  95)														int _g1 = yIter3->max;
HXDLIN(  95)														while((_g < _g1)){
HXLINE(  95)															_g = (_g + 1);
HXDLIN(  95)															int dy = (_g - 1);
HXDLIN(  95)															{
HXLINE(  95)																int _g1 = rectLeft;
HXDLIN(  95)																int _g2 = rectRight;
HXDLIN(  95)																while((_g1 < _g2)){
HXLINE(  95)																	_g1 = (_g1 + 1);
HXDLIN(  95)																	int dx = (_g1 - 1);
HXDLIN(  95)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																	int index;
HXDLIN(  95)																	if (pixelshape->useVirtualPos) {
HXLINE(  95)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  95)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  95)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																	int col;
HXDLIN(  95)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  95)																		col = c;
            																	}
HXDLIN(  95)																	bool _hx_tmp;
HXDLIN(  95)																	if (pixelshape->useMask) {
HXLINE(  95)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  95)																		_hx_tmp = false;
            																	}
HXDLIN(  95)																	if (_hx_tmp) {
HXLINE(  95)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  95)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  95)																		int index;
HXDLIN(  95)																		if (this1->useVirtualPos) {
HXLINE(  95)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  95)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  95)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  95)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  95)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																		int v;
HXDLIN(  95)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  95)																			v = c;
            																		}
HXDLIN(  95)																		int this3 = v;
HXDLIN(  95)																		int maskPixel = this3;
HXDLIN(  95)																		int this4 = col;
HXDLIN(  95)																		int this5 = this4;
HXDLIN(  95)																		if ((maskPixel == 0)) {
HXLINE(  95)																			int this1 = this5;
HXDLIN(  95)																			col = this1;
            																		}
            																		else {
HXLINE(  95)																			Float m0;
HXDLIN(  95)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  95)																			if ((this1 == 0)) {
HXLINE(  95)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m1;
HXDLIN(  95)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  95)																			if ((this2 == 0)) {
HXLINE(  95)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m2;
HXDLIN(  95)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  95)																			if ((this3 == 0)) {
HXLINE(  95)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m3;
HXDLIN(  95)																			int this4 = (maskPixel & 255);
HXDLIN(  95)																			if ((this4 == 0)) {
HXLINE(  95)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  95)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  95)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  95)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  95)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  95)																	if ((col != 0)) {
HXLINE(  95)																		int x = (dx - rectLeft);
HXDLIN(  95)																		int y = (dy - rectTop);
HXDLIN(  95)																		int this1 = col;
HXDLIN(  95)																		int c = this1;
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			int location;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																			int this3 = this2;
HXDLIN(  95)																			int this4;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				this4 = this3;
            																			}
HXDLIN(  95)																			Float a1;
HXDLIN(  95)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)																			if ((this5 == 0)) {
HXLINE(  95)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r1;
HXDLIN(  95)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)																			if ((this6 == 0)) {
HXLINE(  95)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g1;
HXDLIN(  95)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)																			if ((this7 == 0)) {
HXLINE(  95)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b1;
HXDLIN(  95)																			int this8 = (this4 & 255);
HXDLIN(  95)																			if ((this8 == 0)) {
HXLINE(  95)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a2;
HXDLIN(  95)																			int this9 = ((col >> 24) & 255);
HXDLIN(  95)																			if ((this9 == 0)) {
HXLINE(  95)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r2;
HXDLIN(  95)																			int this10 = ((col >> 16) & 255);
HXDLIN(  95)																			if ((this10 == 0)) {
HXLINE(  95)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g2;
HXDLIN(  95)																			int this11 = ((col >> 8) & 255);
HXDLIN(  95)																			if ((this11 == 0)) {
HXLINE(  95)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b2;
HXDLIN(  95)																			int this12 = (col & 255);
HXDLIN(  95)																			if ((this12 == 0)) {
HXLINE(  95)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)																			{
HXLINE(  95)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  95)																				int value;
HXDLIN(  95)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  95)																					value = blended;
            																				}
HXDLIN(  95)																				bool _hx_tmp;
HXDLIN(  95)																				if ((location >= 0)) {
HXLINE(  95)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  95)																					_hx_tmp = false;
            																				}
HXDLIN(  95)																				if (_hx_tmp) {
HXLINE(  95)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			int value;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				value = c;
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  95)																		if (forceClear) {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			int x = (dx - rectLeft);
HXDLIN(  95)																			int y = (dy - rectTop);
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  95)											bool found = false;
HXDLIN(  95)											Float s = ((Float)0.);
HXDLIN(  95)											Float t = ((Float)0.);
HXDLIN(  95)											Float sxx = ((Float)0.);
HXDLIN(  95)											Float txx = ((Float)0.);
HXDLIN(  95)											{
HXLINE(  95)												int _g_min = xIter3->start;
HXDLIN(  95)												int _g_max = xIter3->max;
HXDLIN(  95)												while((_g_min < _g_max)){
HXLINE(  95)													_g_min = (_g_min + 1);
HXDLIN(  95)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXLINE(  95)													{
HXLINE(  95)														int _g_min1 = yIter3->start;
HXDLIN(  95)														int _g_max = yIter3->max;
HXDLIN(  95)														while((_g_min1 < _g_max)){
HXLINE(  95)															_g_min1 = (_g_min1 + 1);
HXDLIN(  95)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  95)															bool _hx_tmp;
HXDLIN(  95)															if (!((s <= 0))) {
HXLINE(  95)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  95)																_hx_tmp = true;
            															}
HXDLIN(  95)															if (_hx_tmp) {
HXLINE(  95)																if (found) {
HXLINE(  95)																	goto _hx_goto_77;
            																}
            															}
            															else {
HXLINE(  95)																if (((s + t) < A)) {
HXLINE(  95)																	{
HXLINE(  95)																		int this1 = color;
HXDLIN(  95)																		int c = this1;
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			int location;
HXDLIN(  95)																			if (pixelshape->useVirtualPos) {
HXLINE(  95)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  95)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  95)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																			int this3 = this2;
HXDLIN(  95)																			int this4;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				this4 = this3;
            																			}
HXDLIN(  95)																			Float a1;
HXDLIN(  95)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)																			if ((this5 == 0)) {
HXLINE(  95)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r1;
HXDLIN(  95)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)																			if ((this6 == 0)) {
HXLINE(  95)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g1;
HXDLIN(  95)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)																			if ((this7 == 0)) {
HXLINE(  95)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b1;
HXDLIN(  95)																			int this8 = (this4 & 255);
HXDLIN(  95)																			if ((this8 == 0)) {
HXLINE(  95)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a2;
HXDLIN(  95)																			int this9 = ((color >> 24) & 255);
HXDLIN(  95)																			if ((this9 == 0)) {
HXLINE(  95)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r2;
HXDLIN(  95)																			int this10 = ((color >> 16) & 255);
HXDLIN(  95)																			if ((this10 == 0)) {
HXLINE(  95)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g2;
HXDLIN(  95)																			int this11 = ((color >> 8) & 255);
HXDLIN(  95)																			if ((this11 == 0)) {
HXLINE(  95)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b2;
HXDLIN(  95)																			int this12 = (color & 255);
HXDLIN(  95)																			if ((this12 == 0)) {
HXLINE(  95)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)																			{
HXLINE(  95)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  95)																				int value;
HXDLIN(  95)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  95)																					value = blended;
            																				}
HXDLIN(  95)																				bool _hx_tmp;
HXDLIN(  95)																				if ((location >= 0)) {
HXLINE(  95)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  95)																					_hx_tmp = false;
            																				}
HXDLIN(  95)																				if (_hx_tmp) {
HXLINE(  95)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (pixelshape->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  95)																			int value;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				value = c;
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  95)																	if (found) {
HXLINE(  95)																		goto _hx_goto_77;
            																	}
            																}
            															}
            														}
            														_hx_goto_77:;
            													}
            												}
            											}
HXDLIN(  95)											if ((hasHit == true)) {
HXLINE(  95)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX,cy1,bx,by,cx,cy,true);
HXDLIN(  95)												if (hasUndo) {
HXLINE(  95)													v->undoImage = undoImage;
HXDLIN(  95)													v->undoX = xIter3->start;
HXDLIN(  95)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX1 = nextX;
HXLINE(  47)								lastY1 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  95)				{
HXLINE(  95)					Float y = ( (Float)(dy) );
HXDLIN(  95)					int p1 = 0;
HXDLIN(  95)					int xx1 = p1;
HXDLIN(  95)					int q1 = ::Std_obj::_hx_int(y);
HXDLIN(  95)					int maxX1 = ::Std_obj::_hx_int(wid);
HXDLIN(  95)					int maxY1 = ::Std_obj::_hx_int((y + ( (Float)(tall) )));
HXDLIN(  95)					while(true){
HXLINE(  95)						{
HXLINE(  95)							p1 = (p1 + 1);
HXDLIN(  95)							int x = (p1 - 1);
HXDLIN(  95)							int this1 = color;
HXDLIN(  95)							int c = this1;
HXDLIN(  95)							bool _hx_tmp;
HXDLIN(  95)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)								_hx_tmp = pixelshape->transparent;
            							}
            							else {
HXLINE(  95)								_hx_tmp = false;
            							}
HXDLIN(  95)							if (_hx_tmp) {
HXLINE(  95)								int location;
HXDLIN(  95)								if (pixelshape->useVirtualPos) {
HXLINE(  95)									location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  95)									location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelshape->width) + x)) ));
            								}
HXDLIN(  95)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)								int this3 = this2;
HXDLIN(  95)								int this4;
HXDLIN(  95)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  95)									this4 = this3;
            								}
HXDLIN(  95)								Float a1;
HXDLIN(  95)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)								if ((this5 == 0)) {
HXLINE(  95)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float r1;
HXDLIN(  95)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)								if ((this6 == 0)) {
HXLINE(  95)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float g1;
HXDLIN(  95)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)								if ((this7 == 0)) {
HXLINE(  95)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float b1;
HXDLIN(  95)								int this8 = (this4 & 255);
HXDLIN(  95)								if ((this8 == 0)) {
HXLINE(  95)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float a2;
HXDLIN(  95)								int this9 = ((color >> 24) & 255);
HXDLIN(  95)								if ((this9 == 0)) {
HXLINE(  95)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float r2;
HXDLIN(  95)								int this10 = ((color >> 16) & 255);
HXDLIN(  95)								if ((this10 == 0)) {
HXLINE(  95)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float g2;
HXDLIN(  95)								int this11 = ((color >> 8) & 255);
HXDLIN(  95)								if ((this11 == 0)) {
HXLINE(  95)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float b2;
HXDLIN(  95)								int this12 = (color & 255);
HXDLIN(  95)								if ((this12 == 0)) {
HXLINE(  95)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)								{
HXLINE(  95)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  95)									int value;
HXDLIN(  95)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  95)										value = blended;
            									}
HXDLIN(  95)									bool _hx_tmp;
HXDLIN(  95)									if ((location >= 0)) {
HXLINE(  95)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  95)										_hx_tmp = false;
            									}
HXDLIN(  95)									if (_hx_tmp) {
HXLINE(  95)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  95)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)								int index;
HXDLIN(  95)								if (pixelshape->useVirtualPos) {
HXLINE(  95)									index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  95)									index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelshape->width) + x)) ));
            								}
HXDLIN(  95)								int value;
HXDLIN(  95)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  95)									value = c;
            								}
HXDLIN(  95)								bool _hx_tmp;
HXDLIN(  95)								if ((index >= 0)) {
HXLINE(  95)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  95)									_hx_tmp = false;
            								}
HXDLIN(  95)								if (_hx_tmp) {
HXLINE(  95)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  95)						if ((p1 > maxX1)) {
HXLINE( 247)							p1 = xx1;
HXLINE(  95)							q1 = (q1 + 1);
            						}
HXDLIN(  95)						if ((q1 > maxY1)) {
HXLINE(  95)							goto _hx_goto_78;
            						}
            					}
            					_hx_goto_78:;
            				}
HXDLIN(  95)				{
HXLINE(  95)					Float cx1 = ( (Float)(dx) );
HXDLIN(  95)					Float rx1 = ( (Float)(dx) );
HXDLIN(  95)					{
HXLINE(  95)						 ::Dynamic targetError2 = ((Float)1.05);
HXDLIN(  95)						if (::hx::IsNull( targetError2 )) {
HXLINE( 840)							targetError2 = ((Float)1.05);
            						}
HXLINE(  95)						Float rSmall2;
HXDLIN(  95)						if ((rx1 > bottomRadius)) {
HXLINE(  95)							rSmall2 = bottomRadius;
            						}
            						else {
HXLINE(  95)							rSmall2 = rx1;
            						}
HXDLIN(  95)						 ::Dynamic targetE2 = ( (Float)(targetError2) );
HXDLIN(  95)						if (::hx::IsNull( targetE2 )) {
HXLINE(  20)							targetE2 = ((Float)1.05);
            						}
HXLINE(  95)						int result2 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE2) ) / rSmall2)))));
HXDLIN(  95)						int noSides2;
HXDLIN(  95)						if ((result2 < 12)) {
HXLINE(  95)							noSides2 = 12;
            						}
            						else {
HXLINE(  95)							if ((result2 > 500)) {
HXLINE(  95)								noSides2 = 500;
            							}
            							else {
HXLINE(  95)								noSides2 = result2;
            							}
            						}
HXDLIN(  95)						int sides2 = (::Math_obj::ceil((( (Float)(noSides2) ) / ( (Float)(4) ))) * 4);
HXDLIN(  95)						Float theta2 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides2) ));
HXDLIN(  95)						Float omega2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  95)						int quarter2 = ::Std_obj::_hx_int((( (Float)(sides2) ) / ( (Float)(4) )));
HXDLIN(  95)						Float lastX2 = ((Float)0.);
HXDLIN(  95)						Float lastY2 = ((Float)0.);
HXDLIN(  95)						{
HXLINE(  26)							lastX2 = (cx1 + (rx1 * ::Math_obj::cos(((( (Float)(sides2) ) * theta2) + omega2))));
HXLINE(  27)							lastY2 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides2) ) * theta2) + omega2))));
            						}
HXLINE(  95)						{
HXLINE(  95)							int _g4 = 0;
HXDLIN(  95)							int _g5 = (quarter2 + 1);
HXDLIN(  95)							while((_g4 < _g5)){
HXLINE(  95)								_g4 = (_g4 + 1);
HXDLIN(  95)								int i = (_g4 - 1);
HXDLIN(  95)								Float nextX = (cx1 + (rx1 * ::Math_obj::cos((((( (Float)(i) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  95)								Float nextY = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  95)								{
HXLINE(  95)									bool hasHit = false;
HXDLIN(  95)									bool hasUndo = false;
HXDLIN(  95)									{
HXLINE(  95)										Float bx = lastX2;
HXDLIN(  95)										Float by = lastY2;
HXDLIN(  95)										Float cx = nextX;
HXDLIN(  95)										Float cy = nextY;
HXDLIN(  95)										bool adjustWinding = (((((cx1 * by) - (bx * lowerY)) + ((bx * cy) - (cx * by))) + ((cx * lowerY) - (cx1 * cy))) > 0);
HXDLIN(  95)										if (!(adjustWinding)) {
HXLINE(  95)											Float bx_ = bx;
HXDLIN(  95)											Float by_ = by;
HXLINE(  26)											bx = cx;
HXLINE(  27)											by = cy;
HXLINE(  28)											cx = bx_;
HXLINE(  29)											cy = by_;
            										}
HXLINE(  95)										{
HXLINE(  95)											Float s0 = ((lowerY * cx) - (cx1 * cy));
HXDLIN(  95)											Float sx = (cy - lowerY);
HXDLIN(  95)											Float sy = (cx1 - cx);
HXDLIN(  95)											Float t0 = ((cx1 * by) - (lowerY * bx));
HXDLIN(  95)											Float tx = (lowerY - by);
HXDLIN(  95)											Float ty = (bx - cx1);
HXDLIN(  95)											Float A = ((((-(by) * cx) + (lowerY * (-(bx) + cx))) + (cx1 * (by - cy))) + (bx * cy));
HXDLIN(  95)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  95)											if ((cx1 > bx)) {
HXLINE(  95)												if ((cx1 > cx)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((bx > cx)) {
HXLINE(  95)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  95)												if ((bx > cx)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((cx1 > cx)) {
HXLINE(  95)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::ceil(cx1);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(cx1);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													xIter3 = this1;
            												}
            											}
HXDLIN(  95)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  95)											if ((lowerY > by)) {
HXLINE(  95)												if ((lowerY > cy)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((by > cy)) {
HXLINE(  95)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  95)												if ((by > cy)) {
HXLINE(  95)													int min;
HXDLIN(  95)													if ((lowerY > cy)) {
HXLINE(  95)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  95)														min = ::Math_obj::ceil(lowerY);
            													}
HXDLIN(  95)													int ii_min = min;
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            												else {
HXLINE(  95)													int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  95)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  95)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)													yIter3 = this1;
            												}
            											}
HXDLIN(  95)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  95)											if (hasUndo) {
HXLINE(  95)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  95)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  95)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  95)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  95)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  95)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  95)												undoImage = this3;
HXDLIN(  95)												{
HXLINE(  95)													int rectLeft = xIter3->start;
HXDLIN(  95)													int rectTop = yIter3->start;
HXDLIN(  95)													int rectRight = xIter3->max;
HXDLIN(  95)													bool forceClear = false;
HXDLIN(  95)													{
HXLINE(  95)														int _g = rectTop;
HXDLIN(  95)														int _g1 = yIter3->max;
HXDLIN(  95)														while((_g < _g1)){
HXLINE(  95)															_g = (_g + 1);
HXDLIN(  95)															int dy = (_g - 1);
HXDLIN(  95)															{
HXLINE(  95)																int _g1 = rectLeft;
HXDLIN(  95)																int _g2 = rectRight;
HXDLIN(  95)																while((_g1 < _g2)){
HXLINE(  95)																	_g1 = (_g1 + 1);
HXDLIN(  95)																	int dx = (_g1 - 1);
HXDLIN(  95)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																	int index;
HXDLIN(  95)																	if (pixelshape->useVirtualPos) {
HXLINE(  95)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  95)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  95)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																	int col;
HXDLIN(  95)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  95)																		col = c;
            																	}
HXDLIN(  95)																	bool _hx_tmp;
HXDLIN(  95)																	if (pixelshape->useMask) {
HXLINE(  95)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  95)																		_hx_tmp = false;
            																	}
HXDLIN(  95)																	if (_hx_tmp) {
HXLINE(  95)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  95)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  95)																		int index;
HXDLIN(  95)																		if (this1->useVirtualPos) {
HXLINE(  95)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  95)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  95)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  95)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  95)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																		int v;
HXDLIN(  95)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  95)																			v = c;
            																		}
HXDLIN(  95)																		int this3 = v;
HXDLIN(  95)																		int maskPixel = this3;
HXDLIN(  95)																		int this4 = col;
HXDLIN(  95)																		int this5 = this4;
HXDLIN(  95)																		if ((maskPixel == 0)) {
HXLINE(  95)																			int this1 = this5;
HXDLIN(  95)																			col = this1;
            																		}
            																		else {
HXLINE(  95)																			Float m0;
HXDLIN(  95)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  95)																			if ((this1 == 0)) {
HXLINE(  95)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m1;
HXDLIN(  95)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  95)																			if ((this2 == 0)) {
HXLINE(  95)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m2;
HXDLIN(  95)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  95)																			if ((this3 == 0)) {
HXLINE(  95)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float m3;
HXDLIN(  95)																			int this4 = (maskPixel & 255);
HXDLIN(  95)																			if ((this4 == 0)) {
HXLINE(  95)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  95)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  95)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  95)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  95)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  95)																	if ((col != 0)) {
HXLINE(  95)																		int x = (dx - rectLeft);
HXDLIN(  95)																		int y = (dy - rectTop);
HXDLIN(  95)																		int this1 = col;
HXDLIN(  95)																		int c = this1;
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			int location;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																			int this3 = this2;
HXDLIN(  95)																			int this4;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				this4 = this3;
            																			}
HXDLIN(  95)																			Float a1;
HXDLIN(  95)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)																			if ((this5 == 0)) {
HXLINE(  95)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r1;
HXDLIN(  95)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)																			if ((this6 == 0)) {
HXLINE(  95)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g1;
HXDLIN(  95)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)																			if ((this7 == 0)) {
HXLINE(  95)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b1;
HXDLIN(  95)																			int this8 = (this4 & 255);
HXDLIN(  95)																			if ((this8 == 0)) {
HXLINE(  95)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a2;
HXDLIN(  95)																			int this9 = ((col >> 24) & 255);
HXDLIN(  95)																			if ((this9 == 0)) {
HXLINE(  95)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r2;
HXDLIN(  95)																			int this10 = ((col >> 16) & 255);
HXDLIN(  95)																			if ((this10 == 0)) {
HXLINE(  95)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g2;
HXDLIN(  95)																			int this11 = ((col >> 8) & 255);
HXDLIN(  95)																			if ((this11 == 0)) {
HXLINE(  95)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b2;
HXDLIN(  95)																			int this12 = (col & 255);
HXDLIN(  95)																			if ((this12 == 0)) {
HXLINE(  95)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)																			{
HXLINE(  95)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  95)																				int value;
HXDLIN(  95)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  95)																					value = blended;
            																				}
HXDLIN(  95)																				bool _hx_tmp;
HXDLIN(  95)																				if ((location >= 0)) {
HXLINE(  95)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  95)																					_hx_tmp = false;
            																				}
HXDLIN(  95)																				if (_hx_tmp) {
HXLINE(  95)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			int value;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				value = c;
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  95)																		if (forceClear) {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																			int x = (dx - rectLeft);
HXDLIN(  95)																			int y = (dy - rectTop);
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (undoImage->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  95)											bool found = false;
HXDLIN(  95)											Float s = ((Float)0.);
HXDLIN(  95)											Float t = ((Float)0.);
HXDLIN(  95)											Float sxx = ((Float)0.);
HXDLIN(  95)											Float txx = ((Float)0.);
HXDLIN(  95)											{
HXLINE(  95)												int _g_min = xIter3->start;
HXDLIN(  95)												int _g_max = xIter3->max;
HXDLIN(  95)												while((_g_min < _g_max)){
HXLINE(  95)													_g_min = (_g_min + 1);
HXDLIN(  95)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXLINE(  95)													{
HXLINE(  95)														int _g_min1 = yIter3->start;
HXDLIN(  95)														int _g_max = yIter3->max;
HXDLIN(  95)														while((_g_min1 < _g_max)){
HXLINE(  95)															_g_min1 = (_g_min1 + 1);
HXDLIN(  95)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  95)															bool _hx_tmp;
HXDLIN(  95)															if (!((s <= 0))) {
HXLINE(  95)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  95)																_hx_tmp = true;
            															}
HXDLIN(  95)															if (_hx_tmp) {
HXLINE(  95)																if (found) {
HXLINE(  95)																	goto _hx_goto_83;
            																}
            															}
            															else {
HXLINE(  95)																if (((s + t) < A)) {
HXLINE(  95)																	{
HXLINE(  95)																		int this1 = color;
HXDLIN(  95)																		int c = this1;
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			int location;
HXDLIN(  95)																			if (pixelshape->useVirtualPos) {
HXLINE(  95)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  95)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  95)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																			int this3 = this2;
HXDLIN(  95)																			int this4;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				this4 = this3;
            																			}
HXDLIN(  95)																			Float a1;
HXDLIN(  95)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)																			if ((this5 == 0)) {
HXLINE(  95)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r1;
HXDLIN(  95)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)																			if ((this6 == 0)) {
HXLINE(  95)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g1;
HXDLIN(  95)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)																			if ((this7 == 0)) {
HXLINE(  95)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b1;
HXDLIN(  95)																			int this8 = (this4 & 255);
HXDLIN(  95)																			if ((this8 == 0)) {
HXLINE(  95)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a2;
HXDLIN(  95)																			int this9 = ((color >> 24) & 255);
HXDLIN(  95)																			if ((this9 == 0)) {
HXLINE(  95)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float r2;
HXDLIN(  95)																			int this10 = ((color >> 16) & 255);
HXDLIN(  95)																			if ((this10 == 0)) {
HXLINE(  95)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float g2;
HXDLIN(  95)																			int this11 = ((color >> 8) & 255);
HXDLIN(  95)																			if ((this11 == 0)) {
HXLINE(  95)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float b2;
HXDLIN(  95)																			int this12 = (color & 255);
HXDLIN(  95)																			if ((this12 == 0)) {
HXLINE(  95)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  95)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  95)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)																			{
HXLINE(  95)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  95)																				int value;
HXDLIN(  95)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  95)																					value = blended;
            																				}
HXDLIN(  95)																				bool _hx_tmp;
HXDLIN(  95)																				if ((location >= 0)) {
HXLINE(  95)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  95)																					_hx_tmp = false;
            																				}
HXDLIN(  95)																				if (_hx_tmp) {
HXLINE(  95)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																			int index;
HXDLIN(  95)																			if (pixelshape->useVirtualPos) {
HXLINE(  95)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  95)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  95)																			int value;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				value = c;
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((index >= 0)) {
HXLINE(  95)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  95)																	if (found) {
HXLINE(  95)																		goto _hx_goto_83;
            																	}
            																}
            															}
            														}
            														_hx_goto_83:;
            													}
            												}
            											}
HXDLIN(  95)											if ((hasHit == true)) {
HXLINE(  95)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx1,lowerY,bx,by,cx,cy,true);
HXDLIN(  95)												if (hasUndo) {
HXLINE(  95)													v->undoImage = undoImage;
HXDLIN(  95)													v->undoX = xIter3->start;
HXDLIN(  95)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX2 = nextX;
HXLINE(  47)								lastY2 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  95)				{
HXLINE(  95)					Float x1 = ( (Float)(dx) );
HXDLIN(  95)					int p2 = ::Std_obj::_hx_int(x1);
HXDLIN(  95)					int xx2 = p2;
HXDLIN(  95)					int q2 = ::Std_obj::_hx_int(lowerY);
HXDLIN(  95)					int maxX2 = ::Std_obj::_hx_int((x1 + ( (Float)(fat) )));
HXDLIN(  95)					int maxY2 = ::Std_obj::_hx_int((lowerY + bottomRadius));
HXDLIN(  95)					while(true){
HXLINE(  95)						{
HXLINE(  95)							p2 = (p2 + 1);
HXDLIN(  95)							int x = (p2 - 1);
HXDLIN(  95)							int this1 = color;
HXDLIN(  95)							int c = this1;
HXDLIN(  95)							bool _hx_tmp;
HXDLIN(  95)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)								_hx_tmp = pixelshape->transparent;
            							}
            							else {
HXLINE(  95)								_hx_tmp = false;
            							}
HXDLIN(  95)							if (_hx_tmp) {
HXLINE(  95)								int location;
HXDLIN(  95)								if (pixelshape->useVirtualPos) {
HXLINE(  95)									location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  95)									location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelshape->width) + x)) ));
            								}
HXDLIN(  95)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)								int this3 = this2;
HXDLIN(  95)								int this4;
HXDLIN(  95)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  95)									this4 = this3;
            								}
HXDLIN(  95)								Float a1;
HXDLIN(  95)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)								if ((this5 == 0)) {
HXLINE(  95)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float r1;
HXDLIN(  95)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)								if ((this6 == 0)) {
HXLINE(  95)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float g1;
HXDLIN(  95)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)								if ((this7 == 0)) {
HXLINE(  95)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float b1;
HXDLIN(  95)								int this8 = (this4 & 255);
HXDLIN(  95)								if ((this8 == 0)) {
HXLINE(  95)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float a2;
HXDLIN(  95)								int this9 = ((color >> 24) & 255);
HXDLIN(  95)								if ((this9 == 0)) {
HXLINE(  95)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float r2;
HXDLIN(  95)								int this10 = ((color >> 16) & 255);
HXDLIN(  95)								if ((this10 == 0)) {
HXLINE(  95)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float g2;
HXDLIN(  95)								int this11 = ((color >> 8) & 255);
HXDLIN(  95)								if ((this11 == 0)) {
HXLINE(  95)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float b2;
HXDLIN(  95)								int this12 = (color & 255);
HXDLIN(  95)								if ((this12 == 0)) {
HXLINE(  95)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  95)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  95)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)								{
HXLINE(  95)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  95)									int value;
HXDLIN(  95)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  95)										value = blended;
            									}
HXDLIN(  95)									bool _hx_tmp;
HXDLIN(  95)									if ((location >= 0)) {
HXLINE(  95)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  95)										_hx_tmp = false;
            									}
HXDLIN(  95)									if (_hx_tmp) {
HXLINE(  95)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  95)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)								int index;
HXDLIN(  95)								if (pixelshape->useVirtualPos) {
HXLINE(  95)									index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  95)									index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelshape->width) + x)) ));
            								}
HXDLIN(  95)								int value;
HXDLIN(  95)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  95)									value = c;
            								}
HXDLIN(  95)								bool _hx_tmp;
HXDLIN(  95)								if ((index >= 0)) {
HXLINE(  95)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  95)									_hx_tmp = false;
            								}
HXDLIN(  95)								if (_hx_tmp) {
HXLINE(  95)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  95)						if ((p2 > maxX2)) {
HXLINE( 247)							p2 = xx2;
HXLINE(  95)							q2 = (q2 + 1);
            						}
HXDLIN(  95)						if ((q2 > maxY2)) {
HXLINE(  95)							goto _hx_goto_84;
            						}
            					}
            					_hx_goto_84:;
            				}
HXDLIN(  95)				{
HXLINE(  95)					 ::Dynamic targetError3 = ((Float)1.05);
HXDLIN(  95)					if (::hx::IsNull( targetError3 )) {
HXLINE( 840)						targetError3 = ((Float)1.05);
            					}
HXLINE(  95)					Float rSmall3;
HXDLIN(  95)					if ((rightRadius > bottomRadius)) {
HXLINE(  95)						rSmall3 = bottomRadius;
            					}
            					else {
HXLINE(  95)						rSmall3 = rightRadius;
            					}
HXDLIN(  95)					 ::Dynamic targetE3 = ( (Float)(targetError3) );
HXDLIN(  95)					if (::hx::IsNull( targetE3 )) {
HXLINE(  20)						targetE3 = ((Float)1.05);
            					}
HXLINE(  95)					int result3 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE3) ) / rSmall3)))));
HXDLIN(  95)					int noSides3;
HXDLIN(  95)					if ((result3 < 12)) {
HXLINE(  95)						noSides3 = 12;
            					}
            					else {
HXLINE(  95)						if ((result3 > 500)) {
HXLINE(  95)							noSides3 = 500;
            						}
            						else {
HXLINE(  95)							noSides3 = result3;
            						}
            					}
HXDLIN(  95)					int sides3 = (::Math_obj::ceil((( (Float)(noSides3) ) / ( (Float)(4) ))) * 4);
HXDLIN(  95)					Float theta3 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN(  95)					Float omega3 = ( (Float)(0) );
HXDLIN(  95)					int quarter3 = ::Std_obj::_hx_int((( (Float)(sides3) ) / ( (Float)(4) )));
HXDLIN(  95)					Float lastX3 = ((Float)0.);
HXDLIN(  95)					Float lastY3 = ((Float)0.);
HXDLIN(  95)					{
HXLINE(  26)						lastX3 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides3) ) * theta3) + omega3))));
HXLINE(  27)						lastY3 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides3) ) * theta3) + omega3))));
            					}
HXLINE(  95)					{
HXLINE(  95)						int _g6 = 0;
HXDLIN(  95)						int _g7 = (quarter3 + 1);
HXDLIN(  95)						while((_g6 < _g7)){
HXLINE(  95)							_g6 = (_g6 + 1);
HXDLIN(  95)							int i = (_g6 - 1);
HXDLIN(  95)							Float nextX = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  95)							Float nextY = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  95)							{
HXLINE(  95)								bool hasHit = false;
HXDLIN(  95)								bool hasUndo = false;
HXDLIN(  95)								{
HXLINE(  95)									Float bx = lastX3;
HXDLIN(  95)									Float by = lastY3;
HXDLIN(  95)									Float cx = nextX;
HXDLIN(  95)									Float cy = nextY;
HXDLIN(  95)									bool adjustWinding = (((((farX * by) - (bx * lowerY)) + ((bx * cy) - (cx * by))) + ((cx * lowerY) - (farX * cy))) > 0);
HXDLIN(  95)									if (!(adjustWinding)) {
HXLINE(  95)										Float bx_ = bx;
HXDLIN(  95)										Float by_ = by;
HXLINE(  26)										bx = cx;
HXLINE(  27)										by = cy;
HXLINE(  28)										cx = bx_;
HXLINE(  29)										cy = by_;
            									}
HXLINE(  95)									{
HXLINE(  95)										Float s0 = ((lowerY * cx) - (farX * cy));
HXDLIN(  95)										Float sx = (cy - lowerY);
HXDLIN(  95)										Float sy = (farX - cx);
HXDLIN(  95)										Float t0 = ((farX * by) - (lowerY * bx));
HXDLIN(  95)										Float tx = (lowerY - by);
HXDLIN(  95)										Float ty = (bx - farX);
HXDLIN(  95)										Float A = ((((-(by) * cx) + (lowerY * (-(bx) + cx))) + (farX * (by - cy))) + (bx * cy));
HXDLIN(  95)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  95)										if ((farX > bx)) {
HXLINE(  95)											if ((farX > cx)) {
HXLINE(  95)												int min;
HXDLIN(  95)												if ((bx > cx)) {
HXLINE(  95)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  95)													min = ::Math_obj::floor(bx);
            												}
HXDLIN(  95)												int ii_min = min;
HXDLIN(  95)												int ii_max = ::Math_obj::ceil(farX);
HXDLIN(  95)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)												xIter3 = this1;
            											}
            											else {
HXLINE(  95)												int ii_min = ::Math_obj::floor(bx);
HXDLIN(  95)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  95)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  95)											if ((bx > cx)) {
HXLINE(  95)												int min;
HXDLIN(  95)												if ((farX > cx)) {
HXLINE(  95)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  95)													min = ::Math_obj::ceil(farX);
            												}
HXDLIN(  95)												int ii_min = min;
HXDLIN(  95)												int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  95)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)												xIter3 = this1;
            											}
            											else {
HXLINE(  95)												int ii_min = ::Math_obj::floor(farX);
HXDLIN(  95)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  95)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)												xIter3 = this1;
            											}
            										}
HXDLIN(  95)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  95)										if ((lowerY > by)) {
HXLINE(  95)											if ((lowerY > cy)) {
HXLINE(  95)												int min;
HXDLIN(  95)												if ((by > cy)) {
HXLINE(  95)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  95)													min = ::Math_obj::floor(by);
            												}
HXDLIN(  95)												int ii_min = min;
HXDLIN(  95)												int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  95)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)												yIter3 = this1;
            											}
            											else {
HXLINE(  95)												int ii_min = ::Math_obj::floor(by);
HXDLIN(  95)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  95)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  95)											if ((by > cy)) {
HXLINE(  95)												int min;
HXDLIN(  95)												if ((lowerY > cy)) {
HXLINE(  95)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  95)													min = ::Math_obj::ceil(lowerY);
            												}
HXDLIN(  95)												int ii_min = min;
HXDLIN(  95)												int ii_max = ::Math_obj::ceil(by);
HXDLIN(  95)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)												yIter3 = this1;
            											}
            											else {
HXLINE(  95)												int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  95)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  95)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  95)												yIter3 = this1;
            											}
            										}
HXDLIN(  95)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  95)										if (hasUndo) {
HXLINE(  95)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  95)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  95)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  95)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  95)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  95)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  95)											undoImage = this3;
HXDLIN(  95)											{
HXLINE(  95)												int rectLeft = xIter3->start;
HXDLIN(  95)												int rectTop = yIter3->start;
HXDLIN(  95)												int rectRight = xIter3->max;
HXDLIN(  95)												bool forceClear = false;
HXDLIN(  95)												{
HXLINE(  95)													int _g = rectTop;
HXDLIN(  95)													int _g1 = yIter3->max;
HXDLIN(  95)													while((_g < _g1)){
HXLINE(  95)														_g = (_g + 1);
HXDLIN(  95)														int dy = (_g - 1);
HXDLIN(  95)														{
HXLINE(  95)															int _g1 = rectLeft;
HXDLIN(  95)															int _g2 = rectRight;
HXDLIN(  95)															while((_g1 < _g2)){
HXLINE(  95)																_g1 = (_g1 + 1);
HXDLIN(  95)																int dx = (_g1 - 1);
HXDLIN(  95)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																int index;
HXDLIN(  95)																if (pixelshape->useVirtualPos) {
HXLINE(  95)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  95)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																}
HXDLIN(  95)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																int col;
HXDLIN(  95)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  95)																	col = c;
            																}
HXDLIN(  95)																bool _hx_tmp;
HXDLIN(  95)																if (pixelshape->useMask) {
HXLINE(  95)																	_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																}
            																else {
HXLINE(  95)																	_hx_tmp = false;
            																}
HXDLIN(  95)																if (_hx_tmp) {
HXLINE(  95)																	::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  95)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  95)																	int index;
HXDLIN(  95)																	if (this1->useVirtualPos) {
HXLINE(  95)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  95)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  95)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  95)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  95)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																	int v;
HXDLIN(  95)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  95)																		v = c;
            																	}
HXDLIN(  95)																	int this3 = v;
HXDLIN(  95)																	int maskPixel = this3;
HXDLIN(  95)																	int this4 = col;
HXDLIN(  95)																	int this5 = this4;
HXDLIN(  95)																	if ((maskPixel == 0)) {
HXLINE(  95)																		int this1 = this5;
HXDLIN(  95)																		col = this1;
            																	}
            																	else {
HXLINE(  95)																		Float m0;
HXDLIN(  95)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  95)																		if ((this1 == 0)) {
HXLINE(  95)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float m1;
HXDLIN(  95)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  95)																		if ((this2 == 0)) {
HXLINE(  95)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float m2;
HXDLIN(  95)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  95)																		if ((this3 == 0)) {
HXLINE(  95)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float m3;
HXDLIN(  95)																		int this4 = (maskPixel & 255);
HXDLIN(  95)																		if ((this4 == 0)) {
HXLINE(  95)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  95)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  95)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  95)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  95)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  95)																if ((col != 0)) {
HXLINE(  95)																	int x = (dx - rectLeft);
HXDLIN(  95)																	int y = (dy - rectTop);
HXDLIN(  95)																	int this1 = col;
HXDLIN(  95)																	int c = this1;
HXDLIN(  95)																	bool _hx_tmp;
HXDLIN(  95)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)																		_hx_tmp = undoImage->transparent;
            																	}
            																	else {
HXLINE(  95)																		_hx_tmp = false;
            																	}
HXDLIN(  95)																	if (_hx_tmp) {
HXLINE(  95)																		int location;
HXDLIN(  95)																		if (undoImage->useVirtualPos) {
HXLINE(  95)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  95)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  95)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																		int this3 = this2;
HXDLIN(  95)																		int this4;
HXDLIN(  95)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  95)																			this4 = this3;
            																		}
HXDLIN(  95)																		Float a1;
HXDLIN(  95)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)																		if ((this5 == 0)) {
HXLINE(  95)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float r1;
HXDLIN(  95)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)																		if ((this6 == 0)) {
HXLINE(  95)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float g1;
HXDLIN(  95)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)																		if ((this7 == 0)) {
HXLINE(  95)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float b1;
HXDLIN(  95)																		int this8 = (this4 & 255);
HXDLIN(  95)																		if ((this8 == 0)) {
HXLINE(  95)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float a2;
HXDLIN(  95)																		int this9 = ((col >> 24) & 255);
HXDLIN(  95)																		if ((this9 == 0)) {
HXLINE(  95)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float r2;
HXDLIN(  95)																		int this10 = ((col >> 16) & 255);
HXDLIN(  95)																		if ((this10 == 0)) {
HXLINE(  95)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float g2;
HXDLIN(  95)																		int this11 = ((col >> 8) & 255);
HXDLIN(  95)																		if ((this11 == 0)) {
HXLINE(  95)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float b2;
HXDLIN(  95)																		int this12 = (col & 255);
HXDLIN(  95)																		if ((this12 == 0)) {
HXLINE(  95)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)																		{
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  95)																			int value;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				value = blended;
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((location >= 0)) {
HXLINE(  95)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  95)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																		int index;
HXDLIN(  95)																		if (undoImage->useVirtualPos) {
HXLINE(  95)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  95)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  95)																		int value;
HXDLIN(  95)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  95)																			value = c;
            																		}
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((index >= 0)) {
HXLINE(  95)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  95)																	if (forceClear) {
HXLINE(  95)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  95)																		int x = (dx - rectLeft);
HXDLIN(  95)																		int y = (dy - rectTop);
HXDLIN(  95)																		int index;
HXDLIN(  95)																		if (undoImage->useVirtualPos) {
HXLINE(  95)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  95)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((index >= 0)) {
HXLINE(  95)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  95)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  95)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  95)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  95)										bool found = false;
HXDLIN(  95)										Float s = ((Float)0.);
HXDLIN(  95)										Float t = ((Float)0.);
HXDLIN(  95)										Float sxx = ((Float)0.);
HXDLIN(  95)										Float txx = ((Float)0.);
HXDLIN(  95)										{
HXLINE(  95)											int _g_min = xIter3->start;
HXDLIN(  95)											int _g_max = xIter3->max;
HXDLIN(  95)											while((_g_min < _g_max)){
HXLINE(  95)												_g_min = (_g_min + 1);
HXDLIN(  95)												int x = (_g_min - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found = false;
HXLINE(  95)												{
HXLINE(  95)													int _g_min1 = yIter3->start;
HXDLIN(  95)													int _g_max = yIter3->max;
HXDLIN(  95)													while((_g_min1 < _g_max)){
HXLINE(  95)														_g_min1 = (_g_min1 + 1);
HXDLIN(  95)														int y = (_g_min1 - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  95)														bool _hx_tmp;
HXDLIN(  95)														if (!((s <= 0))) {
HXLINE(  95)															_hx_tmp = (t <= 0);
            														}
            														else {
HXLINE(  95)															_hx_tmp = true;
            														}
HXDLIN(  95)														if (_hx_tmp) {
HXLINE(  95)															if (found) {
HXLINE(  95)																goto _hx_goto_89;
            															}
            														}
            														else {
HXLINE(  95)															if (((s + t) < A)) {
HXLINE(  95)																{
HXLINE(  95)																	int this1 = color;
HXDLIN(  95)																	int c = this1;
HXDLIN(  95)																	bool _hx_tmp;
HXDLIN(  95)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  95)																		_hx_tmp = pixelshape->transparent;
            																	}
            																	else {
HXLINE(  95)																		_hx_tmp = false;
            																	}
HXDLIN(  95)																	if (_hx_tmp) {
HXLINE(  95)																		int location;
HXDLIN(  95)																		if (pixelshape->useVirtualPos) {
HXLINE(  95)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																		}
            																		else {
HXLINE(  95)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																		}
HXDLIN(  95)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  95)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  95)																		int this3 = this2;
HXDLIN(  95)																		int this4;
HXDLIN(  95)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  95)																			this4 = this3;
            																		}
HXDLIN(  95)																		Float a1;
HXDLIN(  95)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  95)																		if ((this5 == 0)) {
HXLINE(  95)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float r1;
HXDLIN(  95)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  95)																		if ((this6 == 0)) {
HXLINE(  95)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float g1;
HXDLIN(  95)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  95)																		if ((this7 == 0)) {
HXLINE(  95)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float b1;
HXDLIN(  95)																		int this8 = (this4 & 255);
HXDLIN(  95)																		if ((this8 == 0)) {
HXLINE(  95)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float a2;
HXDLIN(  95)																		int this9 = ((color >> 24) & 255);
HXDLIN(  95)																		if ((this9 == 0)) {
HXLINE(  95)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float r2;
HXDLIN(  95)																		int this10 = ((color >> 16) & 255);
HXDLIN(  95)																		if ((this10 == 0)) {
HXLINE(  95)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float g2;
HXDLIN(  95)																		int this11 = ((color >> 8) & 255);
HXDLIN(  95)																		if ((this11 == 0)) {
HXLINE(  95)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float b2;
HXDLIN(  95)																		int this12 = (color & 255);
HXDLIN(  95)																		if ((this12 == 0)) {
HXLINE(  95)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  95)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  95)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  95)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  95)																		{
HXLINE(  95)																			::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  95)																			int value;
HXDLIN(  95)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  95)																				value = blended;
            																			}
HXDLIN(  95)																			bool _hx_tmp;
HXDLIN(  95)																			if ((location >= 0)) {
HXLINE(  95)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  95)																				_hx_tmp = false;
            																			}
HXDLIN(  95)																			if (_hx_tmp) {
HXLINE(  95)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  95)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  95)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  95)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  95)																		int index;
HXDLIN(  95)																		if (pixelshape->useVirtualPos) {
HXLINE(  95)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																		}
            																		else {
HXLINE(  95)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																		}
HXDLIN(  95)																		int value;
HXDLIN(  95)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  95)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  95)																			value = c;
            																		}
HXDLIN(  95)																		bool _hx_tmp;
HXDLIN(  95)																		if ((index >= 0)) {
HXLINE(  95)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  95)																			_hx_tmp = false;
            																		}
HXDLIN(  95)																		if (_hx_tmp) {
HXLINE(  95)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  95)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  95)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  95)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  95)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  95)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found = true;
            															}
            															else {
HXLINE(  95)																if (found) {
HXLINE(  95)																	goto _hx_goto_89;
            																}
            															}
            														}
            													}
            													_hx_goto_89:;
            												}
            											}
            										}
HXDLIN(  95)										if ((hasHit == true)) {
HXLINE(  95)											::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX,lowerY,bx,by,cx,cy,true);
HXDLIN(  95)											if (hasUndo) {
HXLINE(  95)												v->undoImage = undoImage;
HXDLIN(  95)												v->undoX = xIter3->start;
HXDLIN(  95)												v->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX3 = nextX;
HXLINE(  47)							lastY3 = nextY;
            						}
            					}
            				}
            			}
HXLINE(  97)			{
HXLINE(  97)				::pixelimage::ImageStruct pixelshape = temp;
HXDLIN(  97)				Float x = this->strokeWidth;
HXDLIN(  97)				Float y = this->strokeWidth;
HXDLIN(  97)				Float wid = (this->width - (( (Float)(2) ) * this->strokeWidth));
HXDLIN(  97)				Float hi = (this->height - (( (Float)(2) ) * this->strokeWidth));
HXDLIN(  97)				::pixelimage::ImageStruct tileImage = this->tileImageFill;
HXDLIN(  97)				 ::Dynamic dx = ((Float)-1.);
HXDLIN(  97)				 ::Dynamic dy = ((Float)-1.);
HXDLIN(  97)				 ::Dynamic fat = ((Float)-1.);
HXDLIN(  97)				 ::Dynamic tall = ((Float)-1.);
HXDLIN(  97)				if (::hx::IsLess( dx,((Float)0.) )) {
HXLINE(  97)					Float smallest;
HXDLIN(  97)					if ((hi < wid)) {
HXLINE(  97)						smallest = hi;
            					}
            					else {
HXLINE(  97)						smallest = wid;
            					}
HXDLIN(  97)					Float goldenRatio = ((Float)1.61803398875);
HXLINE(  67)					dx = (smallest / (goldenRatio + 2));
            				}
HXLINE(  97)				if (::hx::IsLess( dy,((Float)0.) )) {
HXLINE(  69)					dy = dx;
            				}
HXLINE(  97)				if (::hx::IsLess( fat,((Float)0.) )) {
HXLINE(  70)					fat = (wid - (( (Float)(2) ) * ( (Float)(dx) )));
            				}
HXLINE(  97)				if (::hx::IsLess( tall,((Float)0.) )) {
HXLINE(  71)					tall = (hi - (( (Float)(2) ) * ( (Float)(dy) )));
            				}
HXLINE(  97)				Float rightRadius = ((wid - ( (Float)(fat) )) - ( (Float)(dx) ));
HXDLIN(  97)				Float bottomRadius = ((hi - ( (Float)(tall) )) - ( (Float)(dy) ));
HXDLIN(  97)				Float farX = ((x + dx) + fat);
HXDLIN(  97)				Float lowerY = ((y + dy) + tall);
HXDLIN(  97)				{
HXLINE(  97)					Float cx = (x + dx);
HXDLIN(  97)					Float cy = (y + dy);
HXDLIN(  97)					Float rx = ( (Float)(dx) );
HXDLIN(  97)					Float ry = ( (Float)(dy) );
HXDLIN(  97)					{
HXLINE(  97)						 ::Dynamic targetError = ((Float)1.05);
HXDLIN(  97)						if (::hx::IsNull( targetError )) {
HXLINE( 850)							targetError = ((Float)1.05);
            						}
HXLINE(  97)						Float rSmall;
HXDLIN(  97)						if ((rx > ry)) {
HXLINE(  97)							rSmall = ry;
            						}
            						else {
HXLINE(  97)							rSmall = rx;
            						}
HXDLIN(  97)						 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN(  97)						if (::hx::IsNull( targetE )) {
HXLINE(  20)							targetE = ((Float)1.05);
            						}
HXLINE(  97)						int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  97)						int noSides;
HXDLIN(  97)						if ((result < 12)) {
HXLINE(  97)							noSides = 12;
            						}
            						else {
HXLINE(  97)							if ((result > 500)) {
HXLINE(  97)								noSides = 500;
            							}
            							else {
HXLINE(  97)								noSides = result;
            							}
            						}
HXDLIN(  97)						int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN(  97)						Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN(  97)						Float omega = ::Math_obj::PI;
HXDLIN(  97)						int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN(  97)						Float lastX = ((Float)0.);
HXDLIN(  97)						Float lastY = ((Float)0.);
HXDLIN(  97)						{
HXLINE(  73)							lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  74)							lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            						}
HXLINE(  97)						{
HXLINE(  97)							int _g = 0;
HXDLIN(  97)							int _g1 = (quarter + 1);
HXDLIN(  97)							while((_g < _g1)){
HXLINE(  97)								_g = (_g + 1);
HXDLIN(  97)								int i = (_g - 1);
HXDLIN(  97)								Float nextX = (cx + (rx * ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  97)								Float nextY = (cy + (ry * ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  97)								{
HXLINE(  97)									bool hasHit = false;
HXDLIN(  97)									{
HXLINE(  97)										Float bx = lastX;
HXDLIN(  97)										Float by = lastY;
HXDLIN(  97)										Float cx1 = nextX;
HXDLIN(  97)										Float cy1 = nextY;
HXDLIN(  97)										bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  97)										if (!(adjustWinding)) {
HXLINE(  97)											Float bx_ = bx;
HXDLIN(  97)											Float by_ = by;
HXLINE( 188)											bx = cx1;
HXLINE( 189)											by = cy1;
HXLINE( 190)											cx1 = bx_;
HXLINE( 191)											cy1 = by_;
            										}
HXLINE(  97)										{
HXLINE(  97)											bool hasUndo = false;
HXDLIN(  97)											Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  97)											Float sx = (cy1 - cy);
HXDLIN(  97)											Float sy = (cx - cx1);
HXDLIN(  97)											Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  97)											Float tx = (cy - by);
HXDLIN(  97)											Float ty = (bx - cx);
HXDLIN(  97)											Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  97)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  97)											if ((cx > bx)) {
HXLINE(  97)												if ((cx > cx1)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((bx > cx1)) {
HXLINE(  97)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  97)												if ((bx > cx1)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((cx > cx1)) {
HXLINE(  97)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::ceil(cx);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(cx);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            											}
HXDLIN(  97)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  97)											if ((cy > by)) {
HXLINE(  97)												if ((cy > cy1)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((by > cy1)) {
HXLINE(  97)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  97)												if ((by > cy1)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((cy > cy1)) {
HXLINE(  97)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::ceil(cy);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(cy);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            											}
HXDLIN(  97)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  97)											if (hasUndo) {
HXLINE(  97)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  97)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  97)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)												undoImage = this3;
HXDLIN(  97)												{
HXLINE(  97)													int rectLeft = xIter3->start;
HXDLIN(  97)													int rectTop = yIter3->start;
HXDLIN(  97)													int rectRight = xIter3->max;
HXDLIN(  97)													bool forceClear = false;
HXDLIN(  97)													{
HXLINE(  97)														int _g = rectTop;
HXDLIN(  97)														int _g1 = yIter3->max;
HXDLIN(  97)														while((_g < _g1)){
HXLINE(  97)															_g = (_g + 1);
HXDLIN(  97)															int dy = (_g - 1);
HXDLIN(  97)															{
HXLINE(  97)																int _g1 = rectLeft;
HXDLIN(  97)																int _g2 = rectRight;
HXDLIN(  97)																while((_g1 < _g2)){
HXLINE(  97)																	_g1 = (_g1 + 1);
HXDLIN(  97)																	int dx = (_g1 - 1);
HXDLIN(  97)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																	int index;
HXDLIN(  97)																	if (pixelshape->useVirtualPos) {
HXLINE(  97)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  97)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																	int col;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		col = c;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if (pixelshape->useMask) {
HXLINE(  97)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)																		int index;
HXDLIN(  97)																		if (this1->useVirtualPos) {
HXLINE(  97)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  97)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  97)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																		int v;
HXDLIN(  97)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  97)																			v = c;
            																		}
HXDLIN(  97)																		int this3 = v;
HXDLIN(  97)																		int maskPixel = this3;
HXDLIN(  97)																		int this4 = col;
HXDLIN(  97)																		int this5 = this4;
HXDLIN(  97)																		if ((maskPixel == 0)) {
HXLINE(  97)																			int this1 = this5;
HXDLIN(  97)																			col = this1;
            																		}
            																		else {
HXLINE(  97)																			Float m0;
HXDLIN(  97)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																			if ((this1 == 0)) {
HXLINE(  97)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m1;
HXDLIN(  97)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																			if ((this2 == 0)) {
HXLINE(  97)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m2;
HXDLIN(  97)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																			if ((this3 == 0)) {
HXLINE(  97)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m3;
HXDLIN(  97)																			int this4 = (maskPixel & 255);
HXDLIN(  97)																			if ((this4 == 0)) {
HXLINE(  97)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  97)																	if ((col != 0)) {
HXLINE(  97)																		int x = (dx - rectLeft);
HXDLIN(  97)																		int y = (dy - rectTop);
HXDLIN(  97)																		int this1 = col;
HXDLIN(  97)																		int c = this1;
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			int location;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																			int this3 = this2;
HXDLIN(  97)																			int this4;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				this4 = this3;
            																			}
HXDLIN(  97)																			Float a1;
HXDLIN(  97)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																			if ((this5 == 0)) {
HXLINE(  97)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r1;
HXDLIN(  97)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																			if ((this6 == 0)) {
HXLINE(  97)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g1;
HXDLIN(  97)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																			if ((this7 == 0)) {
HXLINE(  97)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b1;
HXDLIN(  97)																			int this8 = (this4 & 255);
HXDLIN(  97)																			if ((this8 == 0)) {
HXLINE(  97)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a2;
HXDLIN(  97)																			int this9 = ((col >> 24) & 255);
HXDLIN(  97)																			if ((this9 == 0)) {
HXLINE(  97)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r2;
HXDLIN(  97)																			int this10 = ((col >> 16) & 255);
HXDLIN(  97)																			if ((this10 == 0)) {
HXLINE(  97)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g2;
HXDLIN(  97)																			int this11 = ((col >> 8) & 255);
HXDLIN(  97)																			if ((this11 == 0)) {
HXLINE(  97)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b2;
HXDLIN(  97)																			int this12 = (col & 255);
HXDLIN(  97)																			if ((this12 == 0)) {
HXLINE(  97)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																			{
HXLINE(  97)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  97)																				int value;
HXDLIN(  97)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  97)																					value = blended;
            																				}
HXDLIN(  97)																				bool _hx_tmp;
HXDLIN(  97)																				if ((location >= 0)) {
HXLINE(  97)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  97)																					_hx_tmp = false;
            																				}
HXDLIN(  97)																				if (_hx_tmp) {
HXLINE(  97)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			int value;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				value = c;
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  97)																		if (forceClear) {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			int x = (dx - rectLeft);
HXDLIN(  97)																			int y = (dy - rectTop);
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  97)											bool foundY = false;
HXDLIN(  97)											Float s = ((Float)0.);
HXDLIN(  97)											Float t = ((Float)0.);
HXDLIN(  97)											Float sxx = ((Float)0.);
HXDLIN(  97)											Float txx = ((Float)0.);
HXDLIN(  97)											{
HXLINE(  97)												int _g_min = xIter3->start;
HXDLIN(  97)												int _g_max = xIter3->max;
HXDLIN(  97)												while((_g_min < _g_max)){
HXLINE(  97)													_g_min = (_g_min + 1);
HXDLIN(  97)													int x = (_g_min - 1);
HXLINE( 223)													sxx = (sx * ( (Float)(x) ));
HXLINE( 224)													txx = (tx * ( (Float)(x) ));
HXLINE( 225)													foundY = false;
HXLINE(  97)													{
HXLINE(  97)														int _g_min1 = yIter3->start;
HXDLIN(  97)														int _g_max = yIter3->max;
HXDLIN(  97)														while((_g_min1 < _g_max)){
HXLINE(  97)															_g_min1 = (_g_min1 + 1);
HXDLIN(  97)															int y = (_g_min1 - 1);
HXLINE( 227)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  97)															bool _hx_tmp;
HXDLIN(  97)															if (!((s <= 0))) {
HXLINE(  97)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  97)																_hx_tmp = true;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																if (foundY) {
HXLINE(  97)																	goto _hx_goto_94;
            																}
            															}
            															else {
HXLINE(  97)																if (((s + t) < A)) {
HXLINE(  97)																	int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)																	int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)																	::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)																	int index;
HXDLIN(  97)																	if (tileImage->useVirtualPos) {
HXLINE(  97)																		index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																	}
            																	else {
HXLINE(  97)																		index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																	}
HXDLIN(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																	int color;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		color = c;
            																	}
HXDLIN(  97)																	{
HXLINE(  97)																		int this2 = color;
HXDLIN(  97)																		int c1 = this2;
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			int location;
HXDLIN(  97)																			if (pixelshape->useVirtualPos) {
HXLINE(  97)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  97)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  97)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																			int this3 = this2;
HXDLIN(  97)																			int this4;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				this4 = this3;
            																			}
HXDLIN(  97)																			Float a1;
HXDLIN(  97)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																			if ((this5 == 0)) {
HXLINE(  97)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r1;
HXDLIN(  97)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																			if ((this6 == 0)) {
HXLINE(  97)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g1;
HXDLIN(  97)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																			if ((this7 == 0)) {
HXLINE(  97)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b1;
HXDLIN(  97)																			int this8 = (this4 & 255);
HXDLIN(  97)																			if ((this8 == 0)) {
HXLINE(  97)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a2;
HXDLIN(  97)																			int this9 = ((color >> 24) & 255);
HXDLIN(  97)																			if ((this9 == 0)) {
HXLINE(  97)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r2;
HXDLIN(  97)																			int this10 = ((color >> 16) & 255);
HXDLIN(  97)																			if ((this10 == 0)) {
HXLINE(  97)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g2;
HXDLIN(  97)																			int this11 = ((color >> 8) & 255);
HXDLIN(  97)																			if ((this11 == 0)) {
HXLINE(  97)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b2;
HXDLIN(  97)																			int this12 = (color & 255);
HXDLIN(  97)																			if ((this12 == 0)) {
HXLINE(  97)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																			{
HXLINE(  97)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																				int value;
HXDLIN(  97)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  97)																					value = blended;
            																				}
HXDLIN(  97)																				bool _hx_tmp;
HXDLIN(  97)																				if ((location >= 0)) {
HXLINE(  97)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  97)																					_hx_tmp = false;
            																				}
HXDLIN(  97)																				if (_hx_tmp) {
HXLINE(  97)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (pixelshape->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  97)																			int value;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				value = c1;
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE( 237)																	foundY = true;
            																}
            																else {
HXLINE(  97)																	if (foundY) {
HXLINE(  97)																		goto _hx_goto_94;
            																	}
            																}
            															}
            														}
            														_hx_goto_94:;
            													}
            												}
            											}
HXDLIN(  97)											if ((hasHit == false)) {
HXLINE(  97)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  97)												if (hasUndo) {
HXLINE(  97)													v->undoImage = undoImage;
HXDLIN(  97)													v->undoX = xIter3->start;
HXDLIN(  97)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  93)								lastX = nextX;
HXLINE(  94)								lastY = nextY;
            							}
            						}
            					}
            				}
HXLINE(  97)				{
HXLINE(  97)					Float x1 = (x + dx);
HXDLIN(  97)					bool hasHit = false;
HXDLIN(  97)					Float bx = (x1 + ( (Float)(fat) ));
HXDLIN(  97)					Float cy1 = (y + ( (Float)(dy) ));
HXDLIN(  97)					{
HXLINE(  97)						{
HXLINE(  97)							Float bx1 = bx;
HXDLIN(  97)							Float by = y;
HXDLIN(  97)							Float cx1 = x1;
HXDLIN(  97)							Float cy2 = cy1;
HXDLIN(  97)							bool adjustWinding = (((((x1 * by) - (bx1 * y)) + ((bx1 * cy2) - (cx1 * by))) + ((cx1 * y) - (x1 * cy2))) > 0);
HXDLIN(  97)							if (!(adjustWinding)) {
HXLINE(  97)								Float bx_ = bx1;
HXDLIN(  97)								Float by_ = by;
HXLINE( 188)								bx1 = cx1;
HXLINE( 189)								by = cy2;
HXLINE( 190)								cx1 = bx_;
HXLINE( 191)								cy2 = by_;
            							}
HXLINE(  97)							{
HXLINE(  97)								bool hasUndo = false;
HXDLIN(  97)								Float s0 = ((y * cx1) - (x1 * cy2));
HXDLIN(  97)								Float sx = (cy2 - y);
HXDLIN(  97)								Float sy = (x1 - cx1);
HXDLIN(  97)								Float t0 = ((x1 * by) - (y * bx1));
HXDLIN(  97)								Float tx = (y - by);
HXDLIN(  97)								Float ty = (bx1 - x1);
HXDLIN(  97)								Float A = ((((-(by) * cx1) + (y * (-(bx1) + cx1))) + (x1 * (by - cy2))) + (bx1 * cy2));
HXDLIN(  97)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  97)								if ((x1 > bx1)) {
HXLINE(  97)									if ((x1 > cx1)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx1 > cx1)) {
HXLINE(  97)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(bx1);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(x1);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter3 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((bx1 > cx1)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((x1 > cx1)) {
HXLINE(  97)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(x1);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter3 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(x1);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter3 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  97)								if ((y > by)) {
HXLINE(  97)									if ((y > cy2)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((by > cy2)) {
HXLINE(  97)											min = ::Math_obj::floor(cy2);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(y);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter3 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((by > cy2)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((y > cy2)) {
HXLINE(  97)											min = ::Math_obj::floor(cy2);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(y);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter3 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(y);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter3 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  97)								if (hasUndo) {
HXLINE(  97)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  97)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  97)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)									undoImage = this3;
HXDLIN(  97)									{
HXLINE(  97)										int rectLeft = xIter3->start;
HXDLIN(  97)										int rectTop = yIter3->start;
HXDLIN(  97)										int rectRight = xIter3->max;
HXDLIN(  97)										bool forceClear = false;
HXDLIN(  97)										{
HXLINE(  97)											int _g = rectTop;
HXDLIN(  97)											int _g1 = yIter3->max;
HXDLIN(  97)											while((_g < _g1)){
HXLINE(  97)												_g = (_g + 1);
HXDLIN(  97)												int dy = (_g - 1);
HXDLIN(  97)												{
HXLINE(  97)													int _g1 = rectLeft;
HXDLIN(  97)													int _g2 = rectRight;
HXDLIN(  97)													while((_g1 < _g2)){
HXLINE(  97)														_g1 = (_g1 + 1);
HXDLIN(  97)														int dx = (_g1 - 1);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (pixelshape->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int col;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															col = c;
            														}
HXDLIN(  97)														bool _hx_tmp;
HXDLIN(  97)														if (pixelshape->useMask) {
HXLINE(  97)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  97)															_hx_tmp = false;
            														}
HXDLIN(  97)														if (_hx_tmp) {
HXLINE(  97)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)															int index;
HXDLIN(  97)															if (this1->useVirtualPos) {
HXLINE(  97)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  97)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  97)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)															int v;
HXDLIN(  97)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  97)																v = c;
            															}
HXDLIN(  97)															int this3 = v;
HXDLIN(  97)															int maskPixel = this3;
HXDLIN(  97)															int this4 = col;
HXDLIN(  97)															int this5 = this4;
HXDLIN(  97)															if ((maskPixel == 0)) {
HXLINE(  97)																int this1 = this5;
HXDLIN(  97)																col = this1;
            															}
            															else {
HXLINE(  97)																Float m0;
HXDLIN(  97)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																if ((this1 == 0)) {
HXLINE(  97)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m1;
HXDLIN(  97)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																if ((this2 == 0)) {
HXLINE(  97)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m2;
HXDLIN(  97)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																if ((this3 == 0)) {
HXLINE(  97)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m3;
HXDLIN(  97)																int this4 = (maskPixel & 255);
HXDLIN(  97)																if ((this4 == 0)) {
HXLINE(  97)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  97)														if ((col != 0)) {
HXLINE(  97)															int x = (dx - rectLeft);
HXDLIN(  97)															int y = (dy - rectTop);
HXDLIN(  97)															int this1 = col;
HXDLIN(  97)															int c = this1;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = undoImage->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (undoImage->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((col >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((col >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((col >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (col & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  97)															if (forceClear) {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																int x = (dx - rectLeft);
HXDLIN(  97)																int y = (dy - rectTop);
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  97)								bool foundY = false;
HXDLIN(  97)								Float s = ((Float)0.);
HXDLIN(  97)								Float t = ((Float)0.);
HXDLIN(  97)								Float sxx = ((Float)0.);
HXDLIN(  97)								Float txx = ((Float)0.);
HXDLIN(  97)								{
HXLINE(  97)									int _g_min = xIter3->start;
HXDLIN(  97)									int _g_max = xIter3->max;
HXDLIN(  97)									while((_g_min < _g_max)){
HXLINE(  97)										_g_min = (_g_min + 1);
HXDLIN(  97)										int x = (_g_min - 1);
HXLINE( 223)										sxx = (sx * ( (Float)(x) ));
HXLINE( 224)										txx = (tx * ( (Float)(x) ));
HXLINE( 225)										foundY = false;
HXLINE(  97)										{
HXLINE(  97)											int _g_min1 = yIter3->start;
HXDLIN(  97)											int _g_max = yIter3->max;
HXDLIN(  97)											while((_g_min1 < _g_max)){
HXLINE(  97)												_g_min1 = (_g_min1 + 1);
HXDLIN(  97)												int y = (_g_min1 - 1);
HXLINE( 227)												s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)												t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  97)												bool _hx_tmp;
HXDLIN(  97)												if (!((s <= 0))) {
HXLINE(  97)													_hx_tmp = (t <= 0);
            												}
            												else {
HXLINE(  97)													_hx_tmp = true;
            												}
HXDLIN(  97)												if (_hx_tmp) {
HXLINE(  97)													if (foundY) {
HXLINE(  97)														goto _hx_goto_98;
            													}
            												}
            												else {
HXLINE(  97)													if (((s + t) < A)) {
HXLINE(  97)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (tileImage->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int color;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															color = c;
            														}
HXDLIN(  97)														{
HXLINE(  97)															int this2 = color;
HXDLIN(  97)															int c1 = this2;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((color >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((color >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((color >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (color & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c1;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY = true;
            													}
            													else {
HXLINE(  97)														if (foundY) {
HXLINE(  97)															goto _hx_goto_98;
            														}
            													}
            												}
            											}
            											_hx_goto_98:;
            										}
            									}
            								}
HXDLIN(  97)								if ((hasHit == false)) {
HXLINE(  97)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x1,y,bx1,by,cx1,cy2,true);
HXDLIN(  97)									if (hasUndo) {
HXLINE(  97)										v->undoImage = undoImage;
HXDLIN(  97)										v->undoX = xIter3->start;
HXDLIN(  97)										v->undoY = yIter3->start;
            									}
            								}
            							}
            						}
HXDLIN(  97)						{
HXLINE(  97)							Float bx2 = bx;
HXDLIN(  97)							Float by1 = cy1;
HXDLIN(  97)							Float cx2 = x1;
HXDLIN(  97)							Float cy3 = cy1;
HXDLIN(  97)							bool adjustWinding1 = (((((bx * by1) - (bx2 * y)) + ((bx2 * cy3) - (cx2 * by1))) + ((cx2 * y) - (bx * cy3))) > 0);
HXDLIN(  97)							if (!(adjustWinding1)) {
HXLINE(  97)								Float bx_ = bx2;
HXDLIN(  97)								Float by_ = by1;
HXLINE( 188)								bx2 = cx2;
HXLINE( 189)								by1 = cy3;
HXLINE( 190)								cx2 = bx_;
HXLINE( 191)								cy3 = by_;
            							}
HXLINE(  97)							{
HXLINE(  97)								bool hasUndo1 = false;
HXDLIN(  97)								Float s01 = ((y * cx2) - (bx * cy3));
HXDLIN(  97)								Float sx1 = (cy3 - y);
HXDLIN(  97)								Float sy1 = (bx - cx2);
HXDLIN(  97)								Float t01 = ((bx * by1) - (y * bx2));
HXDLIN(  97)								Float tx1 = (y - by1);
HXDLIN(  97)								Float ty1 = (bx2 - bx);
HXDLIN(  97)								Float A1 = ((((-(by1) * cx2) + (y * (-(bx2) + cx2))) + (bx * (by1 - cy3))) + (bx2 * cy3));
HXDLIN(  97)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  97)								if ((bx > bx2)) {
HXLINE(  97)									if ((bx > cx2)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx2 > cx2)) {
HXLINE(  97)											min = ::Math_obj::floor(cx2);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(bx2);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter31 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((bx2 > cx2)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx > cx2)) {
HXLINE(  97)											min = ::Math_obj::floor(cx2);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter31 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter31 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  97)								if ((y > by1)) {
HXLINE(  97)									if ((y > cy3)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((by1 > cy3)) {
HXLINE(  97)											min = ::Math_obj::floor(cy3);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(by1);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(y);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter31 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(by1);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((by1 > cy3)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((y > cy3)) {
HXLINE(  97)											min = ::Math_obj::floor(cy3);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(y);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter31 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(y);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter31 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  97)								if (hasUndo1) {
HXLINE(  97)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  97)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  97)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)									undoImage1 = this3;
HXDLIN(  97)									{
HXLINE(  97)										int rectLeft = xIter31->start;
HXDLIN(  97)										int rectTop = yIter31->start;
HXDLIN(  97)										int rectRight = xIter31->max;
HXDLIN(  97)										bool forceClear = false;
HXDLIN(  97)										{
HXLINE(  97)											int _g = rectTop;
HXDLIN(  97)											int _g1 = yIter31->max;
HXDLIN(  97)											while((_g < _g1)){
HXLINE(  97)												_g = (_g + 1);
HXDLIN(  97)												int dy = (_g - 1);
HXDLIN(  97)												{
HXLINE(  97)													int _g1 = rectLeft;
HXDLIN(  97)													int _g2 = rectRight;
HXDLIN(  97)													while((_g1 < _g2)){
HXLINE(  97)														_g1 = (_g1 + 1);
HXDLIN(  97)														int dx = (_g1 - 1);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (pixelshape->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int col;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															col = c;
            														}
HXDLIN(  97)														bool _hx_tmp;
HXDLIN(  97)														if (pixelshape->useMask) {
HXLINE(  97)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  97)															_hx_tmp = false;
            														}
HXDLIN(  97)														if (_hx_tmp) {
HXLINE(  97)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)															int index;
HXDLIN(  97)															if (this1->useVirtualPos) {
HXLINE(  97)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  97)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  97)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)															int v;
HXDLIN(  97)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  97)																v = c;
            															}
HXDLIN(  97)															int this3 = v;
HXDLIN(  97)															int maskPixel = this3;
HXDLIN(  97)															int this4 = col;
HXDLIN(  97)															int this5 = this4;
HXDLIN(  97)															if ((maskPixel == 0)) {
HXLINE(  97)																int this1 = this5;
HXDLIN(  97)																col = this1;
            															}
            															else {
HXLINE(  97)																Float m0;
HXDLIN(  97)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																if ((this1 == 0)) {
HXLINE(  97)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m1;
HXDLIN(  97)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																if ((this2 == 0)) {
HXLINE(  97)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m2;
HXDLIN(  97)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																if ((this3 == 0)) {
HXLINE(  97)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m3;
HXDLIN(  97)																int this4 = (maskPixel & 255);
HXDLIN(  97)																if ((this4 == 0)) {
HXLINE(  97)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  97)														if ((col != 0)) {
HXLINE(  97)															int x = (dx - rectLeft);
HXDLIN(  97)															int y = (dy - rectTop);
HXDLIN(  97)															int this1 = col;
HXDLIN(  97)															int c = this1;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = undoImage1->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (undoImage1->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((col >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((col >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((col >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (col & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage1->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  97)															if (forceClear) {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  97)																int x = (dx - rectLeft);
HXDLIN(  97)																int y = (dy - rectTop);
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage1->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  97)								bool foundY1 = false;
HXDLIN(  97)								Float s1 = ((Float)0.);
HXDLIN(  97)								Float t1 = ((Float)0.);
HXDLIN(  97)								Float sxx1 = ((Float)0.);
HXDLIN(  97)								Float txx1 = ((Float)0.);
HXDLIN(  97)								{
HXLINE(  97)									int _g_min1 = xIter31->start;
HXDLIN(  97)									int _g_max1 = xIter31->max;
HXDLIN(  97)									while((_g_min1 < _g_max1)){
HXLINE(  97)										_g_min1 = (_g_min1 + 1);
HXDLIN(  97)										int x = (_g_min1 - 1);
HXLINE( 223)										sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)										txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)										foundY1 = false;
HXLINE(  97)										{
HXLINE(  97)											int _g_min = yIter31->start;
HXDLIN(  97)											int _g_max = yIter31->max;
HXDLIN(  97)											while((_g_min < _g_max)){
HXLINE(  97)												_g_min = (_g_min + 1);
HXDLIN(  97)												int y = (_g_min - 1);
HXLINE( 227)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  97)												bool _hx_tmp;
HXDLIN(  97)												if (!((s1 <= 0))) {
HXLINE(  97)													_hx_tmp = (t1 <= 0);
            												}
            												else {
HXLINE(  97)													_hx_tmp = true;
            												}
HXDLIN(  97)												if (_hx_tmp) {
HXLINE(  97)													if (foundY1) {
HXLINE(  97)														goto _hx_goto_102;
            													}
            												}
            												else {
HXLINE(  97)													if (((s1 + t1) < A1)) {
HXLINE(  97)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (tileImage->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int color;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															color = c;
            														}
HXDLIN(  97)														{
HXLINE(  97)															int this2 = color;
HXDLIN(  97)															int c1 = this2;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((color >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((color >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((color >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (color & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c1;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY1 = true;
            													}
            													else {
HXLINE(  97)														if (foundY1) {
HXLINE(  97)															goto _hx_goto_102;
            														}
            													}
            												}
            											}
            											_hx_goto_102:;
            										}
            									}
            								}
HXDLIN(  97)								if ((hasHit == false)) {
HXLINE(  97)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,y,bx2,by1,cx2,cy3,true);
HXDLIN(  97)									if (hasUndo1) {
HXLINE(  97)										v->undoImage = undoImage1;
HXDLIN(  97)										v->undoX = xIter31->start;
HXDLIN(  97)										v->undoY = yIter31->start;
            									}
            								}
            							}
            						}
HXDLIN(  97)						if ((hasHit == true)) {
HXLINE(  97)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x1,y,bx,y,bx,cy1,x1,cy1,true);
            						}
            					}
            				}
HXDLIN(  97)				{
HXLINE(  97)					Float cy4 = (y + dy);
HXDLIN(  97)					Float ry1 = ( (Float)(dy) );
HXDLIN(  97)					{
HXLINE(  97)						 ::Dynamic targetError1 = ((Float)1.05);
HXDLIN(  97)						if (::hx::IsNull( targetError1 )) {
HXLINE( 850)							targetError1 = ((Float)1.05);
            						}
HXLINE(  97)						Float rSmall1;
HXDLIN(  97)						if ((rightRadius > ry1)) {
HXLINE(  97)							rSmall1 = ry1;
            						}
            						else {
HXLINE(  97)							rSmall1 = rightRadius;
            						}
HXDLIN(  97)						 ::Dynamic targetE1 = ( (Float)(targetError1) );
HXDLIN(  97)						if (::hx::IsNull( targetE1 )) {
HXLINE(  20)							targetE1 = ((Float)1.05);
            						}
HXLINE(  97)						int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN(  97)						int noSides1;
HXDLIN(  97)						if ((result1 < 12)) {
HXLINE(  97)							noSides1 = 12;
            						}
            						else {
HXLINE(  97)							if ((result1 > 500)) {
HXLINE(  97)								noSides1 = 500;
            							}
            							else {
HXLINE(  97)								noSides1 = result1;
            							}
            						}
HXDLIN(  97)						int sides1 = (::Math_obj::ceil((( (Float)(noSides1) ) / ( (Float)(4) ))) * 4);
HXDLIN(  97)						Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  97)						Float omega1 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN(  97)						int quarter1 = ::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(4) )));
HXDLIN(  97)						Float lastX1 = ((Float)0.);
HXDLIN(  97)						Float lastY1 = ((Float)0.);
HXDLIN(  97)						{
HXLINE(  73)							lastX1 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides1) ) * theta1) + omega1))));
HXLINE(  74)							lastY1 = (cy4 + (ry1 * ::Math_obj::sin(((( (Float)(sides1) ) * theta1) + omega1))));
            						}
HXLINE(  97)						{
HXLINE(  97)							int _g2 = 0;
HXDLIN(  97)							int _g3 = (quarter1 + 1);
HXDLIN(  97)							while((_g2 < _g3)){
HXLINE(  97)								_g2 = (_g2 + 1);
HXDLIN(  97)								int i = (_g2 - 1);
HXDLIN(  97)								Float nextX = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  97)								Float nextY = (cy4 + (ry1 * ::Math_obj::sin((((( (Float)(i) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  97)								{
HXLINE(  97)									bool hasHit = false;
HXDLIN(  97)									{
HXLINE(  97)										Float bx = lastX1;
HXDLIN(  97)										Float by = lastY1;
HXDLIN(  97)										Float cx = nextX;
HXDLIN(  97)										Float cy = nextY;
HXDLIN(  97)										bool adjustWinding = (((((farX * by) - (bx * cy4)) + ((bx * cy) - (cx * by))) + ((cx * cy4) - (farX * cy))) > 0);
HXDLIN(  97)										if (!(adjustWinding)) {
HXLINE(  97)											Float bx_ = bx;
HXDLIN(  97)											Float by_ = by;
HXLINE( 188)											bx = cx;
HXLINE( 189)											by = cy;
HXLINE( 190)											cx = bx_;
HXLINE( 191)											cy = by_;
            										}
HXLINE(  97)										{
HXLINE(  97)											bool hasUndo = false;
HXDLIN(  97)											Float s0 = ((cy4 * cx) - (farX * cy));
HXDLIN(  97)											Float sx = (cy - cy4);
HXDLIN(  97)											Float sy = (farX - cx);
HXDLIN(  97)											Float t0 = ((farX * by) - (cy4 * bx));
HXDLIN(  97)											Float tx = (cy4 - by);
HXDLIN(  97)											Float ty = (bx - farX);
HXDLIN(  97)											Float A = ((((-(by) * cx) + (cy4 * (-(bx) + cx))) + (farX * (by - cy))) + (bx * cy));
HXDLIN(  97)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  97)											if ((farX > bx)) {
HXLINE(  97)												if ((farX > cx)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((bx > cx)) {
HXLINE(  97)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(farX);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  97)												if ((bx > cx)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((farX > cx)) {
HXLINE(  97)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::ceil(farX);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(farX);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            											}
HXDLIN(  97)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  97)											if ((cy4 > by)) {
HXLINE(  97)												if ((cy4 > cy)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((by > cy)) {
HXLINE(  97)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cy4);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  97)												if ((by > cy)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((cy4 > cy)) {
HXLINE(  97)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::ceil(cy4);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(cy4);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            											}
HXDLIN(  97)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  97)											if (hasUndo) {
HXLINE(  97)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  97)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  97)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)												undoImage = this3;
HXDLIN(  97)												{
HXLINE(  97)													int rectLeft = xIter3->start;
HXDLIN(  97)													int rectTop = yIter3->start;
HXDLIN(  97)													int rectRight = xIter3->max;
HXDLIN(  97)													bool forceClear = false;
HXDLIN(  97)													{
HXLINE(  97)														int _g = rectTop;
HXDLIN(  97)														int _g1 = yIter3->max;
HXDLIN(  97)														while((_g < _g1)){
HXLINE(  97)															_g = (_g + 1);
HXDLIN(  97)															int dy = (_g - 1);
HXDLIN(  97)															{
HXLINE(  97)																int _g1 = rectLeft;
HXDLIN(  97)																int _g2 = rectRight;
HXDLIN(  97)																while((_g1 < _g2)){
HXLINE(  97)																	_g1 = (_g1 + 1);
HXDLIN(  97)																	int dx = (_g1 - 1);
HXDLIN(  97)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																	int index;
HXDLIN(  97)																	if (pixelshape->useVirtualPos) {
HXLINE(  97)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  97)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																	int col;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		col = c;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if (pixelshape->useMask) {
HXLINE(  97)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)																		int index;
HXDLIN(  97)																		if (this1->useVirtualPos) {
HXLINE(  97)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  97)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  97)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																		int v;
HXDLIN(  97)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  97)																			v = c;
            																		}
HXDLIN(  97)																		int this3 = v;
HXDLIN(  97)																		int maskPixel = this3;
HXDLIN(  97)																		int this4 = col;
HXDLIN(  97)																		int this5 = this4;
HXDLIN(  97)																		if ((maskPixel == 0)) {
HXLINE(  97)																			int this1 = this5;
HXDLIN(  97)																			col = this1;
            																		}
            																		else {
HXLINE(  97)																			Float m0;
HXDLIN(  97)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																			if ((this1 == 0)) {
HXLINE(  97)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m1;
HXDLIN(  97)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																			if ((this2 == 0)) {
HXLINE(  97)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m2;
HXDLIN(  97)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																			if ((this3 == 0)) {
HXLINE(  97)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m3;
HXDLIN(  97)																			int this4 = (maskPixel & 255);
HXDLIN(  97)																			if ((this4 == 0)) {
HXLINE(  97)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  97)																	if ((col != 0)) {
HXLINE(  97)																		int x = (dx - rectLeft);
HXDLIN(  97)																		int y = (dy - rectTop);
HXDLIN(  97)																		int this1 = col;
HXDLIN(  97)																		int c = this1;
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			int location;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																			int this3 = this2;
HXDLIN(  97)																			int this4;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				this4 = this3;
            																			}
HXDLIN(  97)																			Float a1;
HXDLIN(  97)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																			if ((this5 == 0)) {
HXLINE(  97)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r1;
HXDLIN(  97)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																			if ((this6 == 0)) {
HXLINE(  97)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g1;
HXDLIN(  97)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																			if ((this7 == 0)) {
HXLINE(  97)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b1;
HXDLIN(  97)																			int this8 = (this4 & 255);
HXDLIN(  97)																			if ((this8 == 0)) {
HXLINE(  97)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a2;
HXDLIN(  97)																			int this9 = ((col >> 24) & 255);
HXDLIN(  97)																			if ((this9 == 0)) {
HXLINE(  97)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r2;
HXDLIN(  97)																			int this10 = ((col >> 16) & 255);
HXDLIN(  97)																			if ((this10 == 0)) {
HXLINE(  97)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g2;
HXDLIN(  97)																			int this11 = ((col >> 8) & 255);
HXDLIN(  97)																			if ((this11 == 0)) {
HXLINE(  97)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b2;
HXDLIN(  97)																			int this12 = (col & 255);
HXDLIN(  97)																			if ((this12 == 0)) {
HXLINE(  97)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																			{
HXLINE(  97)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  97)																				int value;
HXDLIN(  97)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  97)																					value = blended;
            																				}
HXDLIN(  97)																				bool _hx_tmp;
HXDLIN(  97)																				if ((location >= 0)) {
HXLINE(  97)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  97)																					_hx_tmp = false;
            																				}
HXDLIN(  97)																				if (_hx_tmp) {
HXLINE(  97)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			int value;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				value = c;
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  97)																		if (forceClear) {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			int x = (dx - rectLeft);
HXDLIN(  97)																			int y = (dy - rectTop);
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  97)											bool foundY = false;
HXDLIN(  97)											Float s = ((Float)0.);
HXDLIN(  97)											Float t = ((Float)0.);
HXDLIN(  97)											Float sxx = ((Float)0.);
HXDLIN(  97)											Float txx = ((Float)0.);
HXDLIN(  97)											{
HXLINE(  97)												int _g_min = xIter3->start;
HXDLIN(  97)												int _g_max = xIter3->max;
HXDLIN(  97)												while((_g_min < _g_max)){
HXLINE(  97)													_g_min = (_g_min + 1);
HXDLIN(  97)													int x = (_g_min - 1);
HXLINE( 223)													sxx = (sx * ( (Float)(x) ));
HXLINE( 224)													txx = (tx * ( (Float)(x) ));
HXLINE( 225)													foundY = false;
HXLINE(  97)													{
HXLINE(  97)														int _g_min1 = yIter3->start;
HXDLIN(  97)														int _g_max = yIter3->max;
HXDLIN(  97)														while((_g_min1 < _g_max)){
HXLINE(  97)															_g_min1 = (_g_min1 + 1);
HXDLIN(  97)															int y = (_g_min1 - 1);
HXLINE( 227)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  97)															bool _hx_tmp;
HXDLIN(  97)															if (!((s <= 0))) {
HXLINE(  97)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  97)																_hx_tmp = true;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																if (foundY) {
HXLINE(  97)																	goto _hx_goto_107;
            																}
            															}
            															else {
HXLINE(  97)																if (((s + t) < A)) {
HXLINE(  97)																	int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)																	int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)																	::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)																	int index;
HXDLIN(  97)																	if (tileImage->useVirtualPos) {
HXLINE(  97)																		index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																	}
            																	else {
HXLINE(  97)																		index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																	}
HXDLIN(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																	int color;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		color = c;
            																	}
HXDLIN(  97)																	{
HXLINE(  97)																		int this2 = color;
HXDLIN(  97)																		int c1 = this2;
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			int location;
HXDLIN(  97)																			if (pixelshape->useVirtualPos) {
HXLINE(  97)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  97)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  97)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																			int this3 = this2;
HXDLIN(  97)																			int this4;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				this4 = this3;
            																			}
HXDLIN(  97)																			Float a1;
HXDLIN(  97)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																			if ((this5 == 0)) {
HXLINE(  97)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r1;
HXDLIN(  97)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																			if ((this6 == 0)) {
HXLINE(  97)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g1;
HXDLIN(  97)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																			if ((this7 == 0)) {
HXLINE(  97)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b1;
HXDLIN(  97)																			int this8 = (this4 & 255);
HXDLIN(  97)																			if ((this8 == 0)) {
HXLINE(  97)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a2;
HXDLIN(  97)																			int this9 = ((color >> 24) & 255);
HXDLIN(  97)																			if ((this9 == 0)) {
HXLINE(  97)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r2;
HXDLIN(  97)																			int this10 = ((color >> 16) & 255);
HXDLIN(  97)																			if ((this10 == 0)) {
HXLINE(  97)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g2;
HXDLIN(  97)																			int this11 = ((color >> 8) & 255);
HXDLIN(  97)																			if ((this11 == 0)) {
HXLINE(  97)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b2;
HXDLIN(  97)																			int this12 = (color & 255);
HXDLIN(  97)																			if ((this12 == 0)) {
HXLINE(  97)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																			{
HXLINE(  97)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																				int value;
HXDLIN(  97)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  97)																					value = blended;
            																				}
HXDLIN(  97)																				bool _hx_tmp;
HXDLIN(  97)																				if ((location >= 0)) {
HXLINE(  97)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  97)																					_hx_tmp = false;
            																				}
HXDLIN(  97)																				if (_hx_tmp) {
HXLINE(  97)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (pixelshape->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  97)																			int value;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				value = c1;
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE( 237)																	foundY = true;
            																}
            																else {
HXLINE(  97)																	if (foundY) {
HXLINE(  97)																		goto _hx_goto_107;
            																	}
            																}
            															}
            														}
            														_hx_goto_107:;
            													}
            												}
            											}
HXDLIN(  97)											if ((hasHit == false)) {
HXLINE(  97)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX,cy4,bx,by,cx,cy,true);
HXDLIN(  97)												if (hasUndo) {
HXLINE(  97)													v->undoImage = undoImage;
HXDLIN(  97)													v->undoX = xIter3->start;
HXDLIN(  97)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  93)								lastX1 = nextX;
HXLINE(  94)								lastY1 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  97)				{
HXLINE(  97)					Float y1 = (y + dy);
HXDLIN(  97)					bool hasHit1 = false;
HXDLIN(  97)					Float bx3 = (x + wid);
HXDLIN(  97)					Float cy5 = (y1 + ( (Float)(tall) ));
HXDLIN(  97)					{
HXLINE(  97)						{
HXLINE(  97)							Float bx4 = bx3;
HXDLIN(  97)							Float by2 = y1;
HXDLIN(  97)							Float cx3 = x;
HXDLIN(  97)							Float cy6 = cy5;
HXDLIN(  97)							bool adjustWinding2 = (((((x * by2) - (bx4 * y1)) + ((bx4 * cy6) - (cx3 * by2))) + ((cx3 * y1) - (x * cy6))) > 0);
HXDLIN(  97)							if (!(adjustWinding2)) {
HXLINE(  97)								Float bx_ = bx4;
HXDLIN(  97)								Float by_ = by2;
HXLINE( 188)								bx4 = cx3;
HXLINE( 189)								by2 = cy6;
HXLINE( 190)								cx3 = bx_;
HXLINE( 191)								cy6 = by_;
            							}
HXLINE(  97)							{
HXLINE(  97)								bool hasUndo2 = false;
HXDLIN(  97)								Float s02 = ((y1 * cx3) - (x * cy6));
HXDLIN(  97)								Float sx2 = (cy6 - y1);
HXDLIN(  97)								Float sy2 = (x - cx3);
HXDLIN(  97)								Float t02 = ((x * by2) - (y1 * bx4));
HXDLIN(  97)								Float tx2 = (y1 - by2);
HXDLIN(  97)								Float ty2 = (bx4 - x);
HXDLIN(  97)								Float A2 = ((((-(by2) * cx3) + (y1 * (-(bx4) + cx3))) + (x * (by2 - cy6))) + (bx4 * cy6));
HXDLIN(  97)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  97)								if ((x > bx4)) {
HXLINE(  97)									if ((x > cx3)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx4 > cx3)) {
HXLINE(  97)											min = ::Math_obj::floor(cx3);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(bx4);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(x);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter32 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx4);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((bx4 > cx3)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((x > cx3)) {
HXLINE(  97)											min = ::Math_obj::floor(cx3);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(x);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx4);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter32 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(x);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter32 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  97)								if ((y1 > by2)) {
HXLINE(  97)									if ((y1 > cy6)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((by2 > cy6)) {
HXLINE(  97)											min = ::Math_obj::floor(cy6);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(by2);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(y1);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter32 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(by2);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy6);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((by2 > cy6)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((y1 > cy6)) {
HXLINE(  97)											min = ::Math_obj::floor(cy6);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(y1);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter32 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(y1);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy6);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter32 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  97)								if (hasUndo2) {
HXLINE(  97)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  97)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  97)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)									undoImage2 = this3;
HXDLIN(  97)									{
HXLINE(  97)										int rectLeft = xIter32->start;
HXDLIN(  97)										int rectTop = yIter32->start;
HXDLIN(  97)										int rectRight = xIter32->max;
HXDLIN(  97)										bool forceClear = false;
HXDLIN(  97)										{
HXLINE(  97)											int _g = rectTop;
HXDLIN(  97)											int _g1 = yIter32->max;
HXDLIN(  97)											while((_g < _g1)){
HXLINE(  97)												_g = (_g + 1);
HXDLIN(  97)												int dy = (_g - 1);
HXDLIN(  97)												{
HXLINE(  97)													int _g1 = rectLeft;
HXDLIN(  97)													int _g2 = rectRight;
HXDLIN(  97)													while((_g1 < _g2)){
HXLINE(  97)														_g1 = (_g1 + 1);
HXDLIN(  97)														int dx = (_g1 - 1);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (pixelshape->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int col;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															col = c;
            														}
HXDLIN(  97)														bool _hx_tmp;
HXDLIN(  97)														if (pixelshape->useMask) {
HXLINE(  97)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  97)															_hx_tmp = false;
            														}
HXDLIN(  97)														if (_hx_tmp) {
HXLINE(  97)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)															int index;
HXDLIN(  97)															if (this1->useVirtualPos) {
HXLINE(  97)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  97)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  97)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)															int v;
HXDLIN(  97)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  97)																v = c;
            															}
HXDLIN(  97)															int this3 = v;
HXDLIN(  97)															int maskPixel = this3;
HXDLIN(  97)															int this4 = col;
HXDLIN(  97)															int this5 = this4;
HXDLIN(  97)															if ((maskPixel == 0)) {
HXLINE(  97)																int this1 = this5;
HXDLIN(  97)																col = this1;
            															}
            															else {
HXLINE(  97)																Float m0;
HXDLIN(  97)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																if ((this1 == 0)) {
HXLINE(  97)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m1;
HXDLIN(  97)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																if ((this2 == 0)) {
HXLINE(  97)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m2;
HXDLIN(  97)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																if ((this3 == 0)) {
HXLINE(  97)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m3;
HXDLIN(  97)																int this4 = (maskPixel & 255);
HXDLIN(  97)																if ((this4 == 0)) {
HXLINE(  97)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  97)														if ((col != 0)) {
HXLINE(  97)															int x = (dx - rectLeft);
HXDLIN(  97)															int y = (dy - rectTop);
HXDLIN(  97)															int this1 = col;
HXDLIN(  97)															int c = this1;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = undoImage2->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (undoImage2->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((col >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((col >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((col >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (col & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage2->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  97)															if (forceClear) {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  97)																int x = (dx - rectLeft);
HXDLIN(  97)																int y = (dy - rectTop);
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage2->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  97)								bool foundY2 = false;
HXDLIN(  97)								Float s2 = ((Float)0.);
HXDLIN(  97)								Float t2 = ((Float)0.);
HXDLIN(  97)								Float sxx2 = ((Float)0.);
HXDLIN(  97)								Float txx2 = ((Float)0.);
HXDLIN(  97)								{
HXLINE(  97)									int _g_min2 = xIter32->start;
HXDLIN(  97)									int _g_max2 = xIter32->max;
HXDLIN(  97)									while((_g_min2 < _g_max2)){
HXLINE(  97)										_g_min2 = (_g_min2 + 1);
HXDLIN(  97)										int x = (_g_min2 - 1);
HXLINE( 223)										sxx2 = (sx2 * ( (Float)(x) ));
HXLINE( 224)										txx2 = (tx2 * ( (Float)(x) ));
HXLINE( 225)										foundY2 = false;
HXLINE(  97)										{
HXLINE(  97)											int _g_min = yIter32->start;
HXDLIN(  97)											int _g_max = yIter32->max;
HXDLIN(  97)											while((_g_min < _g_max)){
HXLINE(  97)												_g_min = (_g_min + 1);
HXDLIN(  97)												int y = (_g_min - 1);
HXLINE( 227)												s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE( 228)												t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE(  97)												bool _hx_tmp;
HXDLIN(  97)												if (!((s2 <= 0))) {
HXLINE(  97)													_hx_tmp = (t2 <= 0);
            												}
            												else {
HXLINE(  97)													_hx_tmp = true;
            												}
HXDLIN(  97)												if (_hx_tmp) {
HXLINE(  97)													if (foundY2) {
HXLINE(  97)														goto _hx_goto_111;
            													}
            												}
            												else {
HXLINE(  97)													if (((s2 + t2) < A2)) {
HXLINE(  97)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (tileImage->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int color;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															color = c;
            														}
HXDLIN(  97)														{
HXLINE(  97)															int this2 = color;
HXDLIN(  97)															int c1 = this2;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((color >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((color >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((color >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (color & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c1;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY2 = true;
            													}
            													else {
HXLINE(  97)														if (foundY2) {
HXLINE(  97)															goto _hx_goto_111;
            														}
            													}
            												}
            											}
            											_hx_goto_111:;
            										}
            									}
            								}
HXDLIN(  97)								if ((hasHit1 == false)) {
HXLINE(  97)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x,y1,bx4,by2,cx3,cy6,true);
HXDLIN(  97)									if (hasUndo2) {
HXLINE(  97)										v->undoImage = undoImage2;
HXDLIN(  97)										v->undoX = xIter32->start;
HXDLIN(  97)										v->undoY = yIter32->start;
            									}
            								}
            							}
            						}
HXDLIN(  97)						{
HXLINE(  97)							Float bx5 = bx3;
HXDLIN(  97)							Float by3 = cy5;
HXDLIN(  97)							Float cx4 = x;
HXDLIN(  97)							Float cy7 = cy5;
HXDLIN(  97)							bool adjustWinding3 = (((((bx3 * by3) - (bx5 * y1)) + ((bx5 * cy7) - (cx4 * by3))) + ((cx4 * y1) - (bx3 * cy7))) > 0);
HXDLIN(  97)							if (!(adjustWinding3)) {
HXLINE(  97)								Float bx_ = bx5;
HXDLIN(  97)								Float by_ = by3;
HXLINE( 188)								bx5 = cx4;
HXLINE( 189)								by3 = cy7;
HXLINE( 190)								cx4 = bx_;
HXLINE( 191)								cy7 = by_;
            							}
HXLINE(  97)							{
HXLINE(  97)								bool hasUndo3 = false;
HXDLIN(  97)								Float s03 = ((y1 * cx4) - (bx3 * cy7));
HXDLIN(  97)								Float sx3 = (cy7 - y1);
HXDLIN(  97)								Float sy3 = (bx3 - cx4);
HXDLIN(  97)								Float t03 = ((bx3 * by3) - (y1 * bx5));
HXDLIN(  97)								Float tx3 = (y1 - by3);
HXDLIN(  97)								Float ty3 = (bx5 - bx3);
HXDLIN(  97)								Float A3 = ((((-(by3) * cx4) + (y1 * (-(bx5) + cx4))) + (bx3 * (by3 - cy7))) + (bx5 * cy7));
HXDLIN(  97)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  97)								if ((bx3 > bx5)) {
HXLINE(  97)									if ((bx3 > cx4)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx5 > cx4)) {
HXLINE(  97)											min = ::Math_obj::floor(cx4);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(bx5);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx3);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter33 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx5);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx4);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((bx5 > cx4)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx3 > cx4)) {
HXLINE(  97)											min = ::Math_obj::floor(cx4);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(bx3);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx5);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter33 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx3);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx4);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter33 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  97)								if ((y1 > by3)) {
HXLINE(  97)									if ((y1 > cy7)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((by3 > cy7)) {
HXLINE(  97)											min = ::Math_obj::floor(cy7);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(by3);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(y1);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter33 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(by3);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy7);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((by3 > cy7)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((y1 > cy7)) {
HXLINE(  97)											min = ::Math_obj::floor(cy7);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(y1);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(by3);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter33 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(y1);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy7);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter33 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  97)								if (hasUndo3) {
HXLINE(  97)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  97)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  97)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)									undoImage3 = this3;
HXDLIN(  97)									{
HXLINE(  97)										int rectLeft = xIter33->start;
HXDLIN(  97)										int rectTop = yIter33->start;
HXDLIN(  97)										int rectRight = xIter33->max;
HXDLIN(  97)										bool forceClear = false;
HXDLIN(  97)										{
HXLINE(  97)											int _g = rectTop;
HXDLIN(  97)											int _g1 = yIter33->max;
HXDLIN(  97)											while((_g < _g1)){
HXLINE(  97)												_g = (_g + 1);
HXDLIN(  97)												int dy = (_g - 1);
HXDLIN(  97)												{
HXLINE(  97)													int _g1 = rectLeft;
HXDLIN(  97)													int _g2 = rectRight;
HXDLIN(  97)													while((_g1 < _g2)){
HXLINE(  97)														_g1 = (_g1 + 1);
HXDLIN(  97)														int dx = (_g1 - 1);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (pixelshape->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int col;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															col = c;
            														}
HXDLIN(  97)														bool _hx_tmp;
HXDLIN(  97)														if (pixelshape->useMask) {
HXLINE(  97)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  97)															_hx_tmp = false;
            														}
HXDLIN(  97)														if (_hx_tmp) {
HXLINE(  97)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)															int index;
HXDLIN(  97)															if (this1->useVirtualPos) {
HXLINE(  97)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  97)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  97)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)															int v;
HXDLIN(  97)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  97)																v = c;
            															}
HXDLIN(  97)															int this3 = v;
HXDLIN(  97)															int maskPixel = this3;
HXDLIN(  97)															int this4 = col;
HXDLIN(  97)															int this5 = this4;
HXDLIN(  97)															if ((maskPixel == 0)) {
HXLINE(  97)																int this1 = this5;
HXDLIN(  97)																col = this1;
            															}
            															else {
HXLINE(  97)																Float m0;
HXDLIN(  97)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																if ((this1 == 0)) {
HXLINE(  97)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m1;
HXDLIN(  97)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																if ((this2 == 0)) {
HXLINE(  97)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m2;
HXDLIN(  97)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																if ((this3 == 0)) {
HXLINE(  97)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m3;
HXDLIN(  97)																int this4 = (maskPixel & 255);
HXDLIN(  97)																if ((this4 == 0)) {
HXLINE(  97)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  97)														if ((col != 0)) {
HXLINE(  97)															int x = (dx - rectLeft);
HXDLIN(  97)															int y = (dy - rectTop);
HXDLIN(  97)															int this1 = col;
HXDLIN(  97)															int c = this1;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = undoImage3->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (undoImage3->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((col >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((col >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((col >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (col & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage3->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  97)															if (forceClear) {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  97)																int x = (dx - rectLeft);
HXDLIN(  97)																int y = (dy - rectTop);
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage3->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  97)								bool foundY3 = false;
HXDLIN(  97)								Float s3 = ((Float)0.);
HXDLIN(  97)								Float t3 = ((Float)0.);
HXDLIN(  97)								Float sxx3 = ((Float)0.);
HXDLIN(  97)								Float txx3 = ((Float)0.);
HXDLIN(  97)								{
HXLINE(  97)									int _g_min3 = xIter33->start;
HXDLIN(  97)									int _g_max3 = xIter33->max;
HXDLIN(  97)									while((_g_min3 < _g_max3)){
HXLINE(  97)										_g_min3 = (_g_min3 + 1);
HXDLIN(  97)										int x = (_g_min3 - 1);
HXLINE( 223)										sxx3 = (sx3 * ( (Float)(x) ));
HXLINE( 224)										txx3 = (tx3 * ( (Float)(x) ));
HXLINE( 225)										foundY3 = false;
HXLINE(  97)										{
HXLINE(  97)											int _g_min = yIter33->start;
HXDLIN(  97)											int _g_max = yIter33->max;
HXDLIN(  97)											while((_g_min < _g_max)){
HXLINE(  97)												_g_min = (_g_min + 1);
HXDLIN(  97)												int y = (_g_min - 1);
HXLINE( 227)												s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE( 228)												t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE(  97)												bool _hx_tmp;
HXDLIN(  97)												if (!((s3 <= 0))) {
HXLINE(  97)													_hx_tmp = (t3 <= 0);
            												}
            												else {
HXLINE(  97)													_hx_tmp = true;
            												}
HXDLIN(  97)												if (_hx_tmp) {
HXLINE(  97)													if (foundY3) {
HXLINE(  97)														goto _hx_goto_115;
            													}
            												}
            												else {
HXLINE(  97)													if (((s3 + t3) < A3)) {
HXLINE(  97)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (tileImage->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int color;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															color = c;
            														}
HXDLIN(  97)														{
HXLINE(  97)															int this2 = color;
HXDLIN(  97)															int c1 = this2;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((color >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((color >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((color >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (color & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c1;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY3 = true;
            													}
            													else {
HXLINE(  97)														if (foundY3) {
HXLINE(  97)															goto _hx_goto_115;
            														}
            													}
            												}
            											}
            											_hx_goto_115:;
            										}
            									}
            								}
HXDLIN(  97)								if ((hasHit1 == false)) {
HXLINE(  97)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx3,y1,bx5,by3,cx4,cy7,true);
HXDLIN(  97)									if (hasUndo3) {
HXLINE(  97)										v->undoImage = undoImage3;
HXDLIN(  97)										v->undoX = xIter33->start;
HXDLIN(  97)										v->undoY = yIter33->start;
            									}
            								}
            							}
            						}
HXDLIN(  97)						if ((hasHit1 == true)) {
HXLINE(  97)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x,y1,bx3,y1,bx3,cy5,x,cy5,true);
            						}
            					}
            				}
HXDLIN(  97)				{
HXLINE(  97)					Float cx5 = (x + dx);
HXDLIN(  97)					Float rx1 = ( (Float)(dx) );
HXDLIN(  97)					{
HXLINE(  97)						 ::Dynamic targetError2 = ((Float)1.05);
HXDLIN(  97)						if (::hx::IsNull( targetError2 )) {
HXLINE( 850)							targetError2 = ((Float)1.05);
            						}
HXLINE(  97)						Float rSmall2;
HXDLIN(  97)						if ((rx1 > bottomRadius)) {
HXLINE(  97)							rSmall2 = bottomRadius;
            						}
            						else {
HXLINE(  97)							rSmall2 = rx1;
            						}
HXDLIN(  97)						 ::Dynamic targetE2 = ( (Float)(targetError2) );
HXDLIN(  97)						if (::hx::IsNull( targetE2 )) {
HXLINE(  20)							targetE2 = ((Float)1.05);
            						}
HXLINE(  97)						int result2 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE2) ) / rSmall2)))));
HXDLIN(  97)						int noSides2;
HXDLIN(  97)						if ((result2 < 12)) {
HXLINE(  97)							noSides2 = 12;
            						}
            						else {
HXLINE(  97)							if ((result2 > 500)) {
HXLINE(  97)								noSides2 = 500;
            							}
            							else {
HXLINE(  97)								noSides2 = result2;
            							}
            						}
HXDLIN(  97)						int sides2 = (::Math_obj::ceil((( (Float)(noSides2) ) / ( (Float)(4) ))) * 4);
HXDLIN(  97)						Float theta2 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides2) ));
HXDLIN(  97)						Float omega2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  97)						int quarter2 = ::Std_obj::_hx_int((( (Float)(sides2) ) / ( (Float)(4) )));
HXDLIN(  97)						Float lastX2 = ((Float)0.);
HXDLIN(  97)						Float lastY2 = ((Float)0.);
HXDLIN(  97)						{
HXLINE(  73)							lastX2 = (cx5 + (rx1 * ::Math_obj::cos(((( (Float)(sides2) ) * theta2) + omega2))));
HXLINE(  74)							lastY2 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides2) ) * theta2) + omega2))));
            						}
HXLINE(  97)						{
HXLINE(  97)							int _g4 = 0;
HXDLIN(  97)							int _g5 = (quarter2 + 1);
HXDLIN(  97)							while((_g4 < _g5)){
HXLINE(  97)								_g4 = (_g4 + 1);
HXDLIN(  97)								int i = (_g4 - 1);
HXDLIN(  97)								Float nextX = (cx5 + (rx1 * ::Math_obj::cos((((( (Float)(i) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  97)								Float nextY = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  97)								{
HXLINE(  97)									bool hasHit = false;
HXDLIN(  97)									{
HXLINE(  97)										Float bx = lastX2;
HXDLIN(  97)										Float by = lastY2;
HXDLIN(  97)										Float cx = nextX;
HXDLIN(  97)										Float cy = nextY;
HXDLIN(  97)										bool adjustWinding = (((((cx5 * by) - (bx * lowerY)) + ((bx * cy) - (cx * by))) + ((cx * lowerY) - (cx5 * cy))) > 0);
HXDLIN(  97)										if (!(adjustWinding)) {
HXLINE(  97)											Float bx_ = bx;
HXDLIN(  97)											Float by_ = by;
HXLINE( 188)											bx = cx;
HXLINE( 189)											by = cy;
HXLINE( 190)											cx = bx_;
HXLINE( 191)											cy = by_;
            										}
HXLINE(  97)										{
HXLINE(  97)											bool hasUndo = false;
HXDLIN(  97)											Float s0 = ((lowerY * cx) - (cx5 * cy));
HXDLIN(  97)											Float sx = (cy - lowerY);
HXDLIN(  97)											Float sy = (cx5 - cx);
HXDLIN(  97)											Float t0 = ((cx5 * by) - (lowerY * bx));
HXDLIN(  97)											Float tx = (lowerY - by);
HXDLIN(  97)											Float ty = (bx - cx5);
HXDLIN(  97)											Float A = ((((-(by) * cx) + (lowerY * (-(bx) + cx))) + (cx5 * (by - cy))) + (bx * cy));
HXDLIN(  97)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  97)											if ((cx5 > bx)) {
HXLINE(  97)												if ((cx5 > cx)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((bx > cx)) {
HXLINE(  97)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cx5);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  97)												if ((bx > cx)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((cx5 > cx)) {
HXLINE(  97)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::ceil(cx5);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(cx5);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													xIter3 = this1;
            												}
            											}
HXDLIN(  97)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  97)											if ((lowerY > by)) {
HXLINE(  97)												if ((lowerY > cy)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((by > cy)) {
HXLINE(  97)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  97)												if ((by > cy)) {
HXLINE(  97)													int min;
HXDLIN(  97)													if ((lowerY > cy)) {
HXLINE(  97)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  97)														min = ::Math_obj::ceil(lowerY);
            													}
HXDLIN(  97)													int ii_min = min;
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            												else {
HXLINE(  97)													int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  97)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  97)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)													yIter3 = this1;
            												}
            											}
HXDLIN(  97)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  97)											if (hasUndo) {
HXLINE(  97)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  97)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  97)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)												undoImage = this3;
HXDLIN(  97)												{
HXLINE(  97)													int rectLeft = xIter3->start;
HXDLIN(  97)													int rectTop = yIter3->start;
HXDLIN(  97)													int rectRight = xIter3->max;
HXDLIN(  97)													bool forceClear = false;
HXDLIN(  97)													{
HXLINE(  97)														int _g = rectTop;
HXDLIN(  97)														int _g1 = yIter3->max;
HXDLIN(  97)														while((_g < _g1)){
HXLINE(  97)															_g = (_g + 1);
HXDLIN(  97)															int dy = (_g - 1);
HXDLIN(  97)															{
HXLINE(  97)																int _g1 = rectLeft;
HXDLIN(  97)																int _g2 = rectRight;
HXDLIN(  97)																while((_g1 < _g2)){
HXLINE(  97)																	_g1 = (_g1 + 1);
HXDLIN(  97)																	int dx = (_g1 - 1);
HXDLIN(  97)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																	int index;
HXDLIN(  97)																	if (pixelshape->useVirtualPos) {
HXLINE(  97)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  97)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																	int col;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		col = c;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if (pixelshape->useMask) {
HXLINE(  97)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)																		int index;
HXDLIN(  97)																		if (this1->useVirtualPos) {
HXLINE(  97)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  97)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  97)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																		int v;
HXDLIN(  97)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  97)																			v = c;
            																		}
HXDLIN(  97)																		int this3 = v;
HXDLIN(  97)																		int maskPixel = this3;
HXDLIN(  97)																		int this4 = col;
HXDLIN(  97)																		int this5 = this4;
HXDLIN(  97)																		if ((maskPixel == 0)) {
HXLINE(  97)																			int this1 = this5;
HXDLIN(  97)																			col = this1;
            																		}
            																		else {
HXLINE(  97)																			Float m0;
HXDLIN(  97)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																			if ((this1 == 0)) {
HXLINE(  97)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m1;
HXDLIN(  97)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																			if ((this2 == 0)) {
HXLINE(  97)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m2;
HXDLIN(  97)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																			if ((this3 == 0)) {
HXLINE(  97)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float m3;
HXDLIN(  97)																			int this4 = (maskPixel & 255);
HXDLIN(  97)																			if ((this4 == 0)) {
HXLINE(  97)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  97)																	if ((col != 0)) {
HXLINE(  97)																		int x = (dx - rectLeft);
HXDLIN(  97)																		int y = (dy - rectTop);
HXDLIN(  97)																		int this1 = col;
HXDLIN(  97)																		int c = this1;
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			int location;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																			int this3 = this2;
HXDLIN(  97)																			int this4;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				this4 = this3;
            																			}
HXDLIN(  97)																			Float a1;
HXDLIN(  97)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																			if ((this5 == 0)) {
HXLINE(  97)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r1;
HXDLIN(  97)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																			if ((this6 == 0)) {
HXLINE(  97)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g1;
HXDLIN(  97)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																			if ((this7 == 0)) {
HXLINE(  97)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b1;
HXDLIN(  97)																			int this8 = (this4 & 255);
HXDLIN(  97)																			if ((this8 == 0)) {
HXLINE(  97)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a2;
HXDLIN(  97)																			int this9 = ((col >> 24) & 255);
HXDLIN(  97)																			if ((this9 == 0)) {
HXLINE(  97)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r2;
HXDLIN(  97)																			int this10 = ((col >> 16) & 255);
HXDLIN(  97)																			if ((this10 == 0)) {
HXLINE(  97)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g2;
HXDLIN(  97)																			int this11 = ((col >> 8) & 255);
HXDLIN(  97)																			if ((this11 == 0)) {
HXLINE(  97)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b2;
HXDLIN(  97)																			int this12 = (col & 255);
HXDLIN(  97)																			if ((this12 == 0)) {
HXLINE(  97)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																			{
HXLINE(  97)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  97)																				int value;
HXDLIN(  97)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  97)																					value = blended;
            																				}
HXDLIN(  97)																				bool _hx_tmp;
HXDLIN(  97)																				if ((location >= 0)) {
HXLINE(  97)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  97)																					_hx_tmp = false;
            																				}
HXDLIN(  97)																				if (_hx_tmp) {
HXLINE(  97)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			int value;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				value = c;
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  97)																		if (forceClear) {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																			int x = (dx - rectLeft);
HXDLIN(  97)																			int y = (dy - rectTop);
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (undoImage->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  97)											bool foundY = false;
HXDLIN(  97)											Float s = ((Float)0.);
HXDLIN(  97)											Float t = ((Float)0.);
HXDLIN(  97)											Float sxx = ((Float)0.);
HXDLIN(  97)											Float txx = ((Float)0.);
HXDLIN(  97)											{
HXLINE(  97)												int _g_min = xIter3->start;
HXDLIN(  97)												int _g_max = xIter3->max;
HXDLIN(  97)												while((_g_min < _g_max)){
HXLINE(  97)													_g_min = (_g_min + 1);
HXDLIN(  97)													int x = (_g_min - 1);
HXLINE( 223)													sxx = (sx * ( (Float)(x) ));
HXLINE( 224)													txx = (tx * ( (Float)(x) ));
HXLINE( 225)													foundY = false;
HXLINE(  97)													{
HXLINE(  97)														int _g_min1 = yIter3->start;
HXDLIN(  97)														int _g_max = yIter3->max;
HXDLIN(  97)														while((_g_min1 < _g_max)){
HXLINE(  97)															_g_min1 = (_g_min1 + 1);
HXDLIN(  97)															int y = (_g_min1 - 1);
HXLINE( 227)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  97)															bool _hx_tmp;
HXDLIN(  97)															if (!((s <= 0))) {
HXLINE(  97)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  97)																_hx_tmp = true;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																if (foundY) {
HXLINE(  97)																	goto _hx_goto_120;
            																}
            															}
            															else {
HXLINE(  97)																if (((s + t) < A)) {
HXLINE(  97)																	int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)																	int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)																	::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)																	int index;
HXDLIN(  97)																	if (tileImage->useVirtualPos) {
HXLINE(  97)																		index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																	}
            																	else {
HXLINE(  97)																		index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																	}
HXDLIN(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																	int color;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		color = c;
            																	}
HXDLIN(  97)																	{
HXLINE(  97)																		int this2 = color;
HXDLIN(  97)																		int c1 = this2;
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			int location;
HXDLIN(  97)																			if (pixelshape->useVirtualPos) {
HXLINE(  97)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  97)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  97)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																			int this3 = this2;
HXDLIN(  97)																			int this4;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				this4 = this3;
            																			}
HXDLIN(  97)																			Float a1;
HXDLIN(  97)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																			if ((this5 == 0)) {
HXLINE(  97)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r1;
HXDLIN(  97)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																			if ((this6 == 0)) {
HXLINE(  97)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g1;
HXDLIN(  97)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																			if ((this7 == 0)) {
HXLINE(  97)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b1;
HXDLIN(  97)																			int this8 = (this4 & 255);
HXDLIN(  97)																			if ((this8 == 0)) {
HXLINE(  97)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a2;
HXDLIN(  97)																			int this9 = ((color >> 24) & 255);
HXDLIN(  97)																			if ((this9 == 0)) {
HXLINE(  97)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float r2;
HXDLIN(  97)																			int this10 = ((color >> 16) & 255);
HXDLIN(  97)																			if ((this10 == 0)) {
HXLINE(  97)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float g2;
HXDLIN(  97)																			int this11 = ((color >> 8) & 255);
HXDLIN(  97)																			if ((this11 == 0)) {
HXLINE(  97)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float b2;
HXDLIN(  97)																			int this12 = (color & 255);
HXDLIN(  97)																			if ((this12 == 0)) {
HXLINE(  97)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  97)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  97)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																			{
HXLINE(  97)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																				int value;
HXDLIN(  97)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  97)																					value = blended;
            																				}
HXDLIN(  97)																				bool _hx_tmp;
HXDLIN(  97)																				if ((location >= 0)) {
HXLINE(  97)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  97)																					_hx_tmp = false;
            																				}
HXDLIN(  97)																				if (_hx_tmp) {
HXLINE(  97)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																			int index;
HXDLIN(  97)																			if (pixelshape->useVirtualPos) {
HXLINE(  97)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  97)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  97)																			int value;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				value = c1;
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((index >= 0)) {
HXLINE(  97)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE( 237)																	foundY = true;
            																}
            																else {
HXLINE(  97)																	if (foundY) {
HXLINE(  97)																		goto _hx_goto_120;
            																	}
            																}
            															}
            														}
            														_hx_goto_120:;
            													}
            												}
            											}
HXDLIN(  97)											if ((hasHit == false)) {
HXLINE(  97)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx5,lowerY,bx,by,cx,cy,true);
HXDLIN(  97)												if (hasUndo) {
HXLINE(  97)													v->undoImage = undoImage;
HXDLIN(  97)													v->undoX = xIter3->start;
HXDLIN(  97)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  93)								lastX2 = nextX;
HXLINE(  94)								lastY2 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  97)				{
HXLINE(  97)					Float x2 = (x + dx);
HXDLIN(  97)					bool hasHit2 = false;
HXDLIN(  97)					Float bx6 = (x2 + ( (Float)(fat) ));
HXDLIN(  97)					Float cy8 = (lowerY + bottomRadius);
HXDLIN(  97)					{
HXLINE(  97)						{
HXLINE(  97)							Float bx7 = bx6;
HXDLIN(  97)							Float by4 = lowerY;
HXDLIN(  97)							Float cx6 = x2;
HXDLIN(  97)							Float cy9 = cy8;
HXDLIN(  97)							bool adjustWinding4 = (((((x2 * by4) - (bx7 * lowerY)) + ((bx7 * cy9) - (cx6 * by4))) + ((cx6 * lowerY) - (x2 * cy9))) > 0);
HXDLIN(  97)							if (!(adjustWinding4)) {
HXLINE(  97)								Float bx_ = bx7;
HXDLIN(  97)								Float by_ = by4;
HXLINE( 188)								bx7 = cx6;
HXLINE( 189)								by4 = cy9;
HXLINE( 190)								cx6 = bx_;
HXLINE( 191)								cy9 = by_;
            							}
HXLINE(  97)							{
HXLINE(  97)								bool hasUndo4 = false;
HXDLIN(  97)								Float s04 = ((lowerY * cx6) - (x2 * cy9));
HXDLIN(  97)								Float sx4 = (cy9 - lowerY);
HXDLIN(  97)								Float sy4 = (x2 - cx6);
HXDLIN(  97)								Float t04 = ((x2 * by4) - (lowerY * bx7));
HXDLIN(  97)								Float tx4 = (lowerY - by4);
HXDLIN(  97)								Float ty4 = (bx7 - x2);
HXDLIN(  97)								Float A4 = ((((-(by4) * cx6) + (lowerY * (-(bx7) + cx6))) + (x2 * (by4 - cy9))) + (bx7 * cy9));
HXDLIN(  97)								::pixelimage::iter::IntIterStart xIter34;
HXDLIN(  97)								if ((x2 > bx7)) {
HXLINE(  97)									if ((x2 > cx6)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx7 > cx6)) {
HXLINE(  97)											min = ::Math_obj::floor(cx6);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(bx7);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(x2);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter34 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx7);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx6);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter34 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((bx7 > cx6)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((x2 > cx6)) {
HXLINE(  97)											min = ::Math_obj::floor(cx6);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(x2);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx7);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter34 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(x2);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx6);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter34 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::iter::IntIterStart yIter34;
HXDLIN(  97)								if ((lowerY > by4)) {
HXLINE(  97)									if ((lowerY > cy9)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((by4 > cy9)) {
HXLINE(  97)											min = ::Math_obj::floor(cy9);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(by4);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter34 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(by4);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy9);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter34 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((by4 > cy9)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((lowerY > cy9)) {
HXLINE(  97)											min = ::Math_obj::floor(cy9);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(lowerY);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(by4);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter34 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy9);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter34 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::ImageStruct undoImage4 = null();
HXDLIN(  97)								if (hasUndo4) {
HXLINE(  97)									int w = ((xIter34->max - xIter34->start) + 1);
HXDLIN(  97)									int h = ((yIter34->max - yIter34->start) + 1);
HXDLIN(  97)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)									undoImage4 = this3;
HXDLIN(  97)									{
HXLINE(  97)										int rectLeft = xIter34->start;
HXDLIN(  97)										int rectTop = yIter34->start;
HXDLIN(  97)										int rectRight = xIter34->max;
HXDLIN(  97)										bool forceClear = false;
HXDLIN(  97)										{
HXLINE(  97)											int _g = rectTop;
HXDLIN(  97)											int _g1 = yIter34->max;
HXDLIN(  97)											while((_g < _g1)){
HXLINE(  97)												_g = (_g + 1);
HXDLIN(  97)												int dy = (_g - 1);
HXDLIN(  97)												{
HXLINE(  97)													int _g1 = rectLeft;
HXDLIN(  97)													int _g2 = rectRight;
HXDLIN(  97)													while((_g1 < _g2)){
HXLINE(  97)														_g1 = (_g1 + 1);
HXDLIN(  97)														int dx = (_g1 - 1);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (pixelshape->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int col;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															col = c;
            														}
HXDLIN(  97)														bool _hx_tmp;
HXDLIN(  97)														if (pixelshape->useMask) {
HXLINE(  97)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  97)															_hx_tmp = false;
            														}
HXDLIN(  97)														if (_hx_tmp) {
HXLINE(  97)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)															int index;
HXDLIN(  97)															if (this1->useVirtualPos) {
HXLINE(  97)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  97)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  97)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)															int v;
HXDLIN(  97)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  97)																v = c;
            															}
HXDLIN(  97)															int this3 = v;
HXDLIN(  97)															int maskPixel = this3;
HXDLIN(  97)															int this4 = col;
HXDLIN(  97)															int this5 = this4;
HXDLIN(  97)															if ((maskPixel == 0)) {
HXLINE(  97)																int this1 = this5;
HXDLIN(  97)																col = this1;
            															}
            															else {
HXLINE(  97)																Float m0;
HXDLIN(  97)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																if ((this1 == 0)) {
HXLINE(  97)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m1;
HXDLIN(  97)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																if ((this2 == 0)) {
HXLINE(  97)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m2;
HXDLIN(  97)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																if ((this3 == 0)) {
HXLINE(  97)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m3;
HXDLIN(  97)																int this4 = (maskPixel & 255);
HXDLIN(  97)																if ((this4 == 0)) {
HXLINE(  97)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  97)														if ((col != 0)) {
HXLINE(  97)															int x = (dx - rectLeft);
HXDLIN(  97)															int y = (dy - rectTop);
HXDLIN(  97)															int this1 = col;
HXDLIN(  97)															int c = this1;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = undoImage4->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (undoImage4->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((col >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((col >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((col >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (col & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage4->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage4->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  97)															if (forceClear) {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  97)																int x = (dx - rectLeft);
HXDLIN(  97)																int y = (dy - rectTop);
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage4->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  97)								bool foundY4 = false;
HXDLIN(  97)								Float s4 = ((Float)0.);
HXDLIN(  97)								Float t4 = ((Float)0.);
HXDLIN(  97)								Float sxx4 = ((Float)0.);
HXDLIN(  97)								Float txx4 = ((Float)0.);
HXDLIN(  97)								{
HXLINE(  97)									int _g_min4 = xIter34->start;
HXDLIN(  97)									int _g_max4 = xIter34->max;
HXDLIN(  97)									while((_g_min4 < _g_max4)){
HXLINE(  97)										_g_min4 = (_g_min4 + 1);
HXDLIN(  97)										int x = (_g_min4 - 1);
HXLINE( 223)										sxx4 = (sx4 * ( (Float)(x) ));
HXLINE( 224)										txx4 = (tx4 * ( (Float)(x) ));
HXLINE( 225)										foundY4 = false;
HXLINE(  97)										{
HXLINE(  97)											int _g_min = yIter34->start;
HXDLIN(  97)											int _g_max = yIter34->max;
HXDLIN(  97)											while((_g_min < _g_max)){
HXLINE(  97)												_g_min = (_g_min + 1);
HXDLIN(  97)												int y = (_g_min - 1);
HXLINE( 227)												s4 = ((s04 + sxx4) + (sy4 * ( (Float)(y) )));
HXLINE( 228)												t4 = ((t04 + txx4) + (ty4 * ( (Float)(y) )));
HXLINE(  97)												bool _hx_tmp;
HXDLIN(  97)												if (!((s4 <= 0))) {
HXLINE(  97)													_hx_tmp = (t4 <= 0);
            												}
            												else {
HXLINE(  97)													_hx_tmp = true;
            												}
HXDLIN(  97)												if (_hx_tmp) {
HXLINE(  97)													if (foundY4) {
HXLINE(  97)														goto _hx_goto_124;
            													}
            												}
            												else {
HXLINE(  97)													if (((s4 + t4) < A4)) {
HXLINE(  97)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (tileImage->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int color;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															color = c;
            														}
HXDLIN(  97)														{
HXLINE(  97)															int this2 = color;
HXDLIN(  97)															int c1 = this2;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((color >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((color >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((color >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (color & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c1;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY4 = true;
            													}
            													else {
HXLINE(  97)														if (foundY4) {
HXLINE(  97)															goto _hx_goto_124;
            														}
            													}
            												}
            											}
            											_hx_goto_124:;
            										}
            									}
            								}
HXDLIN(  97)								if ((hasHit2 == false)) {
HXLINE(  97)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x2,lowerY,bx7,by4,cx6,cy9,true);
HXDLIN(  97)									if (hasUndo4) {
HXLINE(  97)										v->undoImage = undoImage4;
HXDLIN(  97)										v->undoX = xIter34->start;
HXDLIN(  97)										v->undoY = yIter34->start;
            									}
            								}
            							}
            						}
HXDLIN(  97)						{
HXLINE(  97)							Float bx8 = bx6;
HXDLIN(  97)							Float by5 = cy8;
HXDLIN(  97)							Float cx7 = x2;
HXDLIN(  97)							Float cy10 = cy8;
HXDLIN(  97)							bool adjustWinding5 = (((((bx6 * by5) - (bx8 * lowerY)) + ((bx8 * cy10) - (cx7 * by5))) + ((cx7 * lowerY) - (bx6 * cy10))) > 0);
HXDLIN(  97)							if (!(adjustWinding5)) {
HXLINE(  97)								Float bx_ = bx8;
HXDLIN(  97)								Float by_ = by5;
HXLINE( 188)								bx8 = cx7;
HXLINE( 189)								by5 = cy10;
HXLINE( 190)								cx7 = bx_;
HXLINE( 191)								cy10 = by_;
            							}
HXLINE(  97)							{
HXLINE(  97)								bool hasUndo5 = false;
HXDLIN(  97)								Float s05 = ((lowerY * cx7) - (bx6 * cy10));
HXDLIN(  97)								Float sx5 = (cy10 - lowerY);
HXDLIN(  97)								Float sy5 = (bx6 - cx7);
HXDLIN(  97)								Float t05 = ((bx6 * by5) - (lowerY * bx8));
HXDLIN(  97)								Float tx5 = (lowerY - by5);
HXDLIN(  97)								Float ty5 = (bx8 - bx6);
HXDLIN(  97)								Float A5 = ((((-(by5) * cx7) + (lowerY * (-(bx8) + cx7))) + (bx6 * (by5 - cy10))) + (bx8 * cy10));
HXDLIN(  97)								::pixelimage::iter::IntIterStart xIter35;
HXDLIN(  97)								if ((bx6 > bx8)) {
HXLINE(  97)									if ((bx6 > cx7)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx8 > cx7)) {
HXLINE(  97)											min = ::Math_obj::floor(cx7);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(bx8);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx6);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter35 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx8);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx7);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter35 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((bx8 > cx7)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((bx6 > cx7)) {
HXLINE(  97)											min = ::Math_obj::floor(cx7);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(bx6);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(bx8);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter35 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(bx6);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cx7);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										xIter35 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::iter::IntIterStart yIter35;
HXDLIN(  97)								if ((lowerY > by5)) {
HXLINE(  97)									if ((lowerY > cy10)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((by5 > cy10)) {
HXLINE(  97)											min = ::Math_obj::floor(cy10);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::floor(by5);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter35 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(by5);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy10);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter35 = this1;
            									}
            								}
            								else {
HXLINE(  97)									if ((by5 > cy10)) {
HXLINE(  97)										int min;
HXDLIN(  97)										if ((lowerY > cy10)) {
HXLINE(  97)											min = ::Math_obj::floor(cy10);
            										}
            										else {
HXLINE(  97)											min = ::Math_obj::ceil(lowerY);
            										}
HXDLIN(  97)										int ii_min = min;
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(by5);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter35 = this1;
            									}
            									else {
HXLINE(  97)										int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  97)										int ii_max = ::Math_obj::ceil(cy10);
HXDLIN(  97)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)										yIter35 = this1;
            									}
            								}
HXDLIN(  97)								::pixelimage::ImageStruct undoImage5 = null();
HXDLIN(  97)								if (hasUndo5) {
HXLINE(  97)									int w = ((xIter35->max - xIter35->start) + 1);
HXDLIN(  97)									int h = ((yIter35->max - yIter35->start) + 1);
HXDLIN(  97)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)									undoImage5 = this3;
HXDLIN(  97)									{
HXLINE(  97)										int rectLeft = xIter35->start;
HXDLIN(  97)										int rectTop = yIter35->start;
HXDLIN(  97)										int rectRight = xIter35->max;
HXDLIN(  97)										bool forceClear = false;
HXDLIN(  97)										{
HXLINE(  97)											int _g = rectTop;
HXDLIN(  97)											int _g1 = yIter35->max;
HXDLIN(  97)											while((_g < _g1)){
HXLINE(  97)												_g = (_g + 1);
HXDLIN(  97)												int dy = (_g - 1);
HXDLIN(  97)												{
HXLINE(  97)													int _g1 = rectLeft;
HXDLIN(  97)													int _g2 = rectRight;
HXDLIN(  97)													while((_g1 < _g2)){
HXLINE(  97)														_g1 = (_g1 + 1);
HXDLIN(  97)														int dx = (_g1 - 1);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (pixelshape->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int col;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															col = c;
            														}
HXDLIN(  97)														bool _hx_tmp;
HXDLIN(  97)														if (pixelshape->useMask) {
HXLINE(  97)															_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            														}
            														else {
HXLINE(  97)															_hx_tmp = false;
            														}
HXDLIN(  97)														if (_hx_tmp) {
HXLINE(  97)															::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)															int index;
HXDLIN(  97)															if (this1->useVirtualPos) {
HXLINE(  97)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  97)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  97)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)															int v;
HXDLIN(  97)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  97)																v = c;
            															}
HXDLIN(  97)															int this3 = v;
HXDLIN(  97)															int maskPixel = this3;
HXDLIN(  97)															int this4 = col;
HXDLIN(  97)															int this5 = this4;
HXDLIN(  97)															if ((maskPixel == 0)) {
HXLINE(  97)																int this1 = this5;
HXDLIN(  97)																col = this1;
            															}
            															else {
HXLINE(  97)																Float m0;
HXDLIN(  97)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																if ((this1 == 0)) {
HXLINE(  97)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m1;
HXDLIN(  97)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																if ((this2 == 0)) {
HXLINE(  97)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m2;
HXDLIN(  97)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																if ((this3 == 0)) {
HXLINE(  97)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float m3;
HXDLIN(  97)																int this4 = (maskPixel & 255);
HXDLIN(  97)																if ((this4 == 0)) {
HXLINE(  97)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  97)														if ((col != 0)) {
HXLINE(  97)															int x = (dx - rectLeft);
HXDLIN(  97)															int y = (dy - rectTop);
HXDLIN(  97)															int this1 = col;
HXDLIN(  97)															int c = this1;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = undoImage5->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (undoImage5->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((col >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((col >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((col >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (col & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage5->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage5->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  97)															if (forceClear) {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  97)																int x = (dx - rectLeft);
HXDLIN(  97)																int y = (dy - rectTop);
HXDLIN(  97)																int index;
HXDLIN(  97)																if (undoImage5->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  97)								bool foundY5 = false;
HXDLIN(  97)								Float s5 = ((Float)0.);
HXDLIN(  97)								Float t5 = ((Float)0.);
HXDLIN(  97)								Float sxx5 = ((Float)0.);
HXDLIN(  97)								Float txx5 = ((Float)0.);
HXDLIN(  97)								{
HXLINE(  97)									int _g_min5 = xIter35->start;
HXDLIN(  97)									int _g_max5 = xIter35->max;
HXDLIN(  97)									while((_g_min5 < _g_max5)){
HXLINE(  97)										_g_min5 = (_g_min5 + 1);
HXDLIN(  97)										int x = (_g_min5 - 1);
HXLINE( 223)										sxx5 = (sx5 * ( (Float)(x) ));
HXLINE( 224)										txx5 = (tx5 * ( (Float)(x) ));
HXLINE( 225)										foundY5 = false;
HXLINE(  97)										{
HXLINE(  97)											int _g_min = yIter35->start;
HXDLIN(  97)											int _g_max = yIter35->max;
HXDLIN(  97)											while((_g_min < _g_max)){
HXLINE(  97)												_g_min = (_g_min + 1);
HXDLIN(  97)												int y = (_g_min - 1);
HXLINE( 227)												s5 = ((s05 + sxx5) + (sy5 * ( (Float)(y) )));
HXLINE( 228)												t5 = ((t05 + txx5) + (ty5 * ( (Float)(y) )));
HXLINE(  97)												bool _hx_tmp;
HXDLIN(  97)												if (!((s5 <= 0))) {
HXLINE(  97)													_hx_tmp = (t5 <= 0);
            												}
            												else {
HXLINE(  97)													_hx_tmp = true;
            												}
HXDLIN(  97)												if (_hx_tmp) {
HXLINE(  97)													if (foundY5) {
HXLINE(  97)														goto _hx_goto_128;
            													}
            												}
            												else {
HXLINE(  97)													if (((s5 + t5) < A5)) {
HXLINE(  97)														int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)														int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)														::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)														int index;
HXDLIN(  97)														if (tileImage->useVirtualPos) {
HXLINE(  97)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            														}
            														else {
HXLINE(  97)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            														}
HXDLIN(  97)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)														int color;
HXDLIN(  97)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  97)															color = c;
            														}
HXDLIN(  97)														{
HXLINE(  97)															int this2 = color;
HXDLIN(  97)															int c1 = this2;
HXDLIN(  97)															bool _hx_tmp;
HXDLIN(  97)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																_hx_tmp = pixelshape->transparent;
            															}
            															else {
HXLINE(  97)																_hx_tmp = false;
            															}
HXDLIN(  97)															if (_hx_tmp) {
HXLINE(  97)																int location;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int this3 = this2;
HXDLIN(  97)																int this4;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	this4 = this3;
            																}
HXDLIN(  97)																Float a1;
HXDLIN(  97)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																if ((this5 == 0)) {
HXLINE(  97)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r1;
HXDLIN(  97)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																if ((this6 == 0)) {
HXLINE(  97)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g1;
HXDLIN(  97)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																if ((this7 == 0)) {
HXLINE(  97)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b1;
HXDLIN(  97)																int this8 = (this4 & 255);
HXDLIN(  97)																if ((this8 == 0)) {
HXLINE(  97)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a2;
HXDLIN(  97)																int this9 = ((color >> 24) & 255);
HXDLIN(  97)																if ((this9 == 0)) {
HXLINE(  97)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float r2;
HXDLIN(  97)																int this10 = ((color >> 16) & 255);
HXDLIN(  97)																if ((this10 == 0)) {
HXLINE(  97)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float g2;
HXDLIN(  97)																int this11 = ((color >> 8) & 255);
HXDLIN(  97)																if ((this11 == 0)) {
HXLINE(  97)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float b2;
HXDLIN(  97)																int this12 = (color & 255);
HXDLIN(  97)																if ((this12 == 0)) {
HXLINE(  97)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  97)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  97)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																{
HXLINE(  97)																	::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																	int value;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		value = blended;
            																	}
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((location >= 0)) {
HXLINE(  97)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																}
HXDLIN(  97)																int value;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	value = c1;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if ((index >= 0)) {
HXLINE(  97)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY5 = true;
            													}
            													else {
HXLINE(  97)														if (foundY5) {
HXLINE(  97)															goto _hx_goto_128;
            														}
            													}
            												}
            											}
            											_hx_goto_128:;
            										}
            									}
            								}
HXDLIN(  97)								if ((hasHit2 == false)) {
HXLINE(  97)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx6,lowerY,bx8,by5,cx7,cy10,true);
HXDLIN(  97)									if (hasUndo5) {
HXLINE(  97)										v->undoImage = undoImage5;
HXDLIN(  97)										v->undoX = xIter35->start;
HXDLIN(  97)										v->undoY = yIter35->start;
            									}
            								}
            							}
            						}
HXDLIN(  97)						if ((hasHit2 == true)) {
HXLINE(  97)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x2,lowerY,bx6,lowerY,bx6,cy8,x2,cy8,true);
            						}
            					}
            				}
HXDLIN(  97)				{
HXLINE(  97)					 ::Dynamic targetError3 = ((Float)1.05);
HXDLIN(  97)					if (::hx::IsNull( targetError3 )) {
HXLINE( 850)						targetError3 = ((Float)1.05);
            					}
HXLINE(  97)					Float rSmall3;
HXDLIN(  97)					if ((rightRadius > bottomRadius)) {
HXLINE(  97)						rSmall3 = bottomRadius;
            					}
            					else {
HXLINE(  97)						rSmall3 = rightRadius;
            					}
HXDLIN(  97)					 ::Dynamic targetE3 = ( (Float)(targetError3) );
HXDLIN(  97)					if (::hx::IsNull( targetE3 )) {
HXLINE(  20)						targetE3 = ((Float)1.05);
            					}
HXLINE(  97)					int result3 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE3) ) / rSmall3)))));
HXDLIN(  97)					int noSides3;
HXDLIN(  97)					if ((result3 < 12)) {
HXLINE(  97)						noSides3 = 12;
            					}
            					else {
HXLINE(  97)						if ((result3 > 500)) {
HXLINE(  97)							noSides3 = 500;
            						}
            						else {
HXLINE(  97)							noSides3 = result3;
            						}
            					}
HXDLIN(  97)					int sides3 = (::Math_obj::ceil((( (Float)(noSides3) ) / ( (Float)(4) ))) * 4);
HXDLIN(  97)					Float theta3 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN(  97)					Float omega3 = ( (Float)(0) );
HXDLIN(  97)					int quarter3 = ::Std_obj::_hx_int((( (Float)(sides3) ) / ( (Float)(4) )));
HXDLIN(  97)					Float lastX3 = ((Float)0.);
HXDLIN(  97)					Float lastY3 = ((Float)0.);
HXDLIN(  97)					{
HXLINE(  73)						lastX3 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides3) ) * theta3) + omega3))));
HXLINE(  74)						lastY3 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides3) ) * theta3) + omega3))));
            					}
HXLINE(  97)					{
HXLINE(  97)						int _g6 = 0;
HXDLIN(  97)						int _g7 = (quarter3 + 1);
HXDLIN(  97)						while((_g6 < _g7)){
HXLINE(  97)							_g6 = (_g6 + 1);
HXDLIN(  97)							int i = (_g6 - 1);
HXDLIN(  97)							Float nextX = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  97)							Float nextY = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  97)							{
HXLINE(  97)								bool hasHit = false;
HXDLIN(  97)								{
HXLINE(  97)									Float bx = lastX3;
HXDLIN(  97)									Float by = lastY3;
HXDLIN(  97)									Float cx = nextX;
HXDLIN(  97)									Float cy = nextY;
HXDLIN(  97)									bool adjustWinding = (((((farX * by) - (bx * lowerY)) + ((bx * cy) - (cx * by))) + ((cx * lowerY) - (farX * cy))) > 0);
HXDLIN(  97)									if (!(adjustWinding)) {
HXLINE(  97)										Float bx_ = bx;
HXDLIN(  97)										Float by_ = by;
HXLINE( 188)										bx = cx;
HXLINE( 189)										by = cy;
HXLINE( 190)										cx = bx_;
HXLINE( 191)										cy = by_;
            									}
HXLINE(  97)									{
HXLINE(  97)										bool hasUndo = false;
HXDLIN(  97)										Float s0 = ((lowerY * cx) - (farX * cy));
HXDLIN(  97)										Float sx = (cy - lowerY);
HXDLIN(  97)										Float sy = (farX - cx);
HXDLIN(  97)										Float t0 = ((farX * by) - (lowerY * bx));
HXDLIN(  97)										Float tx = (lowerY - by);
HXDLIN(  97)										Float ty = (bx - farX);
HXDLIN(  97)										Float A = ((((-(by) * cx) + (lowerY * (-(bx) + cx))) + (farX * (by - cy))) + (bx * cy));
HXDLIN(  97)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  97)										if ((farX > bx)) {
HXLINE(  97)											if ((farX > cx)) {
HXLINE(  97)												int min;
HXDLIN(  97)												if ((bx > cx)) {
HXLINE(  97)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  97)													min = ::Math_obj::floor(bx);
            												}
HXDLIN(  97)												int ii_min = min;
HXDLIN(  97)												int ii_max = ::Math_obj::ceil(farX);
HXDLIN(  97)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)												xIter3 = this1;
            											}
            											else {
HXLINE(  97)												int ii_min = ::Math_obj::floor(bx);
HXDLIN(  97)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  97)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  97)											if ((bx > cx)) {
HXLINE(  97)												int min;
HXDLIN(  97)												if ((farX > cx)) {
HXLINE(  97)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  97)													min = ::Math_obj::ceil(farX);
            												}
HXDLIN(  97)												int ii_min = min;
HXDLIN(  97)												int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  97)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)												xIter3 = this1;
            											}
            											else {
HXLINE(  97)												int ii_min = ::Math_obj::floor(farX);
HXDLIN(  97)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  97)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)												xIter3 = this1;
            											}
            										}
HXDLIN(  97)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  97)										if ((lowerY > by)) {
HXLINE(  97)											if ((lowerY > cy)) {
HXLINE(  97)												int min;
HXDLIN(  97)												if ((by > cy)) {
HXLINE(  97)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  97)													min = ::Math_obj::floor(by);
            												}
HXDLIN(  97)												int ii_min = min;
HXDLIN(  97)												int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  97)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)												yIter3 = this1;
            											}
            											else {
HXLINE(  97)												int ii_min = ::Math_obj::floor(by);
HXDLIN(  97)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  97)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  97)											if ((by > cy)) {
HXLINE(  97)												int min;
HXDLIN(  97)												if ((lowerY > cy)) {
HXLINE(  97)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  97)													min = ::Math_obj::ceil(lowerY);
            												}
HXDLIN(  97)												int ii_min = min;
HXDLIN(  97)												int ii_max = ::Math_obj::ceil(by);
HXDLIN(  97)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)												yIter3 = this1;
            											}
            											else {
HXLINE(  97)												int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  97)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  97)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  97)												yIter3 = this1;
            											}
            										}
HXDLIN(  97)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  97)										if (hasUndo) {
HXLINE(  97)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  97)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  97)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  97)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  97)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  97)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  97)											undoImage = this3;
HXDLIN(  97)											{
HXLINE(  97)												int rectLeft = xIter3->start;
HXDLIN(  97)												int rectTop = yIter3->start;
HXDLIN(  97)												int rectRight = xIter3->max;
HXDLIN(  97)												bool forceClear = false;
HXDLIN(  97)												{
HXLINE(  97)													int _g = rectTop;
HXDLIN(  97)													int _g1 = yIter3->max;
HXDLIN(  97)													while((_g < _g1)){
HXLINE(  97)														_g = (_g + 1);
HXDLIN(  97)														int dy = (_g - 1);
HXDLIN(  97)														{
HXLINE(  97)															int _g1 = rectLeft;
HXDLIN(  97)															int _g2 = rectRight;
HXDLIN(  97)															while((_g1 < _g2)){
HXLINE(  97)																_g1 = (_g1 + 1);
HXDLIN(  97)																int dx = (_g1 - 1);
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (pixelshape->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																}
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int col;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	col = c;
            																}
HXDLIN(  97)																bool _hx_tmp;
HXDLIN(  97)																if (pixelshape->useMask) {
HXLINE(  97)																	_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																}
            																else {
HXLINE(  97)																	_hx_tmp = false;
            																}
HXDLIN(  97)																if (_hx_tmp) {
HXLINE(  97)																	::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  97)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)																	int index;
HXDLIN(  97)																	if (this1->useVirtualPos) {
HXLINE(  97)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  97)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  97)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																	int v;
HXDLIN(  97)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  97)																		v = c;
            																	}
HXDLIN(  97)																	int this3 = v;
HXDLIN(  97)																	int maskPixel = this3;
HXDLIN(  97)																	int this4 = col;
HXDLIN(  97)																	int this5 = this4;
HXDLIN(  97)																	if ((maskPixel == 0)) {
HXLINE(  97)																		int this1 = this5;
HXDLIN(  97)																		col = this1;
            																	}
            																	else {
HXLINE(  97)																		Float m0;
HXDLIN(  97)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)																		if ((this1 == 0)) {
HXLINE(  97)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float m1;
HXDLIN(  97)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)																		if ((this2 == 0)) {
HXLINE(  97)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float m2;
HXDLIN(  97)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)																		if ((this3 == 0)) {
HXLINE(  97)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float m3;
HXDLIN(  97)																		int this4 = (maskPixel & 255);
HXDLIN(  97)																		if ((this4 == 0)) {
HXLINE(  97)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  97)																if ((col != 0)) {
HXLINE(  97)																	int x = (dx - rectLeft);
HXDLIN(  97)																	int y = (dy - rectTop);
HXDLIN(  97)																	int this1 = col;
HXDLIN(  97)																	int c = this1;
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)																		_hx_tmp = undoImage->transparent;
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		int location;
HXDLIN(  97)																		if (undoImage->useVirtualPos) {
HXLINE(  97)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  97)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  97)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																		int this3 = this2;
HXDLIN(  97)																		int this4;
HXDLIN(  97)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  97)																			this4 = this3;
            																		}
HXDLIN(  97)																		Float a1;
HXDLIN(  97)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																		if ((this5 == 0)) {
HXLINE(  97)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float r1;
HXDLIN(  97)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																		if ((this6 == 0)) {
HXLINE(  97)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float g1;
HXDLIN(  97)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																		if ((this7 == 0)) {
HXLINE(  97)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float b1;
HXDLIN(  97)																		int this8 = (this4 & 255);
HXDLIN(  97)																		if ((this8 == 0)) {
HXLINE(  97)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float a2;
HXDLIN(  97)																		int this9 = ((col >> 24) & 255);
HXDLIN(  97)																		if ((this9 == 0)) {
HXLINE(  97)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float r2;
HXDLIN(  97)																		int this10 = ((col >> 16) & 255);
HXDLIN(  97)																		if ((this10 == 0)) {
HXLINE(  97)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float g2;
HXDLIN(  97)																		int this11 = ((col >> 8) & 255);
HXDLIN(  97)																		if ((this11 == 0)) {
HXLINE(  97)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float b2;
HXDLIN(  97)																		int this12 = (col & 255);
HXDLIN(  97)																		if ((this12 == 0)) {
HXLINE(  97)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																		{
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  97)																			int value;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				value = blended;
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((location >= 0)) {
HXLINE(  97)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  97)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																		int index;
HXDLIN(  97)																		if (undoImage->useVirtualPos) {
HXLINE(  97)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  97)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  97)																		int value;
HXDLIN(  97)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  97)																			value = c;
            																		}
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((index >= 0)) {
HXLINE(  97)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  97)																	if (forceClear) {
HXLINE(  97)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  97)																		int x = (dx - rectLeft);
HXDLIN(  97)																		int y = (dy - rectTop);
HXDLIN(  97)																		int index;
HXDLIN(  97)																		if (undoImage->useVirtualPos) {
HXLINE(  97)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  97)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((index >= 0)) {
HXLINE(  97)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  97)										bool foundY = false;
HXDLIN(  97)										Float s = ((Float)0.);
HXDLIN(  97)										Float t = ((Float)0.);
HXDLIN(  97)										Float sxx = ((Float)0.);
HXDLIN(  97)										Float txx = ((Float)0.);
HXDLIN(  97)										{
HXLINE(  97)											int _g_min = xIter3->start;
HXDLIN(  97)											int _g_max = xIter3->max;
HXDLIN(  97)											while((_g_min < _g_max)){
HXLINE(  97)												_g_min = (_g_min + 1);
HXDLIN(  97)												int x = (_g_min - 1);
HXLINE( 223)												sxx = (sx * ( (Float)(x) ));
HXLINE( 224)												txx = (tx * ( (Float)(x) ));
HXLINE( 225)												foundY = false;
HXLINE(  97)												{
HXLINE(  97)													int _g_min1 = yIter3->start;
HXDLIN(  97)													int _g_max = yIter3->max;
HXDLIN(  97)													while((_g_min1 < _g_max)){
HXLINE(  97)														_g_min1 = (_g_min1 + 1);
HXDLIN(  97)														int y = (_g_min1 - 1);
HXLINE( 227)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  97)														bool _hx_tmp;
HXDLIN(  97)														if (!((s <= 0))) {
HXLINE(  97)															_hx_tmp = (t <= 0);
            														}
            														else {
HXLINE(  97)															_hx_tmp = true;
            														}
HXDLIN(  97)														if (_hx_tmp) {
HXLINE(  97)															if (foundY) {
HXLINE(  97)																goto _hx_goto_133;
            															}
            														}
            														else {
HXLINE(  97)															if (((s + t) < A)) {
HXLINE(  97)																int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  97)																int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  97)																::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  97)																int index;
HXDLIN(  97)																if (tileImage->useVirtualPos) {
HXLINE(  97)																	index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																}
            																else {
HXLINE(  97)																	index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																}
HXDLIN(  97)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																int color;
HXDLIN(  97)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																	color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  97)																	color = c;
            																}
HXDLIN(  97)																{
HXLINE(  97)																	int this2 = color;
HXDLIN(  97)																	int c1 = this2;
HXDLIN(  97)																	bool _hx_tmp;
HXDLIN(  97)																	if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  97)																		_hx_tmp = pixelshape->transparent;
            																	}
            																	else {
HXLINE(  97)																		_hx_tmp = false;
            																	}
HXDLIN(  97)																	if (_hx_tmp) {
HXLINE(  97)																		int location;
HXDLIN(  97)																		if (pixelshape->useVirtualPos) {
HXLINE(  97)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																		}
            																		else {
HXLINE(  97)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																		}
HXDLIN(  97)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)																		int this3 = this2;
HXDLIN(  97)																		int this4;
HXDLIN(  97)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  97)																			this4 = this3;
            																		}
HXDLIN(  97)																		Float a1;
HXDLIN(  97)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)																		if ((this5 == 0)) {
HXLINE(  97)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float r1;
HXDLIN(  97)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)																		if ((this6 == 0)) {
HXLINE(  97)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float g1;
HXDLIN(  97)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)																		if ((this7 == 0)) {
HXLINE(  97)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float b1;
HXDLIN(  97)																		int this8 = (this4 & 255);
HXDLIN(  97)																		if ((this8 == 0)) {
HXLINE(  97)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float a2;
HXDLIN(  97)																		int this9 = ((color >> 24) & 255);
HXDLIN(  97)																		if ((this9 == 0)) {
HXLINE(  97)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float r2;
HXDLIN(  97)																		int this10 = ((color >> 16) & 255);
HXDLIN(  97)																		if ((this10 == 0)) {
HXLINE(  97)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float g2;
HXDLIN(  97)																		int this11 = ((color >> 8) & 255);
HXDLIN(  97)																		if ((this11 == 0)) {
HXLINE(  97)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float b2;
HXDLIN(  97)																		int this12 = (color & 255);
HXDLIN(  97)																		if ((this12 == 0)) {
HXLINE(  97)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  97)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  97)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)																		{
HXLINE(  97)																			::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  97)																			int value;
HXDLIN(  97)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  97)																				value = blended;
            																			}
HXDLIN(  97)																			bool _hx_tmp;
HXDLIN(  97)																			if ((location >= 0)) {
HXLINE(  97)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  97)																				_hx_tmp = false;
            																			}
HXDLIN(  97)																			if (_hx_tmp) {
HXLINE(  97)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  97)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  97)																		int index;
HXDLIN(  97)																		if (pixelshape->useVirtualPos) {
HXLINE(  97)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																		}
            																		else {
HXLINE(  97)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																		}
HXDLIN(  97)																		int value;
HXDLIN(  97)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)																			value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																		}
            																		else {
HXLINE(  97)																			value = c1;
            																		}
HXDLIN(  97)																		bool _hx_tmp;
HXDLIN(  97)																		if ((index >= 0)) {
HXLINE(  97)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  97)																			_hx_tmp = false;
            																		}
HXDLIN(  97)																		if (_hx_tmp) {
HXLINE(  97)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE( 237)																foundY = true;
            															}
            															else {
HXLINE(  97)																if (foundY) {
HXLINE(  97)																	goto _hx_goto_133;
            																}
            															}
            														}
            													}
            													_hx_goto_133:;
            												}
            											}
            										}
HXDLIN(  97)										if ((hasHit == false)) {
HXLINE(  97)											::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX,lowerY,bx,by,cx,cy,true);
HXDLIN(  97)											if (hasUndo) {
HXLINE(  97)												v->undoImage = undoImage;
HXDLIN(  97)												v->undoX = xIter3->start;
HXDLIN(  97)												v->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  93)							lastX3 = nextX;
HXLINE(  94)							lastY3 = nextY;
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(RectanglePattern_obj,buildRectangles,(void))


::hx::ObjectPtr< RectanglePattern_obj > RectanglePattern_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< bool >  __o_rounded) {
	::hx::ObjectPtr< RectanglePattern_obj > __this = new RectanglePattern_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale,__o_left,__o_top,__o_width,__o_height,__o_rounded);
	return __this;
}

::hx::ObjectPtr< RectanglePattern_obj > RectanglePattern_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< bool >  __o_rounded) {
	RectanglePattern_obj *__this = (RectanglePattern_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(RectanglePattern_obj), true, "pixelimage.triangleGML.patternShape.RectanglePattern"));
	*(void **)__this = RectanglePattern_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale,__o_left,__o_top,__o_width,__o_height,__o_rounded);
	return __this;
}

RectanglePattern_obj::RectanglePattern_obj()
{
}

::hx::Val RectanglePattern_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { return ::hx::Val( top ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { return ::hx::Val( left ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"rounded") ) { return ::hx::Val( rounded ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"buildRectangles") ) { return ::hx::Val( buildRectangles_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val RectanglePattern_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { top=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { left=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"rounded") ) { rounded=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void RectanglePattern_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("left",07,08,b0,47));
	outFields->push(HX_("top",95,66,58,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("rounded",2d,80,0f,8d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo RectanglePattern_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(RectanglePattern_obj,left),HX_("left",07,08,b0,47)},
	{::hx::fsFloat,(int)offsetof(RectanglePattern_obj,top),HX_("top",95,66,58,00)},
	{::hx::fsFloat,(int)offsetof(RectanglePattern_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsFloat,(int)offsetof(RectanglePattern_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsBool,(int)offsetof(RectanglePattern_obj,rounded),HX_("rounded",2d,80,0f,8d)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *RectanglePattern_obj_sStaticStorageInfo = 0;
#endif

static ::String RectanglePattern_obj_sMemberFields[] = {
	HX_("left",07,08,b0,47),
	HX_("top",95,66,58,00),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("rounded",2d,80,0f,8d),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	HX_("buildRectangles",32,ba,8f,db),
	::String(null()) };

::hx::Class RectanglePattern_obj::__mClass;

void RectanglePattern_obj::__register()
{
	RectanglePattern_obj _hx_dummy;
	RectanglePattern_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.patternShape.RectanglePattern",f5,6e,19,81);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(RectanglePattern_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< RectanglePattern_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RectanglePattern_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RectanglePattern_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace patternShape
