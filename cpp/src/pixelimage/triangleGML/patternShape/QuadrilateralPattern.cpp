// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_PatternShape
#include <pixelimage/triangleGML/coreShape/PatternShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_patternShape_QuadrilateralPattern
#include <pixelimage/triangleGML/patternShape/QuadrilateralPattern.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c0b857549da288e9_47_new,"pixelimage.triangleGML.patternShape.QuadrilateralPattern","new",0x0e42eedd,"pixelimage.triangleGML.patternShape.QuadrilateralPattern.new","pixelimage/triangleGML/patternShape/QuadrilateralPattern.hx",47,0xe509e9d4)
HX_LOCAL_STACK_FRAME(_hx_pos_c0b857549da288e9_62_setParameter,"pixelimage.triangleGML.patternShape.QuadrilateralPattern","setParameter",0x47999f8a,"pixelimage.triangleGML.patternShape.QuadrilateralPattern.setParameter","pixelimage/triangleGML/patternShape/QuadrilateralPattern.hx",62,0xe509e9d4)
HX_LOCAL_STACK_FRAME(_hx_pos_c0b857549da288e9_83_render,"pixelimage.triangleGML.patternShape.QuadrilateralPattern","render",0x3da0b8f9,"pixelimage.triangleGML.patternShape.QuadrilateralPattern.render","pixelimage/triangleGML/patternShape/QuadrilateralPattern.hx",83,0xe509e9d4)
namespace pixelimage{
namespace triangleGML{
namespace patternShape{

void QuadrilateralPattern_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3,::hx::Null< Float >  __o_x4,::hx::Null< Float >  __o_y4){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int strokeColor0 = __o_strokeColor0.Default(0);
            		int strokeColor1 = __o_strokeColor1.Default(0);
            		int fillColor0 = __o_fillColor0.Default(0);
            		int fillColor1 = __o_fillColor1.Default(0);
            		bool strokePatternAcross = __o_strokePatternAcross.Default(true);
            		int strokePatternScale = __o_strokePatternScale.Default(1);
            		int fillPatternWidth = __o_fillPatternWidth.Default(16);
            		int fillPatternHeight = __o_fillPatternHeight.Default(16);
            		bool fillPatternAcross = __o_fillPatternAcross.Default(true);
            		int fillPatternScale = __o_fillPatternScale.Default(1);
            		Float x1 = __o_x1.Default(((Float)0.));
            		Float y1 = __o_y1.Default(((Float)0.));
            		Float x2 = __o_x2.Default(((Float)0.));
            		Float y2 = __o_y2.Default(((Float)0.));
            		Float x3 = __o_x3.Default(((Float)0.));
            		Float y3 = __o_y3.Default(((Float)0.));
            		Float x4 = __o_x4.Default(((Float)0.));
            		Float y4 = __o_y4.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_c0b857549da288e9_47_new)
HXLINE(  48)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,strokeColor0,strokeColor1,fillColor0,fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,strokePatternAcross,strokePatternScale,fillPatternFill,fillPatternWidth,fillPatternHeight,fillPatternAcross,fillPatternScale);
HXLINE(  52)		this->x1 = x1;
HXLINE(  53)		this->y1 = y1;
HXLINE(  54)		this->x2 = x2;
HXLINE(  55)		this->y2 = y2;
HXLINE(  56)		this->x3 = x3;
HXLINE(  57)		this->y3 = y3;
HXLINE(  58)		this->x4 = x4;
HXLINE(  59)		this->y4 = y4;
            	}

Dynamic QuadrilateralPattern_obj::__CreateEmpty() { return new QuadrilateralPattern_obj; }

void *QuadrilateralPattern_obj::_hx_vtable = 0;

Dynamic QuadrilateralPattern_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< QuadrilateralPattern_obj > _hx_result = new QuadrilateralPattern_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14],inArgs[15],inArgs[16],inArgs[17],inArgs[18],inArgs[19],inArgs[20],inArgs[21],inArgs[22],inArgs[23],inArgs[24],inArgs[25],inArgs[26]);
	return _hx_result;
}

bool QuadrilateralPattern_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x648a46d1 || inClassId==(int)0x6e596dee;
	}
}

void QuadrilateralPattern_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_c0b857549da288e9_62_setParameter)
HXDLIN(  62)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("x1",b9,68,00,00)) ){
HXLINE(  64)			this->x1 = ::Std_obj::parseFloat(value);
HXDLIN(  64)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x2",ba,68,00,00)) ){
HXLINE(  68)			this->x2 = ::Std_obj::parseFloat(value);
HXDLIN(  68)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x3",bb,68,00,00)) ){
HXLINE(  72)			this->x3 = ::Std_obj::parseFloat(value);
HXDLIN(  72)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x4",bc,68,00,00)) ){
HXLINE(  76)			this->x4 = ::Std_obj::parseFloat(value);
HXDLIN(  76)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y1",98,69,00,00)) ){
HXLINE(  66)			this->y1 = ::Std_obj::parseFloat(value);
HXDLIN(  66)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y2",99,69,00,00)) ){
HXLINE(  70)			this->y2 = ::Std_obj::parseFloat(value);
HXDLIN(  70)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y3",9a,69,00,00)) ){
HXLINE(  74)			this->y3 = ::Std_obj::parseFloat(value);
HXDLIN(  74)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y4",9b,69,00,00)) ){
HXLINE(  78)			this->y4 = ::Std_obj::parseFloat(value);
HXDLIN(  78)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  80)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct QuadrilateralPattern_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_c0b857549da288e9_83_render)
HXLINE(  84)		Float a = this->x1;
HXDLIN(  84)		Float b = this->x2;
HXDLIN(  84)		Float c = this->x3;
HXDLIN(  84)		Float d = this->x4;
HXDLIN(  84)		int min = ::Math_obj::floor(a);
HXDLIN(  84)		int max = ::Math_obj::ceil(a);
HXDLIN(  84)		if ((b < min)) {
HXLINE(  31)			min = ::Math_obj::floor(b);
            		}
            		else {
HXLINE(  84)			if ((b > max)) {
HXLINE(  33)				max = ::Math_obj::ceil(b);
            			}
            		}
HXLINE(  84)		if ((c < min)) {
HXLINE(  36)			min = ::Math_obj::floor(c);
            		}
            		else {
HXLINE(  84)			if ((c > max)) {
HXLINE(  38)				max = ::Math_obj::ceil(c);
            			}
            		}
HXLINE(  84)		if ((d < min)) {
HXLINE(  41)			min = ::Math_obj::floor(d);
            		}
            		else {
HXLINE(  84)			if ((d > max)) {
HXLINE(  43)				max = ::Math_obj::ceil(d);
            			}
            		}
HXLINE(  84)		int ii_min = min;
HXDLIN(  84)		int ii_max = max;
HXDLIN(  84)		::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)		::pixelimage::iter::IntIterStart iterX = this1;
HXLINE(  85)		Float a1 = this->y1;
HXDLIN(  85)		Float b1 = this->y2;
HXDLIN(  85)		Float c1 = this->y3;
HXDLIN(  85)		Float d1 = this->y4;
HXDLIN(  85)		int min1 = ::Math_obj::floor(a1);
HXDLIN(  85)		int max1 = ::Math_obj::ceil(a1);
HXDLIN(  85)		if ((b1 < min1)) {
HXLINE(  31)			min1 = ::Math_obj::floor(b1);
            		}
            		else {
HXLINE(  85)			if ((b1 > max1)) {
HXLINE(  33)				max1 = ::Math_obj::ceil(b1);
            			}
            		}
HXLINE(  85)		if ((c1 < min1)) {
HXLINE(  36)			min1 = ::Math_obj::floor(c1);
            		}
            		else {
HXLINE(  85)			if ((c1 > max1)) {
HXLINE(  38)				max1 = ::Math_obj::ceil(c1);
            			}
            		}
HXLINE(  85)		if ((d1 < min1)) {
HXLINE(  41)			min1 = ::Math_obj::floor(d1);
            		}
            		else {
HXLINE(  85)			if ((d1 > max1)) {
HXLINE(  43)				max1 = ::Math_obj::ceil(d1);
            			}
            		}
HXLINE(  85)		int ii_min1 = min1;
HXDLIN(  85)		int ii_max1 = max1;
HXDLIN(  85)		::pixelimage::iter::IntIterStart this2 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
HXDLIN(  85)		::pixelimage::iter::IntIterStart iterY = this2;
HXLINE(  86)		int left = iterX->start;
HXLINE(  87)		int top = iterY->start;
HXLINE(  88)		int width = (iterX->max - left);
HXLINE(  89)		int height = (iterY->max - top);
HXLINE(  90)		int w = ::Math_obj::ceil(( (Float)(width) ));
HXDLIN(  90)		int h = ::Math_obj::ceil(( (Float)(height) ));
HXDLIN(  90)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  90)		::haxe::io::ArrayBufferViewImpl this3 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  90)		::haxe::io::ArrayBufferViewImpl this4 = this3;
HXDLIN(  90)		::pixelimage::ImageStruct this5 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this4);
HXDLIN(  90)		::pixelimage::ImageStruct this6 = this5;
HXDLIN(  90)		::pixelimage::ImageStruct temp = this6;
HXLINE(  91)		temp->transparent = false;
HXLINE(  93)		this->buildPatternTemplates();
HXLINE(  94)		Float rx = (( (Float)(width) ) / ( (Float)(2) ));
HXLINE(  95)		Float ry = (( (Float)(height) ) / ( (Float)(2) ));
HXLINE(  97)		Float x1_ = (this->x1 - ( (Float)(left) ));
HXLINE(  98)		Float x2_ = (this->x2 - ( (Float)(left) ));
HXLINE(  99)		Float x3_ = (this->x2 - ( (Float)(left) ));
HXLINE( 100)		Float x4_ = (this->x4 - ( (Float)(left) ));
HXLINE( 102)		Float y1_ = (this->y1 - ( (Float)(top) ));
HXLINE( 103)		Float y2_ = (this->y2 - ( (Float)(top) ));
HXLINE( 104)		Float y3_ = (this->y3 - ( (Float)(top) ));
HXLINE( 105)		Float y4_ = (this->y4 - ( (Float)(top) ));
HXLINE( 108)		{
HXLINE( 108)			::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN( 108)			bool hasHit = false;
HXDLIN( 108)			{
HXLINE( 108)				{
HXLINE( 108)					Float bx = x2_;
HXDLIN( 108)					Float by = y2_;
HXDLIN( 108)					Float cx = x4_;
HXDLIN( 108)					Float cy = y4_;
HXDLIN( 108)					bool adjustWinding = (((((x1_ * by) - (bx * y1_)) + ((bx * cy) - (cx * by))) + ((cx * y1_) - (x1_ * cy))) > 0);
HXDLIN( 108)					if (!(adjustWinding)) {
HXLINE( 108)						Float bx_ = bx;
HXDLIN( 108)						Float by_ = by;
HXLINE( 188)						bx = cx;
HXLINE( 189)						by = cy;
HXLINE( 190)						cx = bx_;
HXLINE( 191)						cy = by_;
            					}
HXLINE( 108)					{
HXLINE( 108)						bool hasUndo = false;
HXDLIN( 108)						Float s0 = ((y1_ * cx) - (x1_ * cy));
HXDLIN( 108)						Float sx = (cy - y1_);
HXDLIN( 108)						Float sy = (x1_ - cx);
HXDLIN( 108)						Float t0 = ((x1_ * by) - (y1_ * bx));
HXDLIN( 108)						Float tx = (y1_ - by);
HXDLIN( 108)						Float ty = (bx - x1_);
HXDLIN( 108)						Float A = ((((-(by) * cx) + (y1_ * (-(bx) + cx))) + (x1_ * (by - cy))) + (bx * cy));
HXDLIN( 108)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 108)						if ((x1_ > bx)) {
HXLINE( 108)							if ((x1_ > cx)) {
HXLINE( 108)								int min;
HXDLIN( 108)								if ((bx > cx)) {
HXLINE( 108)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE( 108)									min = ::Math_obj::floor(bx);
            								}
HXDLIN( 108)								int ii_min = min;
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(x1_);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								xIter3 = this1;
            							}
            							else {
HXLINE( 108)								int ii_min = ::Math_obj::floor(bx);
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE( 108)							if ((bx > cx)) {
HXLINE( 108)								int min;
HXDLIN( 108)								if ((x1_ > cx)) {
HXLINE( 108)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE( 108)									min = ::Math_obj::ceil(x1_);
            								}
HXDLIN( 108)								int ii_min = min;
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								xIter3 = this1;
            							}
            							else {
HXLINE( 108)								int ii_min = ::Math_obj::floor(x1_);
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								xIter3 = this1;
            							}
            						}
HXDLIN( 108)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 108)						if ((y1_ > by)) {
HXLINE( 108)							if ((y1_ > cy)) {
HXLINE( 108)								int min;
HXDLIN( 108)								if ((by > cy)) {
HXLINE( 108)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE( 108)									min = ::Math_obj::floor(by);
            								}
HXDLIN( 108)								int ii_min = min;
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(y1_);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								yIter3 = this1;
            							}
            							else {
HXLINE( 108)								int ii_min = ::Math_obj::floor(by);
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE( 108)							if ((by > cy)) {
HXLINE( 108)								int min;
HXDLIN( 108)								if ((y1_ > cy)) {
HXLINE( 108)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE( 108)									min = ::Math_obj::ceil(y1_);
            								}
HXDLIN( 108)								int ii_min = min;
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(by);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								yIter3 = this1;
            							}
            							else {
HXLINE( 108)								int ii_min = ::Math_obj::floor(y1_);
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								yIter3 = this1;
            							}
            						}
HXDLIN( 108)						::pixelimage::ImageStruct undoImage = null();
HXDLIN( 108)						if (hasUndo) {
HXLINE( 108)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 108)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 108)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 108)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 108)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 108)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 108)							undoImage = this3;
HXDLIN( 108)							{
HXLINE( 108)								int rectLeft = xIter3->start;
HXDLIN( 108)								int rectTop = yIter3->start;
HXDLIN( 108)								int rectRight = xIter3->max;
HXDLIN( 108)								bool forceClear = false;
HXDLIN( 108)								{
HXLINE( 108)									int _g = rectTop;
HXDLIN( 108)									int _g1 = yIter3->max;
HXDLIN( 108)									while((_g < _g1)){
HXLINE( 108)										_g = (_g + 1);
HXDLIN( 108)										int dy = (_g - 1);
HXDLIN( 108)										{
HXLINE( 108)											int _g1 = rectLeft;
HXDLIN( 108)											int _g2 = rectRight;
HXDLIN( 108)											while((_g1 < _g2)){
HXLINE( 108)												_g1 = (_g1 + 1);
HXDLIN( 108)												int dx = (_g1 - 1);
HXDLIN( 108)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 108)												int index;
HXDLIN( 108)												if (temp->useVirtualPos) {
HXLINE( 108)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE( 108)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN( 108)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)												int col;
HXDLIN( 108)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 108)													col = c;
            												}
HXDLIN( 108)												bool _hx_tmp;
HXDLIN( 108)												if (temp->useMask) {
HXLINE( 108)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE( 108)													_hx_tmp = false;
            												}
HXDLIN( 108)												if (_hx_tmp) {
HXLINE( 108)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 108)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 108)													int index;
HXDLIN( 108)													if (this1->useVirtualPos) {
HXLINE( 108)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 108)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 108)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 108)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 108)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)													int v;
HXDLIN( 108)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 108)														v = c;
            													}
HXDLIN( 108)													int this3 = v;
HXDLIN( 108)													int maskPixel = this3;
HXDLIN( 108)													int this4 = col;
HXDLIN( 108)													int this5 = this4;
HXDLIN( 108)													if ((maskPixel == 0)) {
HXLINE( 108)														int this1 = this5;
HXDLIN( 108)														col = this1;
            													}
            													else {
HXLINE( 108)														Float m0;
HXDLIN( 108)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 108)														if ((this1 == 0)) {
HXLINE( 108)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float m1;
HXDLIN( 108)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 108)														if ((this2 == 0)) {
HXLINE( 108)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float m2;
HXDLIN( 108)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 108)														if ((this3 == 0)) {
HXLINE( 108)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float m3;
HXDLIN( 108)														int this4 = (maskPixel & 255);
HXDLIN( 108)														if ((this4 == 0)) {
HXLINE( 108)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 108)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 108)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 108)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 108)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 108)												if ((col != 0)) {
HXLINE( 108)													int x = (dx - rectLeft);
HXDLIN( 108)													int y = (dy - rectTop);
HXDLIN( 108)													int this1 = col;
HXDLIN( 108)													int c = this1;
HXDLIN( 108)													bool _hx_tmp;
HXDLIN( 108)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 108)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE( 108)														_hx_tmp = false;
            													}
HXDLIN( 108)													if (_hx_tmp) {
HXLINE( 108)														int location;
HXDLIN( 108)														if (undoImage->useVirtualPos) {
HXLINE( 108)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 108)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 108)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 108)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 108)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)														int this3 = this2;
HXDLIN( 108)														int this4;
HXDLIN( 108)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 108)															this4 = this3;
            														}
HXDLIN( 108)														Float a1;
HXDLIN( 108)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 108)														if ((this5 == 0)) {
HXLINE( 108)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float r1;
HXDLIN( 108)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 108)														if ((this6 == 0)) {
HXLINE( 108)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float g1;
HXDLIN( 108)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 108)														if ((this7 == 0)) {
HXLINE( 108)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float b1;
HXDLIN( 108)														int this8 = (this4 & 255);
HXDLIN( 108)														if ((this8 == 0)) {
HXLINE( 108)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float a2;
HXDLIN( 108)														int this9 = ((col >> 24) & 255);
HXDLIN( 108)														if ((this9 == 0)) {
HXLINE( 108)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float r2;
HXDLIN( 108)														int this10 = ((col >> 16) & 255);
HXDLIN( 108)														if ((this10 == 0)) {
HXLINE( 108)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float g2;
HXDLIN( 108)														int this11 = ((col >> 8) & 255);
HXDLIN( 108)														if ((this11 == 0)) {
HXLINE( 108)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float b2;
HXDLIN( 108)														int this12 = (col & 255);
HXDLIN( 108)														if ((this12 == 0)) {
HXLINE( 108)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 108)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 108)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 108)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 108)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 108)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 108)														{
HXLINE( 108)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 108)															int value;
HXDLIN( 108)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 108)																value = blended;
            															}
HXDLIN( 108)															bool _hx_tmp;
HXDLIN( 108)															if ((location >= 0)) {
HXLINE( 108)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 108)																_hx_tmp = false;
            															}
HXDLIN( 108)															if (_hx_tmp) {
HXLINE( 108)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 108)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 108)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 108)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 108)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 108)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 108)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 108)														int index;
HXDLIN( 108)														if (undoImage->useVirtualPos) {
HXLINE( 108)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 108)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 108)														int value;
HXDLIN( 108)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 108)															value = c;
            														}
HXDLIN( 108)														bool _hx_tmp;
HXDLIN( 108)														if ((index >= 0)) {
HXLINE( 108)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 108)															_hx_tmp = false;
            														}
HXDLIN( 108)														if (_hx_tmp) {
HXLINE( 108)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 108)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 108)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 108)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 108)													if (forceClear) {
HXLINE( 108)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 108)														int x = (dx - rectLeft);
HXDLIN( 108)														int y = (dy - rectTop);
HXDLIN( 108)														int index;
HXDLIN( 108)														if (undoImage->useVirtualPos) {
HXLINE( 108)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 108)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 108)														bool _hx_tmp;
HXDLIN( 108)														if ((index >= 0)) {
HXLINE( 108)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 108)															_hx_tmp = false;
            														}
HXDLIN( 108)														if (_hx_tmp) {
HXLINE( 108)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 108)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 108)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 108)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 108)						bool foundY = false;
HXDLIN( 108)						Float s = ((Float)0.);
HXDLIN( 108)						Float t = ((Float)0.);
HXDLIN( 108)						Float sxx = ((Float)0.);
HXDLIN( 108)						Float txx = ((Float)0.);
HXDLIN( 108)						{
HXLINE( 108)							int _g_min = xIter3->start;
HXDLIN( 108)							int _g_max = xIter3->max;
HXDLIN( 108)							while((_g_min < _g_max)){
HXLINE( 108)								_g_min = (_g_min + 1);
HXDLIN( 108)								int x = (_g_min - 1);
HXLINE( 223)								sxx = (sx * ( (Float)(x) ));
HXLINE( 224)								txx = (tx * ( (Float)(x) ));
HXLINE( 225)								foundY = false;
HXLINE( 108)								{
HXLINE( 108)									int _g_min1 = yIter3->start;
HXDLIN( 108)									int _g_max = yIter3->max;
HXDLIN( 108)									while((_g_min1 < _g_max)){
HXLINE( 108)										_g_min1 = (_g_min1 + 1);
HXDLIN( 108)										int y = (_g_min1 - 1);
HXLINE( 227)										s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)										t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 108)										bool _hx_tmp;
HXDLIN( 108)										if (!((s <= 0))) {
HXLINE( 108)											_hx_tmp = (t <= 0);
            										}
            										else {
HXLINE( 108)											_hx_tmp = true;
            										}
HXDLIN( 108)										if (_hx_tmp) {
HXLINE( 108)											if (foundY) {
HXLINE( 108)												goto _hx_goto_6;
            											}
            										}
            										else {
HXLINE( 108)											if (((s + t) < A)) {
HXLINE( 108)												int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN( 108)												int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN( 108)												::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN( 108)												int index;
HXDLIN( 108)												if (tileImage->useVirtualPos) {
HXLINE( 108)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            												}
            												else {
HXLINE( 108)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            												}
HXDLIN( 108)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)												int color;
HXDLIN( 108)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 108)													color = c;
            												}
HXDLIN( 108)												{
HXLINE( 108)													int this2 = color;
HXDLIN( 108)													int c1 = this2;
HXDLIN( 108)													bool _hx_tmp;
HXDLIN( 108)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 108)														_hx_tmp = temp->transparent;
            													}
            													else {
HXLINE( 108)														_hx_tmp = false;
            													}
HXDLIN( 108)													if (_hx_tmp) {
HXLINE( 108)														int location;
HXDLIN( 108)														if (temp->useVirtualPos) {
HXLINE( 108)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 108)															location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 108)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 108)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 108)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)														int this3 = this2;
HXDLIN( 108)														int this4;
HXDLIN( 108)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 108)															this4 = this3;
            														}
HXDLIN( 108)														Float a1;
HXDLIN( 108)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 108)														if ((this5 == 0)) {
HXLINE( 108)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float r1;
HXDLIN( 108)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 108)														if ((this6 == 0)) {
HXLINE( 108)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float g1;
HXDLIN( 108)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 108)														if ((this7 == 0)) {
HXLINE( 108)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float b1;
HXDLIN( 108)														int this8 = (this4 & 255);
HXDLIN( 108)														if ((this8 == 0)) {
HXLINE( 108)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float a2;
HXDLIN( 108)														int this9 = ((color >> 24) & 255);
HXDLIN( 108)														if ((this9 == 0)) {
HXLINE( 108)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float r2;
HXDLIN( 108)														int this10 = ((color >> 16) & 255);
HXDLIN( 108)														if ((this10 == 0)) {
HXLINE( 108)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float g2;
HXDLIN( 108)														int this11 = ((color >> 8) & 255);
HXDLIN( 108)														if ((this11 == 0)) {
HXLINE( 108)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float b2;
HXDLIN( 108)														int this12 = (color & 255);
HXDLIN( 108)														if ((this12 == 0)) {
HXLINE( 108)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 108)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 108)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 108)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 108)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 108)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 108)														{
HXLINE( 108)															::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 108)															int value;
HXDLIN( 108)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 108)																value = blended;
            															}
HXDLIN( 108)															bool _hx_tmp;
HXDLIN( 108)															if ((location >= 0)) {
HXLINE( 108)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 108)																_hx_tmp = false;
            															}
HXDLIN( 108)															if (_hx_tmp) {
HXLINE( 108)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 108)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 108)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 108)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 108)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 108)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 108)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 108)														int index;
HXDLIN( 108)														if (temp->useVirtualPos) {
HXLINE( 108)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 108)															index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 108)														int value;
HXDLIN( 108)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE( 108)															value = c1;
            														}
HXDLIN( 108)														bool _hx_tmp;
HXDLIN( 108)														if ((index >= 0)) {
HXLINE( 108)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 108)															_hx_tmp = false;
            														}
HXDLIN( 108)														if (_hx_tmp) {
HXLINE( 108)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 108)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 108)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 108)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY = true;
            											}
            											else {
HXLINE( 108)												if (foundY) {
HXLINE( 108)													goto _hx_goto_6;
            												}
            											}
            										}
            									}
            									_hx_goto_6:;
            								}
            							}
            						}
HXDLIN( 108)						if ((hasHit == false)) {
HXLINE( 108)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x1_,y1_,bx,by,cx,cy,true);
HXDLIN( 108)							if (hasUndo) {
HXLINE( 108)								v->undoImage = undoImage;
HXDLIN( 108)								v->undoX = xIter3->start;
HXDLIN( 108)								v->undoY = yIter3->start;
            							}
            						}
            					}
            				}
HXDLIN( 108)				{
HXLINE( 108)					Float bx1 = x3_;
HXDLIN( 108)					Float by1 = y3_;
HXDLIN( 108)					Float cx1 = x4_;
HXDLIN( 108)					Float cy1 = y4_;
HXDLIN( 108)					bool adjustWinding1 = (((((x2_ * by1) - (bx1 * y2_)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * y2_) - (x2_ * cy1))) > 0);
HXDLIN( 108)					if (!(adjustWinding1)) {
HXLINE( 108)						Float bx_ = bx1;
HXDLIN( 108)						Float by_ = by1;
HXLINE( 188)						bx1 = cx1;
HXLINE( 189)						by1 = cy1;
HXLINE( 190)						cx1 = bx_;
HXLINE( 191)						cy1 = by_;
            					}
HXLINE( 108)					{
HXLINE( 108)						bool hasUndo1 = false;
HXDLIN( 108)						Float s01 = ((y2_ * cx1) - (x2_ * cy1));
HXDLIN( 108)						Float sx1 = (cy1 - y2_);
HXDLIN( 108)						Float sy1 = (x2_ - cx1);
HXDLIN( 108)						Float t01 = ((x2_ * by1) - (y2_ * bx1));
HXDLIN( 108)						Float tx1 = (y2_ - by1);
HXDLIN( 108)						Float ty1 = (bx1 - x2_);
HXDLIN( 108)						Float A1 = ((((-(by1) * cx1) + (y2_ * (-(bx1) + cx1))) + (x2_ * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 108)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 108)						if ((x2_ > bx1)) {
HXLINE( 108)							if ((x2_ > cx1)) {
HXLINE( 108)								int min;
HXDLIN( 108)								if ((bx1 > cx1)) {
HXLINE( 108)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE( 108)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN( 108)								int ii_min = min;
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(x2_);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								xIter31 = this1;
            							}
            							else {
HXLINE( 108)								int ii_min = ::Math_obj::floor(bx1);
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE( 108)							if ((bx1 > cx1)) {
HXLINE( 108)								int min;
HXDLIN( 108)								if ((x2_ > cx1)) {
HXLINE( 108)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE( 108)									min = ::Math_obj::ceil(x2_);
            								}
HXDLIN( 108)								int ii_min = min;
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(bx1);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								xIter31 = this1;
            							}
            							else {
HXLINE( 108)								int ii_min = ::Math_obj::floor(x2_);
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								xIter31 = this1;
            							}
            						}
HXDLIN( 108)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 108)						if ((y2_ > by1)) {
HXLINE( 108)							if ((y2_ > cy1)) {
HXLINE( 108)								int min;
HXDLIN( 108)								if ((by1 > cy1)) {
HXLINE( 108)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE( 108)									min = ::Math_obj::floor(by1);
            								}
HXDLIN( 108)								int ii_min = min;
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(y2_);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								yIter31 = this1;
            							}
            							else {
HXLINE( 108)								int ii_min = ::Math_obj::floor(by1);
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE( 108)							if ((by1 > cy1)) {
HXLINE( 108)								int min;
HXDLIN( 108)								if ((y2_ > cy1)) {
HXLINE( 108)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE( 108)									min = ::Math_obj::ceil(y2_);
            								}
HXDLIN( 108)								int ii_min = min;
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(by1);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								yIter31 = this1;
            							}
            							else {
HXLINE( 108)								int ii_min = ::Math_obj::floor(y2_);
HXDLIN( 108)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 108)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 108)								yIter31 = this1;
            							}
            						}
HXDLIN( 108)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 108)						if (hasUndo1) {
HXLINE( 108)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 108)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 108)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 108)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 108)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 108)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 108)							undoImage1 = this3;
HXDLIN( 108)							{
HXLINE( 108)								int rectLeft = xIter31->start;
HXDLIN( 108)								int rectTop = yIter31->start;
HXDLIN( 108)								int rectRight = xIter31->max;
HXDLIN( 108)								bool forceClear = false;
HXDLIN( 108)								{
HXLINE( 108)									int _g = rectTop;
HXDLIN( 108)									int _g1 = yIter31->max;
HXDLIN( 108)									while((_g < _g1)){
HXLINE( 108)										_g = (_g + 1);
HXDLIN( 108)										int dy = (_g - 1);
HXDLIN( 108)										{
HXLINE( 108)											int _g1 = rectLeft;
HXDLIN( 108)											int _g2 = rectRight;
HXDLIN( 108)											while((_g1 < _g2)){
HXLINE( 108)												_g1 = (_g1 + 1);
HXDLIN( 108)												int dx = (_g1 - 1);
HXDLIN( 108)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 108)												int index;
HXDLIN( 108)												if (temp->useVirtualPos) {
HXLINE( 108)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE( 108)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN( 108)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)												int col;
HXDLIN( 108)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 108)													col = c;
            												}
HXDLIN( 108)												bool _hx_tmp;
HXDLIN( 108)												if (temp->useMask) {
HXLINE( 108)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE( 108)													_hx_tmp = false;
            												}
HXDLIN( 108)												if (_hx_tmp) {
HXLINE( 108)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 108)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 108)													int index;
HXDLIN( 108)													if (this1->useVirtualPos) {
HXLINE( 108)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 108)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 108)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 108)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 108)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)													int v;
HXDLIN( 108)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 108)														v = c;
            													}
HXDLIN( 108)													int this3 = v;
HXDLIN( 108)													int maskPixel = this3;
HXDLIN( 108)													int this4 = col;
HXDLIN( 108)													int this5 = this4;
HXDLIN( 108)													if ((maskPixel == 0)) {
HXLINE( 108)														int this1 = this5;
HXDLIN( 108)														col = this1;
            													}
            													else {
HXLINE( 108)														Float m0;
HXDLIN( 108)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 108)														if ((this1 == 0)) {
HXLINE( 108)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float m1;
HXDLIN( 108)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 108)														if ((this2 == 0)) {
HXLINE( 108)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float m2;
HXDLIN( 108)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 108)														if ((this3 == 0)) {
HXLINE( 108)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float m3;
HXDLIN( 108)														int this4 = (maskPixel & 255);
HXDLIN( 108)														if ((this4 == 0)) {
HXLINE( 108)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 108)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 108)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 108)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 108)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 108)												if ((col != 0)) {
HXLINE( 108)													int x = (dx - rectLeft);
HXDLIN( 108)													int y = (dy - rectTop);
HXDLIN( 108)													int this1 = col;
HXDLIN( 108)													int c = this1;
HXDLIN( 108)													bool _hx_tmp;
HXDLIN( 108)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 108)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE( 108)														_hx_tmp = false;
            													}
HXDLIN( 108)													if (_hx_tmp) {
HXLINE( 108)														int location;
HXDLIN( 108)														if (undoImage1->useVirtualPos) {
HXLINE( 108)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 108)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 108)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 108)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 108)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)														int this3 = this2;
HXDLIN( 108)														int this4;
HXDLIN( 108)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 108)															this4 = this3;
            														}
HXDLIN( 108)														Float a1;
HXDLIN( 108)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 108)														if ((this5 == 0)) {
HXLINE( 108)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float r1;
HXDLIN( 108)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 108)														if ((this6 == 0)) {
HXLINE( 108)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float g1;
HXDLIN( 108)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 108)														if ((this7 == 0)) {
HXLINE( 108)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float b1;
HXDLIN( 108)														int this8 = (this4 & 255);
HXDLIN( 108)														if ((this8 == 0)) {
HXLINE( 108)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float a2;
HXDLIN( 108)														int this9 = ((col >> 24) & 255);
HXDLIN( 108)														if ((this9 == 0)) {
HXLINE( 108)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float r2;
HXDLIN( 108)														int this10 = ((col >> 16) & 255);
HXDLIN( 108)														if ((this10 == 0)) {
HXLINE( 108)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float g2;
HXDLIN( 108)														int this11 = ((col >> 8) & 255);
HXDLIN( 108)														if ((this11 == 0)) {
HXLINE( 108)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float b2;
HXDLIN( 108)														int this12 = (col & 255);
HXDLIN( 108)														if ((this12 == 0)) {
HXLINE( 108)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 108)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 108)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 108)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 108)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 108)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 108)														{
HXLINE( 108)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 108)															int value;
HXDLIN( 108)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 108)																value = blended;
            															}
HXDLIN( 108)															bool _hx_tmp;
HXDLIN( 108)															if ((location >= 0)) {
HXLINE( 108)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 108)																_hx_tmp = false;
            															}
HXDLIN( 108)															if (_hx_tmp) {
HXLINE( 108)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 108)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 108)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 108)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 108)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 108)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 108)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 108)														int index;
HXDLIN( 108)														if (undoImage1->useVirtualPos) {
HXLINE( 108)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 108)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 108)														int value;
HXDLIN( 108)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 108)															value = c;
            														}
HXDLIN( 108)														bool _hx_tmp;
HXDLIN( 108)														if ((index >= 0)) {
HXLINE( 108)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 108)															_hx_tmp = false;
            														}
HXDLIN( 108)														if (_hx_tmp) {
HXLINE( 108)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 108)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 108)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 108)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 108)													if (forceClear) {
HXLINE( 108)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 108)														int x = (dx - rectLeft);
HXDLIN( 108)														int y = (dy - rectTop);
HXDLIN( 108)														int index;
HXDLIN( 108)														if (undoImage1->useVirtualPos) {
HXLINE( 108)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 108)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 108)														bool _hx_tmp;
HXDLIN( 108)														if ((index >= 0)) {
HXLINE( 108)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 108)															_hx_tmp = false;
            														}
HXDLIN( 108)														if (_hx_tmp) {
HXLINE( 108)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 108)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 108)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 108)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 108)						bool foundY1 = false;
HXDLIN( 108)						Float s1 = ((Float)0.);
HXDLIN( 108)						Float t1 = ((Float)0.);
HXDLIN( 108)						Float sxx1 = ((Float)0.);
HXDLIN( 108)						Float txx1 = ((Float)0.);
HXDLIN( 108)						{
HXLINE( 108)							int _g_min1 = xIter31->start;
HXDLIN( 108)							int _g_max1 = xIter31->max;
HXDLIN( 108)							while((_g_min1 < _g_max1)){
HXLINE( 108)								_g_min1 = (_g_min1 + 1);
HXDLIN( 108)								int x = (_g_min1 - 1);
HXLINE( 223)								sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)								txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)								foundY1 = false;
HXLINE( 108)								{
HXLINE( 108)									int _g_min = yIter31->start;
HXDLIN( 108)									int _g_max = yIter31->max;
HXDLIN( 108)									while((_g_min < _g_max)){
HXLINE( 108)										_g_min = (_g_min + 1);
HXDLIN( 108)										int y = (_g_min - 1);
HXLINE( 227)										s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)										t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE( 108)										bool _hx_tmp;
HXDLIN( 108)										if (!((s1 <= 0))) {
HXLINE( 108)											_hx_tmp = (t1 <= 0);
            										}
            										else {
HXLINE( 108)											_hx_tmp = true;
            										}
HXDLIN( 108)										if (_hx_tmp) {
HXLINE( 108)											if (foundY1) {
HXLINE( 108)												goto _hx_goto_10;
            											}
            										}
            										else {
HXLINE( 108)											if (((s1 + t1) < A1)) {
HXLINE( 108)												int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN( 108)												int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN( 108)												::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN( 108)												int index;
HXDLIN( 108)												if (tileImage->useVirtualPos) {
HXLINE( 108)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            												}
            												else {
HXLINE( 108)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            												}
HXDLIN( 108)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)												int color;
HXDLIN( 108)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 108)													color = c;
            												}
HXDLIN( 108)												{
HXLINE( 108)													int this2 = color;
HXDLIN( 108)													int c1 = this2;
HXDLIN( 108)													bool _hx_tmp;
HXDLIN( 108)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 108)														_hx_tmp = temp->transparent;
            													}
            													else {
HXLINE( 108)														_hx_tmp = false;
            													}
HXDLIN( 108)													if (_hx_tmp) {
HXLINE( 108)														int location;
HXDLIN( 108)														if (temp->useVirtualPos) {
HXLINE( 108)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 108)															location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 108)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 108)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 108)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 108)														int this3 = this2;
HXDLIN( 108)														int this4;
HXDLIN( 108)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 108)															this4 = this3;
            														}
HXDLIN( 108)														Float a1;
HXDLIN( 108)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 108)														if ((this5 == 0)) {
HXLINE( 108)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float r1;
HXDLIN( 108)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 108)														if ((this6 == 0)) {
HXLINE( 108)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float g1;
HXDLIN( 108)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 108)														if ((this7 == 0)) {
HXLINE( 108)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float b1;
HXDLIN( 108)														int this8 = (this4 & 255);
HXDLIN( 108)														if ((this8 == 0)) {
HXLINE( 108)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float a2;
HXDLIN( 108)														int this9 = ((color >> 24) & 255);
HXDLIN( 108)														if ((this9 == 0)) {
HXLINE( 108)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float r2;
HXDLIN( 108)														int this10 = ((color >> 16) & 255);
HXDLIN( 108)														if ((this10 == 0)) {
HXLINE( 108)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float g2;
HXDLIN( 108)														int this11 = ((color >> 8) & 255);
HXDLIN( 108)														if ((this11 == 0)) {
HXLINE( 108)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float b2;
HXDLIN( 108)														int this12 = (color & 255);
HXDLIN( 108)														if ((this12 == 0)) {
HXLINE( 108)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 108)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 108)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 108)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 108)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 108)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 108)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 108)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 108)														{
HXLINE( 108)															::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 108)															int value;
HXDLIN( 108)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 108)																value = blended;
            															}
HXDLIN( 108)															bool _hx_tmp;
HXDLIN( 108)															if ((location >= 0)) {
HXLINE( 108)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 108)																_hx_tmp = false;
            															}
HXDLIN( 108)															if (_hx_tmp) {
HXLINE( 108)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 108)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 108)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 108)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 108)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 108)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 108)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 108)														int index;
HXDLIN( 108)														if (temp->useVirtualPos) {
HXLINE( 108)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 108)															index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 108)														int value;
HXDLIN( 108)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 108)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE( 108)															value = c1;
            														}
HXDLIN( 108)														bool _hx_tmp;
HXDLIN( 108)														if ((index >= 0)) {
HXLINE( 108)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 108)															_hx_tmp = false;
            														}
HXDLIN( 108)														if (_hx_tmp) {
HXLINE( 108)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 108)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 108)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 108)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 108)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 108)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY1 = true;
            											}
            											else {
HXLINE( 108)												if (foundY1) {
HXLINE( 108)													goto _hx_goto_10;
            												}
            											}
            										}
            									}
            									_hx_goto_10:;
            								}
            							}
            						}
HXDLIN( 108)						if ((hasHit == false)) {
HXLINE( 108)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x2_,y2_,bx1,by1,cx1,cy1,true);
HXDLIN( 108)							if (hasUndo1) {
HXLINE( 108)								v->undoImage = undoImage1;
HXDLIN( 108)								v->undoX = xIter31->start;
HXDLIN( 108)								v->undoY = yIter31->start;
            							}
            						}
            					}
            				}
HXDLIN( 108)				if ((hasHit == true)) {
HXLINE( 108)					::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x1_,y1_,x2_,y2_,x3_,y3_,x4_,y4_,true);
            				}
            			}
            		}
HXLINE( 110)		x1_ = (x1_ + this->strokeWidth);
HXLINE( 111)		x2_ = (x2_ + this->strokeWidth);
HXLINE( 112)		x3_ = (x3_ + this->strokeWidth);
HXLINE( 113)		x4_ = (x4_ + this->strokeWidth);
HXLINE( 115)		y1_ = (y1_ + this->strokeWidth);
HXLINE( 116)		y2_ = (y2_ + this->strokeWidth);
HXLINE( 117)		y3_ = (y3_ + this->strokeWidth);
HXLINE( 118)		y4_ = (y4_ + this->strokeWidth);
HXLINE( 121)		{
HXLINE( 121)			::pixelimage::ImageStruct tileImage1 = this->tileImageFill;
HXDLIN( 121)			bool hasHit1 = false;
HXDLIN( 121)			{
HXLINE( 121)				{
HXLINE( 121)					Float bx2 = x2_;
HXDLIN( 121)					Float by2 = y2_;
HXDLIN( 121)					Float cx2 = x4_;
HXDLIN( 121)					Float cy2 = y4_;
HXDLIN( 121)					bool adjustWinding2 = (((((x1_ * by2) - (bx2 * y1_)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * y1_) - (x1_ * cy2))) > 0);
HXDLIN( 121)					if (!(adjustWinding2)) {
HXLINE( 121)						Float bx_ = bx2;
HXDLIN( 121)						Float by_ = by2;
HXLINE( 188)						bx2 = cx2;
HXLINE( 189)						by2 = cy2;
HXLINE( 190)						cx2 = bx_;
HXLINE( 191)						cy2 = by_;
            					}
HXLINE( 121)					{
HXLINE( 121)						bool hasUndo2 = false;
HXDLIN( 121)						Float s02 = ((y1_ * cx2) - (x1_ * cy2));
HXDLIN( 121)						Float sx2 = (cy2 - y1_);
HXDLIN( 121)						Float sy2 = (x1_ - cx2);
HXDLIN( 121)						Float t02 = ((x1_ * by2) - (y1_ * bx2));
HXDLIN( 121)						Float tx2 = (y1_ - by2);
HXDLIN( 121)						Float ty2 = (bx2 - x1_);
HXDLIN( 121)						Float A2 = ((((-(by2) * cx2) + (y1_ * (-(bx2) + cx2))) + (x1_ * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 121)						::pixelimage::iter::IntIterStart xIter32;
HXDLIN( 121)						if ((x1_ > bx2)) {
HXLINE( 121)							if ((x1_ > cx2)) {
HXLINE( 121)								int min;
HXDLIN( 121)								if ((bx2 > cx2)) {
HXLINE( 121)									min = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE( 121)									min = ::Math_obj::floor(bx2);
            								}
HXDLIN( 121)								int ii_min = min;
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(x1_);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								xIter32 = this1;
            							}
            							else {
HXLINE( 121)								int ii_min = ::Math_obj::floor(bx2);
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								xIter32 = this1;
            							}
            						}
            						else {
HXLINE( 121)							if ((bx2 > cx2)) {
HXLINE( 121)								int min;
HXDLIN( 121)								if ((x1_ > cx2)) {
HXLINE( 121)									min = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE( 121)									min = ::Math_obj::ceil(x1_);
            								}
HXDLIN( 121)								int ii_min = min;
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(bx2);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								xIter32 = this1;
            							}
            							else {
HXLINE( 121)								int ii_min = ::Math_obj::floor(x1_);
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								xIter32 = this1;
            							}
            						}
HXDLIN( 121)						::pixelimage::iter::IntIterStart yIter32;
HXDLIN( 121)						if ((y1_ > by2)) {
HXLINE( 121)							if ((y1_ > cy2)) {
HXLINE( 121)								int min;
HXDLIN( 121)								if ((by2 > cy2)) {
HXLINE( 121)									min = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE( 121)									min = ::Math_obj::floor(by2);
            								}
HXDLIN( 121)								int ii_min = min;
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(y1_);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								yIter32 = this1;
            							}
            							else {
HXLINE( 121)								int ii_min = ::Math_obj::floor(by2);
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								yIter32 = this1;
            							}
            						}
            						else {
HXLINE( 121)							if ((by2 > cy2)) {
HXLINE( 121)								int min;
HXDLIN( 121)								if ((y1_ > cy2)) {
HXLINE( 121)									min = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE( 121)									min = ::Math_obj::ceil(y1_);
            								}
HXDLIN( 121)								int ii_min = min;
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(by2);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								yIter32 = this1;
            							}
            							else {
HXLINE( 121)								int ii_min = ::Math_obj::floor(y1_);
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								yIter32 = this1;
            							}
            						}
HXDLIN( 121)						::pixelimage::ImageStruct undoImage2 = null();
HXDLIN( 121)						if (hasUndo2) {
HXLINE( 121)							int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 121)							int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 121)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 121)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 121)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 121)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 121)							undoImage2 = this3;
HXDLIN( 121)							{
HXLINE( 121)								int rectLeft = xIter32->start;
HXDLIN( 121)								int rectTop = yIter32->start;
HXDLIN( 121)								int rectRight = xIter32->max;
HXDLIN( 121)								bool forceClear = false;
HXDLIN( 121)								{
HXLINE( 121)									int _g = rectTop;
HXDLIN( 121)									int _g1 = yIter32->max;
HXDLIN( 121)									while((_g < _g1)){
HXLINE( 121)										_g = (_g + 1);
HXDLIN( 121)										int dy = (_g - 1);
HXDLIN( 121)										{
HXLINE( 121)											int _g1 = rectLeft;
HXDLIN( 121)											int _g2 = rectRight;
HXDLIN( 121)											while((_g1 < _g2)){
HXLINE( 121)												_g1 = (_g1 + 1);
HXDLIN( 121)												int dx = (_g1 - 1);
HXDLIN( 121)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)												int index;
HXDLIN( 121)												if (temp->useVirtualPos) {
HXLINE( 121)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE( 121)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN( 121)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)												int col;
HXDLIN( 121)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 121)													col = c;
            												}
HXDLIN( 121)												bool _hx_tmp;
HXDLIN( 121)												if (temp->useMask) {
HXLINE( 121)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE( 121)													_hx_tmp = false;
            												}
HXDLIN( 121)												if (_hx_tmp) {
HXLINE( 121)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 121)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 121)													int index;
HXDLIN( 121)													if (this1->useVirtualPos) {
HXLINE( 121)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 121)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 121)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 121)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 121)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)													int v;
HXDLIN( 121)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 121)														v = c;
            													}
HXDLIN( 121)													int this3 = v;
HXDLIN( 121)													int maskPixel = this3;
HXDLIN( 121)													int this4 = col;
HXDLIN( 121)													int this5 = this4;
HXDLIN( 121)													if ((maskPixel == 0)) {
HXLINE( 121)														int this1 = this5;
HXDLIN( 121)														col = this1;
            													}
            													else {
HXLINE( 121)														Float m0;
HXDLIN( 121)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 121)														if ((this1 == 0)) {
HXLINE( 121)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float m1;
HXDLIN( 121)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 121)														if ((this2 == 0)) {
HXLINE( 121)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float m2;
HXDLIN( 121)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 121)														if ((this3 == 0)) {
HXLINE( 121)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float m3;
HXDLIN( 121)														int this4 = (maskPixel & 255);
HXDLIN( 121)														if ((this4 == 0)) {
HXLINE( 121)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 121)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 121)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 121)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 121)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 121)												if ((col != 0)) {
HXLINE( 121)													int x = (dx - rectLeft);
HXDLIN( 121)													int y = (dy - rectTop);
HXDLIN( 121)													int this1 = col;
HXDLIN( 121)													int c = this1;
HXDLIN( 121)													bool _hx_tmp;
HXDLIN( 121)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 121)														_hx_tmp = undoImage2->transparent;
            													}
            													else {
HXLINE( 121)														_hx_tmp = false;
            													}
HXDLIN( 121)													if (_hx_tmp) {
HXLINE( 121)														int location;
HXDLIN( 121)														if (undoImage2->useVirtualPos) {
HXLINE( 121)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 121)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 121)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 121)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)														int this3 = this2;
HXDLIN( 121)														int this4;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 121)															this4 = this3;
            														}
HXDLIN( 121)														Float a1;
HXDLIN( 121)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)														if ((this5 == 0)) {
HXLINE( 121)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float r1;
HXDLIN( 121)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)														if ((this6 == 0)) {
HXLINE( 121)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float g1;
HXDLIN( 121)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)														if ((this7 == 0)) {
HXLINE( 121)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float b1;
HXDLIN( 121)														int this8 = (this4 & 255);
HXDLIN( 121)														if ((this8 == 0)) {
HXLINE( 121)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float a2;
HXDLIN( 121)														int this9 = ((col >> 24) & 255);
HXDLIN( 121)														if ((this9 == 0)) {
HXLINE( 121)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float r2;
HXDLIN( 121)														int this10 = ((col >> 16) & 255);
HXDLIN( 121)														if ((this10 == 0)) {
HXLINE( 121)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float g2;
HXDLIN( 121)														int this11 = ((col >> 8) & 255);
HXDLIN( 121)														if ((this11 == 0)) {
HXLINE( 121)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float b2;
HXDLIN( 121)														int this12 = (col & 255);
HXDLIN( 121)														if ((this12 == 0)) {
HXLINE( 121)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)														{
HXLINE( 121)															::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN( 121)															int value;
HXDLIN( 121)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 121)																value = blended;
            															}
HXDLIN( 121)															bool _hx_tmp;
HXDLIN( 121)															if ((location >= 0)) {
HXLINE( 121)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 121)																_hx_tmp = false;
            															}
HXDLIN( 121)															if (_hx_tmp) {
HXLINE( 121)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 121)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 121)														int index;
HXDLIN( 121)														if (undoImage2->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 121)														int value;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 121)															value = c;
            														}
HXDLIN( 121)														bool _hx_tmp;
HXDLIN( 121)														if ((index >= 0)) {
HXLINE( 121)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 121)															_hx_tmp = false;
            														}
HXDLIN( 121)														if (_hx_tmp) {
HXLINE( 121)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 121)													if (forceClear) {
HXLINE( 121)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 121)														int x = (dx - rectLeft);
HXDLIN( 121)														int y = (dy - rectTop);
HXDLIN( 121)														int index;
HXDLIN( 121)														if (undoImage2->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 121)														bool _hx_tmp;
HXDLIN( 121)														if ((index >= 0)) {
HXLINE( 121)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 121)															_hx_tmp = false;
            														}
HXDLIN( 121)														if (_hx_tmp) {
HXLINE( 121)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 121)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 121)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 121)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 121)						bool foundY2 = false;
HXDLIN( 121)						Float s2 = ((Float)0.);
HXDLIN( 121)						Float t2 = ((Float)0.);
HXDLIN( 121)						Float sxx2 = ((Float)0.);
HXDLIN( 121)						Float txx2 = ((Float)0.);
HXDLIN( 121)						{
HXLINE( 121)							int _g_min2 = xIter32->start;
HXDLIN( 121)							int _g_max2 = xIter32->max;
HXDLIN( 121)							while((_g_min2 < _g_max2)){
HXLINE( 121)								_g_min2 = (_g_min2 + 1);
HXDLIN( 121)								int x = (_g_min2 - 1);
HXLINE( 223)								sxx2 = (sx2 * ( (Float)(x) ));
HXLINE( 224)								txx2 = (tx2 * ( (Float)(x) ));
HXLINE( 225)								foundY2 = false;
HXLINE( 121)								{
HXLINE( 121)									int _g_min = yIter32->start;
HXDLIN( 121)									int _g_max = yIter32->max;
HXDLIN( 121)									while((_g_min < _g_max)){
HXLINE( 121)										_g_min = (_g_min + 1);
HXDLIN( 121)										int y = (_g_min - 1);
HXLINE( 227)										s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE( 228)										t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE( 121)										bool _hx_tmp;
HXDLIN( 121)										if (!((s2 <= 0))) {
HXLINE( 121)											_hx_tmp = (t2 <= 0);
            										}
            										else {
HXLINE( 121)											_hx_tmp = true;
            										}
HXDLIN( 121)										if (_hx_tmp) {
HXLINE( 121)											if (foundY2) {
HXLINE( 121)												goto _hx_goto_14;
            											}
            										}
            										else {
HXLINE( 121)											if (((s2 + t2) < A2)) {
HXLINE( 121)												int x1 = ::hx::Mod(x,tileImage1->width);
HXDLIN( 121)												int y1 = ::hx::Mod(y,tileImage1->height);
HXDLIN( 121)												::haxe::io::ArrayBufferViewImpl this1 = tileImage1->image;
HXDLIN( 121)												int index;
HXDLIN( 121)												if (tileImage1->useVirtualPos) {
HXLINE( 121)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage1->virtualY) * ( (Float)(tileImage1->width) )) + x1) - tileImage1->virtualX));
            												}
            												else {
HXLINE( 121)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage1->width) + x1)) ));
            												}
HXDLIN( 121)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)												int color;
HXDLIN( 121)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 121)													color = c;
            												}
HXDLIN( 121)												{
HXLINE( 121)													int this2 = color;
HXDLIN( 121)													int c1 = this2;
HXDLIN( 121)													bool _hx_tmp;
HXDLIN( 121)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 121)														_hx_tmp = temp->transparent;
            													}
            													else {
HXLINE( 121)														_hx_tmp = false;
            													}
HXDLIN( 121)													if (_hx_tmp) {
HXLINE( 121)														int location;
HXDLIN( 121)														if (temp->useVirtualPos) {
HXLINE( 121)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 121)															location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 121)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)														int this3 = this2;
HXDLIN( 121)														int this4;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 121)															this4 = this3;
            														}
HXDLIN( 121)														Float a1;
HXDLIN( 121)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)														if ((this5 == 0)) {
HXLINE( 121)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float r1;
HXDLIN( 121)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)														if ((this6 == 0)) {
HXLINE( 121)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float g1;
HXDLIN( 121)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)														if ((this7 == 0)) {
HXLINE( 121)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float b1;
HXDLIN( 121)														int this8 = (this4 & 255);
HXDLIN( 121)														if ((this8 == 0)) {
HXLINE( 121)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float a2;
HXDLIN( 121)														int this9 = ((color >> 24) & 255);
HXDLIN( 121)														if ((this9 == 0)) {
HXLINE( 121)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float r2;
HXDLIN( 121)														int this10 = ((color >> 16) & 255);
HXDLIN( 121)														if ((this10 == 0)) {
HXLINE( 121)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float g2;
HXDLIN( 121)														int this11 = ((color >> 8) & 255);
HXDLIN( 121)														if ((this11 == 0)) {
HXLINE( 121)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float b2;
HXDLIN( 121)														int this12 = (color & 255);
HXDLIN( 121)														if ((this12 == 0)) {
HXLINE( 121)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)														{
HXLINE( 121)															::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 121)															int value;
HXDLIN( 121)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 121)																value = blended;
            															}
HXDLIN( 121)															bool _hx_tmp;
HXDLIN( 121)															if ((location >= 0)) {
HXLINE( 121)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 121)																_hx_tmp = false;
            															}
HXDLIN( 121)															if (_hx_tmp) {
HXLINE( 121)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 121)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)														int index;
HXDLIN( 121)														if (temp->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 121)														int value;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE( 121)															value = c1;
            														}
HXDLIN( 121)														bool _hx_tmp;
HXDLIN( 121)														if ((index >= 0)) {
HXLINE( 121)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 121)															_hx_tmp = false;
            														}
HXDLIN( 121)														if (_hx_tmp) {
HXLINE( 121)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY2 = true;
            											}
            											else {
HXLINE( 121)												if (foundY2) {
HXLINE( 121)													goto _hx_goto_14;
            												}
            											}
            										}
            									}
            									_hx_goto_14:;
            								}
            							}
            						}
HXDLIN( 121)						if ((hasHit1 == false)) {
HXLINE( 121)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x1_,y1_,bx2,by2,cx2,cy2,true);
HXDLIN( 121)							if (hasUndo2) {
HXLINE( 121)								v->undoImage = undoImage2;
HXDLIN( 121)								v->undoX = xIter32->start;
HXDLIN( 121)								v->undoY = yIter32->start;
            							}
            						}
            					}
            				}
HXDLIN( 121)				{
HXLINE( 121)					Float bx3 = x3_;
HXDLIN( 121)					Float by3 = y3_;
HXDLIN( 121)					Float cx3 = x4_;
HXDLIN( 121)					Float cy3 = y4_;
HXDLIN( 121)					bool adjustWinding3 = (((((x2_ * by3) - (bx3 * y2_)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * y2_) - (x2_ * cy3))) > 0);
HXDLIN( 121)					if (!(adjustWinding3)) {
HXLINE( 121)						Float bx_ = bx3;
HXDLIN( 121)						Float by_ = by3;
HXLINE( 188)						bx3 = cx3;
HXLINE( 189)						by3 = cy3;
HXLINE( 190)						cx3 = bx_;
HXLINE( 191)						cy3 = by_;
            					}
HXLINE( 121)					{
HXLINE( 121)						bool hasUndo3 = false;
HXDLIN( 121)						Float s03 = ((y2_ * cx3) - (x2_ * cy3));
HXDLIN( 121)						Float sx3 = (cy3 - y2_);
HXDLIN( 121)						Float sy3 = (x2_ - cx3);
HXDLIN( 121)						Float t03 = ((x2_ * by3) - (y2_ * bx3));
HXDLIN( 121)						Float tx3 = (y2_ - by3);
HXDLIN( 121)						Float ty3 = (bx3 - x2_);
HXDLIN( 121)						Float A3 = ((((-(by3) * cx3) + (y2_ * (-(bx3) + cx3))) + (x2_ * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 121)						::pixelimage::iter::IntIterStart xIter33;
HXDLIN( 121)						if ((x2_ > bx3)) {
HXLINE( 121)							if ((x2_ > cx3)) {
HXLINE( 121)								int min;
HXDLIN( 121)								if ((bx3 > cx3)) {
HXLINE( 121)									min = ::Math_obj::floor(cx3);
            								}
            								else {
HXLINE( 121)									min = ::Math_obj::floor(bx3);
            								}
HXDLIN( 121)								int ii_min = min;
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(x2_);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								xIter33 = this1;
            							}
            							else {
HXLINE( 121)								int ii_min = ::Math_obj::floor(bx3);
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								xIter33 = this1;
            							}
            						}
            						else {
HXLINE( 121)							if ((bx3 > cx3)) {
HXLINE( 121)								int min;
HXDLIN( 121)								if ((x2_ > cx3)) {
HXLINE( 121)									min = ::Math_obj::floor(cx3);
            								}
            								else {
HXLINE( 121)									min = ::Math_obj::ceil(x2_);
            								}
HXDLIN( 121)								int ii_min = min;
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(bx3);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								xIter33 = this1;
            							}
            							else {
HXLINE( 121)								int ii_min = ::Math_obj::floor(x2_);
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								xIter33 = this1;
            							}
            						}
HXDLIN( 121)						::pixelimage::iter::IntIterStart yIter33;
HXDLIN( 121)						if ((y2_ > by3)) {
HXLINE( 121)							if ((y2_ > cy3)) {
HXLINE( 121)								int min;
HXDLIN( 121)								if ((by3 > cy3)) {
HXLINE( 121)									min = ::Math_obj::floor(cy3);
            								}
            								else {
HXLINE( 121)									min = ::Math_obj::floor(by3);
            								}
HXDLIN( 121)								int ii_min = min;
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(y2_);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								yIter33 = this1;
            							}
            							else {
HXLINE( 121)								int ii_min = ::Math_obj::floor(by3);
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								yIter33 = this1;
            							}
            						}
            						else {
HXLINE( 121)							if ((by3 > cy3)) {
HXLINE( 121)								int min;
HXDLIN( 121)								if ((y2_ > cy3)) {
HXLINE( 121)									min = ::Math_obj::floor(cy3);
            								}
            								else {
HXLINE( 121)									min = ::Math_obj::ceil(y2_);
            								}
HXDLIN( 121)								int ii_min = min;
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(by3);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								yIter33 = this1;
            							}
            							else {
HXLINE( 121)								int ii_min = ::Math_obj::floor(y2_);
HXDLIN( 121)								int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 121)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)								yIter33 = this1;
            							}
            						}
HXDLIN( 121)						::pixelimage::ImageStruct undoImage3 = null();
HXDLIN( 121)						if (hasUndo3) {
HXLINE( 121)							int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 121)							int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 121)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 121)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 121)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 121)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 121)							undoImage3 = this3;
HXDLIN( 121)							{
HXLINE( 121)								int rectLeft = xIter33->start;
HXDLIN( 121)								int rectTop = yIter33->start;
HXDLIN( 121)								int rectRight = xIter33->max;
HXDLIN( 121)								bool forceClear = false;
HXDLIN( 121)								{
HXLINE( 121)									int _g = rectTop;
HXDLIN( 121)									int _g1 = yIter33->max;
HXDLIN( 121)									while((_g < _g1)){
HXLINE( 121)										_g = (_g + 1);
HXDLIN( 121)										int dy = (_g - 1);
HXDLIN( 121)										{
HXLINE( 121)											int _g1 = rectLeft;
HXDLIN( 121)											int _g2 = rectRight;
HXDLIN( 121)											while((_g1 < _g2)){
HXLINE( 121)												_g1 = (_g1 + 1);
HXDLIN( 121)												int dx = (_g1 - 1);
HXDLIN( 121)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)												int index;
HXDLIN( 121)												if (temp->useVirtualPos) {
HXLINE( 121)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE( 121)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN( 121)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)												int col;
HXDLIN( 121)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 121)													col = c;
            												}
HXDLIN( 121)												bool _hx_tmp;
HXDLIN( 121)												if (temp->useMask) {
HXLINE( 121)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE( 121)													_hx_tmp = false;
            												}
HXDLIN( 121)												if (_hx_tmp) {
HXLINE( 121)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 121)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 121)													int index;
HXDLIN( 121)													if (this1->useVirtualPos) {
HXLINE( 121)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 121)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 121)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 121)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 121)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)													int v;
HXDLIN( 121)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 121)														v = c;
            													}
HXDLIN( 121)													int this3 = v;
HXDLIN( 121)													int maskPixel = this3;
HXDLIN( 121)													int this4 = col;
HXDLIN( 121)													int this5 = this4;
HXDLIN( 121)													if ((maskPixel == 0)) {
HXLINE( 121)														int this1 = this5;
HXDLIN( 121)														col = this1;
            													}
            													else {
HXLINE( 121)														Float m0;
HXDLIN( 121)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 121)														if ((this1 == 0)) {
HXLINE( 121)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float m1;
HXDLIN( 121)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 121)														if ((this2 == 0)) {
HXLINE( 121)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float m2;
HXDLIN( 121)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 121)														if ((this3 == 0)) {
HXLINE( 121)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float m3;
HXDLIN( 121)														int this4 = (maskPixel & 255);
HXDLIN( 121)														if ((this4 == 0)) {
HXLINE( 121)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 121)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 121)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 121)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 121)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 121)												if ((col != 0)) {
HXLINE( 121)													int x = (dx - rectLeft);
HXDLIN( 121)													int y = (dy - rectTop);
HXDLIN( 121)													int this1 = col;
HXDLIN( 121)													int c = this1;
HXDLIN( 121)													bool _hx_tmp;
HXDLIN( 121)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 121)														_hx_tmp = undoImage3->transparent;
            													}
            													else {
HXLINE( 121)														_hx_tmp = false;
            													}
HXDLIN( 121)													if (_hx_tmp) {
HXLINE( 121)														int location;
HXDLIN( 121)														if (undoImage3->useVirtualPos) {
HXLINE( 121)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 121)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 121)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 121)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)														int this3 = this2;
HXDLIN( 121)														int this4;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 121)															this4 = this3;
            														}
HXDLIN( 121)														Float a1;
HXDLIN( 121)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)														if ((this5 == 0)) {
HXLINE( 121)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float r1;
HXDLIN( 121)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)														if ((this6 == 0)) {
HXLINE( 121)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float g1;
HXDLIN( 121)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)														if ((this7 == 0)) {
HXLINE( 121)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float b1;
HXDLIN( 121)														int this8 = (this4 & 255);
HXDLIN( 121)														if ((this8 == 0)) {
HXLINE( 121)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float a2;
HXDLIN( 121)														int this9 = ((col >> 24) & 255);
HXDLIN( 121)														if ((this9 == 0)) {
HXLINE( 121)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float r2;
HXDLIN( 121)														int this10 = ((col >> 16) & 255);
HXDLIN( 121)														if ((this10 == 0)) {
HXLINE( 121)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float g2;
HXDLIN( 121)														int this11 = ((col >> 8) & 255);
HXDLIN( 121)														if ((this11 == 0)) {
HXLINE( 121)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float b2;
HXDLIN( 121)														int this12 = (col & 255);
HXDLIN( 121)														if ((this12 == 0)) {
HXLINE( 121)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)														{
HXLINE( 121)															::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN( 121)															int value;
HXDLIN( 121)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 121)																value = blended;
            															}
HXDLIN( 121)															bool _hx_tmp;
HXDLIN( 121)															if ((location >= 0)) {
HXLINE( 121)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 121)																_hx_tmp = false;
            															}
HXDLIN( 121)															if (_hx_tmp) {
HXLINE( 121)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 121)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 121)														int index;
HXDLIN( 121)														if (undoImage3->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 121)														int value;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 121)															value = c;
            														}
HXDLIN( 121)														bool _hx_tmp;
HXDLIN( 121)														if ((index >= 0)) {
HXLINE( 121)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 121)															_hx_tmp = false;
            														}
HXDLIN( 121)														if (_hx_tmp) {
HXLINE( 121)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 121)													if (forceClear) {
HXLINE( 121)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 121)														int x = (dx - rectLeft);
HXDLIN( 121)														int y = (dy - rectTop);
HXDLIN( 121)														int index;
HXDLIN( 121)														if (undoImage3->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 121)														bool _hx_tmp;
HXDLIN( 121)														if ((index >= 0)) {
HXLINE( 121)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 121)															_hx_tmp = false;
            														}
HXDLIN( 121)														if (_hx_tmp) {
HXLINE( 121)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 121)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 121)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 121)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 121)						bool foundY3 = false;
HXDLIN( 121)						Float s3 = ((Float)0.);
HXDLIN( 121)						Float t3 = ((Float)0.);
HXDLIN( 121)						Float sxx3 = ((Float)0.);
HXDLIN( 121)						Float txx3 = ((Float)0.);
HXDLIN( 121)						{
HXLINE( 121)							int _g_min3 = xIter33->start;
HXDLIN( 121)							int _g_max3 = xIter33->max;
HXDLIN( 121)							while((_g_min3 < _g_max3)){
HXLINE( 121)								_g_min3 = (_g_min3 + 1);
HXDLIN( 121)								int x = (_g_min3 - 1);
HXLINE( 223)								sxx3 = (sx3 * ( (Float)(x) ));
HXLINE( 224)								txx3 = (tx3 * ( (Float)(x) ));
HXLINE( 225)								foundY3 = false;
HXLINE( 121)								{
HXLINE( 121)									int _g_min = yIter33->start;
HXDLIN( 121)									int _g_max = yIter33->max;
HXDLIN( 121)									while((_g_min < _g_max)){
HXLINE( 121)										_g_min = (_g_min + 1);
HXDLIN( 121)										int y = (_g_min - 1);
HXLINE( 227)										s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE( 228)										t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE( 121)										bool _hx_tmp;
HXDLIN( 121)										if (!((s3 <= 0))) {
HXLINE( 121)											_hx_tmp = (t3 <= 0);
            										}
            										else {
HXLINE( 121)											_hx_tmp = true;
            										}
HXDLIN( 121)										if (_hx_tmp) {
HXLINE( 121)											if (foundY3) {
HXLINE( 121)												goto _hx_goto_18;
            											}
            										}
            										else {
HXLINE( 121)											if (((s3 + t3) < A3)) {
HXLINE( 121)												int x1 = ::hx::Mod(x,tileImage1->width);
HXDLIN( 121)												int y1 = ::hx::Mod(y,tileImage1->height);
HXDLIN( 121)												::haxe::io::ArrayBufferViewImpl this1 = tileImage1->image;
HXDLIN( 121)												int index;
HXDLIN( 121)												if (tileImage1->useVirtualPos) {
HXLINE( 121)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage1->virtualY) * ( (Float)(tileImage1->width) )) + x1) - tileImage1->virtualX));
            												}
            												else {
HXLINE( 121)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage1->width) + x1)) ));
            												}
HXDLIN( 121)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)												int color;
HXDLIN( 121)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 121)													color = c;
            												}
HXDLIN( 121)												{
HXLINE( 121)													int this2 = color;
HXDLIN( 121)													int c1 = this2;
HXDLIN( 121)													bool _hx_tmp;
HXDLIN( 121)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 121)														_hx_tmp = temp->transparent;
            													}
            													else {
HXLINE( 121)														_hx_tmp = false;
            													}
HXDLIN( 121)													if (_hx_tmp) {
HXLINE( 121)														int location;
HXDLIN( 121)														if (temp->useVirtualPos) {
HXLINE( 121)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 121)															location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 121)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)														int this3 = this2;
HXDLIN( 121)														int this4;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 121)															this4 = this3;
            														}
HXDLIN( 121)														Float a1;
HXDLIN( 121)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)														if ((this5 == 0)) {
HXLINE( 121)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float r1;
HXDLIN( 121)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)														if ((this6 == 0)) {
HXLINE( 121)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float g1;
HXDLIN( 121)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)														if ((this7 == 0)) {
HXLINE( 121)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float b1;
HXDLIN( 121)														int this8 = (this4 & 255);
HXDLIN( 121)														if ((this8 == 0)) {
HXLINE( 121)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float a2;
HXDLIN( 121)														int this9 = ((color >> 24) & 255);
HXDLIN( 121)														if ((this9 == 0)) {
HXLINE( 121)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float r2;
HXDLIN( 121)														int this10 = ((color >> 16) & 255);
HXDLIN( 121)														if ((this10 == 0)) {
HXLINE( 121)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float g2;
HXDLIN( 121)														int this11 = ((color >> 8) & 255);
HXDLIN( 121)														if ((this11 == 0)) {
HXLINE( 121)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float b2;
HXDLIN( 121)														int this12 = (color & 255);
HXDLIN( 121)														if ((this12 == 0)) {
HXLINE( 121)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 121)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 121)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)														{
HXLINE( 121)															::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 121)															int value;
HXDLIN( 121)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 121)																value = blended;
            															}
HXDLIN( 121)															bool _hx_tmp;
HXDLIN( 121)															if ((location >= 0)) {
HXLINE( 121)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 121)																_hx_tmp = false;
            															}
HXDLIN( 121)															if (_hx_tmp) {
HXLINE( 121)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 121)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)														int index;
HXDLIN( 121)														if (temp->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 121)														int value;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE( 121)															value = c1;
            														}
HXDLIN( 121)														bool _hx_tmp;
HXDLIN( 121)														if ((index >= 0)) {
HXLINE( 121)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 121)															_hx_tmp = false;
            														}
HXDLIN( 121)														if (_hx_tmp) {
HXLINE( 121)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY3 = true;
            											}
            											else {
HXLINE( 121)												if (foundY3) {
HXLINE( 121)													goto _hx_goto_18;
            												}
            											}
            										}
            									}
            									_hx_goto_18:;
            								}
            							}
            						}
HXDLIN( 121)						if ((hasHit1 == false)) {
HXLINE( 121)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,x2_,y2_,bx3,by3,cx3,cy3,true);
HXDLIN( 121)							if (hasUndo3) {
HXLINE( 121)								v->undoImage = undoImage3;
HXDLIN( 121)								v->undoX = xIter33->start;
HXDLIN( 121)								v->undoY = yIter33->start;
            							}
            						}
            					}
            				}
HXDLIN( 121)				if ((hasHit1 == true)) {
HXLINE( 121)					::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,x1_,y1_,x2_,y2_,x3_,y3_,x4_,y4_,true);
            				}
            			}
            		}
HXLINE( 123)		{
HXLINE( 123)			int x = ::Std_obj::_hx_int((left + this->offX));
HXDLIN( 123)			int y = ::Std_obj::_hx_int((top + this->offY));
HXDLIN( 123)			bool forceClear = false;
HXDLIN( 123)			{
HXLINE( 123)				int _g = 0;
HXDLIN( 123)				int _g1 = temp->height;
HXDLIN( 123)				while((_g < _g1)){
HXLINE( 123)					_g = (_g + 1);
HXDLIN( 123)					int dy = (_g - 1);
HXDLIN( 123)					{
HXLINE( 123)						int _g1 = 0;
HXDLIN( 123)						int _g2 = temp->width;
HXDLIN( 123)						while((_g1 < _g2)){
HXLINE( 123)							_g1 = (_g1 + 1);
HXDLIN( 123)							int dx = (_g1 - 1);
HXDLIN( 123)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 123)							int index;
HXDLIN( 123)							if (temp->useVirtualPos) {
HXLINE( 123)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE( 123)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN( 123)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 123)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 123)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 123)							int col;
HXDLIN( 123)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 123)								col = c;
            							}
HXDLIN( 123)							bool _hx_tmp;
HXDLIN( 123)							if (temp->useMask) {
HXLINE( 123)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE( 123)								_hx_tmp = false;
            							}
HXDLIN( 123)							if (_hx_tmp) {
HXLINE( 123)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 123)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 123)								int index;
HXDLIN( 123)								if (this1->useVirtualPos) {
HXLINE( 123)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE( 123)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN( 123)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 123)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 123)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 123)								int v;
HXDLIN( 123)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 123)									v = c;
            								}
HXDLIN( 123)								int this3 = v;
HXDLIN( 123)								int maskPixel = this3;
HXDLIN( 123)								int this4 = col;
HXDLIN( 123)								int this5 = this4;
HXDLIN( 123)								if ((maskPixel == 0)) {
HXLINE( 123)									int this1 = this5;
HXDLIN( 123)									col = this1;
            								}
            								else {
HXLINE( 123)									Float m0;
HXDLIN( 123)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 123)									if ((this1 == 0)) {
HXLINE( 123)										m0 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float m1;
HXDLIN( 123)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 123)									if ((this2 == 0)) {
HXLINE( 123)										m1 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float m2;
HXDLIN( 123)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 123)									if ((this3 == 0)) {
HXLINE( 123)										m2 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float m3;
HXDLIN( 123)									int this4 = (maskPixel & 255);
HXDLIN( 123)									if ((this4 == 0)) {
HXLINE( 123)										m3 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 123)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 123)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 123)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 123)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 123)							if ((col != 0)) {
HXLINE( 123)								int x1 = (x + dx);
HXDLIN( 123)								int y1 = (y + dy);
HXDLIN( 123)								int this1 = col;
HXDLIN( 123)								int c = this1;
HXDLIN( 123)								bool _hx_tmp;
HXDLIN( 123)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 123)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE( 123)									_hx_tmp = false;
            								}
HXDLIN( 123)								if (_hx_tmp) {
HXLINE( 123)									int location;
HXDLIN( 123)									if (pixelShape->useVirtualPos) {
HXLINE( 123)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE( 123)										location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN( 123)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN( 123)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 123)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 123)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 123)									int this3 = this2;
HXDLIN( 123)									int this4;
HXDLIN( 123)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 123)										this4 = this3;
            									}
HXDLIN( 123)									Float a1;
HXDLIN( 123)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 123)									if ((this5 == 0)) {
HXLINE( 123)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float r1;
HXDLIN( 123)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 123)									if ((this6 == 0)) {
HXLINE( 123)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float g1;
HXDLIN( 123)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 123)									if ((this7 == 0)) {
HXLINE( 123)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float b1;
HXDLIN( 123)									int this8 = (this4 & 255);
HXDLIN( 123)									if ((this8 == 0)) {
HXLINE( 123)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float a2;
HXDLIN( 123)									int this9 = ((col >> 24) & 255);
HXDLIN( 123)									if ((this9 == 0)) {
HXLINE( 123)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float r2;
HXDLIN( 123)									int this10 = ((col >> 16) & 255);
HXDLIN( 123)									if ((this10 == 0)) {
HXLINE( 123)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float g2;
HXDLIN( 123)									int this11 = ((col >> 8) & 255);
HXDLIN( 123)									if ((this11 == 0)) {
HXLINE( 123)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float b2;
HXDLIN( 123)									int this12 = (col & 255);
HXDLIN( 123)									if ((this12 == 0)) {
HXLINE( 123)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 123)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 123)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 123)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 123)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 123)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 123)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 123)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 123)									{
HXLINE( 123)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN( 123)										int value;
HXDLIN( 123)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 123)											value = blended;
            										}
HXDLIN( 123)										bool _hx_tmp;
HXDLIN( 123)										if ((location >= 0)) {
HXLINE( 123)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 123)											_hx_tmp = false;
            										}
HXDLIN( 123)										if (_hx_tmp) {
HXLINE( 123)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 123)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 123)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 123)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 123)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 123)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 123)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN( 123)									int index;
HXDLIN( 123)									if (pixelShape->useVirtualPos) {
HXLINE( 123)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE( 123)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN( 123)									int value;
HXDLIN( 123)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 123)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 123)										value = c;
            									}
HXDLIN( 123)									bool _hx_tmp;
HXDLIN( 123)									if ((index >= 0)) {
HXLINE( 123)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 123)										_hx_tmp = false;
            									}
HXDLIN( 123)									if (_hx_tmp) {
HXLINE( 123)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 123)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 123)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 123)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 123)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 123)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE( 123)								if (forceClear) {
HXLINE( 123)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN( 123)									int x1 = (x + dx);
HXDLIN( 123)									int y1 = (y + dy);
HXDLIN( 123)									int index;
HXDLIN( 123)									if (pixelShape->useVirtualPos) {
HXLINE( 123)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE( 123)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN( 123)									bool _hx_tmp;
HXDLIN( 123)									if ((index >= 0)) {
HXLINE( 123)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 123)										_hx_tmp = false;
            									}
HXDLIN( 123)									if (_hx_tmp) {
HXLINE( 123)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 123)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 123)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 123)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 123)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 123)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 124)		temp = null();
HXLINE( 126)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< QuadrilateralPattern_obj > QuadrilateralPattern_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3,::hx::Null< Float >  __o_x4,::hx::Null< Float >  __o_y4) {
	::hx::ObjectPtr< QuadrilateralPattern_obj > __this = new QuadrilateralPattern_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale,__o_x1,__o_y1,__o_x2,__o_y2,__o_x3,__o_y3,__o_x4,__o_y4);
	return __this;
}

::hx::ObjectPtr< QuadrilateralPattern_obj > QuadrilateralPattern_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3,::hx::Null< Float >  __o_x4,::hx::Null< Float >  __o_y4) {
	QuadrilateralPattern_obj *__this = (QuadrilateralPattern_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(QuadrilateralPattern_obj), true, "pixelimage.triangleGML.patternShape.QuadrilateralPattern"));
	*(void **)__this = QuadrilateralPattern_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale,__o_x1,__o_y1,__o_x2,__o_y2,__o_x3,__o_y3,__o_x4,__o_y4);
	return __this;
}

QuadrilateralPattern_obj::QuadrilateralPattern_obj()
{
}

::hx::Val QuadrilateralPattern_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { return ::hx::Val( x1 ); }
		if (HX_FIELD_EQ(inName,"y1") ) { return ::hx::Val( y1 ); }
		if (HX_FIELD_EQ(inName,"x2") ) { return ::hx::Val( x2 ); }
		if (HX_FIELD_EQ(inName,"y2") ) { return ::hx::Val( y2 ); }
		if (HX_FIELD_EQ(inName,"x3") ) { return ::hx::Val( x3 ); }
		if (HX_FIELD_EQ(inName,"y3") ) { return ::hx::Val( y3 ); }
		if (HX_FIELD_EQ(inName,"x4") ) { return ::hx::Val( x4 ); }
		if (HX_FIELD_EQ(inName,"y4") ) { return ::hx::Val( y4 ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val QuadrilateralPattern_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { x1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y1") ) { y1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x2") ) { x2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y2") ) { y2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x3") ) { x3=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y3") ) { y3=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x4") ) { x4=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y4") ) { y4=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void QuadrilateralPattern_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x1",b9,68,00,00));
	outFields->push(HX_("y1",98,69,00,00));
	outFields->push(HX_("x2",ba,68,00,00));
	outFields->push(HX_("y2",99,69,00,00));
	outFields->push(HX_("x3",bb,68,00,00));
	outFields->push(HX_("y3",9a,69,00,00));
	outFields->push(HX_("x4",bc,68,00,00));
	outFields->push(HX_("y4",9b,69,00,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo QuadrilateralPattern_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(QuadrilateralPattern_obj,x1),HX_("x1",b9,68,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadrilateralPattern_obj,y1),HX_("y1",98,69,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadrilateralPattern_obj,x2),HX_("x2",ba,68,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadrilateralPattern_obj,y2),HX_("y2",99,69,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadrilateralPattern_obj,x3),HX_("x3",bb,68,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadrilateralPattern_obj,y3),HX_("y3",9a,69,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadrilateralPattern_obj,x4),HX_("x4",bc,68,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadrilateralPattern_obj,y4),HX_("y4",9b,69,00,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *QuadrilateralPattern_obj_sStaticStorageInfo = 0;
#endif

static ::String QuadrilateralPattern_obj_sMemberFields[] = {
	HX_("x1",b9,68,00,00),
	HX_("y1",98,69,00,00),
	HX_("x2",ba,68,00,00),
	HX_("y2",99,69,00,00),
	HX_("x3",bb,68,00,00),
	HX_("y3",9a,69,00,00),
	HX_("x4",bc,68,00,00),
	HX_("y4",9b,69,00,00),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class QuadrilateralPattern_obj::__mClass;

void QuadrilateralPattern_obj::__register()
{
	QuadrilateralPattern_obj _hx_dummy;
	QuadrilateralPattern_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.patternShape.QuadrilateralPattern",6b,3c,59,a8);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(QuadrilateralPattern_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< QuadrilateralPattern_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = QuadrilateralPattern_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = QuadrilateralPattern_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace patternShape
