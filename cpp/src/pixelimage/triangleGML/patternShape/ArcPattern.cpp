// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTriArray
#include <pixelimage/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_PatternShape
#include <pixelimage/triangleGML/coreShape/PatternShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_patternShape_ArcPattern
#include <pixelimage/triangleGML/patternShape/ArcPattern.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_32a31af4d124b381_48_new,"pixelimage.triangleGML.patternShape.ArcPattern","new",0x044efa24,"pixelimage.triangleGML.patternShape.ArcPattern.new","pixelimage/triangleGML/patternShape/ArcPattern.hx",48,0xcf86c12d)
HX_LOCAL_STACK_FRAME(_hx_pos_32a31af4d124b381_60_setParameter,"pixelimage.triangleGML.patternShape.ArcPattern","setParameter",0xb7db7363,"pixelimage.triangleGML.patternShape.ArcPattern.setParameter","pixelimage/triangleGML/patternShape/ArcPattern.hx",60,0xcf86c12d)
HX_LOCAL_STACK_FRAME(_hx_pos_32a31af4d124b381_84_render,"pixelimage.triangleGML.patternShape.ArcPattern","render",0x0b5bb412,"pixelimage.triangleGML.patternShape.ArcPattern.render","pixelimage/triangleGML/patternShape/ArcPattern.hx",84,0xcf86c12d)
HX_LOCAL_STACK_FRAME(_hx_pos_32a31af4d124b381_102_chord,"pixelimage.triangleGML.patternShape.ArcPattern","chord",0x9e2a5f20,"pixelimage.triangleGML.patternShape.ArcPattern.chord","pixelimage/triangleGML/patternShape/ArcPattern.hx",102,0xcf86c12d)
HX_LOCAL_STACK_FRAME(_hx_pos_32a31af4d124b381_124_ellipse,"pixelimage.triangleGML.patternShape.ArcPattern","ellipse",0x71539ca2,"pixelimage.triangleGML.patternShape.ArcPattern.ellipse","pixelimage/triangleGML/patternShape/ArcPattern.hx",124,0xcf86c12d)
HX_LOCAL_STACK_FRAME(_hx_pos_32a31af4d124b381_128_pie,"pixelimage.triangleGML.patternShape.ArcPattern","pie",0x04508210,"pixelimage.triangleGML.patternShape.ArcPattern.pie","pixelimage/triangleGML/patternShape/ArcPattern.hx",128,0xcf86c12d)
namespace pixelimage{
namespace triangleGML{
namespace patternShape{

void ArcPattern_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_startAngle,::hx::Null< Float >  __o_sweepAngle,::String __o_arcType){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int strokeColor0 = __o_strokeColor0.Default(0);
            		int strokeColor1 = __o_strokeColor1.Default(0);
            		int fillColor0 = __o_fillColor0.Default(0);
            		int fillColor1 = __o_fillColor1.Default(0);
            		bool strokePatternAcross = __o_strokePatternAcross.Default(true);
            		int strokePatternScale = __o_strokePatternScale.Default(1);
            		int fillPatternWidth = __o_fillPatternWidth.Default(16);
            		int fillPatternHeight = __o_fillPatternHeight.Default(16);
            		bool fillPatternAcross = __o_fillPatternAcross.Default(true);
            		int fillPatternScale = __o_fillPatternScale.Default(1);
            		Float left = __o_left.Default(((Float)0.));
            		Float top = __o_top.Default(((Float)0.));
            		Float width = __o_width.Default(((Float)1.));
            		Float height = __o_height.Default(((Float)1.));
            		Float startAngle = __o_startAngle.Default(((Float)0.));
            		Float sweepAngle = __o_sweepAngle.Default(((Float)0.));
            		::String arcType = __o_arcType;
            		if (::hx::IsNull(__o_arcType)) arcType = HX_("pie",4c,58,55,00);
            	HX_STACKFRAME(&_hx_pos_32a31af4d124b381_48_new)
HXLINE(  49)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,strokeColor0,strokeColor1,fillColor0,fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,strokePatternAcross,strokePatternScale,fillPatternFill,fillPatternWidth,fillPatternHeight,fillPatternAcross,fillPatternScale);
HXLINE(  50)		this->left = left;
HXLINE(  51)		this->top = top;
HXLINE(  52)		this->width = width;
HXLINE(  53)		this->height = height;
HXLINE(  54)		this->startAngle = startAngle;
HXLINE(  55)		this->sweepAngle = sweepAngle;
HXLINE(  56)		this->arcType = arcType;
HXLINE(  57)		this->rx = (width / ( (Float)(2) ));
HXLINE(  58)		this->ry = (height / ( (Float)(2) ));
            	}

Dynamic ArcPattern_obj::__CreateEmpty() { return new ArcPattern_obj; }

void *ArcPattern_obj::_hx_vtable = 0;

Dynamic ArcPattern_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ArcPattern_obj > _hx_result = new ArcPattern_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14],inArgs[15],inArgs[16],inArgs[17],inArgs[18],inArgs[19],inArgs[20],inArgs[21],inArgs[22],inArgs[23],inArgs[24],inArgs[25]);
	return _hx_result;
}

bool ArcPattern_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x4bd58718 || inClassId==(int)0x6e596dee;
	}
}

void ArcPattern_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_32a31af4d124b381_60_setParameter)
HXLINE(  61)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("arcType",2c,ae,de,8e)) ){
HXLINE(  77)			this->arcType = value;
HXDLIN(  77)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("height",e7,07,4c,02)) ){
HXLINE(  69)			this->height = ::Std_obj::parseFloat(value);
HXDLIN(  69)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("left",07,08,b0,47)) ){
HXLINE(  63)			this->left = ::Std_obj::parseFloat(value);
HXDLIN(  63)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("startAngle",11,1c,f9,3e)) ){
HXLINE(  71)			Float degree = ::Std_obj::parseFloat(value);
HXLINE(  72)			Float _hx_tmp;
HXDLIN(  72)			if ((degree == 0)) {
HXLINE(  72)				_hx_tmp = ( (Float)(0) );
            			}
            			else {
HXLINE(  72)				_hx_tmp = ((::Math_obj::PI * degree) / ( (Float)(180) ));
            			}
HXDLIN(  72)			this->startAngle = _hx_tmp;
HXLINE(  70)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("sweepAngle",47,a6,92,e6)) ){
HXLINE(  74)			Float degree = ::Std_obj::parseFloat(value);
HXLINE(  75)			Float _hx_tmp;
HXDLIN(  75)			if ((degree == 0)) {
HXLINE(  75)				_hx_tmp = ( (Float)(0) );
            			}
            			else {
HXLINE(  75)				_hx_tmp = ((::Math_obj::PI * degree) / ( (Float)(180) ));
            			}
HXDLIN(  75)			this->sweepAngle = _hx_tmp;
HXLINE(  73)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("top",95,66,58,00)) ){
HXLINE(  65)			this->top = ::Std_obj::parseFloat(value);
HXDLIN(  65)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("width",06,b6,62,ca)) ){
HXLINE(  67)			this->width = ::Std_obj::parseFloat(value);
HXDLIN(  67)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  79)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
HXLINE(  81)		this->rx = (this->width / ( (Float)(2) ));
HXLINE(  82)		this->ry = (this->height / ( (Float)(2) ));
            	}


::pixelimage::ImageStruct ArcPattern_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_32a31af4d124b381_84_render)
HXLINE(  85)		int w = ::Math_obj::ceil(this->width);
HXDLIN(  85)		int h = ::Math_obj::ceil(this->height);
HXDLIN(  85)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  85)		::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)		::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  85)		::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  85)		::pixelimage::ImageStruct this4 = this3;
HXDLIN(  85)		::pixelimage::ImageStruct temp = this4;
HXLINE(  86)		temp->transparent = false;
HXLINE(  87)		this->buildPatternTemplates();
HXLINE(  88)		::String _hx_switch_0 = this->arcType;
            		if (  (_hx_switch_0==HX_("chord",5c,3c,be,45)) ){
HXLINE(  90)			this->chord(temp);
HXDLIN(  90)			goto _hx_goto_3;
            		}
            		if (  (_hx_switch_0==HX_("ellipse",de,40,86,0b)) ){
HXLINE(  92)			this->ellipse(temp);
HXDLIN(  92)			goto _hx_goto_3;
            		}
            		if (  (_hx_switch_0==HX_("pie",4c,58,55,00)) ){
HXLINE(  94)			this->pie(temp);
HXDLIN(  94)			goto _hx_goto_3;
            		}
            		_hx_goto_3:;
HXLINE(  97)		{
HXLINE(  97)			int x = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  97)			int y = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  97)			bool forceClear = false;
HXDLIN(  97)			{
HXLINE(  97)				int _g = 0;
HXDLIN(  97)				int _g1 = temp->height;
HXDLIN(  97)				while((_g < _g1)){
HXLINE(  97)					_g = (_g + 1);
HXDLIN(  97)					int dy = (_g - 1);
HXDLIN(  97)					{
HXLINE(  97)						int _g1 = 0;
HXDLIN(  97)						int _g2 = temp->width;
HXDLIN(  97)						while((_g1 < _g2)){
HXLINE(  97)							_g1 = (_g1 + 1);
HXDLIN(  97)							int dx = (_g1 - 1);
HXDLIN(  97)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  97)							int index;
HXDLIN(  97)							if (temp->useVirtualPos) {
HXLINE(  97)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  97)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  97)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)							int col;
HXDLIN(  97)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  97)								col = c;
            							}
HXDLIN(  97)							bool _hx_tmp;
HXDLIN(  97)							if (temp->useMask) {
HXLINE(  97)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  97)								_hx_tmp = false;
            							}
HXDLIN(  97)							if (_hx_tmp) {
HXLINE(  97)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  97)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  97)								int index;
HXDLIN(  97)								if (this1->useVirtualPos) {
HXLINE(  97)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  97)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  97)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  97)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  97)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)								int v;
HXDLIN(  97)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  97)									v = c;
            								}
HXDLIN(  97)								int this3 = v;
HXDLIN(  97)								int maskPixel = this3;
HXDLIN(  97)								int this4 = col;
HXDLIN(  97)								int this5 = this4;
HXDLIN(  97)								if ((maskPixel == 0)) {
HXLINE(  97)									int this1 = this5;
HXDLIN(  97)									col = this1;
            								}
            								else {
HXLINE(  97)									Float m0;
HXDLIN(  97)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  97)									if ((this1 == 0)) {
HXLINE(  97)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float m1;
HXDLIN(  97)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  97)									if ((this2 == 0)) {
HXLINE(  97)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float m2;
HXDLIN(  97)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  97)									if ((this3 == 0)) {
HXLINE(  97)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float m3;
HXDLIN(  97)									int this4 = (maskPixel & 255);
HXDLIN(  97)									if ((this4 == 0)) {
HXLINE(  97)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  97)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  97)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  97)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  97)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  97)							if ((col != 0)) {
HXLINE(  97)								int x1 = (x + dx);
HXDLIN(  97)								int y1 = (y + dy);
HXDLIN(  97)								int this1 = col;
HXDLIN(  97)								int c = this1;
HXDLIN(  97)								bool _hx_tmp;
HXDLIN(  97)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  97)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  97)									_hx_tmp = false;
            								}
HXDLIN(  97)								if (_hx_tmp) {
HXLINE(  97)									int location;
HXDLIN(  97)									if (pixelShape->useVirtualPos) {
HXLINE(  97)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  97)										location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  97)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  97)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  97)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  97)									int this3 = this2;
HXDLIN(  97)									int this4;
HXDLIN(  97)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  97)										this4 = this3;
            									}
HXDLIN(  97)									Float a1;
HXDLIN(  97)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  97)									if ((this5 == 0)) {
HXLINE(  97)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float r1;
HXDLIN(  97)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  97)									if ((this6 == 0)) {
HXLINE(  97)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float g1;
HXDLIN(  97)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  97)									if ((this7 == 0)) {
HXLINE(  97)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float b1;
HXDLIN(  97)									int this8 = (this4 & 255);
HXDLIN(  97)									if ((this8 == 0)) {
HXLINE(  97)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float a2;
HXDLIN(  97)									int this9 = ((col >> 24) & 255);
HXDLIN(  97)									if ((this9 == 0)) {
HXLINE(  97)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float r2;
HXDLIN(  97)									int this10 = ((col >> 16) & 255);
HXDLIN(  97)									if ((this10 == 0)) {
HXLINE(  97)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float g2;
HXDLIN(  97)									int this11 = ((col >> 8) & 255);
HXDLIN(  97)									if ((this11 == 0)) {
HXLINE(  97)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float b2;
HXDLIN(  97)									int this12 = (col & 255);
HXDLIN(  97)									if ((this12 == 0)) {
HXLINE(  97)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  97)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  97)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  97)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  97)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  97)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  97)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  97)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  97)									{
HXLINE(  97)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  97)										int value;
HXDLIN(  97)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  97)											value = blended;
            										}
HXDLIN(  97)										bool _hx_tmp;
HXDLIN(  97)										if ((location >= 0)) {
HXLINE(  97)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  97)											_hx_tmp = false;
            										}
HXDLIN(  97)										if (_hx_tmp) {
HXLINE(  97)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  97)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  97)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  97)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  97)									int index;
HXDLIN(  97)									if (pixelShape->useVirtualPos) {
HXLINE(  97)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  97)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  97)									int value;
HXDLIN(  97)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  97)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  97)										value = c;
            									}
HXDLIN(  97)									bool _hx_tmp;
HXDLIN(  97)									if ((index >= 0)) {
HXLINE(  97)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  97)										_hx_tmp = false;
            									}
HXDLIN(  97)									if (_hx_tmp) {
HXLINE(  97)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  97)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  97)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  97)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  97)								if (forceClear) {
HXLINE(  97)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  97)									int x1 = (x + dx);
HXDLIN(  97)									int y1 = (y + dy);
HXDLIN(  97)									int index;
HXDLIN(  97)									if (pixelShape->useVirtualPos) {
HXLINE(  97)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  97)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  97)									bool _hx_tmp;
HXDLIN(  97)									if ((index >= 0)) {
HXLINE(  97)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  97)										_hx_tmp = false;
            									}
HXDLIN(  97)									if (_hx_tmp) {
HXLINE(  97)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  97)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  97)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  97)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  97)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  97)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  98)		temp = null();
HXLINE( 100)		return this->super::render(pixelShape);
            	}


void ArcPattern_obj::chord(::pixelimage::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_32a31af4d124b381_102_chord)
HXLINE( 103)		this->ellipse(temp);
HXLINE( 105)		Float endAngle = (this->startAngle + this->sweepAngle);
HXLINE( 106)		Float bx = ((this->rx * ::Math_obj::cos(this->startAngle)) + this->rx);
HXLINE( 107)		Float by = ((this->ry * ::Math_obj::sin(this->startAngle)) + this->ry);
HXLINE( 108)		Float cx = ((this->rx * ::Math_obj::cos(endAngle)) + this->rx);
HXLINE( 109)		Float cy = ((this->ry * ::Math_obj::sin(endAngle)) + this->ry);
HXLINE( 110)		if ((this->sweepAngle < ::Math_obj::PI)) {
HXLINE( 111)			Float bxS = (((this->rx - this->strokeWidth) * ::Math_obj::cos(this->startAngle)) + this->rx);
HXLINE( 112)			Float byS = (((this->ry - this->strokeWidth) * ::Math_obj::sin(this->startAngle)) + this->ry);
HXLINE( 113)			Float cxS = (((this->rx - this->strokeWidth) * ::Math_obj::cos((endAngle + ((Float)0.01)))) + this->rx);
HXLINE( 114)			Float cyS = (((this->ry - this->strokeWidth) * ::Math_obj::sin((endAngle + ((Float)0.01)))) + this->ry);
HXLINE( 115)			{
HXLINE( 115)				Float d = this->strokeWidth;
HXDLIN( 115)				{
HXLINE( 115)					Float x = (this->rx - (d / ( (Float)(2) )));
HXDLIN( 115)					Float y = (this->ry - (d / ( (Float)(2) )));
HXDLIN( 115)					int p = ::Std_obj::_hx_int(x);
HXDLIN( 115)					int xx = p;
HXDLIN( 115)					int q = ::Std_obj::_hx_int(y);
HXDLIN( 115)					int maxX = ::Std_obj::_hx_int((x + d));
HXDLIN( 115)					int maxY = ::Std_obj::_hx_int((y + d));
HXDLIN( 115)					while(true){
HXLINE( 115)						{
HXLINE( 115)							p = (p + 1);
HXDLIN( 115)							int x = (p - 1);
HXDLIN( 115)							int this1 = 0;
HXDLIN( 115)							int c = this1;
HXDLIN( 115)							bool _hx_tmp;
HXDLIN( 115)							if ((((c >> 24) & 255) < 254)) {
HXLINE( 115)								_hx_tmp = temp->transparent;
            							}
            							else {
HXLINE( 115)								_hx_tmp = false;
            							}
HXDLIN( 115)							if (_hx_tmp) {
HXLINE( 115)								int location;
HXDLIN( 115)								if (temp->useVirtualPos) {
HXLINE( 115)									location = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            								}
            								else {
HXLINE( 115)									location = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            								}
HXDLIN( 115)								::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 115)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 115)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 115)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 115)								int this3 = this2;
HXDLIN( 115)								int this4;
HXDLIN( 115)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 115)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE( 115)									this4 = this3;
            								}
HXDLIN( 115)								Float a1;
HXDLIN( 115)								int this5 = ((this4 >> 24) & 255);
HXDLIN( 115)								if ((this5 == 0)) {
HXLINE( 115)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 115)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 115)								Float r1;
HXDLIN( 115)								int this6 = ((this4 >> 16) & 255);
HXDLIN( 115)								if ((this6 == 0)) {
HXLINE( 115)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 115)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 115)								Float g1;
HXDLIN( 115)								int this7 = ((this4 >> 8) & 255);
HXDLIN( 115)								if ((this7 == 0)) {
HXLINE( 115)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 115)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 115)								Float b1;
HXDLIN( 115)								int this8 = (this4 & 255);
HXDLIN( 115)								if ((this8 == 0)) {
HXLINE( 115)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 115)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 115)								Float a2;
HXDLIN( 115)								int this9 = ((0 >> 24) & 255);
HXDLIN( 115)								if ((this9 == 0)) {
HXLINE( 115)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 115)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 115)								Float r2;
HXDLIN( 115)								int this10 = ((0 >> 16) & 255);
HXDLIN( 115)								if ((this10 == 0)) {
HXLINE( 115)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 115)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 115)								Float g2;
HXDLIN( 115)								int this11 = ((0 >> 8) & 255);
HXDLIN( 115)								if ((this11 == 0)) {
HXLINE( 115)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 115)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 115)								Float b2;
HXDLIN( 115)								int this12 = (0 & 255);
HXDLIN( 115)								if ((this12 == 0)) {
HXLINE( 115)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 115)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN( 115)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 115)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 115)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 115)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 115)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 115)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 115)								{
HXLINE( 115)									::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 115)									int value;
HXDLIN( 115)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 115)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 115)										value = blended;
            									}
HXDLIN( 115)									bool _hx_tmp;
HXDLIN( 115)									if ((location >= 0)) {
HXLINE( 115)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE( 115)										_hx_tmp = false;
            									}
HXDLIN( 115)									if (_hx_tmp) {
HXLINE( 115)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 115)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 115)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 115)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 115)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 115)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE( 115)								::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 115)								int index;
HXDLIN( 115)								if (temp->useVirtualPos) {
HXLINE( 115)									index = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            								}
            								else {
HXLINE( 115)									index = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            								}
HXDLIN( 115)								int value;
HXDLIN( 115)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 115)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 115)									value = c;
            								}
HXDLIN( 115)								bool _hx_tmp;
HXDLIN( 115)								if ((index >= 0)) {
HXLINE( 115)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE( 115)									_hx_tmp = false;
            								}
HXDLIN( 115)								if (_hx_tmp) {
HXLINE( 115)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 115)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 115)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 115)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 115)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 115)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN( 115)						if ((p > maxX)) {
HXLINE( 247)							p = xx;
HXLINE( 115)							q = (q + 1);
            						}
HXDLIN( 115)						if ((q > maxY)) {
HXLINE( 115)							goto _hx_goto_7;
            						}
            					}
            					_hx_goto_7:;
            				}
            			}
HXLINE( 116)			{
HXLINE( 116)				Float ax = this->rx;
HXDLIN( 116)				Float ay = this->ry;
HXDLIN( 116)				::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN( 116)				bool hasHit = false;
HXDLIN( 116)				{
HXLINE( 116)					Float bx1 = bx;
HXDLIN( 116)					Float by1 = by;
HXDLIN( 116)					Float cx1 = cx;
HXDLIN( 116)					Float cy1 = cy;
HXDLIN( 116)					bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 116)					if (!(adjustWinding)) {
HXLINE( 116)						Float bx_ = bx1;
HXDLIN( 116)						Float by_ = by1;
HXLINE( 188)						bx1 = cx1;
HXLINE( 189)						by1 = cy1;
HXLINE( 190)						cx1 = bx_;
HXLINE( 191)						cy1 = by_;
            					}
HXLINE( 116)					{
HXLINE( 116)						bool hasUndo = false;
HXDLIN( 116)						Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 116)						Float sx = (cy1 - ay);
HXDLIN( 116)						Float sy = (ax - cx1);
HXDLIN( 116)						Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 116)						Float tx = (ay - by1);
HXDLIN( 116)						Float ty = (bx1 - ax);
HXDLIN( 116)						Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 116)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 116)						if ((ax > bx1)) {
HXLINE( 116)							if ((ax > cx1)) {
HXLINE( 116)								int min;
HXDLIN( 116)								if ((bx1 > cx1)) {
HXLINE( 116)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE( 116)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN( 116)								int ii_min = min;
HXDLIN( 116)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 116)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 116)								xIter3 = this1;
            							}
            							else {
HXLINE( 116)								int ii_min = ::Math_obj::floor(bx1);
HXDLIN( 116)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 116)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 116)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE( 116)							if ((bx1 > cx1)) {
HXLINE( 116)								int min;
HXDLIN( 116)								if ((ax > cx1)) {
HXLINE( 116)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE( 116)									min = ::Math_obj::ceil(ax);
            								}
HXDLIN( 116)								int ii_min = min;
HXDLIN( 116)								int ii_max = ::Math_obj::ceil(bx1);
HXDLIN( 116)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 116)								xIter3 = this1;
            							}
            							else {
HXLINE( 116)								int ii_min = ::Math_obj::floor(ax);
HXDLIN( 116)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 116)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 116)								xIter3 = this1;
            							}
            						}
HXDLIN( 116)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 116)						if ((ay > by1)) {
HXLINE( 116)							if ((ay > cy1)) {
HXLINE( 116)								int min;
HXDLIN( 116)								if ((by1 > cy1)) {
HXLINE( 116)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE( 116)									min = ::Math_obj::floor(by1);
            								}
HXDLIN( 116)								int ii_min = min;
HXDLIN( 116)								int ii_max = ::Math_obj::ceil(ay);
HXDLIN( 116)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 116)								yIter3 = this1;
            							}
            							else {
HXLINE( 116)								int ii_min = ::Math_obj::floor(by1);
HXDLIN( 116)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 116)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 116)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE( 116)							if ((by1 > cy1)) {
HXLINE( 116)								int min;
HXDLIN( 116)								if ((ay > cy1)) {
HXLINE( 116)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE( 116)									min = ::Math_obj::ceil(ay);
            								}
HXDLIN( 116)								int ii_min = min;
HXDLIN( 116)								int ii_max = ::Math_obj::ceil(by1);
HXDLIN( 116)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 116)								yIter3 = this1;
            							}
            							else {
HXLINE( 116)								int ii_min = ::Math_obj::floor(ay);
HXDLIN( 116)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 116)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 116)								yIter3 = this1;
            							}
            						}
HXDLIN( 116)						::pixelimage::ImageStruct undoImage = null();
HXDLIN( 116)						if (hasUndo) {
HXLINE( 116)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 116)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 116)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 116)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 116)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 116)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 116)							undoImage = this3;
HXDLIN( 116)							{
HXLINE( 116)								int rectLeft = xIter3->start;
HXDLIN( 116)								int rectTop = yIter3->start;
HXDLIN( 116)								int rectRight = xIter3->max;
HXDLIN( 116)								bool forceClear = false;
HXDLIN( 116)								{
HXLINE( 116)									int _g = rectTop;
HXDLIN( 116)									int _g1 = yIter3->max;
HXDLIN( 116)									while((_g < _g1)){
HXLINE( 116)										_g = (_g + 1);
HXDLIN( 116)										int dy = (_g - 1);
HXDLIN( 116)										{
HXLINE( 116)											int _g1 = rectLeft;
HXDLIN( 116)											int _g2 = rectRight;
HXDLIN( 116)											while((_g1 < _g2)){
HXLINE( 116)												_g1 = (_g1 + 1);
HXDLIN( 116)												int dx = (_g1 - 1);
HXDLIN( 116)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 116)												int index;
HXDLIN( 116)												if (temp->useVirtualPos) {
HXLINE( 116)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE( 116)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN( 116)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 116)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 116)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 116)												int col;
HXDLIN( 116)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 116)													col = c;
            												}
HXDLIN( 116)												bool _hx_tmp;
HXDLIN( 116)												if (temp->useMask) {
HXLINE( 116)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE( 116)													_hx_tmp = false;
            												}
HXDLIN( 116)												if (_hx_tmp) {
HXLINE( 116)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 116)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 116)													int index;
HXDLIN( 116)													if (this1->useVirtualPos) {
HXLINE( 116)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 116)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 116)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 116)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 116)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 116)													int v;
HXDLIN( 116)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 116)														v = c;
            													}
HXDLIN( 116)													int this3 = v;
HXDLIN( 116)													int maskPixel = this3;
HXDLIN( 116)													int this4 = col;
HXDLIN( 116)													int this5 = this4;
HXDLIN( 116)													if ((maskPixel == 0)) {
HXLINE( 116)														int this1 = this5;
HXDLIN( 116)														col = this1;
            													}
            													else {
HXLINE( 116)														Float m0;
HXDLIN( 116)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 116)														if ((this1 == 0)) {
HXLINE( 116)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float m1;
HXDLIN( 116)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 116)														if ((this2 == 0)) {
HXLINE( 116)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float m2;
HXDLIN( 116)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 116)														if ((this3 == 0)) {
HXLINE( 116)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float m3;
HXDLIN( 116)														int this4 = (maskPixel & 255);
HXDLIN( 116)														if ((this4 == 0)) {
HXLINE( 116)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 116)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 116)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 116)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 116)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 116)												if ((col != 0)) {
HXLINE( 116)													int x = (dx - rectLeft);
HXDLIN( 116)													int y = (dy - rectTop);
HXDLIN( 116)													int this1 = col;
HXDLIN( 116)													int c = this1;
HXDLIN( 116)													bool _hx_tmp;
HXDLIN( 116)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 116)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE( 116)														_hx_tmp = false;
            													}
HXDLIN( 116)													if (_hx_tmp) {
HXLINE( 116)														int location;
HXDLIN( 116)														if (undoImage->useVirtualPos) {
HXLINE( 116)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 116)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 116)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 116)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 116)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 116)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 116)														int this3 = this2;
HXDLIN( 116)														int this4;
HXDLIN( 116)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 116)															this4 = this3;
            														}
HXDLIN( 116)														Float a1;
HXDLIN( 116)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 116)														if ((this5 == 0)) {
HXLINE( 116)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float r1;
HXDLIN( 116)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 116)														if ((this6 == 0)) {
HXLINE( 116)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float g1;
HXDLIN( 116)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 116)														if ((this7 == 0)) {
HXLINE( 116)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float b1;
HXDLIN( 116)														int this8 = (this4 & 255);
HXDLIN( 116)														if ((this8 == 0)) {
HXLINE( 116)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float a2;
HXDLIN( 116)														int this9 = ((col >> 24) & 255);
HXDLIN( 116)														if ((this9 == 0)) {
HXLINE( 116)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float r2;
HXDLIN( 116)														int this10 = ((col >> 16) & 255);
HXDLIN( 116)														if ((this10 == 0)) {
HXLINE( 116)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float g2;
HXDLIN( 116)														int this11 = ((col >> 8) & 255);
HXDLIN( 116)														if ((this11 == 0)) {
HXLINE( 116)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float b2;
HXDLIN( 116)														int this12 = (col & 255);
HXDLIN( 116)														if ((this12 == 0)) {
HXLINE( 116)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 116)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 116)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 116)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 116)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 116)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 116)														{
HXLINE( 116)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 116)															int value;
HXDLIN( 116)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 116)																value = blended;
            															}
HXDLIN( 116)															bool _hx_tmp;
HXDLIN( 116)															if ((location >= 0)) {
HXLINE( 116)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 116)																_hx_tmp = false;
            															}
HXDLIN( 116)															if (_hx_tmp) {
HXLINE( 116)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 116)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 116)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 116)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 116)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 116)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 116)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 116)														int index;
HXDLIN( 116)														if (undoImage->useVirtualPos) {
HXLINE( 116)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 116)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 116)														int value;
HXDLIN( 116)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 116)															value = c;
            														}
HXDLIN( 116)														bool _hx_tmp;
HXDLIN( 116)														if ((index >= 0)) {
HXLINE( 116)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 116)															_hx_tmp = false;
            														}
HXDLIN( 116)														if (_hx_tmp) {
HXLINE( 116)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 116)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 116)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 116)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 116)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 116)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 116)													if (forceClear) {
HXLINE( 116)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 116)														int x = (dx - rectLeft);
HXDLIN( 116)														int y = (dy - rectTop);
HXDLIN( 116)														int index;
HXDLIN( 116)														if (undoImage->useVirtualPos) {
HXLINE( 116)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 116)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 116)														bool _hx_tmp;
HXDLIN( 116)														if ((index >= 0)) {
HXLINE( 116)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 116)															_hx_tmp = false;
            														}
HXDLIN( 116)														if (_hx_tmp) {
HXLINE( 116)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 116)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 116)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 116)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 116)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 116)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 116)						bool foundY = false;
HXDLIN( 116)						Float s = ((Float)0.);
HXDLIN( 116)						Float t = ((Float)0.);
HXDLIN( 116)						Float sxx = ((Float)0.);
HXDLIN( 116)						Float txx = ((Float)0.);
HXDLIN( 116)						{
HXLINE( 116)							int _g_min = xIter3->start;
HXDLIN( 116)							int _g_max = xIter3->max;
HXDLIN( 116)							while((_g_min < _g_max)){
HXLINE( 116)								_g_min = (_g_min + 1);
HXDLIN( 116)								int x = (_g_min - 1);
HXLINE( 223)								sxx = (sx * ( (Float)(x) ));
HXLINE( 224)								txx = (tx * ( (Float)(x) ));
HXLINE( 225)								foundY = false;
HXLINE( 116)								{
HXLINE( 116)									int _g_min1 = yIter3->start;
HXDLIN( 116)									int _g_max = yIter3->max;
HXDLIN( 116)									while((_g_min1 < _g_max)){
HXLINE( 116)										_g_min1 = (_g_min1 + 1);
HXDLIN( 116)										int y = (_g_min1 - 1);
HXLINE( 227)										s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)										t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 116)										bool _hx_tmp;
HXDLIN( 116)										if (!((s <= 0))) {
HXLINE( 116)											_hx_tmp = (t <= 0);
            										}
            										else {
HXLINE( 116)											_hx_tmp = true;
            										}
HXDLIN( 116)										if (_hx_tmp) {
HXLINE( 116)											if (foundY) {
HXLINE( 116)												goto _hx_goto_11;
            											}
            										}
            										else {
HXLINE( 116)											if (((s + t) < A)) {
HXLINE( 116)												int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN( 116)												int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN( 116)												::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN( 116)												int index;
HXDLIN( 116)												if (tileImage->useVirtualPos) {
HXLINE( 116)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            												}
            												else {
HXLINE( 116)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            												}
HXDLIN( 116)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 116)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 116)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 116)												int color;
HXDLIN( 116)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 116)													color = c;
            												}
HXDLIN( 116)												{
HXLINE( 116)													int this2 = color;
HXDLIN( 116)													int c1 = this2;
HXDLIN( 116)													bool _hx_tmp;
HXDLIN( 116)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 116)														_hx_tmp = temp->transparent;
            													}
            													else {
HXLINE( 116)														_hx_tmp = false;
            													}
HXDLIN( 116)													if (_hx_tmp) {
HXLINE( 116)														int location;
HXDLIN( 116)														if (temp->useVirtualPos) {
HXLINE( 116)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 116)															location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 116)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 116)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 116)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 116)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 116)														int this3 = this2;
HXDLIN( 116)														int this4;
HXDLIN( 116)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 116)															this4 = this3;
            														}
HXDLIN( 116)														Float a1;
HXDLIN( 116)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 116)														if ((this5 == 0)) {
HXLINE( 116)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float r1;
HXDLIN( 116)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 116)														if ((this6 == 0)) {
HXLINE( 116)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float g1;
HXDLIN( 116)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 116)														if ((this7 == 0)) {
HXLINE( 116)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float b1;
HXDLIN( 116)														int this8 = (this4 & 255);
HXDLIN( 116)														if ((this8 == 0)) {
HXLINE( 116)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float a2;
HXDLIN( 116)														int this9 = ((color >> 24) & 255);
HXDLIN( 116)														if ((this9 == 0)) {
HXLINE( 116)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float r2;
HXDLIN( 116)														int this10 = ((color >> 16) & 255);
HXDLIN( 116)														if ((this10 == 0)) {
HXLINE( 116)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float g2;
HXDLIN( 116)														int this11 = ((color >> 8) & 255);
HXDLIN( 116)														if ((this11 == 0)) {
HXLINE( 116)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float b2;
HXDLIN( 116)														int this12 = (color & 255);
HXDLIN( 116)														if ((this12 == 0)) {
HXLINE( 116)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 116)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 116)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 116)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 116)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 116)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 116)														{
HXLINE( 116)															::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 116)															int value;
HXDLIN( 116)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 116)																value = blended;
            															}
HXDLIN( 116)															bool _hx_tmp;
HXDLIN( 116)															if ((location >= 0)) {
HXLINE( 116)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 116)																_hx_tmp = false;
            															}
HXDLIN( 116)															if (_hx_tmp) {
HXLINE( 116)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 116)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 116)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 116)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 116)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 116)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 116)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 116)														int index;
HXDLIN( 116)														if (temp->useVirtualPos) {
HXLINE( 116)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 116)															index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 116)														int value;
HXDLIN( 116)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE( 116)															value = c1;
            														}
HXDLIN( 116)														bool _hx_tmp;
HXDLIN( 116)														if ((index >= 0)) {
HXLINE( 116)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 116)															_hx_tmp = false;
            														}
HXDLIN( 116)														if (_hx_tmp) {
HXLINE( 116)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 116)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 116)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 116)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 116)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 116)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY = true;
            											}
            											else {
HXLINE( 116)												if (foundY) {
HXLINE( 116)													goto _hx_goto_11;
            												}
            											}
            										}
            									}
            									_hx_goto_11:;
            								}
            							}
            						}
HXDLIN( 116)						if ((hasHit == false)) {
HXLINE( 116)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 116)							if (hasUndo) {
HXLINE( 116)								v->undoImage = undoImage;
HXDLIN( 116)								v->undoX = xIter3->start;
HXDLIN( 116)								v->undoY = yIter3->start;
            							}
            						}
            					}
            				}
            			}
HXLINE( 117)			{
HXLINE( 117)				Float ax1 = this->rx;
HXDLIN( 117)				Float ay1 = this->ry;
HXDLIN( 117)				bool hasHit1 = false;
HXDLIN( 117)				bool hasUndo1 = false;
HXDLIN( 117)				{
HXLINE( 117)					Float bx2 = bxS;
HXDLIN( 117)					Float by2 = byS;
HXDLIN( 117)					Float cx2 = cxS;
HXDLIN( 117)					Float cy2 = cyS;
HXDLIN( 117)					bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN( 117)					if (!(adjustWinding1)) {
HXLINE( 117)						Float bx_ = bx2;
HXDLIN( 117)						Float by_ = by2;
HXLINE(  26)						bx2 = cx2;
HXLINE(  27)						by2 = cy2;
HXLINE(  28)						cx2 = bx_;
HXLINE(  29)						cy2 = by_;
            					}
HXLINE( 117)					{
HXLINE( 117)						Float s01 = ((ay1 * cx2) - (ax1 * cy2));
HXDLIN( 117)						Float sx1 = (cy2 - ay1);
HXDLIN( 117)						Float sy1 = (ax1 - cx2);
HXDLIN( 117)						Float t01 = ((ax1 * by2) - (ay1 * bx2));
HXDLIN( 117)						Float tx1 = (ay1 - by2);
HXDLIN( 117)						Float ty1 = (bx2 - ax1);
HXDLIN( 117)						Float A1 = ((((-(by2) * cx2) + (ay1 * (-(bx2) + cx2))) + (ax1 * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 117)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 117)						if ((ax1 > bx2)) {
HXLINE( 117)							if ((ax1 > cx2)) {
HXLINE( 117)								int min;
HXDLIN( 117)								if ((bx2 > cx2)) {
HXLINE( 117)									min = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE( 117)									min = ::Math_obj::floor(bx2);
            								}
HXDLIN( 117)								int ii_min = min;
HXDLIN( 117)								int ii_max = ::Math_obj::ceil(ax1);
HXDLIN( 117)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 117)								xIter31 = this1;
            							}
            							else {
HXLINE( 117)								int ii_min = ::Math_obj::floor(bx2);
HXDLIN( 117)								int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 117)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 117)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE( 117)							if ((bx2 > cx2)) {
HXLINE( 117)								int min;
HXDLIN( 117)								if ((ax1 > cx2)) {
HXLINE( 117)									min = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE( 117)									min = ::Math_obj::ceil(ax1);
            								}
HXDLIN( 117)								int ii_min = min;
HXDLIN( 117)								int ii_max = ::Math_obj::ceil(bx2);
HXDLIN( 117)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 117)								xIter31 = this1;
            							}
            							else {
HXLINE( 117)								int ii_min = ::Math_obj::floor(ax1);
HXDLIN( 117)								int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 117)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 117)								xIter31 = this1;
            							}
            						}
HXDLIN( 117)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 117)						if ((ay1 > by2)) {
HXLINE( 117)							if ((ay1 > cy2)) {
HXLINE( 117)								int min;
HXDLIN( 117)								if ((by2 > cy2)) {
HXLINE( 117)									min = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE( 117)									min = ::Math_obj::floor(by2);
            								}
HXDLIN( 117)								int ii_min = min;
HXDLIN( 117)								int ii_max = ::Math_obj::ceil(ay1);
HXDLIN( 117)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 117)								yIter31 = this1;
            							}
            							else {
HXLINE( 117)								int ii_min = ::Math_obj::floor(by2);
HXDLIN( 117)								int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 117)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 117)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE( 117)							if ((by2 > cy2)) {
HXLINE( 117)								int min;
HXDLIN( 117)								if ((ay1 > cy2)) {
HXLINE( 117)									min = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE( 117)									min = ::Math_obj::ceil(ay1);
            								}
HXDLIN( 117)								int ii_min = min;
HXDLIN( 117)								int ii_max = ::Math_obj::ceil(by2);
HXDLIN( 117)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 117)								yIter31 = this1;
            							}
            							else {
HXLINE( 117)								int ii_min = ::Math_obj::floor(ay1);
HXDLIN( 117)								int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 117)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 117)								yIter31 = this1;
            							}
            						}
HXDLIN( 117)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 117)						if (hasUndo1) {
HXLINE( 117)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 117)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 117)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 117)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 117)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 117)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 117)							undoImage1 = this3;
HXDLIN( 117)							{
HXLINE( 117)								int rectLeft = xIter31->start;
HXDLIN( 117)								int rectTop = yIter31->start;
HXDLIN( 117)								int rectRight = xIter31->max;
HXDLIN( 117)								bool forceClear = false;
HXDLIN( 117)								{
HXLINE( 117)									int _g = rectTop;
HXDLIN( 117)									int _g1 = yIter31->max;
HXDLIN( 117)									while((_g < _g1)){
HXLINE( 117)										_g = (_g + 1);
HXDLIN( 117)										int dy = (_g - 1);
HXDLIN( 117)										{
HXLINE( 117)											int _g1 = rectLeft;
HXDLIN( 117)											int _g2 = rectRight;
HXDLIN( 117)											while((_g1 < _g2)){
HXLINE( 117)												_g1 = (_g1 + 1);
HXDLIN( 117)												int dx = (_g1 - 1);
HXDLIN( 117)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 117)												int index;
HXDLIN( 117)												if (temp->useVirtualPos) {
HXLINE( 117)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE( 117)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN( 117)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 117)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 117)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 117)												int col;
HXDLIN( 117)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 117)													col = c;
            												}
HXDLIN( 117)												bool _hx_tmp;
HXDLIN( 117)												if (temp->useMask) {
HXLINE( 117)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE( 117)													_hx_tmp = false;
            												}
HXDLIN( 117)												if (_hx_tmp) {
HXLINE( 117)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 117)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 117)													int index;
HXDLIN( 117)													if (this1->useVirtualPos) {
HXLINE( 117)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 117)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 117)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 117)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 117)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 117)													int v;
HXDLIN( 117)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 117)														v = c;
            													}
HXDLIN( 117)													int this3 = v;
HXDLIN( 117)													int maskPixel = this3;
HXDLIN( 117)													int this4 = col;
HXDLIN( 117)													int this5 = this4;
HXDLIN( 117)													if ((maskPixel == 0)) {
HXLINE( 117)														int this1 = this5;
HXDLIN( 117)														col = this1;
            													}
            													else {
HXLINE( 117)														Float m0;
HXDLIN( 117)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 117)														if ((this1 == 0)) {
HXLINE( 117)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float m1;
HXDLIN( 117)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 117)														if ((this2 == 0)) {
HXLINE( 117)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float m2;
HXDLIN( 117)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 117)														if ((this3 == 0)) {
HXLINE( 117)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float m3;
HXDLIN( 117)														int this4 = (maskPixel & 255);
HXDLIN( 117)														if ((this4 == 0)) {
HXLINE( 117)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 117)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 117)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 117)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 117)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 117)												if ((col != 0)) {
HXLINE( 117)													int x = (dx - rectLeft);
HXDLIN( 117)													int y = (dy - rectTop);
HXDLIN( 117)													int this1 = col;
HXDLIN( 117)													int c = this1;
HXDLIN( 117)													bool _hx_tmp;
HXDLIN( 117)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 117)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE( 117)														_hx_tmp = false;
            													}
HXDLIN( 117)													if (_hx_tmp) {
HXLINE( 117)														int location;
HXDLIN( 117)														if (undoImage1->useVirtualPos) {
HXLINE( 117)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 117)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 117)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 117)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 117)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 117)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 117)														int this3 = this2;
HXDLIN( 117)														int this4;
HXDLIN( 117)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 117)															this4 = this3;
            														}
HXDLIN( 117)														Float a1;
HXDLIN( 117)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 117)														if ((this5 == 0)) {
HXLINE( 117)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float r1;
HXDLIN( 117)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 117)														if ((this6 == 0)) {
HXLINE( 117)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float g1;
HXDLIN( 117)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 117)														if ((this7 == 0)) {
HXLINE( 117)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float b1;
HXDLIN( 117)														int this8 = (this4 & 255);
HXDLIN( 117)														if ((this8 == 0)) {
HXLINE( 117)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float a2;
HXDLIN( 117)														int this9 = ((col >> 24) & 255);
HXDLIN( 117)														if ((this9 == 0)) {
HXLINE( 117)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float r2;
HXDLIN( 117)														int this10 = ((col >> 16) & 255);
HXDLIN( 117)														if ((this10 == 0)) {
HXLINE( 117)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float g2;
HXDLIN( 117)														int this11 = ((col >> 8) & 255);
HXDLIN( 117)														if ((this11 == 0)) {
HXLINE( 117)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float b2;
HXDLIN( 117)														int this12 = (col & 255);
HXDLIN( 117)														if ((this12 == 0)) {
HXLINE( 117)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 117)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 117)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 117)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 117)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 117)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 117)														{
HXLINE( 117)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 117)															int value;
HXDLIN( 117)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 117)																value = blended;
            															}
HXDLIN( 117)															bool _hx_tmp;
HXDLIN( 117)															if ((location >= 0)) {
HXLINE( 117)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 117)																_hx_tmp = false;
            															}
HXDLIN( 117)															if (_hx_tmp) {
HXLINE( 117)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 117)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 117)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 117)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 117)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 117)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 117)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 117)														int index;
HXDLIN( 117)														if (undoImage1->useVirtualPos) {
HXLINE( 117)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 117)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 117)														int value;
HXDLIN( 117)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 117)															value = c;
            														}
HXDLIN( 117)														bool _hx_tmp;
HXDLIN( 117)														if ((index >= 0)) {
HXLINE( 117)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 117)															_hx_tmp = false;
            														}
HXDLIN( 117)														if (_hx_tmp) {
HXLINE( 117)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 117)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 117)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 117)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 117)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 117)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 117)													if (forceClear) {
HXLINE( 117)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 117)														int x = (dx - rectLeft);
HXDLIN( 117)														int y = (dy - rectTop);
HXDLIN( 117)														int index;
HXDLIN( 117)														if (undoImage1->useVirtualPos) {
HXLINE( 117)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 117)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 117)														bool _hx_tmp;
HXDLIN( 117)														if ((index >= 0)) {
HXLINE( 117)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 117)															_hx_tmp = false;
            														}
HXDLIN( 117)														if (_hx_tmp) {
HXLINE( 117)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 117)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 117)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 117)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 117)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 117)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 117)						bool found = false;
HXDLIN( 117)						Float s1 = ((Float)0.);
HXDLIN( 117)						Float t1 = ((Float)0.);
HXDLIN( 117)						Float sxx1 = ((Float)0.);
HXDLIN( 117)						Float txx1 = ((Float)0.);
HXDLIN( 117)						{
HXLINE( 117)							int _g_min1 = xIter31->start;
HXDLIN( 117)							int _g_max1 = xIter31->max;
HXDLIN( 117)							while((_g_min1 < _g_max1)){
HXLINE( 117)								_g_min1 = (_g_min1 + 1);
HXDLIN( 117)								int x = (_g_min1 - 1);
HXLINE(  61)								sxx1 = (sx1 * ( (Float)(x) ));
HXLINE(  62)								txx1 = (tx1 * ( (Float)(x) ));
HXLINE(  63)								found = false;
HXLINE( 117)								{
HXLINE( 117)									int _g_min = yIter31->start;
HXDLIN( 117)									int _g_max = yIter31->max;
HXDLIN( 117)									while((_g_min < _g_max)){
HXLINE( 117)										_g_min = (_g_min + 1);
HXDLIN( 117)										int y = (_g_min - 1);
HXLINE(  65)										s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE(  66)										t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE( 117)										bool _hx_tmp;
HXDLIN( 117)										if (!((s1 <= 0))) {
HXLINE( 117)											_hx_tmp = (t1 <= 0);
            										}
            										else {
HXLINE( 117)											_hx_tmp = true;
            										}
HXDLIN( 117)										if (_hx_tmp) {
HXLINE( 117)											if (found) {
HXLINE( 117)												goto _hx_goto_15;
            											}
            										}
            										else {
HXLINE( 117)											if (((s1 + t1) < A1)) {
HXLINE( 117)												{
HXLINE( 117)													int this1 = 0;
HXDLIN( 117)													int c = this1;
HXDLIN( 117)													bool _hx_tmp;
HXDLIN( 117)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 117)														_hx_tmp = temp->transparent;
            													}
            													else {
HXLINE( 117)														_hx_tmp = false;
            													}
HXDLIN( 117)													if (_hx_tmp) {
HXLINE( 117)														int location;
HXDLIN( 117)														if (temp->useVirtualPos) {
HXLINE( 117)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 117)															location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 117)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 117)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 117)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 117)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 117)														int this3 = this2;
HXDLIN( 117)														int this4;
HXDLIN( 117)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 117)															this4 = this3;
            														}
HXDLIN( 117)														Float a1;
HXDLIN( 117)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 117)														if ((this5 == 0)) {
HXLINE( 117)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float r1;
HXDLIN( 117)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 117)														if ((this6 == 0)) {
HXLINE( 117)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float g1;
HXDLIN( 117)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 117)														if ((this7 == 0)) {
HXLINE( 117)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float b1;
HXDLIN( 117)														int this8 = (this4 & 255);
HXDLIN( 117)														if ((this8 == 0)) {
HXLINE( 117)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float a2;
HXDLIN( 117)														int this9 = ((0 >> 24) & 255);
HXDLIN( 117)														if ((this9 == 0)) {
HXLINE( 117)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float r2;
HXDLIN( 117)														int this10 = ((0 >> 16) & 255);
HXDLIN( 117)														if ((this10 == 0)) {
HXLINE( 117)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float g2;
HXDLIN( 117)														int this11 = ((0 >> 8) & 255);
HXDLIN( 117)														if ((this11 == 0)) {
HXLINE( 117)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float b2;
HXDLIN( 117)														int this12 = (0 & 255);
HXDLIN( 117)														if ((this12 == 0)) {
HXLINE( 117)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 117)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 117)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 117)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 117)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 117)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 117)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 117)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 117)														{
HXLINE( 117)															::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 117)															int value;
HXDLIN( 117)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 117)																value = blended;
            															}
HXDLIN( 117)															bool _hx_tmp;
HXDLIN( 117)															if ((location >= 0)) {
HXLINE( 117)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 117)																_hx_tmp = false;
            															}
HXDLIN( 117)															if (_hx_tmp) {
HXLINE( 117)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 117)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 117)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 117)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 117)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 117)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 117)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 117)														int index;
HXDLIN( 117)														if (temp->useVirtualPos) {
HXLINE( 117)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 117)															index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 117)														int value;
HXDLIN( 117)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 117)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 117)															value = c;
            														}
HXDLIN( 117)														bool _hx_tmp;
HXDLIN( 117)														if ((index >= 0)) {
HXLINE( 117)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 117)															_hx_tmp = false;
            														}
HXDLIN( 117)														if (_hx_tmp) {
HXLINE( 117)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 117)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 117)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 117)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 117)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 117)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found = true;
            											}
            											else {
HXLINE( 117)												if (found) {
HXLINE( 117)													goto _hx_goto_15;
            												}
            											}
            										}
            									}
            									_hx_goto_15:;
            								}
            							}
            						}
HXDLIN( 117)						if ((hasHit1 == true)) {
HXLINE( 117)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx2,by2,cx2,cy2,true);
HXDLIN( 117)							if (hasUndo1) {
HXLINE( 117)								v->undoImage = undoImage1;
HXDLIN( 117)								v->undoX = xIter31->start;
HXDLIN( 117)								v->undoY = yIter31->start;
            							}
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE( 119)			{
HXLINE( 119)				Float ax = this->rx;
HXDLIN( 119)				Float ay = this->ry;
HXDLIN( 119)				Float rx = this->rx;
HXDLIN( 119)				Float ry = this->ry;
HXDLIN( 119)				::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN( 119)				bool hasHit = false;
HXDLIN( 119)				Float currAngle = endAngle;
HXDLIN( 119)				Float bx1 = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXDLIN( 119)				Float by1 = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 403)				currAngle = (endAngle + (((( (Float)(2) ) * ::Math_obj::PI) - this->sweepAngle) + ((Float)0.01)));
HXLINE( 119)				Float cx1 = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXDLIN( 119)				Float cy1 = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXDLIN( 119)				{
HXLINE( 119)					Float bx2 = bx1;
HXDLIN( 119)					Float by2 = by1;
HXDLIN( 119)					Float cx2 = cx1;
HXDLIN( 119)					Float cy2 = cy1;
HXDLIN( 119)					bool adjustWinding = (((((ax * by2) - (bx2 * ay)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay) - (ax * cy2))) > 0);
HXDLIN( 119)					if (!(adjustWinding)) {
HXLINE( 119)						Float bx_ = bx2;
HXDLIN( 119)						Float by_ = by2;
HXLINE( 188)						bx2 = cx2;
HXLINE( 189)						by2 = cy2;
HXLINE( 190)						cx2 = bx_;
HXLINE( 191)						cy2 = by_;
            					}
HXLINE( 119)					{
HXLINE( 119)						bool hasUndo = false;
HXDLIN( 119)						Float s0 = ((ay * cx2) - (ax * cy2));
HXDLIN( 119)						Float sx = (cy2 - ay);
HXDLIN( 119)						Float sy = (ax - cx2);
HXDLIN( 119)						Float t0 = ((ax * by2) - (ay * bx2));
HXDLIN( 119)						Float tx = (ay - by2);
HXDLIN( 119)						Float ty = (bx2 - ax);
HXDLIN( 119)						Float A = ((((-(by2) * cx2) + (ay * (-(bx2) + cx2))) + (ax * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 119)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 119)						if ((ax > bx2)) {
HXLINE( 119)							if ((ax > cx2)) {
HXLINE( 119)								int min;
HXDLIN( 119)								if ((bx2 > cx2)) {
HXLINE( 119)									min = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE( 119)									min = ::Math_obj::floor(bx2);
            								}
HXDLIN( 119)								int ii_min = min;
HXDLIN( 119)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 119)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 119)								xIter3 = this1;
            							}
            							else {
HXLINE( 119)								int ii_min = ::Math_obj::floor(bx2);
HXDLIN( 119)								int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 119)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 119)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE( 119)							if ((bx2 > cx2)) {
HXLINE( 119)								int min;
HXDLIN( 119)								if ((ax > cx2)) {
HXLINE( 119)									min = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE( 119)									min = ::Math_obj::ceil(ax);
            								}
HXDLIN( 119)								int ii_min = min;
HXDLIN( 119)								int ii_max = ::Math_obj::ceil(bx2);
HXDLIN( 119)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 119)								xIter3 = this1;
            							}
            							else {
HXLINE( 119)								int ii_min = ::Math_obj::floor(ax);
HXDLIN( 119)								int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 119)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 119)								xIter3 = this1;
            							}
            						}
HXDLIN( 119)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 119)						if ((ay > by2)) {
HXLINE( 119)							if ((ay > cy2)) {
HXLINE( 119)								int min;
HXDLIN( 119)								if ((by2 > cy2)) {
HXLINE( 119)									min = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE( 119)									min = ::Math_obj::floor(by2);
            								}
HXDLIN( 119)								int ii_min = min;
HXDLIN( 119)								int ii_max = ::Math_obj::ceil(ay);
HXDLIN( 119)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 119)								yIter3 = this1;
            							}
            							else {
HXLINE( 119)								int ii_min = ::Math_obj::floor(by2);
HXDLIN( 119)								int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 119)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 119)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE( 119)							if ((by2 > cy2)) {
HXLINE( 119)								int min;
HXDLIN( 119)								if ((ay > cy2)) {
HXLINE( 119)									min = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE( 119)									min = ::Math_obj::ceil(ay);
            								}
HXDLIN( 119)								int ii_min = min;
HXDLIN( 119)								int ii_max = ::Math_obj::ceil(by2);
HXDLIN( 119)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 119)								yIter3 = this1;
            							}
            							else {
HXLINE( 119)								int ii_min = ::Math_obj::floor(ay);
HXDLIN( 119)								int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 119)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 119)								yIter3 = this1;
            							}
            						}
HXDLIN( 119)						::pixelimage::ImageStruct undoImage = null();
HXDLIN( 119)						if (hasUndo) {
HXLINE( 119)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 119)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 119)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 119)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 119)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 119)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 119)							undoImage = this3;
HXDLIN( 119)							{
HXLINE( 119)								int rectLeft = xIter3->start;
HXDLIN( 119)								int rectTop = yIter3->start;
HXDLIN( 119)								int rectRight = xIter3->max;
HXDLIN( 119)								bool forceClear = false;
HXDLIN( 119)								{
HXLINE( 119)									int _g = rectTop;
HXDLIN( 119)									int _g1 = yIter3->max;
HXDLIN( 119)									while((_g < _g1)){
HXLINE( 119)										_g = (_g + 1);
HXDLIN( 119)										int dy = (_g - 1);
HXDLIN( 119)										{
HXLINE( 119)											int _g1 = rectLeft;
HXDLIN( 119)											int _g2 = rectRight;
HXDLIN( 119)											while((_g1 < _g2)){
HXLINE( 119)												_g1 = (_g1 + 1);
HXDLIN( 119)												int dx = (_g1 - 1);
HXDLIN( 119)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 119)												int index;
HXDLIN( 119)												if (temp->useVirtualPos) {
HXLINE( 119)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE( 119)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN( 119)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 119)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 119)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 119)												int col;
HXDLIN( 119)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 119)													col = c;
            												}
HXDLIN( 119)												bool _hx_tmp;
HXDLIN( 119)												if (temp->useMask) {
HXLINE( 119)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE( 119)													_hx_tmp = false;
            												}
HXDLIN( 119)												if (_hx_tmp) {
HXLINE( 119)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 119)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 119)													int index;
HXDLIN( 119)													if (this1->useVirtualPos) {
HXLINE( 119)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 119)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 119)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 119)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 119)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 119)													int v;
HXDLIN( 119)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 119)														v = c;
            													}
HXDLIN( 119)													int this3 = v;
HXDLIN( 119)													int maskPixel = this3;
HXDLIN( 119)													int this4 = col;
HXDLIN( 119)													int this5 = this4;
HXDLIN( 119)													if ((maskPixel == 0)) {
HXLINE( 119)														int this1 = this5;
HXDLIN( 119)														col = this1;
            													}
            													else {
HXLINE( 119)														Float m0;
HXDLIN( 119)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 119)														if ((this1 == 0)) {
HXLINE( 119)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float m1;
HXDLIN( 119)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 119)														if ((this2 == 0)) {
HXLINE( 119)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float m2;
HXDLIN( 119)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 119)														if ((this3 == 0)) {
HXLINE( 119)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float m3;
HXDLIN( 119)														int this4 = (maskPixel & 255);
HXDLIN( 119)														if ((this4 == 0)) {
HXLINE( 119)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 119)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 119)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 119)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 119)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 119)												if ((col != 0)) {
HXLINE( 119)													int x = (dx - rectLeft);
HXDLIN( 119)													int y = (dy - rectTop);
HXDLIN( 119)													int this1 = col;
HXDLIN( 119)													int c = this1;
HXDLIN( 119)													bool _hx_tmp;
HXDLIN( 119)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 119)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE( 119)														_hx_tmp = false;
            													}
HXDLIN( 119)													if (_hx_tmp) {
HXLINE( 119)														int location;
HXDLIN( 119)														if (undoImage->useVirtualPos) {
HXLINE( 119)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 119)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 119)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 119)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 119)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 119)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 119)														int this3 = this2;
HXDLIN( 119)														int this4;
HXDLIN( 119)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 119)															this4 = this3;
            														}
HXDLIN( 119)														Float a1;
HXDLIN( 119)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 119)														if ((this5 == 0)) {
HXLINE( 119)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float r1;
HXDLIN( 119)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 119)														if ((this6 == 0)) {
HXLINE( 119)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float g1;
HXDLIN( 119)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 119)														if ((this7 == 0)) {
HXLINE( 119)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float b1;
HXDLIN( 119)														int this8 = (this4 & 255);
HXDLIN( 119)														if ((this8 == 0)) {
HXLINE( 119)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float a2;
HXDLIN( 119)														int this9 = ((col >> 24) & 255);
HXDLIN( 119)														if ((this9 == 0)) {
HXLINE( 119)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float r2;
HXDLIN( 119)														int this10 = ((col >> 16) & 255);
HXDLIN( 119)														if ((this10 == 0)) {
HXLINE( 119)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float g2;
HXDLIN( 119)														int this11 = ((col >> 8) & 255);
HXDLIN( 119)														if ((this11 == 0)) {
HXLINE( 119)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float b2;
HXDLIN( 119)														int this12 = (col & 255);
HXDLIN( 119)														if ((this12 == 0)) {
HXLINE( 119)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 119)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 119)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 119)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 119)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 119)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 119)														{
HXLINE( 119)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 119)															int value;
HXDLIN( 119)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 119)																value = blended;
            															}
HXDLIN( 119)															bool _hx_tmp;
HXDLIN( 119)															if ((location >= 0)) {
HXLINE( 119)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 119)																_hx_tmp = false;
            															}
HXDLIN( 119)															if (_hx_tmp) {
HXLINE( 119)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 119)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 119)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 119)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 119)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 119)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 119)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 119)														int index;
HXDLIN( 119)														if (undoImage->useVirtualPos) {
HXLINE( 119)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 119)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 119)														int value;
HXDLIN( 119)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 119)															value = c;
            														}
HXDLIN( 119)														bool _hx_tmp;
HXDLIN( 119)														if ((index >= 0)) {
HXLINE( 119)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 119)															_hx_tmp = false;
            														}
HXDLIN( 119)														if (_hx_tmp) {
HXLINE( 119)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 119)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 119)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 119)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 119)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 119)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 119)													if (forceClear) {
HXLINE( 119)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 119)														int x = (dx - rectLeft);
HXDLIN( 119)														int y = (dy - rectTop);
HXDLIN( 119)														int index;
HXDLIN( 119)														if (undoImage->useVirtualPos) {
HXLINE( 119)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 119)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 119)														bool _hx_tmp;
HXDLIN( 119)														if ((index >= 0)) {
HXLINE( 119)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 119)															_hx_tmp = false;
            														}
HXDLIN( 119)														if (_hx_tmp) {
HXLINE( 119)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 119)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 119)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 119)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 119)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 119)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 119)						bool foundY = false;
HXDLIN( 119)						Float s = ((Float)0.);
HXDLIN( 119)						Float t = ((Float)0.);
HXDLIN( 119)						Float sxx = ((Float)0.);
HXDLIN( 119)						Float txx = ((Float)0.);
HXDLIN( 119)						{
HXLINE( 119)							int _g_min = xIter3->start;
HXDLIN( 119)							int _g_max = xIter3->max;
HXDLIN( 119)							while((_g_min < _g_max)){
HXLINE( 119)								_g_min = (_g_min + 1);
HXDLIN( 119)								int x = (_g_min - 1);
HXLINE( 223)								sxx = (sx * ( (Float)(x) ));
HXLINE( 224)								txx = (tx * ( (Float)(x) ));
HXLINE( 225)								foundY = false;
HXLINE( 119)								{
HXLINE( 119)									int _g_min1 = yIter3->start;
HXDLIN( 119)									int _g_max = yIter3->max;
HXDLIN( 119)									while((_g_min1 < _g_max)){
HXLINE( 119)										_g_min1 = (_g_min1 + 1);
HXDLIN( 119)										int y = (_g_min1 - 1);
HXLINE( 227)										s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)										t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 119)										bool _hx_tmp;
HXDLIN( 119)										if (!((s <= 0))) {
HXLINE( 119)											_hx_tmp = (t <= 0);
            										}
            										else {
HXLINE( 119)											_hx_tmp = true;
            										}
HXDLIN( 119)										if (_hx_tmp) {
HXLINE( 119)											if (foundY) {
HXLINE( 119)												goto _hx_goto_19;
            											}
            										}
            										else {
HXLINE( 119)											if (((s + t) < A)) {
HXLINE( 119)												int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN( 119)												int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN( 119)												::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN( 119)												int index;
HXDLIN( 119)												if (tileImage->useVirtualPos) {
HXLINE( 119)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            												}
            												else {
HXLINE( 119)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            												}
HXDLIN( 119)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 119)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 119)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 119)												int color;
HXDLIN( 119)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 119)													color = c;
            												}
HXDLIN( 119)												{
HXLINE( 119)													int this2 = color;
HXDLIN( 119)													int c1 = this2;
HXDLIN( 119)													bool _hx_tmp;
HXDLIN( 119)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 119)														_hx_tmp = temp->transparent;
            													}
            													else {
HXLINE( 119)														_hx_tmp = false;
            													}
HXDLIN( 119)													if (_hx_tmp) {
HXLINE( 119)														int location;
HXDLIN( 119)														if (temp->useVirtualPos) {
HXLINE( 119)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 119)															location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 119)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 119)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 119)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 119)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 119)														int this3 = this2;
HXDLIN( 119)														int this4;
HXDLIN( 119)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 119)															this4 = this3;
            														}
HXDLIN( 119)														Float a1;
HXDLIN( 119)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 119)														if ((this5 == 0)) {
HXLINE( 119)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float r1;
HXDLIN( 119)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 119)														if ((this6 == 0)) {
HXLINE( 119)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float g1;
HXDLIN( 119)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 119)														if ((this7 == 0)) {
HXLINE( 119)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float b1;
HXDLIN( 119)														int this8 = (this4 & 255);
HXDLIN( 119)														if ((this8 == 0)) {
HXLINE( 119)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float a2;
HXDLIN( 119)														int this9 = ((color >> 24) & 255);
HXDLIN( 119)														if ((this9 == 0)) {
HXLINE( 119)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float r2;
HXDLIN( 119)														int this10 = ((color >> 16) & 255);
HXDLIN( 119)														if ((this10 == 0)) {
HXLINE( 119)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float g2;
HXDLIN( 119)														int this11 = ((color >> 8) & 255);
HXDLIN( 119)														if ((this11 == 0)) {
HXLINE( 119)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float b2;
HXDLIN( 119)														int this12 = (color & 255);
HXDLIN( 119)														if ((this12 == 0)) {
HXLINE( 119)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 119)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 119)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 119)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 119)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 119)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 119)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 119)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 119)														{
HXLINE( 119)															::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 119)															int value;
HXDLIN( 119)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 119)																value = blended;
            															}
HXDLIN( 119)															bool _hx_tmp;
HXDLIN( 119)															if ((location >= 0)) {
HXLINE( 119)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 119)																_hx_tmp = false;
            															}
HXDLIN( 119)															if (_hx_tmp) {
HXLINE( 119)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 119)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 119)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 119)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 119)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 119)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 119)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 119)														int index;
HXDLIN( 119)														if (temp->useVirtualPos) {
HXLINE( 119)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 119)															index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 119)														int value;
HXDLIN( 119)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 119)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE( 119)															value = c1;
            														}
HXDLIN( 119)														bool _hx_tmp;
HXDLIN( 119)														if ((index >= 0)) {
HXLINE( 119)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 119)															_hx_tmp = false;
            														}
HXDLIN( 119)														if (_hx_tmp) {
HXLINE( 119)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 119)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 119)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 119)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 119)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 119)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY = true;
            											}
            											else {
HXLINE( 119)												if (foundY) {
HXLINE( 119)													goto _hx_goto_19;
            												}
            											}
            										}
            									}
            									_hx_goto_19:;
            								}
            							}
            						}
HXDLIN( 119)						if ((hasHit == false)) {
HXLINE( 119)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx2,by2,cx2,cy2,true);
HXDLIN( 119)							if (hasUndo) {
HXLINE( 119)								v->undoImage = undoImage;
HXDLIN( 119)								v->undoX = xIter3->start;
HXDLIN( 119)								v->undoY = yIter3->start;
            							}
            						}
            					}
            				}
            			}
HXLINE( 120)			{
HXLINE( 120)				Float ax1 = this->rx;
HXDLIN( 120)				Float ay1 = this->ry;
HXDLIN( 120)				Float rx1 = (this->rx - this->strokeWidth);
HXDLIN( 120)				Float ry1 = (this->ry - this->strokeWidth);
HXDLIN( 120)				::pixelimage::ImageStruct tileImage1 = this->tileImageFill;
HXDLIN( 120)				bool hasHit1 = false;
HXDLIN( 120)				Float currAngle1 = endAngle;
HXDLIN( 120)				Float bx3 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax1);
HXDLIN( 120)				Float by3 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay1);
HXLINE( 403)				currAngle1 = (endAngle + (((( (Float)(2) ) * ::Math_obj::PI) - this->sweepAngle) + ((Float)0.01)));
HXLINE( 120)				Float cx3 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax1);
HXDLIN( 120)				Float cy3 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay1);
HXDLIN( 120)				{
HXLINE( 120)					Float bx4 = bx3;
HXDLIN( 120)					Float by4 = by3;
HXDLIN( 120)					Float cx4 = cx3;
HXDLIN( 120)					Float cy4 = cy3;
HXDLIN( 120)					bool adjustWinding1 = (((((ax1 * by4) - (bx4 * ay1)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay1) - (ax1 * cy4))) > 0);
HXDLIN( 120)					if (!(adjustWinding1)) {
HXLINE( 120)						Float bx_ = bx4;
HXDLIN( 120)						Float by_ = by4;
HXLINE( 188)						bx4 = cx4;
HXLINE( 189)						by4 = cy4;
HXLINE( 190)						cx4 = bx_;
HXLINE( 191)						cy4 = by_;
            					}
HXLINE( 120)					{
HXLINE( 120)						bool hasUndo1 = false;
HXDLIN( 120)						Float s01 = ((ay1 * cx4) - (ax1 * cy4));
HXDLIN( 120)						Float sx1 = (cy4 - ay1);
HXDLIN( 120)						Float sy1 = (ax1 - cx4);
HXDLIN( 120)						Float t01 = ((ax1 * by4) - (ay1 * bx4));
HXDLIN( 120)						Float tx1 = (ay1 - by4);
HXDLIN( 120)						Float ty1 = (bx4 - ax1);
HXDLIN( 120)						Float A1 = ((((-(by4) * cx4) + (ay1 * (-(bx4) + cx4))) + (ax1 * (by4 - cy4))) + (bx4 * cy4));
HXDLIN( 120)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 120)						if ((ax1 > bx4)) {
HXLINE( 120)							if ((ax1 > cx4)) {
HXLINE( 120)								int min;
HXDLIN( 120)								if ((bx4 > cx4)) {
HXLINE( 120)									min = ::Math_obj::floor(cx4);
            								}
            								else {
HXLINE( 120)									min = ::Math_obj::floor(bx4);
            								}
HXDLIN( 120)								int ii_min = min;
HXDLIN( 120)								int ii_max = ::Math_obj::ceil(ax1);
HXDLIN( 120)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 120)								xIter31 = this1;
            							}
            							else {
HXLINE( 120)								int ii_min = ::Math_obj::floor(bx4);
HXDLIN( 120)								int ii_max = ::Math_obj::ceil(cx4);
HXDLIN( 120)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 120)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE( 120)							if ((bx4 > cx4)) {
HXLINE( 120)								int min;
HXDLIN( 120)								if ((ax1 > cx4)) {
HXLINE( 120)									min = ::Math_obj::floor(cx4);
            								}
            								else {
HXLINE( 120)									min = ::Math_obj::ceil(ax1);
            								}
HXDLIN( 120)								int ii_min = min;
HXDLIN( 120)								int ii_max = ::Math_obj::ceil(bx4);
HXDLIN( 120)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 120)								xIter31 = this1;
            							}
            							else {
HXLINE( 120)								int ii_min = ::Math_obj::floor(ax1);
HXDLIN( 120)								int ii_max = ::Math_obj::ceil(cx4);
HXDLIN( 120)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 120)								xIter31 = this1;
            							}
            						}
HXDLIN( 120)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 120)						if ((ay1 > by4)) {
HXLINE( 120)							if ((ay1 > cy4)) {
HXLINE( 120)								int min;
HXDLIN( 120)								if ((by4 > cy4)) {
HXLINE( 120)									min = ::Math_obj::floor(cy4);
            								}
            								else {
HXLINE( 120)									min = ::Math_obj::floor(by4);
            								}
HXDLIN( 120)								int ii_min = min;
HXDLIN( 120)								int ii_max = ::Math_obj::ceil(ay1);
HXDLIN( 120)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 120)								yIter31 = this1;
            							}
            							else {
HXLINE( 120)								int ii_min = ::Math_obj::floor(by4);
HXDLIN( 120)								int ii_max = ::Math_obj::ceil(cy4);
HXDLIN( 120)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 120)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE( 120)							if ((by4 > cy4)) {
HXLINE( 120)								int min;
HXDLIN( 120)								if ((ay1 > cy4)) {
HXLINE( 120)									min = ::Math_obj::floor(cy4);
            								}
            								else {
HXLINE( 120)									min = ::Math_obj::ceil(ay1);
            								}
HXDLIN( 120)								int ii_min = min;
HXDLIN( 120)								int ii_max = ::Math_obj::ceil(by4);
HXDLIN( 120)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 120)								yIter31 = this1;
            							}
            							else {
HXLINE( 120)								int ii_min = ::Math_obj::floor(ay1);
HXDLIN( 120)								int ii_max = ::Math_obj::ceil(cy4);
HXDLIN( 120)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 120)								yIter31 = this1;
            							}
            						}
HXDLIN( 120)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 120)						if (hasUndo1) {
HXLINE( 120)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 120)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 120)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 120)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 120)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 120)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 120)							undoImage1 = this3;
HXDLIN( 120)							{
HXLINE( 120)								int rectLeft = xIter31->start;
HXDLIN( 120)								int rectTop = yIter31->start;
HXDLIN( 120)								int rectRight = xIter31->max;
HXDLIN( 120)								bool forceClear = false;
HXDLIN( 120)								{
HXLINE( 120)									int _g = rectTop;
HXDLIN( 120)									int _g1 = yIter31->max;
HXDLIN( 120)									while((_g < _g1)){
HXLINE( 120)										_g = (_g + 1);
HXDLIN( 120)										int dy = (_g - 1);
HXDLIN( 120)										{
HXLINE( 120)											int _g1 = rectLeft;
HXDLIN( 120)											int _g2 = rectRight;
HXDLIN( 120)											while((_g1 < _g2)){
HXLINE( 120)												_g1 = (_g1 + 1);
HXDLIN( 120)												int dx = (_g1 - 1);
HXDLIN( 120)												::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 120)												int index;
HXDLIN( 120)												if (temp->useVirtualPos) {
HXLINE( 120)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            												}
            												else {
HXLINE( 120)													index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            												}
HXDLIN( 120)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 120)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 120)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 120)												int col;
HXDLIN( 120)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 120)													col = c;
            												}
HXDLIN( 120)												bool _hx_tmp;
HXDLIN( 120)												if (temp->useMask) {
HXLINE( 120)													_hx_tmp = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE( 120)													_hx_tmp = false;
            												}
HXDLIN( 120)												if (_hx_tmp) {
HXLINE( 120)													::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 120)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 120)													int index;
HXDLIN( 120)													if (this1->useVirtualPos) {
HXLINE( 120)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 120)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 120)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 120)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 120)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 120)													int v;
HXDLIN( 120)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 120)														v = c;
            													}
HXDLIN( 120)													int this3 = v;
HXDLIN( 120)													int maskPixel = this3;
HXDLIN( 120)													int this4 = col;
HXDLIN( 120)													int this5 = this4;
HXDLIN( 120)													if ((maskPixel == 0)) {
HXLINE( 120)														int this1 = this5;
HXDLIN( 120)														col = this1;
            													}
            													else {
HXLINE( 120)														Float m0;
HXDLIN( 120)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 120)														if ((this1 == 0)) {
HXLINE( 120)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float m1;
HXDLIN( 120)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 120)														if ((this2 == 0)) {
HXLINE( 120)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float m2;
HXDLIN( 120)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 120)														if ((this3 == 0)) {
HXLINE( 120)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float m3;
HXDLIN( 120)														int this4 = (maskPixel & 255);
HXDLIN( 120)														if ((this4 == 0)) {
HXLINE( 120)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 120)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 120)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 120)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 120)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 120)												if ((col != 0)) {
HXLINE( 120)													int x = (dx - rectLeft);
HXDLIN( 120)													int y = (dy - rectTop);
HXDLIN( 120)													int this1 = col;
HXDLIN( 120)													int c = this1;
HXDLIN( 120)													bool _hx_tmp;
HXDLIN( 120)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 120)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE( 120)														_hx_tmp = false;
            													}
HXDLIN( 120)													if (_hx_tmp) {
HXLINE( 120)														int location;
HXDLIN( 120)														if (undoImage1->useVirtualPos) {
HXLINE( 120)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 120)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 120)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 120)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 120)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 120)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 120)														int this3 = this2;
HXDLIN( 120)														int this4;
HXDLIN( 120)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 120)															this4 = this3;
            														}
HXDLIN( 120)														Float a1;
HXDLIN( 120)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 120)														if ((this5 == 0)) {
HXLINE( 120)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float r1;
HXDLIN( 120)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 120)														if ((this6 == 0)) {
HXLINE( 120)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float g1;
HXDLIN( 120)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 120)														if ((this7 == 0)) {
HXLINE( 120)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float b1;
HXDLIN( 120)														int this8 = (this4 & 255);
HXDLIN( 120)														if ((this8 == 0)) {
HXLINE( 120)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float a2;
HXDLIN( 120)														int this9 = ((col >> 24) & 255);
HXDLIN( 120)														if ((this9 == 0)) {
HXLINE( 120)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float r2;
HXDLIN( 120)														int this10 = ((col >> 16) & 255);
HXDLIN( 120)														if ((this10 == 0)) {
HXLINE( 120)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float g2;
HXDLIN( 120)														int this11 = ((col >> 8) & 255);
HXDLIN( 120)														if ((this11 == 0)) {
HXLINE( 120)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float b2;
HXDLIN( 120)														int this12 = (col & 255);
HXDLIN( 120)														if ((this12 == 0)) {
HXLINE( 120)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 120)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 120)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 120)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 120)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 120)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 120)														{
HXLINE( 120)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 120)															int value;
HXDLIN( 120)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 120)																value = blended;
            															}
HXDLIN( 120)															bool _hx_tmp;
HXDLIN( 120)															if ((location >= 0)) {
HXLINE( 120)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 120)																_hx_tmp = false;
            															}
HXDLIN( 120)															if (_hx_tmp) {
HXLINE( 120)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 120)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 120)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 120)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 120)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 120)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 120)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 120)														int index;
HXDLIN( 120)														if (undoImage1->useVirtualPos) {
HXLINE( 120)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 120)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 120)														int value;
HXDLIN( 120)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 120)															value = c;
            														}
HXDLIN( 120)														bool _hx_tmp;
HXDLIN( 120)														if ((index >= 0)) {
HXLINE( 120)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 120)															_hx_tmp = false;
            														}
HXDLIN( 120)														if (_hx_tmp) {
HXLINE( 120)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 120)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 120)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 120)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 120)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 120)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 120)													if (forceClear) {
HXLINE( 120)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 120)														int x = (dx - rectLeft);
HXDLIN( 120)														int y = (dy - rectTop);
HXDLIN( 120)														int index;
HXDLIN( 120)														if (undoImage1->useVirtualPos) {
HXLINE( 120)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 120)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 120)														bool _hx_tmp;
HXDLIN( 120)														if ((index >= 0)) {
HXLINE( 120)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 120)															_hx_tmp = false;
            														}
HXDLIN( 120)														if (_hx_tmp) {
HXLINE( 120)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 120)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 120)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 120)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 120)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 120)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 120)						bool foundY1 = false;
HXDLIN( 120)						Float s1 = ((Float)0.);
HXDLIN( 120)						Float t1 = ((Float)0.);
HXDLIN( 120)						Float sxx1 = ((Float)0.);
HXDLIN( 120)						Float txx1 = ((Float)0.);
HXDLIN( 120)						{
HXLINE( 120)							int _g_min1 = xIter31->start;
HXDLIN( 120)							int _g_max1 = xIter31->max;
HXDLIN( 120)							while((_g_min1 < _g_max1)){
HXLINE( 120)								_g_min1 = (_g_min1 + 1);
HXDLIN( 120)								int x = (_g_min1 - 1);
HXLINE( 223)								sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)								txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)								foundY1 = false;
HXLINE( 120)								{
HXLINE( 120)									int _g_min = yIter31->start;
HXDLIN( 120)									int _g_max = yIter31->max;
HXDLIN( 120)									while((_g_min < _g_max)){
HXLINE( 120)										_g_min = (_g_min + 1);
HXDLIN( 120)										int y = (_g_min - 1);
HXLINE( 227)										s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)										t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE( 120)										bool _hx_tmp;
HXDLIN( 120)										if (!((s1 <= 0))) {
HXLINE( 120)											_hx_tmp = (t1 <= 0);
            										}
            										else {
HXLINE( 120)											_hx_tmp = true;
            										}
HXDLIN( 120)										if (_hx_tmp) {
HXLINE( 120)											if (foundY1) {
HXLINE( 120)												goto _hx_goto_23;
            											}
            										}
            										else {
HXLINE( 120)											if (((s1 + t1) < A1)) {
HXLINE( 120)												int x1 = ::hx::Mod(x,tileImage1->width);
HXDLIN( 120)												int y1 = ::hx::Mod(y,tileImage1->height);
HXDLIN( 120)												::haxe::io::ArrayBufferViewImpl this1 = tileImage1->image;
HXDLIN( 120)												int index;
HXDLIN( 120)												if (tileImage1->useVirtualPos) {
HXLINE( 120)													index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage1->virtualY) * ( (Float)(tileImage1->width) )) + x1) - tileImage1->virtualX));
            												}
            												else {
HXLINE( 120)													index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage1->width) + x1)) ));
            												}
HXDLIN( 120)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 120)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 120)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 120)												int color;
HXDLIN( 120)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)													color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 120)													color = c;
            												}
HXDLIN( 120)												{
HXLINE( 120)													int this2 = color;
HXDLIN( 120)													int c1 = this2;
HXDLIN( 120)													bool _hx_tmp;
HXDLIN( 120)													if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 120)														_hx_tmp = temp->transparent;
            													}
            													else {
HXLINE( 120)														_hx_tmp = false;
            													}
HXDLIN( 120)													if (_hx_tmp) {
HXLINE( 120)														int location;
HXDLIN( 120)														if (temp->useVirtualPos) {
HXLINE( 120)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 120)															location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 120)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 120)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 120)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 120)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 120)														int this3 = this2;
HXDLIN( 120)														int this4;
HXDLIN( 120)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 120)															this4 = this3;
            														}
HXDLIN( 120)														Float a1;
HXDLIN( 120)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 120)														if ((this5 == 0)) {
HXLINE( 120)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float r1;
HXDLIN( 120)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 120)														if ((this6 == 0)) {
HXLINE( 120)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float g1;
HXDLIN( 120)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 120)														if ((this7 == 0)) {
HXLINE( 120)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float b1;
HXDLIN( 120)														int this8 = (this4 & 255);
HXDLIN( 120)														if ((this8 == 0)) {
HXLINE( 120)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float a2;
HXDLIN( 120)														int this9 = ((color >> 24) & 255);
HXDLIN( 120)														if ((this9 == 0)) {
HXLINE( 120)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float r2;
HXDLIN( 120)														int this10 = ((color >> 16) & 255);
HXDLIN( 120)														if ((this10 == 0)) {
HXLINE( 120)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float g2;
HXDLIN( 120)														int this11 = ((color >> 8) & 255);
HXDLIN( 120)														if ((this11 == 0)) {
HXLINE( 120)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float b2;
HXDLIN( 120)														int this12 = (color & 255);
HXDLIN( 120)														if ((this12 == 0)) {
HXLINE( 120)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 120)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 120)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 120)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 120)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 120)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 120)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 120)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 120)														{
HXLINE( 120)															::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 120)															int value;
HXDLIN( 120)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 120)																value = blended;
            															}
HXDLIN( 120)															bool _hx_tmp;
HXDLIN( 120)															if ((location >= 0)) {
HXLINE( 120)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 120)																_hx_tmp = false;
            															}
HXDLIN( 120)															if (_hx_tmp) {
HXLINE( 120)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 120)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 120)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 120)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 120)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 120)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 120)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 120)														int index;
HXDLIN( 120)														if (temp->useVirtualPos) {
HXLINE( 120)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            														}
            														else {
HXLINE( 120)															index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            														}
HXDLIN( 120)														int value;
HXDLIN( 120)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 120)															value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXLINE( 120)															value = c1;
            														}
HXDLIN( 120)														bool _hx_tmp;
HXDLIN( 120)														if ((index >= 0)) {
HXLINE( 120)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 120)															_hx_tmp = false;
            														}
HXDLIN( 120)														if (_hx_tmp) {
HXLINE( 120)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 120)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 120)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 120)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 120)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 120)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 237)												foundY1 = true;
            											}
            											else {
HXLINE( 120)												if (foundY1) {
HXLINE( 120)													goto _hx_goto_23;
            												}
            											}
            										}
            									}
            									_hx_goto_23:;
            								}
            							}
            						}
HXDLIN( 120)						if ((hasHit1 == false)) {
HXLINE( 120)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx4,by4,cx4,cy4,true);
HXDLIN( 120)							if (hasUndo1) {
HXLINE( 120)								v->undoImage = undoImage1;
HXDLIN( 120)								v->undoX = xIter31->start;
HXDLIN( 120)								v->undoY = yIter31->start;
            							}
            						}
            					}
            				}
            			}
HXLINE( 121)			{
HXLINE( 121)				::pixelimage::ImageStruct tileImage2 = this->tileImageStroke;
HXDLIN( 121)				bool hasHit2 = false;
HXDLIN( 121)				Float o = (by - cy);
HXDLIN( 121)				Float a = (bx - cx);
HXDLIN( 121)				Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 121)				Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 121)				{
HXLINE( 121)					 ::Dynamic debugCorners = false;
HXDLIN( 121)					if (::hx::IsNull( debugCorners )) {
HXLINE( 893)						debugCorners = false;
            					}
HXLINE( 121)					Float sin = ::Math_obj::sin(theta);
HXDLIN( 121)					Float cos = ::Math_obj::cos(theta);
HXDLIN( 121)					Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN( 121)					Float dx = ((Float)0.1);
HXDLIN( 121)					Float dy = radius;
HXDLIN( 121)					Float cx5 = h;
HXDLIN( 121)					Float cy5 = radius;
HXDLIN( 121)					Float bx5 = h;
HXDLIN( 121)					Float by5 = -(radius);
HXDLIN( 121)					Float ax2 = ((Float)0.1);
HXDLIN( 121)					Float ay2 = -(radius);
HXDLIN( 121)					Float temp1 = ((Float)0.);
HXLINE( 380)					temp1 = (cx + ((ax2 * cos) - (ay2 * sin)));
HXLINE( 381)					ay2 = (cy + ((ay2 * cos) + (ax2 * sin)));
HXLINE( 382)					ax2 = temp1;
HXLINE( 384)					temp1 = (cx + ((bx5 * cos) - (by5 * sin)));
HXLINE( 385)					by5 = (cy + ((by5 * cos) + (bx5 * sin)));
HXLINE( 386)					bx5 = temp1;
HXLINE( 388)					temp1 = (cx + ((cx5 * cos) - (cy5 * sin)));
HXLINE( 389)					cy5 = (cy + ((cy5 * cos) + (cx5 * sin)));
HXLINE( 390)					cx5 = temp1;
HXLINE( 392)					temp1 = (cx + ((dx * cos) - (dy * sin)));
HXLINE( 393)					dy = (cy + ((dy * cos) + (dx * sin)));
HXLINE( 394)					dx = temp1;
HXLINE( 121)					if (( (bool)(debugCorners) )) {
HXLINE( 121)						{
HXLINE( 121)							Float x = (ax2 - ((Float)6.));
HXDLIN( 121)							Float y = (ay2 - ((Float)6.));
HXDLIN( 121)							int p = ::Std_obj::_hx_int(x);
HXDLIN( 121)							int xx = p;
HXDLIN( 121)							int q = ::Std_obj::_hx_int(y);
HXDLIN( 121)							int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN( 121)							int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN( 121)							while(true){
HXLINE( 121)								{
HXLINE( 121)									p = (p + 1);
HXDLIN( 121)									int x = (p - 1);
HXDLIN( 121)									int this1 = -65536;
HXDLIN( 121)									int c = this1;
HXDLIN( 121)									bool _hx_tmp;
HXDLIN( 121)									if ((((c >> 24) & 255) < 254)) {
HXLINE( 121)										_hx_tmp = temp->transparent;
            									}
            									else {
HXLINE( 121)										_hx_tmp = false;
            									}
HXDLIN( 121)									if (_hx_tmp) {
HXLINE( 121)										int location;
HXDLIN( 121)										if (temp->useVirtualPos) {
HXLINE( 121)											location = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            										}
            										else {
HXLINE( 121)											location = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            										}
HXDLIN( 121)										::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)										int this3 = this2;
HXDLIN( 121)										int this4;
HXDLIN( 121)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE( 121)											this4 = this3;
            										}
HXDLIN( 121)										Float a1;
HXDLIN( 121)										int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)										if ((this5 == 0)) {
HXLINE( 121)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float r1;
HXDLIN( 121)										int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)										if ((this6 == 0)) {
HXLINE( 121)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float g1;
HXDLIN( 121)										int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)										if ((this7 == 0)) {
HXLINE( 121)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float b1;
HXDLIN( 121)										int this8 = (this4 & 255);
HXDLIN( 121)										if ((this8 == 0)) {
HXLINE( 121)											b1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float a2;
HXDLIN( 121)										int this9 = ((-65536 >> 24) & 255);
HXDLIN( 121)										if ((this9 == 0)) {
HXLINE( 121)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float r2;
HXDLIN( 121)										int this10 = ((-65536 >> 16) & 255);
HXDLIN( 121)										if ((this10 == 0)) {
HXLINE( 121)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float g2;
HXDLIN( 121)										int this11 = ((-65536 >> 8) & 255);
HXDLIN( 121)										if ((this11 == 0)) {
HXLINE( 121)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float b2;
HXDLIN( 121)										int this12 = (-65536 & 255);
HXDLIN( 121)										if ((this12 == 0)) {
HXLINE( 121)											b2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)										{
HXLINE( 121)											::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 121)											int value;
HXDLIN( 121)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 121)												value = blended;
            											}
HXDLIN( 121)											bool _hx_tmp;
HXDLIN( 121)											if ((location >= 0)) {
HXLINE( 121)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE( 121)												_hx_tmp = false;
            											}
HXDLIN( 121)											if (_hx_tmp) {
HXLINE( 121)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE( 121)										::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)										int index;
HXDLIN( 121)										if (temp->useVirtualPos) {
HXLINE( 121)											index = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            										}
            										else {
HXLINE( 121)											index = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            										}
HXDLIN( 121)										int value;
HXDLIN( 121)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 121)											value = c;
            										}
HXDLIN( 121)										bool _hx_tmp;
HXDLIN( 121)										if ((index >= 0)) {
HXLINE( 121)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE( 121)											_hx_tmp = false;
            										}
HXDLIN( 121)										if (_hx_tmp) {
HXLINE( 121)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXDLIN( 121)								if ((p > maxX)) {
HXLINE( 247)									p = xx;
HXLINE( 121)									q = (q + 1);
            								}
HXDLIN( 121)								if ((q > maxY)) {
HXLINE( 121)									goto _hx_goto_24;
            								}
            							}
            							_hx_goto_24:;
            						}
HXDLIN( 121)						{
HXLINE( 121)							Float x1 = (bx5 - ((Float)6.));
HXDLIN( 121)							Float y1 = (by5 - ((Float)6.));
HXDLIN( 121)							int p1 = ::Std_obj::_hx_int(x1);
HXDLIN( 121)							int xx1 = p1;
HXDLIN( 121)							int q1 = ::Std_obj::_hx_int(y1);
HXDLIN( 121)							int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN( 121)							int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN( 121)							while(true){
HXLINE( 121)								{
HXLINE( 121)									p1 = (p1 + 1);
HXDLIN( 121)									int x = (p1 - 1);
HXDLIN( 121)									int this1 = -16711936;
HXDLIN( 121)									int c = this1;
HXDLIN( 121)									bool _hx_tmp;
HXDLIN( 121)									if ((((c >> 24) & 255) < 254)) {
HXLINE( 121)										_hx_tmp = temp->transparent;
            									}
            									else {
HXLINE( 121)										_hx_tmp = false;
            									}
HXDLIN( 121)									if (_hx_tmp) {
HXLINE( 121)										int location;
HXDLIN( 121)										if (temp->useVirtualPos) {
HXLINE( 121)											location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            										}
            										else {
HXLINE( 121)											location = ::Std_obj::_hx_int(( (Float)(((q1 * temp->width) + x)) ));
            										}
HXDLIN( 121)										::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)										int this3 = this2;
HXDLIN( 121)										int this4;
HXDLIN( 121)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE( 121)											this4 = this3;
            										}
HXDLIN( 121)										Float a1;
HXDLIN( 121)										int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)										if ((this5 == 0)) {
HXLINE( 121)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float r1;
HXDLIN( 121)										int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)										if ((this6 == 0)) {
HXLINE( 121)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float g1;
HXDLIN( 121)										int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)										if ((this7 == 0)) {
HXLINE( 121)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float b1;
HXDLIN( 121)										int this8 = (this4 & 255);
HXDLIN( 121)										if ((this8 == 0)) {
HXLINE( 121)											b1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float a2;
HXDLIN( 121)										int this9 = ((-16711936 >> 24) & 255);
HXDLIN( 121)										if ((this9 == 0)) {
HXLINE( 121)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float r2;
HXDLIN( 121)										int this10 = ((-16711936 >> 16) & 255);
HXDLIN( 121)										if ((this10 == 0)) {
HXLINE( 121)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float g2;
HXDLIN( 121)										int this11 = ((-16711936 >> 8) & 255);
HXDLIN( 121)										if ((this11 == 0)) {
HXLINE( 121)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float b2;
HXDLIN( 121)										int this12 = (-16711936 & 255);
HXDLIN( 121)										if ((this12 == 0)) {
HXLINE( 121)											b2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)										{
HXLINE( 121)											::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 121)											int value;
HXDLIN( 121)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 121)												value = blended;
            											}
HXDLIN( 121)											bool _hx_tmp;
HXDLIN( 121)											if ((location >= 0)) {
HXLINE( 121)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE( 121)												_hx_tmp = false;
            											}
HXDLIN( 121)											if (_hx_tmp) {
HXLINE( 121)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE( 121)										::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)										int index;
HXDLIN( 121)										if (temp->useVirtualPos) {
HXLINE( 121)											index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            										}
            										else {
HXLINE( 121)											index = ::Std_obj::_hx_int(( (Float)(((q1 * temp->width) + x)) ));
            										}
HXDLIN( 121)										int value;
HXDLIN( 121)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 121)											value = c;
            										}
HXDLIN( 121)										bool _hx_tmp;
HXDLIN( 121)										if ((index >= 0)) {
HXLINE( 121)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE( 121)											_hx_tmp = false;
            										}
HXDLIN( 121)										if (_hx_tmp) {
HXLINE( 121)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXDLIN( 121)								if ((p1 > maxX1)) {
HXLINE( 247)									p1 = xx1;
HXLINE( 121)									q1 = (q1 + 1);
            								}
HXDLIN( 121)								if ((q1 > maxY1)) {
HXLINE( 121)									goto _hx_goto_25;
            								}
            							}
            							_hx_goto_25:;
            						}
HXDLIN( 121)						{
HXLINE( 121)							Float x2 = (cx5 - ((Float)6.));
HXDLIN( 121)							Float y2 = (cy5 - ((Float)6.));
HXDLIN( 121)							int p2 = ::Std_obj::_hx_int(x2);
HXDLIN( 121)							int xx2 = p2;
HXDLIN( 121)							int q2 = ::Std_obj::_hx_int(y2);
HXDLIN( 121)							int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN( 121)							int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN( 121)							while(true){
HXLINE( 121)								{
HXLINE( 121)									p2 = (p2 + 1);
HXDLIN( 121)									int x = (p2 - 1);
HXDLIN( 121)									int this1 = -16776961;
HXDLIN( 121)									int c = this1;
HXDLIN( 121)									bool _hx_tmp;
HXDLIN( 121)									if ((((c >> 24) & 255) < 254)) {
HXLINE( 121)										_hx_tmp = temp->transparent;
            									}
            									else {
HXLINE( 121)										_hx_tmp = false;
            									}
HXDLIN( 121)									if (_hx_tmp) {
HXLINE( 121)										int location;
HXDLIN( 121)										if (temp->useVirtualPos) {
HXLINE( 121)											location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            										}
            										else {
HXLINE( 121)											location = ::Std_obj::_hx_int(( (Float)(((q2 * temp->width) + x)) ));
            										}
HXDLIN( 121)										::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)										int this3 = this2;
HXDLIN( 121)										int this4;
HXDLIN( 121)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE( 121)											this4 = this3;
            										}
HXDLIN( 121)										Float a1;
HXDLIN( 121)										int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)										if ((this5 == 0)) {
HXLINE( 121)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float r1;
HXDLIN( 121)										int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)										if ((this6 == 0)) {
HXLINE( 121)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float g1;
HXDLIN( 121)										int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)										if ((this7 == 0)) {
HXLINE( 121)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float b1;
HXDLIN( 121)										int this8 = (this4 & 255);
HXDLIN( 121)										if ((this8 == 0)) {
HXLINE( 121)											b1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float a2;
HXDLIN( 121)										int this9 = ((-16776961 >> 24) & 255);
HXDLIN( 121)										if ((this9 == 0)) {
HXLINE( 121)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float r2;
HXDLIN( 121)										int this10 = ((-16776961 >> 16) & 255);
HXDLIN( 121)										if ((this10 == 0)) {
HXLINE( 121)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float g2;
HXDLIN( 121)										int this11 = ((-16776961 >> 8) & 255);
HXDLIN( 121)										if ((this11 == 0)) {
HXLINE( 121)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float b2;
HXDLIN( 121)										int this12 = (-16776961 & 255);
HXDLIN( 121)										if ((this12 == 0)) {
HXLINE( 121)											b2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)										{
HXLINE( 121)											::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 121)											int value;
HXDLIN( 121)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 121)												value = blended;
            											}
HXDLIN( 121)											bool _hx_tmp;
HXDLIN( 121)											if ((location >= 0)) {
HXLINE( 121)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE( 121)												_hx_tmp = false;
            											}
HXDLIN( 121)											if (_hx_tmp) {
HXLINE( 121)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE( 121)										::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)										int index;
HXDLIN( 121)										if (temp->useVirtualPos) {
HXLINE( 121)											index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            										}
            										else {
HXLINE( 121)											index = ::Std_obj::_hx_int(( (Float)(((q2 * temp->width) + x)) ));
            										}
HXDLIN( 121)										int value;
HXDLIN( 121)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 121)											value = c;
            										}
HXDLIN( 121)										bool _hx_tmp;
HXDLIN( 121)										if ((index >= 0)) {
HXLINE( 121)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE( 121)											_hx_tmp = false;
            										}
HXDLIN( 121)										if (_hx_tmp) {
HXLINE( 121)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXDLIN( 121)								if ((p2 > maxX2)) {
HXLINE( 247)									p2 = xx2;
HXLINE( 121)									q2 = (q2 + 1);
            								}
HXDLIN( 121)								if ((q2 > maxY2)) {
HXLINE( 121)									goto _hx_goto_26;
            								}
            							}
            							_hx_goto_26:;
            						}
HXDLIN( 121)						{
HXLINE( 121)							Float x3 = (dx - ((Float)6.));
HXDLIN( 121)							Float y3 = (dy - ((Float)6.));
HXDLIN( 121)							int p3 = ::Std_obj::_hx_int(x3);
HXDLIN( 121)							int xx3 = p3;
HXDLIN( 121)							int q3 = ::Std_obj::_hx_int(y3);
HXDLIN( 121)							int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN( 121)							int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN( 121)							while(true){
HXLINE( 121)								{
HXLINE( 121)									p3 = (p3 + 1);
HXDLIN( 121)									int x = (p3 - 1);
HXDLIN( 121)									int this1 = -1048336;
HXDLIN( 121)									int c = this1;
HXDLIN( 121)									bool _hx_tmp;
HXDLIN( 121)									if ((((c >> 24) & 255) < 254)) {
HXLINE( 121)										_hx_tmp = temp->transparent;
            									}
            									else {
HXLINE( 121)										_hx_tmp = false;
            									}
HXDLIN( 121)									if (_hx_tmp) {
HXLINE( 121)										int location;
HXDLIN( 121)										if (temp->useVirtualPos) {
HXLINE( 121)											location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            										}
            										else {
HXLINE( 121)											location = ::Std_obj::_hx_int(( (Float)(((q3 * temp->width) + x)) ));
            										}
HXDLIN( 121)										::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)										int this3 = this2;
HXDLIN( 121)										int this4;
HXDLIN( 121)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE( 121)											this4 = this3;
            										}
HXDLIN( 121)										Float a1;
HXDLIN( 121)										int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)										if ((this5 == 0)) {
HXLINE( 121)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float r1;
HXDLIN( 121)										int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)										if ((this6 == 0)) {
HXLINE( 121)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float g1;
HXDLIN( 121)										int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)										if ((this7 == 0)) {
HXLINE( 121)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float b1;
HXDLIN( 121)										int this8 = (this4 & 255);
HXDLIN( 121)										if ((this8 == 0)) {
HXLINE( 121)											b1 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float a2;
HXDLIN( 121)										int this9 = ((-1048336 >> 24) & 255);
HXDLIN( 121)										if ((this9 == 0)) {
HXLINE( 121)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float r2;
HXDLIN( 121)										int this10 = ((-1048336 >> 16) & 255);
HXDLIN( 121)										if ((this10 == 0)) {
HXLINE( 121)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float g2;
HXDLIN( 121)										int this11 = ((-1048336 >> 8) & 255);
HXDLIN( 121)										if ((this11 == 0)) {
HXLINE( 121)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float b2;
HXDLIN( 121)										int this12 = (-1048336 & 255);
HXDLIN( 121)										if ((this12 == 0)) {
HXLINE( 121)											b2 = ((Float)0.);
            										}
            										else {
HXLINE( 121)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN( 121)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)										{
HXLINE( 121)											::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 121)											int value;
HXDLIN( 121)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 121)												value = blended;
            											}
HXDLIN( 121)											bool _hx_tmp;
HXDLIN( 121)											if ((location >= 0)) {
HXLINE( 121)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE( 121)												_hx_tmp = false;
            											}
HXDLIN( 121)											if (_hx_tmp) {
HXLINE( 121)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE( 121)										::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)										int index;
HXDLIN( 121)										if (temp->useVirtualPos) {
HXLINE( 121)											index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            										}
            										else {
HXLINE( 121)											index = ::Std_obj::_hx_int(( (Float)(((q3 * temp->width) + x)) ));
            										}
HXDLIN( 121)										int value;
HXDLIN( 121)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 121)											value = c;
            										}
HXDLIN( 121)										bool _hx_tmp;
HXDLIN( 121)										if ((index >= 0)) {
HXLINE( 121)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE( 121)											_hx_tmp = false;
            										}
HXDLIN( 121)										if (_hx_tmp) {
HXLINE( 121)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXDLIN( 121)								if ((p3 > maxX3)) {
HXLINE( 247)									p3 = xx3;
HXLINE( 121)									q3 = (q3 + 1);
            								}
HXDLIN( 121)								if ((q3 > maxY3)) {
HXLINE( 121)									goto _hx_goto_27;
            								}
            							}
            							_hx_goto_27:;
            						}
            					}
HXDLIN( 121)					{
HXLINE( 121)						{
HXLINE( 121)							Float bx6 = bx5;
HXDLIN( 121)							Float by6 = by5;
HXDLIN( 121)							Float cx6 = dx;
HXDLIN( 121)							Float cy6 = dy;
HXDLIN( 121)							bool adjustWinding2 = (((((ax2 * by6) - (bx6 * ay2)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * ay2) - (ax2 * cy6))) > 0);
HXDLIN( 121)							if (!(adjustWinding2)) {
HXLINE( 121)								Float bx_ = bx6;
HXDLIN( 121)								Float by_ = by6;
HXLINE( 188)								bx6 = cx6;
HXLINE( 189)								by6 = cy6;
HXLINE( 190)								cx6 = bx_;
HXLINE( 191)								cy6 = by_;
            							}
HXLINE( 121)							{
HXLINE( 121)								bool hasUndo2 = false;
HXDLIN( 121)								Float s02 = ((ay2 * cx6) - (ax2 * cy6));
HXDLIN( 121)								Float sx2 = (cy6 - ay2);
HXDLIN( 121)								Float sy2 = (ax2 - cx6);
HXDLIN( 121)								Float t02 = ((ax2 * by6) - (ay2 * bx6));
HXDLIN( 121)								Float tx2 = (ay2 - by6);
HXDLIN( 121)								Float ty2 = (bx6 - ax2);
HXDLIN( 121)								Float A2 = ((((-(by6) * cx6) + (ay2 * (-(bx6) + cx6))) + (ax2 * (by6 - cy6))) + (bx6 * cy6));
HXDLIN( 121)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN( 121)								if ((ax2 > bx6)) {
HXLINE( 121)									if ((ax2 > cx6)) {
HXLINE( 121)										int min;
HXDLIN( 121)										if ((bx6 > cx6)) {
HXLINE( 121)											min = ::Math_obj::floor(cx6);
            										}
            										else {
HXLINE( 121)											min = ::Math_obj::floor(bx6);
            										}
HXDLIN( 121)										int ii_min = min;
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(ax2);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										xIter32 = this1;
            									}
            									else {
HXLINE( 121)										int ii_min = ::Math_obj::floor(bx6);
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(cx6);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE( 121)									if ((bx6 > cx6)) {
HXLINE( 121)										int min;
HXDLIN( 121)										if ((ax2 > cx6)) {
HXLINE( 121)											min = ::Math_obj::floor(cx6);
            										}
            										else {
HXLINE( 121)											min = ::Math_obj::ceil(ax2);
            										}
HXDLIN( 121)										int ii_min = min;
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(bx6);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										xIter32 = this1;
            									}
            									else {
HXLINE( 121)										int ii_min = ::Math_obj::floor(ax2);
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(cx6);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										xIter32 = this1;
            									}
            								}
HXDLIN( 121)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN( 121)								if ((ay2 > by6)) {
HXLINE( 121)									if ((ay2 > cy6)) {
HXLINE( 121)										int min;
HXDLIN( 121)										if ((by6 > cy6)) {
HXLINE( 121)											min = ::Math_obj::floor(cy6);
            										}
            										else {
HXLINE( 121)											min = ::Math_obj::floor(by6);
            										}
HXDLIN( 121)										int ii_min = min;
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(ay2);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										yIter32 = this1;
            									}
            									else {
HXLINE( 121)										int ii_min = ::Math_obj::floor(by6);
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(cy6);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE( 121)									if ((by6 > cy6)) {
HXLINE( 121)										int min;
HXDLIN( 121)										if ((ay2 > cy6)) {
HXLINE( 121)											min = ::Math_obj::floor(cy6);
            										}
            										else {
HXLINE( 121)											min = ::Math_obj::ceil(ay2);
            										}
HXDLIN( 121)										int ii_min = min;
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(by6);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										yIter32 = this1;
            									}
            									else {
HXLINE( 121)										int ii_min = ::Math_obj::floor(ay2);
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(cy6);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										yIter32 = this1;
            									}
            								}
HXDLIN( 121)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN( 121)								if (hasUndo2) {
HXLINE( 121)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 121)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 121)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 121)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 121)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 121)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 121)									undoImage2 = this3;
HXDLIN( 121)									{
HXLINE( 121)										int rectLeft = xIter32->start;
HXDLIN( 121)										int rectTop = yIter32->start;
HXDLIN( 121)										int rectRight = xIter32->max;
HXDLIN( 121)										bool forceClear = false;
HXDLIN( 121)										{
HXLINE( 121)											int _g = rectTop;
HXDLIN( 121)											int _g1 = yIter32->max;
HXDLIN( 121)											while((_g < _g1)){
HXLINE( 121)												_g = (_g + 1);
HXDLIN( 121)												int dy = (_g - 1);
HXDLIN( 121)												{
HXLINE( 121)													int _g1 = rectLeft;
HXDLIN( 121)													int _g2 = rectRight;
HXDLIN( 121)													while((_g1 < _g2)){
HXLINE( 121)														_g1 = (_g1 + 1);
HXDLIN( 121)														int dx = (_g1 - 1);
HXDLIN( 121)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)														int index;
HXDLIN( 121)														if (temp->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            														}
HXDLIN( 121)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)														int col;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 121)															col = c;
            														}
HXDLIN( 121)														bool _hx_tmp;
HXDLIN( 121)														if (temp->useMask) {
HXLINE( 121)															_hx_tmp = ::hx::IsNotNull( temp->mask );
            														}
            														else {
HXLINE( 121)															_hx_tmp = false;
            														}
HXDLIN( 121)														if (_hx_tmp) {
HXLINE( 121)															::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 121)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 121)															int index;
HXDLIN( 121)															if (this1->useVirtualPos) {
HXLINE( 121)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE( 121)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN( 121)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 121)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 121)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)															int v;
HXDLIN( 121)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE( 121)																v = c;
            															}
HXDLIN( 121)															int this3 = v;
HXDLIN( 121)															int maskPixel = this3;
HXDLIN( 121)															int this4 = col;
HXDLIN( 121)															int this5 = this4;
HXDLIN( 121)															if ((maskPixel == 0)) {
HXLINE( 121)																int this1 = this5;
HXDLIN( 121)																col = this1;
            															}
            															else {
HXLINE( 121)																Float m0;
HXDLIN( 121)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 121)																if ((this1 == 0)) {
HXLINE( 121)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float m1;
HXDLIN( 121)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 121)																if ((this2 == 0)) {
HXLINE( 121)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float m2;
HXDLIN( 121)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 121)																if ((this3 == 0)) {
HXLINE( 121)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float m3;
HXDLIN( 121)																int this4 = (maskPixel & 255);
HXDLIN( 121)																if ((this4 == 0)) {
HXLINE( 121)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 121)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 121)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 121)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 121)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 121)														if ((col != 0)) {
HXLINE( 121)															int x = (dx - rectLeft);
HXDLIN( 121)															int y = (dy - rectTop);
HXDLIN( 121)															int this1 = col;
HXDLIN( 121)															int c = this1;
HXDLIN( 121)															bool _hx_tmp;
HXDLIN( 121)															if ((((c >> 24) & 255) < 254)) {
HXLINE( 121)																_hx_tmp = undoImage2->transparent;
            															}
            															else {
HXLINE( 121)																_hx_tmp = false;
            															}
HXDLIN( 121)															if (_hx_tmp) {
HXLINE( 121)																int location;
HXDLIN( 121)																if (undoImage2->useVirtualPos) {
HXLINE( 121)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE( 121)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN( 121)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 121)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)																int this3 = this2;
HXDLIN( 121)																int this4;
HXDLIN( 121)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE( 121)																	this4 = this3;
            																}
HXDLIN( 121)																Float a1;
HXDLIN( 121)																int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)																if ((this5 == 0)) {
HXLINE( 121)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float r1;
HXDLIN( 121)																int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)																if ((this6 == 0)) {
HXLINE( 121)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float g1;
HXDLIN( 121)																int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)																if ((this7 == 0)) {
HXLINE( 121)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float b1;
HXDLIN( 121)																int this8 = (this4 & 255);
HXDLIN( 121)																if ((this8 == 0)) {
HXLINE( 121)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float a2;
HXDLIN( 121)																int this9 = ((col >> 24) & 255);
HXDLIN( 121)																if ((this9 == 0)) {
HXLINE( 121)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float r2;
HXDLIN( 121)																int this10 = ((col >> 16) & 255);
HXDLIN( 121)																if ((this10 == 0)) {
HXLINE( 121)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float g2;
HXDLIN( 121)																int this11 = ((col >> 8) & 255);
HXDLIN( 121)																if ((this11 == 0)) {
HXLINE( 121)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float b2;
HXDLIN( 121)																int this12 = (col & 255);
HXDLIN( 121)																if ((this12 == 0)) {
HXLINE( 121)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)																{
HXLINE( 121)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN( 121)																	int value;
HXDLIN( 121)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE( 121)																		value = blended;
            																	}
HXDLIN( 121)																	bool _hx_tmp;
HXDLIN( 121)																	if ((location >= 0)) {
HXLINE( 121)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE( 121)																		_hx_tmp = false;
            																	}
HXDLIN( 121)																	if (_hx_tmp) {
HXLINE( 121)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE( 121)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 121)																int index;
HXDLIN( 121)																if (undoImage2->useVirtualPos) {
HXLINE( 121)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE( 121)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN( 121)																int value;
HXDLIN( 121)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE( 121)																	value = c;
            																}
HXDLIN( 121)																bool _hx_tmp;
HXDLIN( 121)																if ((index >= 0)) {
HXLINE( 121)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE( 121)																	_hx_tmp = false;
            																}
HXDLIN( 121)																if (_hx_tmp) {
HXLINE( 121)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 121)															if (forceClear) {
HXLINE( 121)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 121)																int x = (dx - rectLeft);
HXDLIN( 121)																int y = (dy - rectTop);
HXDLIN( 121)																int index;
HXDLIN( 121)																if (undoImage2->useVirtualPos) {
HXLINE( 121)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE( 121)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN( 121)																bool _hx_tmp;
HXDLIN( 121)																if ((index >= 0)) {
HXLINE( 121)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE( 121)																	_hx_tmp = false;
            																}
HXDLIN( 121)																if (_hx_tmp) {
HXLINE( 121)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 121)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 121)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 121)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 121)								bool foundY2 = false;
HXDLIN( 121)								Float s2 = ((Float)0.);
HXDLIN( 121)								Float t2 = ((Float)0.);
HXDLIN( 121)								Float sxx2 = ((Float)0.);
HXDLIN( 121)								Float txx2 = ((Float)0.);
HXDLIN( 121)								{
HXLINE( 121)									int _g_min2 = xIter32->start;
HXDLIN( 121)									int _g_max2 = xIter32->max;
HXDLIN( 121)									while((_g_min2 < _g_max2)){
HXLINE( 121)										_g_min2 = (_g_min2 + 1);
HXDLIN( 121)										int x = (_g_min2 - 1);
HXLINE( 223)										sxx2 = (sx2 * ( (Float)(x) ));
HXLINE( 224)										txx2 = (tx2 * ( (Float)(x) ));
HXLINE( 225)										foundY2 = false;
HXLINE( 121)										{
HXLINE( 121)											int _g_min = yIter32->start;
HXDLIN( 121)											int _g_max = yIter32->max;
HXDLIN( 121)											while((_g_min < _g_max)){
HXLINE( 121)												_g_min = (_g_min + 1);
HXDLIN( 121)												int y = (_g_min - 1);
HXLINE( 227)												s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE( 228)												t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE( 121)												bool _hx_tmp;
HXDLIN( 121)												if (!((s2 <= 0))) {
HXLINE( 121)													_hx_tmp = (t2 <= 0);
            												}
            												else {
HXLINE( 121)													_hx_tmp = true;
            												}
HXDLIN( 121)												if (_hx_tmp) {
HXLINE( 121)													if (foundY2) {
HXLINE( 121)														goto _hx_goto_31;
            													}
            												}
            												else {
HXLINE( 121)													if (((s2 + t2) < A2)) {
HXLINE( 121)														int x1 = ::hx::Mod(x,tileImage2->width);
HXDLIN( 121)														int y1 = ::hx::Mod(y,tileImage2->height);
HXDLIN( 121)														::haxe::io::ArrayBufferViewImpl this1 = tileImage2->image;
HXDLIN( 121)														int index;
HXDLIN( 121)														if (tileImage2->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage2->virtualY) * ( (Float)(tileImage2->width) )) + x1) - tileImage2->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage2->width) + x1)) ));
            														}
HXDLIN( 121)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)														int color;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 121)															color = c;
            														}
HXDLIN( 121)														{
HXLINE( 121)															int this2 = color;
HXDLIN( 121)															int c1 = this2;
HXDLIN( 121)															bool _hx_tmp;
HXDLIN( 121)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 121)																_hx_tmp = temp->transparent;
            															}
            															else {
HXLINE( 121)																_hx_tmp = false;
            															}
HXDLIN( 121)															if (_hx_tmp) {
HXLINE( 121)																int location;
HXDLIN( 121)																if (temp->useVirtualPos) {
HXLINE( 121)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																}
            																else {
HXLINE( 121)																	location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																}
HXDLIN( 121)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)																int this3 = this2;
HXDLIN( 121)																int this4;
HXDLIN( 121)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE( 121)																	this4 = this3;
            																}
HXDLIN( 121)																Float a1;
HXDLIN( 121)																int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)																if ((this5 == 0)) {
HXLINE( 121)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float r1;
HXDLIN( 121)																int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)																if ((this6 == 0)) {
HXLINE( 121)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float g1;
HXDLIN( 121)																int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)																if ((this7 == 0)) {
HXLINE( 121)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float b1;
HXDLIN( 121)																int this8 = (this4 & 255);
HXDLIN( 121)																if ((this8 == 0)) {
HXLINE( 121)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float a2;
HXDLIN( 121)																int this9 = ((color >> 24) & 255);
HXDLIN( 121)																if ((this9 == 0)) {
HXLINE( 121)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float r2;
HXDLIN( 121)																int this10 = ((color >> 16) & 255);
HXDLIN( 121)																if ((this10 == 0)) {
HXLINE( 121)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float g2;
HXDLIN( 121)																int this11 = ((color >> 8) & 255);
HXDLIN( 121)																if ((this11 == 0)) {
HXLINE( 121)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float b2;
HXDLIN( 121)																int this12 = (color & 255);
HXDLIN( 121)																if ((this12 == 0)) {
HXLINE( 121)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)																{
HXLINE( 121)																	::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 121)																	int value;
HXDLIN( 121)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE( 121)																		value = blended;
            																	}
HXDLIN( 121)																	bool _hx_tmp;
HXDLIN( 121)																	if ((location >= 0)) {
HXLINE( 121)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE( 121)																		_hx_tmp = false;
            																	}
HXDLIN( 121)																	if (_hx_tmp) {
HXLINE( 121)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE( 121)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)																int index;
HXDLIN( 121)																if (temp->useVirtualPos) {
HXLINE( 121)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																}
            																else {
HXLINE( 121)																	index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																}
HXDLIN( 121)																int value;
HXDLIN( 121)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE( 121)																	value = c1;
            																}
HXDLIN( 121)																bool _hx_tmp;
HXDLIN( 121)																if ((index >= 0)) {
HXLINE( 121)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE( 121)																	_hx_tmp = false;
            																}
HXDLIN( 121)																if (_hx_tmp) {
HXLINE( 121)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY2 = true;
            													}
            													else {
HXLINE( 121)														if (foundY2) {
HXLINE( 121)															goto _hx_goto_31;
            														}
            													}
            												}
            											}
            											_hx_goto_31:;
            										}
            									}
            								}
HXDLIN( 121)								if ((hasHit2 == false)) {
HXLINE( 121)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax2,ay2,bx6,by6,cx6,cy6,true);
HXDLIN( 121)									if (hasUndo2) {
HXLINE( 121)										v->undoImage = undoImage2;
HXDLIN( 121)										v->undoX = xIter32->start;
HXDLIN( 121)										v->undoY = yIter32->start;
            									}
            								}
            							}
            						}
HXDLIN( 121)						{
HXLINE( 121)							Float bx7 = cx5;
HXDLIN( 121)							Float by7 = cy5;
HXDLIN( 121)							Float cx7 = dx;
HXDLIN( 121)							Float cy7 = dy;
HXDLIN( 121)							bool adjustWinding3 = (((((bx5 * by7) - (bx7 * by5)) + ((bx7 * cy7) - (cx7 * by7))) + ((cx7 * by5) - (bx5 * cy7))) > 0);
HXDLIN( 121)							if (!(adjustWinding3)) {
HXLINE( 121)								Float bx_ = bx7;
HXDLIN( 121)								Float by_ = by7;
HXLINE( 188)								bx7 = cx7;
HXLINE( 189)								by7 = cy7;
HXLINE( 190)								cx7 = bx_;
HXLINE( 191)								cy7 = by_;
            							}
HXLINE( 121)							{
HXLINE( 121)								bool hasUndo3 = false;
HXDLIN( 121)								Float s03 = ((by5 * cx7) - (bx5 * cy7));
HXDLIN( 121)								Float sx3 = (cy7 - by5);
HXDLIN( 121)								Float sy3 = (bx5 - cx7);
HXDLIN( 121)								Float t03 = ((bx5 * by7) - (by5 * bx7));
HXDLIN( 121)								Float tx3 = (by5 - by7);
HXDLIN( 121)								Float ty3 = (bx7 - bx5);
HXDLIN( 121)								Float A3 = ((((-(by7) * cx7) + (by5 * (-(bx7) + cx7))) + (bx5 * (by7 - cy7))) + (bx7 * cy7));
HXDLIN( 121)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN( 121)								if ((bx5 > bx7)) {
HXLINE( 121)									if ((bx5 > cx7)) {
HXLINE( 121)										int min;
HXDLIN( 121)										if ((bx7 > cx7)) {
HXLINE( 121)											min = ::Math_obj::floor(cx7);
            										}
            										else {
HXLINE( 121)											min = ::Math_obj::floor(bx7);
            										}
HXDLIN( 121)										int ii_min = min;
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(bx5);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										xIter33 = this1;
            									}
            									else {
HXLINE( 121)										int ii_min = ::Math_obj::floor(bx7);
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(cx7);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE( 121)									if ((bx7 > cx7)) {
HXLINE( 121)										int min;
HXDLIN( 121)										if ((bx5 > cx7)) {
HXLINE( 121)											min = ::Math_obj::floor(cx7);
            										}
            										else {
HXLINE( 121)											min = ::Math_obj::ceil(bx5);
            										}
HXDLIN( 121)										int ii_min = min;
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(bx7);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										xIter33 = this1;
            									}
            									else {
HXLINE( 121)										int ii_min = ::Math_obj::floor(bx5);
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(cx7);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										xIter33 = this1;
            									}
            								}
HXDLIN( 121)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN( 121)								if ((by5 > by7)) {
HXLINE( 121)									if ((by5 > cy7)) {
HXLINE( 121)										int min;
HXDLIN( 121)										if ((by7 > cy7)) {
HXLINE( 121)											min = ::Math_obj::floor(cy7);
            										}
            										else {
HXLINE( 121)											min = ::Math_obj::floor(by7);
            										}
HXDLIN( 121)										int ii_min = min;
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(by5);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										yIter33 = this1;
            									}
            									else {
HXLINE( 121)										int ii_min = ::Math_obj::floor(by7);
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(cy7);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE( 121)									if ((by7 > cy7)) {
HXLINE( 121)										int min;
HXDLIN( 121)										if ((by5 > cy7)) {
HXLINE( 121)											min = ::Math_obj::floor(cy7);
            										}
            										else {
HXLINE( 121)											min = ::Math_obj::ceil(by5);
            										}
HXDLIN( 121)										int ii_min = min;
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(by7);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										yIter33 = this1;
            									}
            									else {
HXLINE( 121)										int ii_min = ::Math_obj::floor(by5);
HXDLIN( 121)										int ii_max = ::Math_obj::ceil(cy7);
HXDLIN( 121)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 121)										yIter33 = this1;
            									}
            								}
HXDLIN( 121)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN( 121)								if (hasUndo3) {
HXLINE( 121)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 121)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 121)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 121)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 121)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 121)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 121)									undoImage3 = this3;
HXDLIN( 121)									{
HXLINE( 121)										int rectLeft = xIter33->start;
HXDLIN( 121)										int rectTop = yIter33->start;
HXDLIN( 121)										int rectRight = xIter33->max;
HXDLIN( 121)										bool forceClear = false;
HXDLIN( 121)										{
HXLINE( 121)											int _g = rectTop;
HXDLIN( 121)											int _g1 = yIter33->max;
HXDLIN( 121)											while((_g < _g1)){
HXLINE( 121)												_g = (_g + 1);
HXDLIN( 121)												int dy = (_g - 1);
HXDLIN( 121)												{
HXLINE( 121)													int _g1 = rectLeft;
HXDLIN( 121)													int _g2 = rectRight;
HXDLIN( 121)													while((_g1 < _g2)){
HXLINE( 121)														_g1 = (_g1 + 1);
HXDLIN( 121)														int dx = (_g1 - 1);
HXDLIN( 121)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)														int index;
HXDLIN( 121)														if (temp->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            														}
HXDLIN( 121)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)														int col;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 121)															col = c;
            														}
HXDLIN( 121)														bool _hx_tmp;
HXDLIN( 121)														if (temp->useMask) {
HXLINE( 121)															_hx_tmp = ::hx::IsNotNull( temp->mask );
            														}
            														else {
HXLINE( 121)															_hx_tmp = false;
            														}
HXDLIN( 121)														if (_hx_tmp) {
HXLINE( 121)															::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 121)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 121)															int index;
HXDLIN( 121)															if (this1->useVirtualPos) {
HXLINE( 121)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE( 121)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN( 121)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 121)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 121)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)															int v;
HXDLIN( 121)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE( 121)																v = c;
            															}
HXDLIN( 121)															int this3 = v;
HXDLIN( 121)															int maskPixel = this3;
HXDLIN( 121)															int this4 = col;
HXDLIN( 121)															int this5 = this4;
HXDLIN( 121)															if ((maskPixel == 0)) {
HXLINE( 121)																int this1 = this5;
HXDLIN( 121)																col = this1;
            															}
            															else {
HXLINE( 121)																Float m0;
HXDLIN( 121)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 121)																if ((this1 == 0)) {
HXLINE( 121)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float m1;
HXDLIN( 121)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 121)																if ((this2 == 0)) {
HXLINE( 121)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float m2;
HXDLIN( 121)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 121)																if ((this3 == 0)) {
HXLINE( 121)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float m3;
HXDLIN( 121)																int this4 = (maskPixel & 255);
HXDLIN( 121)																if ((this4 == 0)) {
HXLINE( 121)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 121)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 121)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 121)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 121)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 121)														if ((col != 0)) {
HXLINE( 121)															int x = (dx - rectLeft);
HXDLIN( 121)															int y = (dy - rectTop);
HXDLIN( 121)															int this1 = col;
HXDLIN( 121)															int c = this1;
HXDLIN( 121)															bool _hx_tmp;
HXDLIN( 121)															if ((((c >> 24) & 255) < 254)) {
HXLINE( 121)																_hx_tmp = undoImage3->transparent;
            															}
            															else {
HXLINE( 121)																_hx_tmp = false;
            															}
HXDLIN( 121)															if (_hx_tmp) {
HXLINE( 121)																int location;
HXDLIN( 121)																if (undoImage3->useVirtualPos) {
HXLINE( 121)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 121)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN( 121)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 121)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)																int this3 = this2;
HXDLIN( 121)																int this4;
HXDLIN( 121)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE( 121)																	this4 = this3;
            																}
HXDLIN( 121)																Float a1;
HXDLIN( 121)																int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)																if ((this5 == 0)) {
HXLINE( 121)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float r1;
HXDLIN( 121)																int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)																if ((this6 == 0)) {
HXLINE( 121)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float g1;
HXDLIN( 121)																int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)																if ((this7 == 0)) {
HXLINE( 121)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float b1;
HXDLIN( 121)																int this8 = (this4 & 255);
HXDLIN( 121)																if ((this8 == 0)) {
HXLINE( 121)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float a2;
HXDLIN( 121)																int this9 = ((col >> 24) & 255);
HXDLIN( 121)																if ((this9 == 0)) {
HXLINE( 121)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float r2;
HXDLIN( 121)																int this10 = ((col >> 16) & 255);
HXDLIN( 121)																if ((this10 == 0)) {
HXLINE( 121)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float g2;
HXDLIN( 121)																int this11 = ((col >> 8) & 255);
HXDLIN( 121)																if ((this11 == 0)) {
HXLINE( 121)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float b2;
HXDLIN( 121)																int this12 = (col & 255);
HXDLIN( 121)																if ((this12 == 0)) {
HXLINE( 121)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)																{
HXLINE( 121)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN( 121)																	int value;
HXDLIN( 121)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE( 121)																		value = blended;
            																	}
HXDLIN( 121)																	bool _hx_tmp;
HXDLIN( 121)																	if ((location >= 0)) {
HXLINE( 121)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE( 121)																		_hx_tmp = false;
            																	}
HXDLIN( 121)																	if (_hx_tmp) {
HXLINE( 121)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE( 121)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 121)																int index;
HXDLIN( 121)																if (undoImage3->useVirtualPos) {
HXLINE( 121)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 121)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN( 121)																int value;
HXDLIN( 121)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE( 121)																	value = c;
            																}
HXDLIN( 121)																bool _hx_tmp;
HXDLIN( 121)																if ((index >= 0)) {
HXLINE( 121)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE( 121)																	_hx_tmp = false;
            																}
HXDLIN( 121)																if (_hx_tmp) {
HXLINE( 121)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 121)															if (forceClear) {
HXLINE( 121)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 121)																int x = (dx - rectLeft);
HXDLIN( 121)																int y = (dy - rectTop);
HXDLIN( 121)																int index;
HXDLIN( 121)																if (undoImage3->useVirtualPos) {
HXLINE( 121)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 121)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN( 121)																bool _hx_tmp;
HXDLIN( 121)																if ((index >= 0)) {
HXLINE( 121)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE( 121)																	_hx_tmp = false;
            																}
HXDLIN( 121)																if (_hx_tmp) {
HXLINE( 121)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 121)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 121)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 121)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 121)								bool foundY3 = false;
HXDLIN( 121)								Float s3 = ((Float)0.);
HXDLIN( 121)								Float t3 = ((Float)0.);
HXDLIN( 121)								Float sxx3 = ((Float)0.);
HXDLIN( 121)								Float txx3 = ((Float)0.);
HXDLIN( 121)								{
HXLINE( 121)									int _g_min3 = xIter33->start;
HXDLIN( 121)									int _g_max3 = xIter33->max;
HXDLIN( 121)									while((_g_min3 < _g_max3)){
HXLINE( 121)										_g_min3 = (_g_min3 + 1);
HXDLIN( 121)										int x = (_g_min3 - 1);
HXLINE( 223)										sxx3 = (sx3 * ( (Float)(x) ));
HXLINE( 224)										txx3 = (tx3 * ( (Float)(x) ));
HXLINE( 225)										foundY3 = false;
HXLINE( 121)										{
HXLINE( 121)											int _g_min = yIter33->start;
HXDLIN( 121)											int _g_max = yIter33->max;
HXDLIN( 121)											while((_g_min < _g_max)){
HXLINE( 121)												_g_min = (_g_min + 1);
HXDLIN( 121)												int y = (_g_min - 1);
HXLINE( 227)												s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE( 228)												t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE( 121)												bool _hx_tmp;
HXDLIN( 121)												if (!((s3 <= 0))) {
HXLINE( 121)													_hx_tmp = (t3 <= 0);
            												}
            												else {
HXLINE( 121)													_hx_tmp = true;
            												}
HXDLIN( 121)												if (_hx_tmp) {
HXLINE( 121)													if (foundY3) {
HXLINE( 121)														goto _hx_goto_35;
            													}
            												}
            												else {
HXLINE( 121)													if (((s3 + t3) < A3)) {
HXLINE( 121)														int x1 = ::hx::Mod(x,tileImage2->width);
HXDLIN( 121)														int y1 = ::hx::Mod(y,tileImage2->height);
HXDLIN( 121)														::haxe::io::ArrayBufferViewImpl this1 = tileImage2->image;
HXDLIN( 121)														int index;
HXDLIN( 121)														if (tileImage2->useVirtualPos) {
HXLINE( 121)															index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage2->virtualY) * ( (Float)(tileImage2->width) )) + x1) - tileImage2->virtualX));
            														}
            														else {
HXLINE( 121)															index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage2->width) + x1)) ));
            														}
HXDLIN( 121)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)														int color;
HXDLIN( 121)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)															color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 121)															color = c;
            														}
HXDLIN( 121)														{
HXLINE( 121)															int this2 = color;
HXDLIN( 121)															int c1 = this2;
HXDLIN( 121)															bool _hx_tmp;
HXDLIN( 121)															if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 121)																_hx_tmp = temp->transparent;
            															}
            															else {
HXLINE( 121)																_hx_tmp = false;
            															}
HXDLIN( 121)															if (_hx_tmp) {
HXLINE( 121)																int location;
HXDLIN( 121)																if (temp->useVirtualPos) {
HXLINE( 121)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																}
            																else {
HXLINE( 121)																	location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																}
HXDLIN( 121)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 121)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 121)																int this3 = this2;
HXDLIN( 121)																int this4;
HXDLIN( 121)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE( 121)																	this4 = this3;
            																}
HXDLIN( 121)																Float a1;
HXDLIN( 121)																int this5 = ((this4 >> 24) & 255);
HXDLIN( 121)																if ((this5 == 0)) {
HXLINE( 121)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float r1;
HXDLIN( 121)																int this6 = ((this4 >> 16) & 255);
HXDLIN( 121)																if ((this6 == 0)) {
HXLINE( 121)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float g1;
HXDLIN( 121)																int this7 = ((this4 >> 8) & 255);
HXDLIN( 121)																if ((this7 == 0)) {
HXLINE( 121)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float b1;
HXDLIN( 121)																int this8 = (this4 & 255);
HXDLIN( 121)																if ((this8 == 0)) {
HXLINE( 121)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float a2;
HXDLIN( 121)																int this9 = ((color >> 24) & 255);
HXDLIN( 121)																if ((this9 == 0)) {
HXLINE( 121)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float r2;
HXDLIN( 121)																int this10 = ((color >> 16) & 255);
HXDLIN( 121)																if ((this10 == 0)) {
HXLINE( 121)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float g2;
HXDLIN( 121)																int this11 = ((color >> 8) & 255);
HXDLIN( 121)																if ((this11 == 0)) {
HXLINE( 121)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float b2;
HXDLIN( 121)																int this12 = (color & 255);
HXDLIN( 121)																if ((this12 == 0)) {
HXLINE( 121)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE( 121)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 121)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 121)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 121)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 121)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 121)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 121)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 121)																{
HXLINE( 121)																	::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 121)																	int value;
HXDLIN( 121)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE( 121)																		value = blended;
            																	}
HXDLIN( 121)																	bool _hx_tmp;
HXDLIN( 121)																	if ((location >= 0)) {
HXLINE( 121)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE( 121)																		_hx_tmp = false;
            																	}
HXDLIN( 121)																	if (_hx_tmp) {
HXLINE( 121)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 121)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 121)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE( 121)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 121)																int index;
HXDLIN( 121)																if (temp->useVirtualPos) {
HXLINE( 121)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																}
            																else {
HXLINE( 121)																	index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																}
HXDLIN( 121)																int value;
HXDLIN( 121)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 121)																	value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXLINE( 121)																	value = c1;
            																}
HXDLIN( 121)																bool _hx_tmp;
HXDLIN( 121)																if ((index >= 0)) {
HXLINE( 121)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE( 121)																	_hx_tmp = false;
            																}
HXDLIN( 121)																if (_hx_tmp) {
HXLINE( 121)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 121)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 121)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 121)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 121)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 121)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 237)														foundY3 = true;
            													}
            													else {
HXLINE( 121)														if (foundY3) {
HXLINE( 121)															goto _hx_goto_35;
            														}
            													}
            												}
            											}
            											_hx_goto_35:;
            										}
            									}
            								}
HXDLIN( 121)								if ((hasHit2 == false)) {
HXLINE( 121)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx5,by5,bx7,by7,cx7,cy7,true);
HXDLIN( 121)									if (hasUndo3) {
HXLINE( 121)										v->undoImage = undoImage3;
HXDLIN( 121)										v->undoX = xIter33->start;
HXDLIN( 121)										v->undoY = yIter33->start;
            									}
            								}
            							}
            						}
HXDLIN( 121)						if ((hasHit2 == true)) {
HXLINE( 121)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax2,ay2,bx5,by5,cx5,cy5,dx,dy,true);
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ArcPattern_obj,chord,(void))

void ArcPattern_obj::ellipse(::pixelimage::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_32a31af4d124b381_124_ellipse)
HXLINE( 125)		{
HXLINE( 125)			Float ax = this->rx;
HXDLIN( 125)			Float ay = this->ry;
HXDLIN( 125)			Float rx = this->rx;
HXDLIN( 125)			Float ry = this->ry;
HXDLIN( 125)			Float startRadian = this->startAngle;
HXDLIN( 125)			Float sweepRadian = this->sweepAngle;
HXDLIN( 125)			::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN( 125)			bool hasHit = false;
HXDLIN( 125)			Float rSmall;
HXDLIN( 125)			if ((rx > ry)) {
HXLINE( 125)				rSmall = ry;
            			}
            			else {
HXLINE( 125)				rSmall = rx;
            			}
HXDLIN( 125)			 ::Dynamic targetE = ((Float)1.05);
HXDLIN( 125)			if (::hx::IsNull( targetE )) {
HXLINE( 457)				targetE = ((Float)1.05);
            			}
HXLINE( 125)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 125)			int noSides;
HXDLIN( 125)			if ((result < 12)) {
HXLINE( 125)				noSides = 12;
            			}
            			else {
HXLINE( 125)				if ((result > 500)) {
HXLINE( 125)					noSides = 500;
            				}
            				else {
HXLINE( 125)					noSides = result;
            				}
            			}
HXDLIN( 125)			Float theta = ((((Float)1.41213) * ::Math_obj::PI) / ( (Float)(noSides) ));
HXDLIN( 125)			Float currAngle = startRadian;
HXDLIN( 125)			int tot = ::Math_obj::floor((sweepRadian / theta));
HXDLIN( 125)			theta = (theta + (((sweepRadian / theta) - ( (Float)(tot) )) / ( (Float)(noSides) )));
HXLINE( 462)			tot = ::Math_obj::floor((sweepRadian / theta));
HXLINE( 125)			Float bx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXDLIN( 125)			Float by = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXDLIN( 125)			Float cx = ((Float)0.);
HXDLIN( 125)			Float cy = ((Float)0.);
HXDLIN( 125)			::Array< ::Dynamic> arrTri = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 125)			{
HXLINE( 125)				int _g = 1;
HXDLIN( 125)				int _g1 = (tot + 1);
HXDLIN( 125)				while((_g < _g1)){
HXLINE( 125)					_g = (_g + 1);
HXDLIN( 125)					int i = (_g - 1);
HXLINE( 469)					currAngle = (startRadian + (( (Float)(i) ) * theta));
HXLINE( 470)					cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 471)					cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 125)					Float bx1 = bx;
HXDLIN( 125)					Float by1 = by;
HXDLIN( 125)					Float cx1 = cx;
HXDLIN( 125)					Float cy1 = cy;
HXDLIN( 125)					bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 125)					if (!(adjustWinding)) {
HXLINE( 125)						Float bx_ = bx1;
HXDLIN( 125)						Float by_ = by1;
HXLINE( 188)						bx1 = cx1;
HXLINE( 189)						by1 = cy1;
HXLINE( 190)						cx1 = bx_;
HXLINE( 191)						cy1 = by_;
            					}
HXLINE( 125)					bool hasUndo = false;
HXDLIN( 125)					Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 125)					Float sx = (cy1 - ay);
HXDLIN( 125)					Float sy = (ax - cx1);
HXDLIN( 125)					Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 125)					Float tx = (ay - by1);
HXDLIN( 125)					Float ty = (bx1 - ax);
HXDLIN( 125)					Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 125)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 125)					if ((ax > bx1)) {
HXLINE( 125)						if ((ax > cx1)) {
HXLINE( 125)							int min;
HXDLIN( 125)							if ((bx1 > cx1)) {
HXLINE( 125)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE( 125)								min = ::Math_obj::floor(bx1);
            							}
HXDLIN( 125)							int ii_min = min;
HXDLIN( 125)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 125)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)							xIter3 = this1;
            						}
            						else {
HXLINE( 125)							int ii_min = ::Math_obj::floor(bx1);
HXDLIN( 125)							int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 125)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE( 125)						if ((bx1 > cx1)) {
HXLINE( 125)							int min;
HXDLIN( 125)							if ((ax > cx1)) {
HXLINE( 125)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE( 125)								min = ::Math_obj::ceil(ax);
            							}
HXDLIN( 125)							int ii_min = min;
HXDLIN( 125)							int ii_max = ::Math_obj::ceil(bx1);
HXDLIN( 125)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)							xIter3 = this1;
            						}
            						else {
HXLINE( 125)							int ii_min = ::Math_obj::floor(ax);
HXDLIN( 125)							int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 125)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)							xIter3 = this1;
            						}
            					}
HXDLIN( 125)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 125)					if ((ay > by1)) {
HXLINE( 125)						if ((ay > cy1)) {
HXLINE( 125)							int min;
HXDLIN( 125)							if ((by1 > cy1)) {
HXLINE( 125)								min = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE( 125)								min = ::Math_obj::floor(by1);
            							}
HXDLIN( 125)							int ii_min = min;
HXDLIN( 125)							int ii_max = ::Math_obj::ceil(ay);
HXDLIN( 125)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)							yIter3 = this1;
            						}
            						else {
HXLINE( 125)							int ii_min = ::Math_obj::floor(by1);
HXDLIN( 125)							int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 125)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE( 125)						if ((by1 > cy1)) {
HXLINE( 125)							int min;
HXDLIN( 125)							if ((ay > cy1)) {
HXLINE( 125)								min = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE( 125)								min = ::Math_obj::ceil(ay);
            							}
HXDLIN( 125)							int ii_min = min;
HXDLIN( 125)							int ii_max = ::Math_obj::ceil(by1);
HXDLIN( 125)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)							yIter3 = this1;
            						}
            						else {
HXLINE( 125)							int ii_min = ::Math_obj::floor(ay);
HXDLIN( 125)							int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 125)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)							yIter3 = this1;
            						}
            					}
HXDLIN( 125)					::pixelimage::ImageStruct undoImage = null();
HXDLIN( 125)					if (hasUndo) {
HXLINE( 125)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 125)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 125)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 125)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 125)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 125)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 125)						undoImage = this3;
HXDLIN( 125)						{
HXLINE( 125)							int rectLeft = xIter3->start;
HXDLIN( 125)							int rectTop = yIter3->start;
HXDLIN( 125)							int rectRight = xIter3->max;
HXDLIN( 125)							bool forceClear = false;
HXDLIN( 125)							{
HXLINE( 125)								int _g = rectTop;
HXDLIN( 125)								int _g1 = yIter3->max;
HXDLIN( 125)								while((_g < _g1)){
HXLINE( 125)									_g = (_g + 1);
HXDLIN( 125)									int dy = (_g - 1);
HXDLIN( 125)									{
HXLINE( 125)										int _g1 = rectLeft;
HXDLIN( 125)										int _g2 = rectRight;
HXDLIN( 125)										while((_g1 < _g2)){
HXLINE( 125)											_g1 = (_g1 + 1);
HXDLIN( 125)											int dx = (_g1 - 1);
HXDLIN( 125)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 125)											int index;
HXDLIN( 125)											if (temp->useVirtualPos) {
HXLINE( 125)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            											}
            											else {
HXLINE( 125)												index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            											}
HXDLIN( 125)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)											int col;
HXDLIN( 125)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 125)												col = c;
            											}
HXDLIN( 125)											bool _hx_tmp;
HXDLIN( 125)											if (temp->useMask) {
HXLINE( 125)												_hx_tmp = ::hx::IsNotNull( temp->mask );
            											}
            											else {
HXLINE( 125)												_hx_tmp = false;
            											}
HXDLIN( 125)											if (_hx_tmp) {
HXLINE( 125)												::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 125)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 125)												int index;
HXDLIN( 125)												if (this1->useVirtualPos) {
HXLINE( 125)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE( 125)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN( 125)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 125)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 125)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)												int v;
HXDLIN( 125)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 125)													v = c;
            												}
HXDLIN( 125)												int this3 = v;
HXDLIN( 125)												int maskPixel = this3;
HXDLIN( 125)												int this4 = col;
HXDLIN( 125)												int this5 = this4;
HXDLIN( 125)												if ((maskPixel == 0)) {
HXLINE( 125)													int this1 = this5;
HXDLIN( 125)													col = this1;
            												}
            												else {
HXLINE( 125)													Float m0;
HXDLIN( 125)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 125)													if ((this1 == 0)) {
HXLINE( 125)														m0 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float m1;
HXDLIN( 125)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 125)													if ((this2 == 0)) {
HXLINE( 125)														m1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float m2;
HXDLIN( 125)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 125)													if ((this3 == 0)) {
HXLINE( 125)														m2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float m3;
HXDLIN( 125)													int this4 = (maskPixel & 255);
HXDLIN( 125)													if ((this4 == 0)) {
HXLINE( 125)														m3 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 125)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 125)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 125)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 125)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 125)											if ((col != 0)) {
HXLINE( 125)												int x = (dx - rectLeft);
HXDLIN( 125)												int y = (dy - rectTop);
HXDLIN( 125)												int this1 = col;
HXDLIN( 125)												int c = this1;
HXDLIN( 125)												bool _hx_tmp;
HXDLIN( 125)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 125)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE( 125)													_hx_tmp = false;
            												}
HXDLIN( 125)												if (_hx_tmp) {
HXLINE( 125)													int location;
HXDLIN( 125)													if (undoImage->useVirtualPos) {
HXLINE( 125)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 125)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 125)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 125)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 125)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)													int this3 = this2;
HXDLIN( 125)													int this4;
HXDLIN( 125)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 125)														this4 = this3;
            													}
HXDLIN( 125)													Float a1;
HXDLIN( 125)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 125)													if ((this5 == 0)) {
HXLINE( 125)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float r1;
HXDLIN( 125)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 125)													if ((this6 == 0)) {
HXLINE( 125)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float g1;
HXDLIN( 125)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 125)													if ((this7 == 0)) {
HXLINE( 125)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float b1;
HXDLIN( 125)													int this8 = (this4 & 255);
HXDLIN( 125)													if ((this8 == 0)) {
HXLINE( 125)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float a2;
HXDLIN( 125)													int this9 = ((col >> 24) & 255);
HXDLIN( 125)													if ((this9 == 0)) {
HXLINE( 125)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float r2;
HXDLIN( 125)													int this10 = ((col >> 16) & 255);
HXDLIN( 125)													if ((this10 == 0)) {
HXLINE( 125)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float g2;
HXDLIN( 125)													int this11 = ((col >> 8) & 255);
HXDLIN( 125)													if ((this11 == 0)) {
HXLINE( 125)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float b2;
HXDLIN( 125)													int this12 = (col & 255);
HXDLIN( 125)													if ((this12 == 0)) {
HXLINE( 125)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 125)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 125)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 125)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 125)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 125)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 125)													{
HXLINE( 125)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 125)														int value;
HXDLIN( 125)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 125)															value = blended;
            														}
HXDLIN( 125)														bool _hx_tmp;
HXDLIN( 125)														if ((location >= 0)) {
HXLINE( 125)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 125)															_hx_tmp = false;
            														}
HXDLIN( 125)														if (_hx_tmp) {
HXLINE( 125)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 125)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 125)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 125)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 125)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 125)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 125)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 125)													int index;
HXDLIN( 125)													if (undoImage->useVirtualPos) {
HXLINE( 125)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 125)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 125)													int value;
HXDLIN( 125)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 125)														value = c;
            													}
HXDLIN( 125)													bool _hx_tmp;
HXDLIN( 125)													if ((index >= 0)) {
HXLINE( 125)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 125)														_hx_tmp = false;
            													}
HXDLIN( 125)													if (_hx_tmp) {
HXLINE( 125)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 125)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 125)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 125)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 125)												if (forceClear) {
HXLINE( 125)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 125)													int x = (dx - rectLeft);
HXDLIN( 125)													int y = (dy - rectTop);
HXDLIN( 125)													int index;
HXDLIN( 125)													if (undoImage->useVirtualPos) {
HXLINE( 125)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 125)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 125)													bool _hx_tmp;
HXDLIN( 125)													if ((index >= 0)) {
HXLINE( 125)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 125)														_hx_tmp = false;
            													}
HXDLIN( 125)													if (_hx_tmp) {
HXLINE( 125)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 125)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 125)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 125)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 125)					bool foundY = false;
HXDLIN( 125)					Float s = ((Float)0.);
HXDLIN( 125)					Float t = ((Float)0.);
HXDLIN( 125)					Float sxx = ((Float)0.);
HXDLIN( 125)					Float txx = ((Float)0.);
HXDLIN( 125)					{
HXLINE( 125)						int _g_min = xIter3->start;
HXDLIN( 125)						int _g_max = xIter3->max;
HXDLIN( 125)						while((_g_min < _g_max)){
HXLINE( 125)							_g_min = (_g_min + 1);
HXDLIN( 125)							int x = (_g_min - 1);
HXLINE( 223)							sxx = (sx * ( (Float)(x) ));
HXLINE( 224)							txx = (tx * ( (Float)(x) ));
HXLINE( 225)							foundY = false;
HXLINE( 125)							{
HXLINE( 125)								int _g_min1 = yIter3->start;
HXDLIN( 125)								int _g_max = yIter3->max;
HXDLIN( 125)								while((_g_min1 < _g_max)){
HXLINE( 125)									_g_min1 = (_g_min1 + 1);
HXDLIN( 125)									int y = (_g_min1 - 1);
HXLINE( 227)									s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)									t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 125)									bool _hx_tmp;
HXDLIN( 125)									if (!((s <= 0))) {
HXLINE( 125)										_hx_tmp = (t <= 0);
            									}
            									else {
HXLINE( 125)										_hx_tmp = true;
            									}
HXDLIN( 125)									if (_hx_tmp) {
HXLINE( 125)										if (foundY) {
HXLINE( 125)											goto _hx_goto_41;
            										}
            									}
            									else {
HXLINE( 125)										if (((s + t) < A)) {
HXLINE( 125)											int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN( 125)											int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN( 125)											::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN( 125)											int index;
HXDLIN( 125)											if (tileImage->useVirtualPos) {
HXLINE( 125)												index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            											}
            											else {
HXLINE( 125)												index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            											}
HXDLIN( 125)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)											int color;
HXDLIN( 125)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)												color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 125)												color = c;
            											}
HXDLIN( 125)											{
HXLINE( 125)												int this2 = color;
HXDLIN( 125)												int c1 = this2;
HXDLIN( 125)												bool _hx_tmp;
HXDLIN( 125)												if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 125)													_hx_tmp = temp->transparent;
            												}
            												else {
HXLINE( 125)													_hx_tmp = false;
            												}
HXDLIN( 125)												if (_hx_tmp) {
HXLINE( 125)													int location;
HXDLIN( 125)													if (temp->useVirtualPos) {
HXLINE( 125)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 125)														location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 125)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 125)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 125)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)													int this3 = this2;
HXDLIN( 125)													int this4;
HXDLIN( 125)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 125)														this4 = this3;
            													}
HXDLIN( 125)													Float a1;
HXDLIN( 125)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 125)													if ((this5 == 0)) {
HXLINE( 125)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float r1;
HXDLIN( 125)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 125)													if ((this6 == 0)) {
HXLINE( 125)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float g1;
HXDLIN( 125)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 125)													if ((this7 == 0)) {
HXLINE( 125)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float b1;
HXDLIN( 125)													int this8 = (this4 & 255);
HXDLIN( 125)													if ((this8 == 0)) {
HXLINE( 125)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float a2;
HXDLIN( 125)													int this9 = ((color >> 24) & 255);
HXDLIN( 125)													if ((this9 == 0)) {
HXLINE( 125)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float r2;
HXDLIN( 125)													int this10 = ((color >> 16) & 255);
HXDLIN( 125)													if ((this10 == 0)) {
HXLINE( 125)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float g2;
HXDLIN( 125)													int this11 = ((color >> 8) & 255);
HXDLIN( 125)													if ((this11 == 0)) {
HXLINE( 125)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float b2;
HXDLIN( 125)													int this12 = (color & 255);
HXDLIN( 125)													if ((this12 == 0)) {
HXLINE( 125)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 125)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 125)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 125)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 125)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 125)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 125)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 125)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 125)													{
HXLINE( 125)														::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 125)														int value;
HXDLIN( 125)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 125)															value = blended;
            														}
HXDLIN( 125)														bool _hx_tmp;
HXDLIN( 125)														if ((location >= 0)) {
HXLINE( 125)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 125)															_hx_tmp = false;
            														}
HXDLIN( 125)														if (_hx_tmp) {
HXLINE( 125)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 125)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 125)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 125)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 125)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 125)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 125)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 125)													int index;
HXDLIN( 125)													if (temp->useVirtualPos) {
HXLINE( 125)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 125)														index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 125)													int value;
HXDLIN( 125)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)														value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            													}
            													else {
HXLINE( 125)														value = c1;
            													}
HXDLIN( 125)													bool _hx_tmp;
HXDLIN( 125)													if ((index >= 0)) {
HXLINE( 125)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 125)														_hx_tmp = false;
            													}
HXDLIN( 125)													if (_hx_tmp) {
HXLINE( 125)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 125)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 125)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 125)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 237)											foundY = true;
            										}
            										else {
HXLINE( 125)											if (foundY) {
HXLINE( 125)												goto _hx_goto_41;
            											}
            										}
            									}
            								}
            								_hx_goto_41:;
            							}
            						}
            					}
HXDLIN( 125)					::pixelimage::algo::HitTri triHit;
HXDLIN( 125)					if ((hasHit == false)) {
HXLINE( 125)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 125)						if (hasUndo) {
HXLINE( 125)							v->undoImage = undoImage;
HXDLIN( 125)							v->undoX = xIter3->start;
HXDLIN( 125)							v->undoY = yIter3->start;
            						}
HXDLIN( 125)						triHit = v;
            					}
            					else {
HXLINE( 125)						triHit = null();
            					}
HXDLIN( 125)					if (hasHit) {
HXLINE( 125)						arrTri[arrTri->length] = triHit;
            					}
HXLINE( 474)					bx = cx;
HXLINE( 475)					by = cy;
            				}
            			}
HXLINE( 478)			currAngle = (startRadian + sweepRadian);
HXLINE( 479)			cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 480)			cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 125)			Float bx1 = bx;
HXDLIN( 125)			Float by1 = by;
HXDLIN( 125)			Float cx1 = cx;
HXDLIN( 125)			Float cy1 = cy;
HXDLIN( 125)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 125)			if (!(adjustWinding)) {
HXLINE( 125)				Float bx_ = bx1;
HXDLIN( 125)				Float by_ = by1;
HXLINE( 188)				bx1 = cx1;
HXLINE( 189)				by1 = cy1;
HXLINE( 190)				cx1 = bx_;
HXLINE( 191)				cy1 = by_;
            			}
HXLINE( 125)			bool hasUndo = false;
HXDLIN( 125)			Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 125)			Float sx = (cy1 - ay);
HXDLIN( 125)			Float sy = (ax - cx1);
HXDLIN( 125)			Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 125)			Float tx = (ay - by1);
HXDLIN( 125)			Float ty = (bx1 - ax);
HXDLIN( 125)			Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 125)			::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 125)			if ((ax > bx1)) {
HXLINE( 125)				if ((ax > cx1)) {
HXLINE( 125)					int min;
HXDLIN( 125)					if ((bx1 > cx1)) {
HXLINE( 125)						min = ::Math_obj::floor(cx1);
            					}
            					else {
HXLINE( 125)						min = ::Math_obj::floor(bx1);
            					}
HXDLIN( 125)					int ii_min = min;
HXDLIN( 125)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 125)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)					xIter3 = this1;
            				}
            				else {
HXLINE( 125)					int ii_min = ::Math_obj::floor(bx1);
HXDLIN( 125)					int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 125)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)					xIter3 = this1;
            				}
            			}
            			else {
HXLINE( 125)				if ((bx1 > cx1)) {
HXLINE( 125)					int min;
HXDLIN( 125)					if ((ax > cx1)) {
HXLINE( 125)						min = ::Math_obj::floor(cx1);
            					}
            					else {
HXLINE( 125)						min = ::Math_obj::ceil(ax);
            					}
HXDLIN( 125)					int ii_min = min;
HXDLIN( 125)					int ii_max = ::Math_obj::ceil(bx1);
HXDLIN( 125)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)					xIter3 = this1;
            				}
            				else {
HXLINE( 125)					int ii_min = ::Math_obj::floor(ax);
HXDLIN( 125)					int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 125)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)					xIter3 = this1;
            				}
            			}
HXDLIN( 125)			::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 125)			if ((ay > by1)) {
HXLINE( 125)				if ((ay > cy1)) {
HXLINE( 125)					int min;
HXDLIN( 125)					if ((by1 > cy1)) {
HXLINE( 125)						min = ::Math_obj::floor(cy1);
            					}
            					else {
HXLINE( 125)						min = ::Math_obj::floor(by1);
            					}
HXDLIN( 125)					int ii_min = min;
HXDLIN( 125)					int ii_max = ::Math_obj::ceil(ay);
HXDLIN( 125)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)					yIter3 = this1;
            				}
            				else {
HXLINE( 125)					int ii_min = ::Math_obj::floor(by1);
HXDLIN( 125)					int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 125)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)					yIter3 = this1;
            				}
            			}
            			else {
HXLINE( 125)				if ((by1 > cy1)) {
HXLINE( 125)					int min;
HXDLIN( 125)					if ((ay > cy1)) {
HXLINE( 125)						min = ::Math_obj::floor(cy1);
            					}
            					else {
HXLINE( 125)						min = ::Math_obj::ceil(ay);
            					}
HXDLIN( 125)					int ii_min = min;
HXDLIN( 125)					int ii_max = ::Math_obj::ceil(by1);
HXDLIN( 125)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)					yIter3 = this1;
            				}
            				else {
HXLINE( 125)					int ii_min = ::Math_obj::floor(ay);
HXDLIN( 125)					int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 125)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 125)					yIter3 = this1;
            				}
            			}
HXDLIN( 125)			::pixelimage::ImageStruct undoImage = null();
HXDLIN( 125)			if (hasUndo) {
HXLINE( 125)				int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 125)				int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 125)				int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 125)				::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 125)				::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 125)				::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 125)				undoImage = this3;
HXDLIN( 125)				{
HXLINE( 125)					int rectLeft = xIter3->start;
HXDLIN( 125)					int rectTop = yIter3->start;
HXDLIN( 125)					int rectRight = xIter3->max;
HXDLIN( 125)					bool forceClear = false;
HXDLIN( 125)					{
HXLINE( 125)						int _g = rectTop;
HXDLIN( 125)						int _g1 = yIter3->max;
HXDLIN( 125)						while((_g < _g1)){
HXLINE( 125)							_g = (_g + 1);
HXDLIN( 125)							int dy = (_g - 1);
HXDLIN( 125)							{
HXLINE( 125)								int _g1 = rectLeft;
HXDLIN( 125)								int _g2 = rectRight;
HXDLIN( 125)								while((_g1 < _g2)){
HXLINE( 125)									_g1 = (_g1 + 1);
HXDLIN( 125)									int dx = (_g1 - 1);
HXDLIN( 125)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 125)									int index;
HXDLIN( 125)									if (temp->useVirtualPos) {
HXLINE( 125)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            									}
            									else {
HXLINE( 125)										index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            									}
HXDLIN( 125)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)									int col;
HXDLIN( 125)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 125)										col = c;
            									}
HXDLIN( 125)									bool _hx_tmp;
HXDLIN( 125)									if (temp->useMask) {
HXLINE( 125)										_hx_tmp = ::hx::IsNotNull( temp->mask );
            									}
            									else {
HXLINE( 125)										_hx_tmp = false;
            									}
HXDLIN( 125)									if (_hx_tmp) {
HXLINE( 125)										::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 125)										::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 125)										int index;
HXDLIN( 125)										if (this1->useVirtualPos) {
HXLINE( 125)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            										}
            										else {
HXLINE( 125)											index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            										}
HXDLIN( 125)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 125)										int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 125)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)										int v;
HXDLIN( 125)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)											v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 125)											v = c;
            										}
HXDLIN( 125)										int this3 = v;
HXDLIN( 125)										int maskPixel = this3;
HXDLIN( 125)										int this4 = col;
HXDLIN( 125)										int this5 = this4;
HXDLIN( 125)										if ((maskPixel == 0)) {
HXLINE( 125)											int this1 = this5;
HXDLIN( 125)											col = this1;
            										}
            										else {
HXLINE( 125)											Float m0;
HXDLIN( 125)											int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 125)											if ((this1 == 0)) {
HXLINE( 125)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float m1;
HXDLIN( 125)											int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 125)											if ((this2 == 0)) {
HXLINE( 125)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float m2;
HXDLIN( 125)											int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 125)											if ((this3 == 0)) {
HXLINE( 125)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float m3;
HXDLIN( 125)											int this4 = (maskPixel & 255);
HXDLIN( 125)											if ((this4 == 0)) {
HXLINE( 125)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 125)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 125)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 125)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 125)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 125)									if ((col != 0)) {
HXLINE( 125)										int x = (dx - rectLeft);
HXDLIN( 125)										int y = (dy - rectTop);
HXDLIN( 125)										int this1 = col;
HXDLIN( 125)										int c = this1;
HXDLIN( 125)										bool _hx_tmp;
HXDLIN( 125)										if ((((c >> 24) & 255) < 254)) {
HXLINE( 125)											_hx_tmp = undoImage->transparent;
            										}
            										else {
HXLINE( 125)											_hx_tmp = false;
            										}
HXDLIN( 125)										if (_hx_tmp) {
HXLINE( 125)											int location;
HXDLIN( 125)											if (undoImage->useVirtualPos) {
HXLINE( 125)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE( 125)												location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN( 125)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 125)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 125)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)											int this3 = this2;
HXDLIN( 125)											int this4;
HXDLIN( 125)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE( 125)												this4 = this3;
            											}
HXDLIN( 125)											Float a1;
HXDLIN( 125)											int this5 = ((this4 >> 24) & 255);
HXDLIN( 125)											if ((this5 == 0)) {
HXLINE( 125)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float r1;
HXDLIN( 125)											int this6 = ((this4 >> 16) & 255);
HXDLIN( 125)											if ((this6 == 0)) {
HXLINE( 125)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float g1;
HXDLIN( 125)											int this7 = ((this4 >> 8) & 255);
HXDLIN( 125)											if ((this7 == 0)) {
HXLINE( 125)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float b1;
HXDLIN( 125)											int this8 = (this4 & 255);
HXDLIN( 125)											if ((this8 == 0)) {
HXLINE( 125)												b1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float a2;
HXDLIN( 125)											int this9 = ((col >> 24) & 255);
HXDLIN( 125)											if ((this9 == 0)) {
HXLINE( 125)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float r2;
HXDLIN( 125)											int this10 = ((col >> 16) & 255);
HXDLIN( 125)											if ((this10 == 0)) {
HXLINE( 125)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float g2;
HXDLIN( 125)											int this11 = ((col >> 8) & 255);
HXDLIN( 125)											if ((this11 == 0)) {
HXLINE( 125)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float b2;
HXDLIN( 125)											int this12 = (col & 255);
HXDLIN( 125)											if ((this12 == 0)) {
HXLINE( 125)												b2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 125)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 125)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 125)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 125)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 125)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 125)											{
HXLINE( 125)												::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 125)												int value;
HXDLIN( 125)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 125)													value = blended;
            												}
HXDLIN( 125)												bool _hx_tmp;
HXDLIN( 125)												if ((location >= 0)) {
HXLINE( 125)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE( 125)													_hx_tmp = false;
            												}
HXDLIN( 125)												if (_hx_tmp) {
HXLINE( 125)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 125)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 125)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 125)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 125)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 125)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE( 125)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 125)											int index;
HXDLIN( 125)											if (undoImage->useVirtualPos) {
HXLINE( 125)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE( 125)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN( 125)											int value;
HXDLIN( 125)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 125)												value = c;
            											}
HXDLIN( 125)											bool _hx_tmp;
HXDLIN( 125)											if ((index >= 0)) {
HXLINE( 125)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE( 125)												_hx_tmp = false;
            											}
HXDLIN( 125)											if (_hx_tmp) {
HXLINE( 125)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 125)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 125)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 125)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE( 125)										if (forceClear) {
HXLINE( 125)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 125)											int x = (dx - rectLeft);
HXDLIN( 125)											int y = (dy - rectTop);
HXDLIN( 125)											int index;
HXDLIN( 125)											if (undoImage->useVirtualPos) {
HXLINE( 125)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE( 125)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN( 125)											bool _hx_tmp;
HXDLIN( 125)											if ((index >= 0)) {
HXLINE( 125)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE( 125)												_hx_tmp = false;
            											}
HXDLIN( 125)											if (_hx_tmp) {
HXLINE( 125)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 125)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 125)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 125)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 125)			bool foundY = false;
HXDLIN( 125)			Float s = ((Float)0.);
HXDLIN( 125)			Float t = ((Float)0.);
HXDLIN( 125)			Float sxx = ((Float)0.);
HXDLIN( 125)			Float txx = ((Float)0.);
HXDLIN( 125)			{
HXLINE( 125)				int _g_min = xIter3->start;
HXDLIN( 125)				int _g_max = xIter3->max;
HXDLIN( 125)				while((_g_min < _g_max)){
HXLINE( 125)					_g_min = (_g_min + 1);
HXDLIN( 125)					int x = (_g_min - 1);
HXLINE( 223)					sxx = (sx * ( (Float)(x) ));
HXLINE( 224)					txx = (tx * ( (Float)(x) ));
HXLINE( 225)					foundY = false;
HXLINE( 125)					{
HXLINE( 125)						int _g_min1 = yIter3->start;
HXDLIN( 125)						int _g_max = yIter3->max;
HXDLIN( 125)						while((_g_min1 < _g_max)){
HXLINE( 125)							_g_min1 = (_g_min1 + 1);
HXDLIN( 125)							int y = (_g_min1 - 1);
HXLINE( 227)							s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)							t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 125)							bool _hx_tmp;
HXDLIN( 125)							if (!((s <= 0))) {
HXLINE( 125)								_hx_tmp = (t <= 0);
            							}
            							else {
HXLINE( 125)								_hx_tmp = true;
            							}
HXDLIN( 125)							if (_hx_tmp) {
HXLINE( 125)								if (foundY) {
HXLINE( 125)									goto _hx_goto_45;
            								}
            							}
            							else {
HXLINE( 125)								if (((s + t) < A)) {
HXLINE( 125)									int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN( 125)									int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN( 125)									::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN( 125)									int index;
HXDLIN( 125)									if (tileImage->useVirtualPos) {
HXLINE( 125)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            									}
            									else {
HXLINE( 125)										index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            									}
HXDLIN( 125)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)									int color;
HXDLIN( 125)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)										color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 125)										color = c;
            									}
HXDLIN( 125)									{
HXLINE( 125)										int this2 = color;
HXDLIN( 125)										int c1 = this2;
HXDLIN( 125)										bool _hx_tmp;
HXDLIN( 125)										if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 125)											_hx_tmp = temp->transparent;
            										}
            										else {
HXLINE( 125)											_hx_tmp = false;
            										}
HXDLIN( 125)										if (_hx_tmp) {
HXLINE( 125)											int location;
HXDLIN( 125)											if (temp->useVirtualPos) {
HXLINE( 125)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            											}
            											else {
HXLINE( 125)												location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            											}
HXDLIN( 125)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 125)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 125)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 125)											int this3 = this2;
HXDLIN( 125)											int this4;
HXDLIN( 125)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE( 125)												this4 = this3;
            											}
HXDLIN( 125)											Float a1;
HXDLIN( 125)											int this5 = ((this4 >> 24) & 255);
HXDLIN( 125)											if ((this5 == 0)) {
HXLINE( 125)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float r1;
HXDLIN( 125)											int this6 = ((this4 >> 16) & 255);
HXDLIN( 125)											if ((this6 == 0)) {
HXLINE( 125)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float g1;
HXDLIN( 125)											int this7 = ((this4 >> 8) & 255);
HXDLIN( 125)											if ((this7 == 0)) {
HXLINE( 125)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float b1;
HXDLIN( 125)											int this8 = (this4 & 255);
HXDLIN( 125)											if ((this8 == 0)) {
HXLINE( 125)												b1 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float a2;
HXDLIN( 125)											int this9 = ((color >> 24) & 255);
HXDLIN( 125)											if ((this9 == 0)) {
HXLINE( 125)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float r2;
HXDLIN( 125)											int this10 = ((color >> 16) & 255);
HXDLIN( 125)											if ((this10 == 0)) {
HXLINE( 125)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float g2;
HXDLIN( 125)											int this11 = ((color >> 8) & 255);
HXDLIN( 125)											if ((this11 == 0)) {
HXLINE( 125)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float b2;
HXDLIN( 125)											int this12 = (color & 255);
HXDLIN( 125)											if ((this12 == 0)) {
HXLINE( 125)												b2 = ((Float)0.);
            											}
            											else {
HXLINE( 125)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN( 125)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 125)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 125)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 125)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 125)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 125)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 125)											{
HXLINE( 125)												::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 125)												int value;
HXDLIN( 125)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 125)													value = blended;
            												}
HXDLIN( 125)												bool _hx_tmp;
HXDLIN( 125)												if ((location >= 0)) {
HXLINE( 125)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE( 125)													_hx_tmp = false;
            												}
HXDLIN( 125)												if (_hx_tmp) {
HXLINE( 125)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 125)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 125)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 125)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 125)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 125)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE( 125)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 125)											int index;
HXDLIN( 125)											if (temp->useVirtualPos) {
HXLINE( 125)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            											}
            											else {
HXLINE( 125)												index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            											}
HXDLIN( 125)											int value;
HXDLIN( 125)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)												value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 125)												value = c1;
            											}
HXDLIN( 125)											bool _hx_tmp;
HXDLIN( 125)											if ((index >= 0)) {
HXLINE( 125)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE( 125)												_hx_tmp = false;
            											}
HXDLIN( 125)											if (_hx_tmp) {
HXLINE( 125)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 125)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 125)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 125)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 125)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 125)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXLINE( 237)									foundY = true;
            								}
            								else {
HXLINE( 125)									if (foundY) {
HXLINE( 125)										goto _hx_goto_45;
            									}
            								}
            							}
            						}
            						_hx_goto_45:;
            					}
            				}
            			}
HXDLIN( 125)			::pixelimage::algo::HitTri triHit;
HXDLIN( 125)			if ((hasHit == false)) {
HXLINE( 125)				::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 125)				if (hasUndo) {
HXLINE( 125)					v->undoImage = undoImage;
HXDLIN( 125)					v->undoX = xIter3->start;
HXDLIN( 125)					v->undoY = yIter3->start;
            				}
HXDLIN( 125)				triHit = v;
            			}
            			else {
HXLINE( 125)				triHit = null();
            			}
HXDLIN( 125)			if (hasHit) {
HXLINE( 125)				arrTri[arrTri->length] = triHit;
            			}
HXDLIN( 125)			if (hasHit) {
HXLINE( 125)				::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,arrTri);
            			}
            			else {
HXLINE( 486)				arrTri = null();
            			}
            		}
HXLINE( 126)		{
HXLINE( 126)			Float ax1 = this->rx;
HXDLIN( 126)			Float ay1 = this->ry;
HXDLIN( 126)			Float rx1 = (this->rx - this->strokeWidth);
HXDLIN( 126)			Float ry1 = (this->ry - this->strokeWidth);
HXDLIN( 126)			Float startRadian1 = this->startAngle;
HXDLIN( 126)			Float sweepRadian1 = this->sweepAngle;
HXDLIN( 126)			::pixelimage::ImageStruct tileImage1 = this->tileImageFill;
HXDLIN( 126)			bool hasHit1 = false;
HXDLIN( 126)			Float rSmall1;
HXDLIN( 126)			if ((rx1 > ry1)) {
HXLINE( 126)				rSmall1 = ry1;
            			}
            			else {
HXLINE( 126)				rSmall1 = rx1;
            			}
HXDLIN( 126)			 ::Dynamic targetE1 = ((Float)1.05);
HXDLIN( 126)			if (::hx::IsNull( targetE1 )) {
HXLINE( 457)				targetE1 = ((Float)1.05);
            			}
HXLINE( 126)			int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN( 126)			int noSides1;
HXDLIN( 126)			if ((result1 < 12)) {
HXLINE( 126)				noSides1 = 12;
            			}
            			else {
HXLINE( 126)				if ((result1 > 500)) {
HXLINE( 126)					noSides1 = 500;
            				}
            				else {
HXLINE( 126)					noSides1 = result1;
            				}
            			}
HXDLIN( 126)			Float theta1 = ((((Float)1.41213) * ::Math_obj::PI) / ( (Float)(noSides1) ));
HXDLIN( 126)			Float currAngle1 = startRadian1;
HXDLIN( 126)			int tot1 = ::Math_obj::floor((sweepRadian1 / theta1));
HXDLIN( 126)			theta1 = (theta1 + (((sweepRadian1 / theta1) - ( (Float)(tot1) )) / ( (Float)(noSides1) )));
HXLINE( 462)			tot1 = ::Math_obj::floor((sweepRadian1 / theta1));
HXLINE( 126)			Float bx2 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax1);
HXDLIN( 126)			Float by2 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay1);
HXDLIN( 126)			Float cx2 = ((Float)0.);
HXDLIN( 126)			Float cy2 = ((Float)0.);
HXDLIN( 126)			::Array< ::Dynamic> arrTri1 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 126)			{
HXLINE( 126)				int _g2 = 1;
HXDLIN( 126)				int _g3 = (tot1 + 1);
HXDLIN( 126)				while((_g2 < _g3)){
HXLINE( 126)					_g2 = (_g2 + 1);
HXDLIN( 126)					int i = (_g2 - 1);
HXLINE( 469)					currAngle1 = (startRadian1 + (( (Float)(i) ) * theta1));
HXLINE( 470)					cx2 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax1);
HXLINE( 471)					cy2 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay1);
HXLINE( 126)					Float bx = bx2;
HXDLIN( 126)					Float by = by2;
HXDLIN( 126)					Float cx = cx2;
HXDLIN( 126)					Float cy = cy2;
HXDLIN( 126)					bool adjustWinding = (((((ax1 * by) - (bx * ay1)) + ((bx * cy) - (cx * by))) + ((cx * ay1) - (ax1 * cy))) > 0);
HXDLIN( 126)					if (!(adjustWinding)) {
HXLINE( 126)						Float bx_ = bx;
HXDLIN( 126)						Float by_ = by;
HXLINE( 188)						bx = cx;
HXLINE( 189)						by = cy;
HXLINE( 190)						cx = bx_;
HXLINE( 191)						cy = by_;
            					}
HXLINE( 126)					bool hasUndo = false;
HXDLIN( 126)					Float s0 = ((ay1 * cx) - (ax1 * cy));
HXDLIN( 126)					Float sx = (cy - ay1);
HXDLIN( 126)					Float sy = (ax1 - cx);
HXDLIN( 126)					Float t0 = ((ax1 * by) - (ay1 * bx));
HXDLIN( 126)					Float tx = (ay1 - by);
HXDLIN( 126)					Float ty = (bx - ax1);
HXDLIN( 126)					Float A = ((((-(by) * cx) + (ay1 * (-(bx) + cx))) + (ax1 * (by - cy))) + (bx * cy));
HXDLIN( 126)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 126)					if ((ax1 > bx)) {
HXLINE( 126)						if ((ax1 > cx)) {
HXLINE( 126)							int min;
HXDLIN( 126)							if ((bx > cx)) {
HXLINE( 126)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE( 126)								min = ::Math_obj::floor(bx);
            							}
HXDLIN( 126)							int ii_min = min;
HXDLIN( 126)							int ii_max = ::Math_obj::ceil(ax1);
HXDLIN( 126)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)							xIter3 = this1;
            						}
            						else {
HXLINE( 126)							int ii_min = ::Math_obj::floor(bx);
HXDLIN( 126)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 126)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE( 126)						if ((bx > cx)) {
HXLINE( 126)							int min;
HXDLIN( 126)							if ((ax1 > cx)) {
HXLINE( 126)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE( 126)								min = ::Math_obj::ceil(ax1);
            							}
HXDLIN( 126)							int ii_min = min;
HXDLIN( 126)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 126)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)							xIter3 = this1;
            						}
            						else {
HXLINE( 126)							int ii_min = ::Math_obj::floor(ax1);
HXDLIN( 126)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 126)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)							xIter3 = this1;
            						}
            					}
HXDLIN( 126)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 126)					if ((ay1 > by)) {
HXLINE( 126)						if ((ay1 > cy)) {
HXLINE( 126)							int min;
HXDLIN( 126)							if ((by > cy)) {
HXLINE( 126)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE( 126)								min = ::Math_obj::floor(by);
            							}
HXDLIN( 126)							int ii_min = min;
HXDLIN( 126)							int ii_max = ::Math_obj::ceil(ay1);
HXDLIN( 126)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)							yIter3 = this1;
            						}
            						else {
HXLINE( 126)							int ii_min = ::Math_obj::floor(by);
HXDLIN( 126)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN( 126)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE( 126)						if ((by > cy)) {
HXLINE( 126)							int min;
HXDLIN( 126)							if ((ay1 > cy)) {
HXLINE( 126)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE( 126)								min = ::Math_obj::ceil(ay1);
            							}
HXDLIN( 126)							int ii_min = min;
HXDLIN( 126)							int ii_max = ::Math_obj::ceil(by);
HXDLIN( 126)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)							yIter3 = this1;
            						}
            						else {
HXLINE( 126)							int ii_min = ::Math_obj::floor(ay1);
HXDLIN( 126)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN( 126)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)							yIter3 = this1;
            						}
            					}
HXDLIN( 126)					::pixelimage::ImageStruct undoImage = null();
HXDLIN( 126)					if (hasUndo) {
HXLINE( 126)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 126)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 126)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 126)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 126)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 126)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 126)						undoImage = this3;
HXDLIN( 126)						{
HXLINE( 126)							int rectLeft = xIter3->start;
HXDLIN( 126)							int rectTop = yIter3->start;
HXDLIN( 126)							int rectRight = xIter3->max;
HXDLIN( 126)							bool forceClear = false;
HXDLIN( 126)							{
HXLINE( 126)								int _g = rectTop;
HXDLIN( 126)								int _g1 = yIter3->max;
HXDLIN( 126)								while((_g < _g1)){
HXLINE( 126)									_g = (_g + 1);
HXDLIN( 126)									int dy = (_g - 1);
HXDLIN( 126)									{
HXLINE( 126)										int _g1 = rectLeft;
HXDLIN( 126)										int _g2 = rectRight;
HXDLIN( 126)										while((_g1 < _g2)){
HXLINE( 126)											_g1 = (_g1 + 1);
HXDLIN( 126)											int dx = (_g1 - 1);
HXDLIN( 126)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 126)											int index;
HXDLIN( 126)											if (temp->useVirtualPos) {
HXLINE( 126)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            											}
            											else {
HXLINE( 126)												index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            											}
HXDLIN( 126)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)											int col;
HXDLIN( 126)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 126)												col = c;
            											}
HXDLIN( 126)											bool _hx_tmp;
HXDLIN( 126)											if (temp->useMask) {
HXLINE( 126)												_hx_tmp = ::hx::IsNotNull( temp->mask );
            											}
            											else {
HXLINE( 126)												_hx_tmp = false;
            											}
HXDLIN( 126)											if (_hx_tmp) {
HXLINE( 126)												::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 126)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 126)												int index;
HXDLIN( 126)												if (this1->useVirtualPos) {
HXLINE( 126)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE( 126)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN( 126)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 126)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 126)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)												int v;
HXDLIN( 126)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 126)													v = c;
            												}
HXDLIN( 126)												int this3 = v;
HXDLIN( 126)												int maskPixel = this3;
HXDLIN( 126)												int this4 = col;
HXDLIN( 126)												int this5 = this4;
HXDLIN( 126)												if ((maskPixel == 0)) {
HXLINE( 126)													int this1 = this5;
HXDLIN( 126)													col = this1;
            												}
            												else {
HXLINE( 126)													Float m0;
HXDLIN( 126)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 126)													if ((this1 == 0)) {
HXLINE( 126)														m0 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float m1;
HXDLIN( 126)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 126)													if ((this2 == 0)) {
HXLINE( 126)														m1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float m2;
HXDLIN( 126)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 126)													if ((this3 == 0)) {
HXLINE( 126)														m2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float m3;
HXDLIN( 126)													int this4 = (maskPixel & 255);
HXDLIN( 126)													if ((this4 == 0)) {
HXLINE( 126)														m3 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 126)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 126)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 126)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 126)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 126)											if ((col != 0)) {
HXLINE( 126)												int x = (dx - rectLeft);
HXDLIN( 126)												int y = (dy - rectTop);
HXDLIN( 126)												int this1 = col;
HXDLIN( 126)												int c = this1;
HXDLIN( 126)												bool _hx_tmp;
HXDLIN( 126)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 126)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE( 126)													_hx_tmp = false;
            												}
HXDLIN( 126)												if (_hx_tmp) {
HXLINE( 126)													int location;
HXDLIN( 126)													if (undoImage->useVirtualPos) {
HXLINE( 126)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 126)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 126)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 126)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 126)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)													int this3 = this2;
HXDLIN( 126)													int this4;
HXDLIN( 126)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 126)														this4 = this3;
            													}
HXDLIN( 126)													Float a1;
HXDLIN( 126)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 126)													if ((this5 == 0)) {
HXLINE( 126)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float r1;
HXDLIN( 126)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 126)													if ((this6 == 0)) {
HXLINE( 126)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float g1;
HXDLIN( 126)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 126)													if ((this7 == 0)) {
HXLINE( 126)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float b1;
HXDLIN( 126)													int this8 = (this4 & 255);
HXDLIN( 126)													if ((this8 == 0)) {
HXLINE( 126)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float a2;
HXDLIN( 126)													int this9 = ((col >> 24) & 255);
HXDLIN( 126)													if ((this9 == 0)) {
HXLINE( 126)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float r2;
HXDLIN( 126)													int this10 = ((col >> 16) & 255);
HXDLIN( 126)													if ((this10 == 0)) {
HXLINE( 126)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float g2;
HXDLIN( 126)													int this11 = ((col >> 8) & 255);
HXDLIN( 126)													if ((this11 == 0)) {
HXLINE( 126)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float b2;
HXDLIN( 126)													int this12 = (col & 255);
HXDLIN( 126)													if ((this12 == 0)) {
HXLINE( 126)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 126)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 126)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 126)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 126)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 126)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 126)													{
HXLINE( 126)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 126)														int value;
HXDLIN( 126)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 126)															value = blended;
            														}
HXDLIN( 126)														bool _hx_tmp;
HXDLIN( 126)														if ((location >= 0)) {
HXLINE( 126)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 126)															_hx_tmp = false;
            														}
HXDLIN( 126)														if (_hx_tmp) {
HXLINE( 126)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 126)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 126)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 126)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 126)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 126)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 126)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 126)													int index;
HXDLIN( 126)													if (undoImage->useVirtualPos) {
HXLINE( 126)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 126)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 126)													int value;
HXDLIN( 126)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 126)														value = c;
            													}
HXDLIN( 126)													bool _hx_tmp;
HXDLIN( 126)													if ((index >= 0)) {
HXLINE( 126)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 126)														_hx_tmp = false;
            													}
HXDLIN( 126)													if (_hx_tmp) {
HXLINE( 126)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 126)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 126)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 126)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 126)												if (forceClear) {
HXLINE( 126)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 126)													int x = (dx - rectLeft);
HXDLIN( 126)													int y = (dy - rectTop);
HXDLIN( 126)													int index;
HXDLIN( 126)													if (undoImage->useVirtualPos) {
HXLINE( 126)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 126)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 126)													bool _hx_tmp;
HXDLIN( 126)													if ((index >= 0)) {
HXLINE( 126)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 126)														_hx_tmp = false;
            													}
HXDLIN( 126)													if (_hx_tmp) {
HXLINE( 126)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 126)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 126)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 126)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 126)					bool foundY = false;
HXDLIN( 126)					Float s = ((Float)0.);
HXDLIN( 126)					Float t = ((Float)0.);
HXDLIN( 126)					Float sxx = ((Float)0.);
HXDLIN( 126)					Float txx = ((Float)0.);
HXDLIN( 126)					{
HXLINE( 126)						int _g_min = xIter3->start;
HXDLIN( 126)						int _g_max = xIter3->max;
HXDLIN( 126)						while((_g_min < _g_max)){
HXLINE( 126)							_g_min = (_g_min + 1);
HXDLIN( 126)							int x = (_g_min - 1);
HXLINE( 223)							sxx = (sx * ( (Float)(x) ));
HXLINE( 224)							txx = (tx * ( (Float)(x) ));
HXLINE( 225)							foundY = false;
HXLINE( 126)							{
HXLINE( 126)								int _g_min1 = yIter3->start;
HXDLIN( 126)								int _g_max = yIter3->max;
HXDLIN( 126)								while((_g_min1 < _g_max)){
HXLINE( 126)									_g_min1 = (_g_min1 + 1);
HXDLIN( 126)									int y = (_g_min1 - 1);
HXLINE( 227)									s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)									t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 126)									bool _hx_tmp;
HXDLIN( 126)									if (!((s <= 0))) {
HXLINE( 126)										_hx_tmp = (t <= 0);
            									}
            									else {
HXLINE( 126)										_hx_tmp = true;
            									}
HXDLIN( 126)									if (_hx_tmp) {
HXLINE( 126)										if (foundY) {
HXLINE( 126)											goto _hx_goto_50;
            										}
            									}
            									else {
HXLINE( 126)										if (((s + t) < A)) {
HXLINE( 126)											int x1 = ::hx::Mod(x,tileImage1->width);
HXDLIN( 126)											int y1 = ::hx::Mod(y,tileImage1->height);
HXDLIN( 126)											::haxe::io::ArrayBufferViewImpl this1 = tileImage1->image;
HXDLIN( 126)											int index;
HXDLIN( 126)											if (tileImage1->useVirtualPos) {
HXLINE( 126)												index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage1->virtualY) * ( (Float)(tileImage1->width) )) + x1) - tileImage1->virtualX));
            											}
            											else {
HXLINE( 126)												index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage1->width) + x1)) ));
            											}
HXDLIN( 126)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)											int color;
HXDLIN( 126)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)												color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 126)												color = c;
            											}
HXDLIN( 126)											{
HXLINE( 126)												int this2 = color;
HXDLIN( 126)												int c1 = this2;
HXDLIN( 126)												bool _hx_tmp;
HXDLIN( 126)												if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 126)													_hx_tmp = temp->transparent;
            												}
            												else {
HXLINE( 126)													_hx_tmp = false;
            												}
HXDLIN( 126)												if (_hx_tmp) {
HXLINE( 126)													int location;
HXDLIN( 126)													if (temp->useVirtualPos) {
HXLINE( 126)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 126)														location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 126)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 126)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 126)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)													int this3 = this2;
HXDLIN( 126)													int this4;
HXDLIN( 126)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 126)														this4 = this3;
            													}
HXDLIN( 126)													Float a1;
HXDLIN( 126)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 126)													if ((this5 == 0)) {
HXLINE( 126)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float r1;
HXDLIN( 126)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 126)													if ((this6 == 0)) {
HXLINE( 126)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float g1;
HXDLIN( 126)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 126)													if ((this7 == 0)) {
HXLINE( 126)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float b1;
HXDLIN( 126)													int this8 = (this4 & 255);
HXDLIN( 126)													if ((this8 == 0)) {
HXLINE( 126)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float a2;
HXDLIN( 126)													int this9 = ((color >> 24) & 255);
HXDLIN( 126)													if ((this9 == 0)) {
HXLINE( 126)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float r2;
HXDLIN( 126)													int this10 = ((color >> 16) & 255);
HXDLIN( 126)													if ((this10 == 0)) {
HXLINE( 126)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float g2;
HXDLIN( 126)													int this11 = ((color >> 8) & 255);
HXDLIN( 126)													if ((this11 == 0)) {
HXLINE( 126)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float b2;
HXDLIN( 126)													int this12 = (color & 255);
HXDLIN( 126)													if ((this12 == 0)) {
HXLINE( 126)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 126)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 126)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 126)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 126)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 126)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 126)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 126)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 126)													{
HXLINE( 126)														::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 126)														int value;
HXDLIN( 126)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 126)															value = blended;
            														}
HXDLIN( 126)														bool _hx_tmp;
HXDLIN( 126)														if ((location >= 0)) {
HXLINE( 126)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 126)															_hx_tmp = false;
            														}
HXDLIN( 126)														if (_hx_tmp) {
HXLINE( 126)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 126)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 126)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 126)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 126)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 126)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 126)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 126)													int index;
HXDLIN( 126)													if (temp->useVirtualPos) {
HXLINE( 126)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 126)														index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 126)													int value;
HXDLIN( 126)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)														value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            													}
            													else {
HXLINE( 126)														value = c1;
            													}
HXDLIN( 126)													bool _hx_tmp;
HXDLIN( 126)													if ((index >= 0)) {
HXLINE( 126)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 126)														_hx_tmp = false;
            													}
HXDLIN( 126)													if (_hx_tmp) {
HXLINE( 126)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 126)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 126)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 126)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 237)											foundY = true;
            										}
            										else {
HXLINE( 126)											if (foundY) {
HXLINE( 126)												goto _hx_goto_50;
            											}
            										}
            									}
            								}
            								_hx_goto_50:;
            							}
            						}
            					}
HXDLIN( 126)					::pixelimage::algo::HitTri triHit;
HXDLIN( 126)					if ((hasHit1 == false)) {
HXLINE( 126)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx,by,cx,cy,true);
HXDLIN( 126)						if (hasUndo) {
HXLINE( 126)							v->undoImage = undoImage;
HXDLIN( 126)							v->undoX = xIter3->start;
HXDLIN( 126)							v->undoY = yIter3->start;
            						}
HXDLIN( 126)						triHit = v;
            					}
            					else {
HXLINE( 126)						triHit = null();
            					}
HXDLIN( 126)					if (hasHit1) {
HXLINE( 126)						arrTri1[arrTri1->length] = triHit;
            					}
HXLINE( 474)					bx2 = cx2;
HXLINE( 475)					by2 = cy2;
            				}
            			}
HXLINE( 478)			currAngle1 = (startRadian1 + sweepRadian1);
HXLINE( 479)			cx2 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax1);
HXLINE( 480)			cy2 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay1);
HXLINE( 126)			Float bx3 = bx2;
HXDLIN( 126)			Float by3 = by2;
HXDLIN( 126)			Float cx3 = cx2;
HXDLIN( 126)			Float cy3 = cy2;
HXDLIN( 126)			bool adjustWinding1 = (((((ax1 * by3) - (bx3 * ay1)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay1) - (ax1 * cy3))) > 0);
HXDLIN( 126)			if (!(adjustWinding1)) {
HXLINE( 126)				Float bx_ = bx3;
HXDLIN( 126)				Float by_ = by3;
HXLINE( 188)				bx3 = cx3;
HXLINE( 189)				by3 = cy3;
HXLINE( 190)				cx3 = bx_;
HXLINE( 191)				cy3 = by_;
            			}
HXLINE( 126)			bool hasUndo1 = false;
HXDLIN( 126)			Float s01 = ((ay1 * cx3) - (ax1 * cy3));
HXDLIN( 126)			Float sx1 = (cy3 - ay1);
HXDLIN( 126)			Float sy1 = (ax1 - cx3);
HXDLIN( 126)			Float t01 = ((ax1 * by3) - (ay1 * bx3));
HXDLIN( 126)			Float tx1 = (ay1 - by3);
HXDLIN( 126)			Float ty1 = (bx3 - ax1);
HXDLIN( 126)			Float A1 = ((((-(by3) * cx3) + (ay1 * (-(bx3) + cx3))) + (ax1 * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 126)			::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 126)			if ((ax1 > bx3)) {
HXLINE( 126)				if ((ax1 > cx3)) {
HXLINE( 126)					int min;
HXDLIN( 126)					if ((bx3 > cx3)) {
HXLINE( 126)						min = ::Math_obj::floor(cx3);
            					}
            					else {
HXLINE( 126)						min = ::Math_obj::floor(bx3);
            					}
HXDLIN( 126)					int ii_min = min;
HXDLIN( 126)					int ii_max = ::Math_obj::ceil(ax1);
HXDLIN( 126)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)					xIter31 = this1;
            				}
            				else {
HXLINE( 126)					int ii_min = ::Math_obj::floor(bx3);
HXDLIN( 126)					int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 126)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)					xIter31 = this1;
            				}
            			}
            			else {
HXLINE( 126)				if ((bx3 > cx3)) {
HXLINE( 126)					int min;
HXDLIN( 126)					if ((ax1 > cx3)) {
HXLINE( 126)						min = ::Math_obj::floor(cx3);
            					}
            					else {
HXLINE( 126)						min = ::Math_obj::ceil(ax1);
            					}
HXDLIN( 126)					int ii_min = min;
HXDLIN( 126)					int ii_max = ::Math_obj::ceil(bx3);
HXDLIN( 126)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)					xIter31 = this1;
            				}
            				else {
HXLINE( 126)					int ii_min = ::Math_obj::floor(ax1);
HXDLIN( 126)					int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 126)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)					xIter31 = this1;
            				}
            			}
HXDLIN( 126)			::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 126)			if ((ay1 > by3)) {
HXLINE( 126)				if ((ay1 > cy3)) {
HXLINE( 126)					int min;
HXDLIN( 126)					if ((by3 > cy3)) {
HXLINE( 126)						min = ::Math_obj::floor(cy3);
            					}
            					else {
HXLINE( 126)						min = ::Math_obj::floor(by3);
            					}
HXDLIN( 126)					int ii_min = min;
HXDLIN( 126)					int ii_max = ::Math_obj::ceil(ay1);
HXDLIN( 126)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)					yIter31 = this1;
            				}
            				else {
HXLINE( 126)					int ii_min = ::Math_obj::floor(by3);
HXDLIN( 126)					int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 126)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)					yIter31 = this1;
            				}
            			}
            			else {
HXLINE( 126)				if ((by3 > cy3)) {
HXLINE( 126)					int min;
HXDLIN( 126)					if ((ay1 > cy3)) {
HXLINE( 126)						min = ::Math_obj::floor(cy3);
            					}
            					else {
HXLINE( 126)						min = ::Math_obj::ceil(ay1);
            					}
HXDLIN( 126)					int ii_min = min;
HXDLIN( 126)					int ii_max = ::Math_obj::ceil(by3);
HXDLIN( 126)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)					yIter31 = this1;
            				}
            				else {
HXLINE( 126)					int ii_min = ::Math_obj::floor(ay1);
HXDLIN( 126)					int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 126)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 126)					yIter31 = this1;
            				}
            			}
HXDLIN( 126)			::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 126)			if (hasUndo1) {
HXLINE( 126)				int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 126)				int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 126)				int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 126)				::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 126)				::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 126)				::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 126)				undoImage1 = this3;
HXDLIN( 126)				{
HXLINE( 126)					int rectLeft = xIter31->start;
HXDLIN( 126)					int rectTop = yIter31->start;
HXDLIN( 126)					int rectRight = xIter31->max;
HXDLIN( 126)					bool forceClear = false;
HXDLIN( 126)					{
HXLINE( 126)						int _g = rectTop;
HXDLIN( 126)						int _g1 = yIter31->max;
HXDLIN( 126)						while((_g < _g1)){
HXLINE( 126)							_g = (_g + 1);
HXDLIN( 126)							int dy = (_g - 1);
HXDLIN( 126)							{
HXLINE( 126)								int _g1 = rectLeft;
HXDLIN( 126)								int _g2 = rectRight;
HXDLIN( 126)								while((_g1 < _g2)){
HXLINE( 126)									_g1 = (_g1 + 1);
HXDLIN( 126)									int dx = (_g1 - 1);
HXDLIN( 126)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 126)									int index;
HXDLIN( 126)									if (temp->useVirtualPos) {
HXLINE( 126)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            									}
            									else {
HXLINE( 126)										index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            									}
HXDLIN( 126)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)									int col;
HXDLIN( 126)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 126)										col = c;
            									}
HXDLIN( 126)									bool _hx_tmp;
HXDLIN( 126)									if (temp->useMask) {
HXLINE( 126)										_hx_tmp = ::hx::IsNotNull( temp->mask );
            									}
            									else {
HXLINE( 126)										_hx_tmp = false;
            									}
HXDLIN( 126)									if (_hx_tmp) {
HXLINE( 126)										::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 126)										::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 126)										int index;
HXDLIN( 126)										if (this1->useVirtualPos) {
HXLINE( 126)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            										}
            										else {
HXLINE( 126)											index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            										}
HXDLIN( 126)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 126)										int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 126)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)										int v;
HXDLIN( 126)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)											v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 126)											v = c;
            										}
HXDLIN( 126)										int this3 = v;
HXDLIN( 126)										int maskPixel = this3;
HXDLIN( 126)										int this4 = col;
HXDLIN( 126)										int this5 = this4;
HXDLIN( 126)										if ((maskPixel == 0)) {
HXLINE( 126)											int this1 = this5;
HXDLIN( 126)											col = this1;
            										}
            										else {
HXLINE( 126)											Float m0;
HXDLIN( 126)											int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 126)											if ((this1 == 0)) {
HXLINE( 126)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float m1;
HXDLIN( 126)											int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 126)											if ((this2 == 0)) {
HXLINE( 126)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float m2;
HXDLIN( 126)											int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 126)											if ((this3 == 0)) {
HXLINE( 126)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float m3;
HXDLIN( 126)											int this4 = (maskPixel & 255);
HXDLIN( 126)											if ((this4 == 0)) {
HXLINE( 126)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 126)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 126)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 126)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 126)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 126)									if ((col != 0)) {
HXLINE( 126)										int x = (dx - rectLeft);
HXDLIN( 126)										int y = (dy - rectTop);
HXDLIN( 126)										int this1 = col;
HXDLIN( 126)										int c = this1;
HXDLIN( 126)										bool _hx_tmp;
HXDLIN( 126)										if ((((c >> 24) & 255) < 254)) {
HXLINE( 126)											_hx_tmp = undoImage1->transparent;
            										}
            										else {
HXLINE( 126)											_hx_tmp = false;
            										}
HXDLIN( 126)										if (_hx_tmp) {
HXLINE( 126)											int location;
HXDLIN( 126)											if (undoImage1->useVirtualPos) {
HXLINE( 126)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE( 126)												location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN( 126)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 126)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 126)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)											int this3 = this2;
HXDLIN( 126)											int this4;
HXDLIN( 126)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE( 126)												this4 = this3;
            											}
HXDLIN( 126)											Float a1;
HXDLIN( 126)											int this5 = ((this4 >> 24) & 255);
HXDLIN( 126)											if ((this5 == 0)) {
HXLINE( 126)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float r1;
HXDLIN( 126)											int this6 = ((this4 >> 16) & 255);
HXDLIN( 126)											if ((this6 == 0)) {
HXLINE( 126)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float g1;
HXDLIN( 126)											int this7 = ((this4 >> 8) & 255);
HXDLIN( 126)											if ((this7 == 0)) {
HXLINE( 126)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float b1;
HXDLIN( 126)											int this8 = (this4 & 255);
HXDLIN( 126)											if ((this8 == 0)) {
HXLINE( 126)												b1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float a2;
HXDLIN( 126)											int this9 = ((col >> 24) & 255);
HXDLIN( 126)											if ((this9 == 0)) {
HXLINE( 126)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float r2;
HXDLIN( 126)											int this10 = ((col >> 16) & 255);
HXDLIN( 126)											if ((this10 == 0)) {
HXLINE( 126)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float g2;
HXDLIN( 126)											int this11 = ((col >> 8) & 255);
HXDLIN( 126)											if ((this11 == 0)) {
HXLINE( 126)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float b2;
HXDLIN( 126)											int this12 = (col & 255);
HXDLIN( 126)											if ((this12 == 0)) {
HXLINE( 126)												b2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 126)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 126)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 126)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 126)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 126)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 126)											{
HXLINE( 126)												::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 126)												int value;
HXDLIN( 126)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 126)													value = blended;
            												}
HXDLIN( 126)												bool _hx_tmp;
HXDLIN( 126)												if ((location >= 0)) {
HXLINE( 126)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE( 126)													_hx_tmp = false;
            												}
HXDLIN( 126)												if (_hx_tmp) {
HXLINE( 126)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 126)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 126)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 126)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 126)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 126)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE( 126)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 126)											int index;
HXDLIN( 126)											if (undoImage1->useVirtualPos) {
HXLINE( 126)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE( 126)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN( 126)											int value;
HXDLIN( 126)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 126)												value = c;
            											}
HXDLIN( 126)											bool _hx_tmp;
HXDLIN( 126)											if ((index >= 0)) {
HXLINE( 126)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE( 126)												_hx_tmp = false;
            											}
HXDLIN( 126)											if (_hx_tmp) {
HXLINE( 126)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 126)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 126)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 126)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE( 126)										if (forceClear) {
HXLINE( 126)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 126)											int x = (dx - rectLeft);
HXDLIN( 126)											int y = (dy - rectTop);
HXDLIN( 126)											int index;
HXDLIN( 126)											if (undoImage1->useVirtualPos) {
HXLINE( 126)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE( 126)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN( 126)											bool _hx_tmp;
HXDLIN( 126)											if ((index >= 0)) {
HXLINE( 126)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE( 126)												_hx_tmp = false;
            											}
HXDLIN( 126)											if (_hx_tmp) {
HXLINE( 126)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 126)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 126)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 126)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 126)			bool foundY1 = false;
HXDLIN( 126)			Float s1 = ((Float)0.);
HXDLIN( 126)			Float t1 = ((Float)0.);
HXDLIN( 126)			Float sxx1 = ((Float)0.);
HXDLIN( 126)			Float txx1 = ((Float)0.);
HXDLIN( 126)			{
HXLINE( 126)				int _g_min1 = xIter31->start;
HXDLIN( 126)				int _g_max1 = xIter31->max;
HXDLIN( 126)				while((_g_min1 < _g_max1)){
HXLINE( 126)					_g_min1 = (_g_min1 + 1);
HXDLIN( 126)					int x = (_g_min1 - 1);
HXLINE( 223)					sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)					txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)					foundY1 = false;
HXLINE( 126)					{
HXLINE( 126)						int _g_min = yIter31->start;
HXDLIN( 126)						int _g_max = yIter31->max;
HXDLIN( 126)						while((_g_min < _g_max)){
HXLINE( 126)							_g_min = (_g_min + 1);
HXDLIN( 126)							int y = (_g_min - 1);
HXLINE( 227)							s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)							t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE( 126)							bool _hx_tmp;
HXDLIN( 126)							if (!((s1 <= 0))) {
HXLINE( 126)								_hx_tmp = (t1 <= 0);
            							}
            							else {
HXLINE( 126)								_hx_tmp = true;
            							}
HXDLIN( 126)							if (_hx_tmp) {
HXLINE( 126)								if (foundY1) {
HXLINE( 126)									goto _hx_goto_54;
            								}
            							}
            							else {
HXLINE( 126)								if (((s1 + t1) < A1)) {
HXLINE( 126)									int x1 = ::hx::Mod(x,tileImage1->width);
HXDLIN( 126)									int y1 = ::hx::Mod(y,tileImage1->height);
HXDLIN( 126)									::haxe::io::ArrayBufferViewImpl this1 = tileImage1->image;
HXDLIN( 126)									int index;
HXDLIN( 126)									if (tileImage1->useVirtualPos) {
HXLINE( 126)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage1->virtualY) * ( (Float)(tileImage1->width) )) + x1) - tileImage1->virtualX));
            									}
            									else {
HXLINE( 126)										index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage1->width) + x1)) ));
            									}
HXDLIN( 126)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)									int color;
HXDLIN( 126)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)										color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 126)										color = c;
            									}
HXDLIN( 126)									{
HXLINE( 126)										int this2 = color;
HXDLIN( 126)										int c1 = this2;
HXDLIN( 126)										bool _hx_tmp;
HXDLIN( 126)										if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 126)											_hx_tmp = temp->transparent;
            										}
            										else {
HXLINE( 126)											_hx_tmp = false;
            										}
HXDLIN( 126)										if (_hx_tmp) {
HXLINE( 126)											int location;
HXDLIN( 126)											if (temp->useVirtualPos) {
HXLINE( 126)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            											}
            											else {
HXLINE( 126)												location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            											}
HXDLIN( 126)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 126)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 126)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 126)											int this3 = this2;
HXDLIN( 126)											int this4;
HXDLIN( 126)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE( 126)												this4 = this3;
            											}
HXDLIN( 126)											Float a1;
HXDLIN( 126)											int this5 = ((this4 >> 24) & 255);
HXDLIN( 126)											if ((this5 == 0)) {
HXLINE( 126)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float r1;
HXDLIN( 126)											int this6 = ((this4 >> 16) & 255);
HXDLIN( 126)											if ((this6 == 0)) {
HXLINE( 126)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float g1;
HXDLIN( 126)											int this7 = ((this4 >> 8) & 255);
HXDLIN( 126)											if ((this7 == 0)) {
HXLINE( 126)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float b1;
HXDLIN( 126)											int this8 = (this4 & 255);
HXDLIN( 126)											if ((this8 == 0)) {
HXLINE( 126)												b1 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float a2;
HXDLIN( 126)											int this9 = ((color >> 24) & 255);
HXDLIN( 126)											if ((this9 == 0)) {
HXLINE( 126)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float r2;
HXDLIN( 126)											int this10 = ((color >> 16) & 255);
HXDLIN( 126)											if ((this10 == 0)) {
HXLINE( 126)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float g2;
HXDLIN( 126)											int this11 = ((color >> 8) & 255);
HXDLIN( 126)											if ((this11 == 0)) {
HXLINE( 126)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float b2;
HXDLIN( 126)											int this12 = (color & 255);
HXDLIN( 126)											if ((this12 == 0)) {
HXLINE( 126)												b2 = ((Float)0.);
            											}
            											else {
HXLINE( 126)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN( 126)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 126)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 126)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 126)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 126)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 126)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 126)											{
HXLINE( 126)												::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 126)												int value;
HXDLIN( 126)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 126)													value = blended;
            												}
HXDLIN( 126)												bool _hx_tmp;
HXDLIN( 126)												if ((location >= 0)) {
HXLINE( 126)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE( 126)													_hx_tmp = false;
            												}
HXDLIN( 126)												if (_hx_tmp) {
HXLINE( 126)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 126)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 126)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 126)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 126)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 126)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE( 126)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 126)											int index;
HXDLIN( 126)											if (temp->useVirtualPos) {
HXLINE( 126)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            											}
            											else {
HXLINE( 126)												index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            											}
HXDLIN( 126)											int value;
HXDLIN( 126)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)												value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 126)												value = c1;
            											}
HXDLIN( 126)											bool _hx_tmp;
HXDLIN( 126)											if ((index >= 0)) {
HXLINE( 126)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE( 126)												_hx_tmp = false;
            											}
HXDLIN( 126)											if (_hx_tmp) {
HXLINE( 126)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 126)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 126)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 126)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 126)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 126)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXLINE( 237)									foundY1 = true;
            								}
            								else {
HXLINE( 126)									if (foundY1) {
HXLINE( 126)										goto _hx_goto_54;
            									}
            								}
            							}
            						}
            						_hx_goto_54:;
            					}
            				}
            			}
HXDLIN( 126)			::pixelimage::algo::HitTri triHit1;
HXDLIN( 126)			if ((hasHit1 == false)) {
HXLINE( 126)				::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx3,by3,cx3,cy3,true);
HXDLIN( 126)				if (hasUndo1) {
HXLINE( 126)					v->undoImage = undoImage1;
HXDLIN( 126)					v->undoX = xIter31->start;
HXDLIN( 126)					v->undoY = yIter31->start;
            				}
HXDLIN( 126)				triHit1 = v;
            			}
            			else {
HXLINE( 126)				triHit1 = null();
            			}
HXDLIN( 126)			if (hasHit1) {
HXLINE( 126)				arrTri1[arrTri1->length] = triHit1;
            			}
HXDLIN( 126)			if (hasHit1) {
HXLINE( 126)				::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,arrTri1);
            			}
            			else {
HXLINE( 486)				arrTri1 = null();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ArcPattern_obj,ellipse,(void))

void ArcPattern_obj::pie(::pixelimage::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_32a31af4d124b381_128_pie)
HXLINE( 129)		this->ellipse(temp);
HXLINE( 130)		Float bx = ((this->rx * ::Math_obj::cos(this->startAngle)) + this->rx);
HXLINE( 131)		Float by = ((this->ry * ::Math_obj::sin(this->startAngle)) + this->ry);
HXLINE( 132)		Float currAngle = (this->startAngle + (this->sweepAngle / ( (Float)(2) )));
HXLINE( 133)		Float ax = ((this->strokeWidth * ::Math_obj::cos(currAngle)) + this->rx);
HXLINE( 134)		Float ay = ((this->strokeWidth * ::Math_obj::sin(currAngle)) + this->ry);
HXLINE( 135)		currAngle = (this->startAngle + this->sweepAngle);
HXLINE( 136)		Float cx = ((this->rx * ::Math_obj::cos(currAngle)) + this->rx);
HXLINE( 137)		Float cy = ((this->ry * ::Math_obj::sin(currAngle)) + this->ry);
HXLINE( 138)		{
HXLINE( 138)			Float px = this->rx;
HXDLIN( 138)			Float py = this->ry;
HXDLIN( 138)			::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN( 138)			bool hasHit = false;
HXDLIN( 138)			Float o = (by - py);
HXDLIN( 138)			Float a = (bx - px);
HXDLIN( 138)			Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 138)			Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 138)			{
HXLINE( 138)				 ::Dynamic debugCorners = false;
HXDLIN( 138)				if (::hx::IsNull( debugCorners )) {
HXLINE( 893)					debugCorners = false;
            				}
HXLINE( 138)				Float sin = ::Math_obj::sin(theta);
HXDLIN( 138)				Float cos = ::Math_obj::cos(theta);
HXDLIN( 138)				Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN( 138)				Float dx = ((Float)0.1);
HXDLIN( 138)				Float dy = radius;
HXDLIN( 138)				Float cx1 = h;
HXDLIN( 138)				Float cy1 = radius;
HXDLIN( 138)				Float bx1 = h;
HXDLIN( 138)				Float by1 = -(radius);
HXDLIN( 138)				Float ax1 = ((Float)0.1);
HXDLIN( 138)				Float ay1 = -(radius);
HXDLIN( 138)				Float temp1 = ((Float)0.);
HXLINE( 380)				temp1 = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE( 381)				ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE( 382)				ax1 = temp1;
HXLINE( 384)				temp1 = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE( 385)				by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE( 386)				bx1 = temp1;
HXLINE( 388)				temp1 = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE( 389)				cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE( 390)				cx1 = temp1;
HXLINE( 392)				temp1 = (px + ((dx * cos) - (dy * sin)));
HXLINE( 393)				dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 394)				dx = temp1;
HXLINE( 138)				if (( (bool)(debugCorners) )) {
HXLINE( 138)					{
HXLINE( 138)						Float x = (ax1 - ((Float)6.));
HXDLIN( 138)						Float y = (ay1 - ((Float)6.));
HXDLIN( 138)						int p = ::Std_obj::_hx_int(x);
HXDLIN( 138)						int xx = p;
HXDLIN( 138)						int q = ::Std_obj::_hx_int(y);
HXDLIN( 138)						int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN( 138)						int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN( 138)						while(true){
HXLINE( 138)							{
HXLINE( 138)								p = (p + 1);
HXDLIN( 138)								int x = (p - 1);
HXDLIN( 138)								int this1 = -65536;
HXDLIN( 138)								int c = this1;
HXDLIN( 138)								bool _hx_tmp;
HXDLIN( 138)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 138)									_hx_tmp = temp->transparent;
            								}
            								else {
HXLINE( 138)									_hx_tmp = false;
            								}
HXDLIN( 138)								if (_hx_tmp) {
HXLINE( 138)									int location;
HXDLIN( 138)									if (temp->useVirtualPos) {
HXLINE( 138)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 138)										location = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            									}
HXDLIN( 138)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 138)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)									int this3 = this2;
HXDLIN( 138)									int this4;
HXDLIN( 138)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 138)										this4 = this3;
            									}
HXDLIN( 138)									Float a1;
HXDLIN( 138)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 138)									if ((this5 == 0)) {
HXLINE( 138)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r1;
HXDLIN( 138)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 138)									if ((this6 == 0)) {
HXLINE( 138)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g1;
HXDLIN( 138)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 138)									if ((this7 == 0)) {
HXLINE( 138)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b1;
HXDLIN( 138)									int this8 = (this4 & 255);
HXDLIN( 138)									if ((this8 == 0)) {
HXLINE( 138)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a2;
HXDLIN( 138)									int this9 = ((-65536 >> 24) & 255);
HXDLIN( 138)									if ((this9 == 0)) {
HXLINE( 138)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r2;
HXDLIN( 138)									int this10 = ((-65536 >> 16) & 255);
HXDLIN( 138)									if ((this10 == 0)) {
HXLINE( 138)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g2;
HXDLIN( 138)									int this11 = ((-65536 >> 8) & 255);
HXDLIN( 138)									if ((this11 == 0)) {
HXLINE( 138)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b2;
HXDLIN( 138)									int this12 = (-65536 & 255);
HXDLIN( 138)									if ((this12 == 0)) {
HXLINE( 138)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)									{
HXLINE( 138)										::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 138)										int value;
HXDLIN( 138)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 138)											value = blended;
            										}
HXDLIN( 138)										bool _hx_tmp;
HXDLIN( 138)										if ((location >= 0)) {
HXLINE( 138)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 138)											_hx_tmp = false;
            										}
HXDLIN( 138)										if (_hx_tmp) {
HXLINE( 138)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 138)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 138)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 138)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)									int index;
HXDLIN( 138)									if (temp->useVirtualPos) {
HXLINE( 138)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 138)										index = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            									}
HXDLIN( 138)									int value;
HXDLIN( 138)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 138)										value = c;
            									}
HXDLIN( 138)									bool _hx_tmp;
HXDLIN( 138)									if ((index >= 0)) {
HXLINE( 138)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 138)										_hx_tmp = false;
            									}
HXDLIN( 138)									if (_hx_tmp) {
HXLINE( 138)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN( 138)							if ((p > maxX)) {
HXLINE( 247)								p = xx;
HXLINE( 138)								q = (q + 1);
            							}
HXDLIN( 138)							if ((q > maxY)) {
HXLINE( 138)								goto _hx_goto_56;
            							}
            						}
            						_hx_goto_56:;
            					}
HXDLIN( 138)					{
HXLINE( 138)						Float x1 = (bx1 - ((Float)6.));
HXDLIN( 138)						Float y1 = (by1 - ((Float)6.));
HXDLIN( 138)						int p1 = ::Std_obj::_hx_int(x1);
HXDLIN( 138)						int xx1 = p1;
HXDLIN( 138)						int q1 = ::Std_obj::_hx_int(y1);
HXDLIN( 138)						int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN( 138)						int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN( 138)						while(true){
HXLINE( 138)							{
HXLINE( 138)								p1 = (p1 + 1);
HXDLIN( 138)								int x = (p1 - 1);
HXDLIN( 138)								int this1 = -16711936;
HXDLIN( 138)								int c = this1;
HXDLIN( 138)								bool _hx_tmp;
HXDLIN( 138)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 138)									_hx_tmp = temp->transparent;
            								}
            								else {
HXLINE( 138)									_hx_tmp = false;
            								}
HXDLIN( 138)								if (_hx_tmp) {
HXLINE( 138)									int location;
HXDLIN( 138)									if (temp->useVirtualPos) {
HXLINE( 138)										location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 138)										location = ::Std_obj::_hx_int(( (Float)(((q1 * temp->width) + x)) ));
            									}
HXDLIN( 138)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 138)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)									int this3 = this2;
HXDLIN( 138)									int this4;
HXDLIN( 138)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 138)										this4 = this3;
            									}
HXDLIN( 138)									Float a1;
HXDLIN( 138)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 138)									if ((this5 == 0)) {
HXLINE( 138)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r1;
HXDLIN( 138)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 138)									if ((this6 == 0)) {
HXLINE( 138)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g1;
HXDLIN( 138)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 138)									if ((this7 == 0)) {
HXLINE( 138)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b1;
HXDLIN( 138)									int this8 = (this4 & 255);
HXDLIN( 138)									if ((this8 == 0)) {
HXLINE( 138)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a2;
HXDLIN( 138)									int this9 = ((-16711936 >> 24) & 255);
HXDLIN( 138)									if ((this9 == 0)) {
HXLINE( 138)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r2;
HXDLIN( 138)									int this10 = ((-16711936 >> 16) & 255);
HXDLIN( 138)									if ((this10 == 0)) {
HXLINE( 138)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g2;
HXDLIN( 138)									int this11 = ((-16711936 >> 8) & 255);
HXDLIN( 138)									if ((this11 == 0)) {
HXLINE( 138)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b2;
HXDLIN( 138)									int this12 = (-16711936 & 255);
HXDLIN( 138)									if ((this12 == 0)) {
HXLINE( 138)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)									{
HXLINE( 138)										::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 138)										int value;
HXDLIN( 138)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 138)											value = blended;
            										}
HXDLIN( 138)										bool _hx_tmp;
HXDLIN( 138)										if ((location >= 0)) {
HXLINE( 138)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 138)											_hx_tmp = false;
            										}
HXDLIN( 138)										if (_hx_tmp) {
HXLINE( 138)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 138)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 138)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 138)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)									int index;
HXDLIN( 138)									if (temp->useVirtualPos) {
HXLINE( 138)										index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 138)										index = ::Std_obj::_hx_int(( (Float)(((q1 * temp->width) + x)) ));
            									}
HXDLIN( 138)									int value;
HXDLIN( 138)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 138)										value = c;
            									}
HXDLIN( 138)									bool _hx_tmp;
HXDLIN( 138)									if ((index >= 0)) {
HXLINE( 138)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 138)										_hx_tmp = false;
            									}
HXDLIN( 138)									if (_hx_tmp) {
HXLINE( 138)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN( 138)							if ((p1 > maxX1)) {
HXLINE( 247)								p1 = xx1;
HXLINE( 138)								q1 = (q1 + 1);
            							}
HXDLIN( 138)							if ((q1 > maxY1)) {
HXLINE( 138)								goto _hx_goto_57;
            							}
            						}
            						_hx_goto_57:;
            					}
HXDLIN( 138)					{
HXLINE( 138)						Float x2 = (cx1 - ((Float)6.));
HXDLIN( 138)						Float y2 = (cy1 - ((Float)6.));
HXDLIN( 138)						int p2 = ::Std_obj::_hx_int(x2);
HXDLIN( 138)						int xx2 = p2;
HXDLIN( 138)						int q2 = ::Std_obj::_hx_int(y2);
HXDLIN( 138)						int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN( 138)						int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN( 138)						while(true){
HXLINE( 138)							{
HXLINE( 138)								p2 = (p2 + 1);
HXDLIN( 138)								int x = (p2 - 1);
HXDLIN( 138)								int this1 = -16776961;
HXDLIN( 138)								int c = this1;
HXDLIN( 138)								bool _hx_tmp;
HXDLIN( 138)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 138)									_hx_tmp = temp->transparent;
            								}
            								else {
HXLINE( 138)									_hx_tmp = false;
            								}
HXDLIN( 138)								if (_hx_tmp) {
HXLINE( 138)									int location;
HXDLIN( 138)									if (temp->useVirtualPos) {
HXLINE( 138)										location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 138)										location = ::Std_obj::_hx_int(( (Float)(((q2 * temp->width) + x)) ));
            									}
HXDLIN( 138)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 138)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)									int this3 = this2;
HXDLIN( 138)									int this4;
HXDLIN( 138)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 138)										this4 = this3;
            									}
HXDLIN( 138)									Float a1;
HXDLIN( 138)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 138)									if ((this5 == 0)) {
HXLINE( 138)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r1;
HXDLIN( 138)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 138)									if ((this6 == 0)) {
HXLINE( 138)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g1;
HXDLIN( 138)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 138)									if ((this7 == 0)) {
HXLINE( 138)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b1;
HXDLIN( 138)									int this8 = (this4 & 255);
HXDLIN( 138)									if ((this8 == 0)) {
HXLINE( 138)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a2;
HXDLIN( 138)									int this9 = ((-16776961 >> 24) & 255);
HXDLIN( 138)									if ((this9 == 0)) {
HXLINE( 138)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r2;
HXDLIN( 138)									int this10 = ((-16776961 >> 16) & 255);
HXDLIN( 138)									if ((this10 == 0)) {
HXLINE( 138)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g2;
HXDLIN( 138)									int this11 = ((-16776961 >> 8) & 255);
HXDLIN( 138)									if ((this11 == 0)) {
HXLINE( 138)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b2;
HXDLIN( 138)									int this12 = (-16776961 & 255);
HXDLIN( 138)									if ((this12 == 0)) {
HXLINE( 138)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)									{
HXLINE( 138)										::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 138)										int value;
HXDLIN( 138)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 138)											value = blended;
            										}
HXDLIN( 138)										bool _hx_tmp;
HXDLIN( 138)										if ((location >= 0)) {
HXLINE( 138)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 138)											_hx_tmp = false;
            										}
HXDLIN( 138)										if (_hx_tmp) {
HXLINE( 138)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 138)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 138)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 138)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)									int index;
HXDLIN( 138)									if (temp->useVirtualPos) {
HXLINE( 138)										index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 138)										index = ::Std_obj::_hx_int(( (Float)(((q2 * temp->width) + x)) ));
            									}
HXDLIN( 138)									int value;
HXDLIN( 138)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 138)										value = c;
            									}
HXDLIN( 138)									bool _hx_tmp;
HXDLIN( 138)									if ((index >= 0)) {
HXLINE( 138)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 138)										_hx_tmp = false;
            									}
HXDLIN( 138)									if (_hx_tmp) {
HXLINE( 138)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN( 138)							if ((p2 > maxX2)) {
HXLINE( 247)								p2 = xx2;
HXLINE( 138)								q2 = (q2 + 1);
            							}
HXDLIN( 138)							if ((q2 > maxY2)) {
HXLINE( 138)								goto _hx_goto_58;
            							}
            						}
            						_hx_goto_58:;
            					}
HXDLIN( 138)					{
HXLINE( 138)						Float x3 = (dx - ((Float)6.));
HXDLIN( 138)						Float y3 = (dy - ((Float)6.));
HXDLIN( 138)						int p3 = ::Std_obj::_hx_int(x3);
HXDLIN( 138)						int xx3 = p3;
HXDLIN( 138)						int q3 = ::Std_obj::_hx_int(y3);
HXDLIN( 138)						int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN( 138)						int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN( 138)						while(true){
HXLINE( 138)							{
HXLINE( 138)								p3 = (p3 + 1);
HXDLIN( 138)								int x = (p3 - 1);
HXDLIN( 138)								int this1 = -1048336;
HXDLIN( 138)								int c = this1;
HXDLIN( 138)								bool _hx_tmp;
HXDLIN( 138)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 138)									_hx_tmp = temp->transparent;
            								}
            								else {
HXLINE( 138)									_hx_tmp = false;
            								}
HXDLIN( 138)								if (_hx_tmp) {
HXLINE( 138)									int location;
HXDLIN( 138)									if (temp->useVirtualPos) {
HXLINE( 138)										location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 138)										location = ::Std_obj::_hx_int(( (Float)(((q3 * temp->width) + x)) ));
            									}
HXDLIN( 138)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 138)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)									int this3 = this2;
HXDLIN( 138)									int this4;
HXDLIN( 138)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 138)										this4 = this3;
            									}
HXDLIN( 138)									Float a1;
HXDLIN( 138)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 138)									if ((this5 == 0)) {
HXLINE( 138)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r1;
HXDLIN( 138)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 138)									if ((this6 == 0)) {
HXLINE( 138)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g1;
HXDLIN( 138)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 138)									if ((this7 == 0)) {
HXLINE( 138)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b1;
HXDLIN( 138)									int this8 = (this4 & 255);
HXDLIN( 138)									if ((this8 == 0)) {
HXLINE( 138)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a2;
HXDLIN( 138)									int this9 = ((-1048336 >> 24) & 255);
HXDLIN( 138)									if ((this9 == 0)) {
HXLINE( 138)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r2;
HXDLIN( 138)									int this10 = ((-1048336 >> 16) & 255);
HXDLIN( 138)									if ((this10 == 0)) {
HXLINE( 138)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g2;
HXDLIN( 138)									int this11 = ((-1048336 >> 8) & 255);
HXDLIN( 138)									if ((this11 == 0)) {
HXLINE( 138)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b2;
HXDLIN( 138)									int this12 = (-1048336 & 255);
HXDLIN( 138)									if ((this12 == 0)) {
HXLINE( 138)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)									{
HXLINE( 138)										::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 138)										int value;
HXDLIN( 138)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 138)											value = blended;
            										}
HXDLIN( 138)										bool _hx_tmp;
HXDLIN( 138)										if ((location >= 0)) {
HXLINE( 138)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 138)											_hx_tmp = false;
            										}
HXDLIN( 138)										if (_hx_tmp) {
HXLINE( 138)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 138)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 138)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 138)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)									int index;
HXDLIN( 138)									if (temp->useVirtualPos) {
HXLINE( 138)										index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 138)										index = ::Std_obj::_hx_int(( (Float)(((q3 * temp->width) + x)) ));
            									}
HXDLIN( 138)									int value;
HXDLIN( 138)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 138)										value = c;
            									}
HXDLIN( 138)									bool _hx_tmp;
HXDLIN( 138)									if ((index >= 0)) {
HXLINE( 138)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 138)										_hx_tmp = false;
            									}
HXDLIN( 138)									if (_hx_tmp) {
HXLINE( 138)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN( 138)							if ((p3 > maxX3)) {
HXLINE( 247)								p3 = xx3;
HXLINE( 138)								q3 = (q3 + 1);
            							}
HXDLIN( 138)							if ((q3 > maxY3)) {
HXLINE( 138)								goto _hx_goto_59;
            							}
            						}
            						_hx_goto_59:;
            					}
            				}
HXDLIN( 138)				{
HXLINE( 138)					{
HXLINE( 138)						Float bx2 = bx1;
HXDLIN( 138)						Float by2 = by1;
HXDLIN( 138)						Float cx2 = dx;
HXDLIN( 138)						Float cy2 = dy;
HXDLIN( 138)						bool adjustWinding = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN( 138)						if (!(adjustWinding)) {
HXLINE( 138)							Float bx_ = bx2;
HXDLIN( 138)							Float by_ = by2;
HXLINE( 188)							bx2 = cx2;
HXLINE( 189)							by2 = cy2;
HXLINE( 190)							cx2 = bx_;
HXLINE( 191)							cy2 = by_;
            						}
HXLINE( 138)						{
HXLINE( 138)							bool hasUndo = false;
HXDLIN( 138)							Float s0 = ((ay1 * cx2) - (ax1 * cy2));
HXDLIN( 138)							Float sx = (cy2 - ay1);
HXDLIN( 138)							Float sy = (ax1 - cx2);
HXDLIN( 138)							Float t0 = ((ax1 * by2) - (ay1 * bx2));
HXDLIN( 138)							Float tx = (ay1 - by2);
HXDLIN( 138)							Float ty = (bx2 - ax1);
HXDLIN( 138)							Float A = ((((-(by2) * cx2) + (ay1 * (-(bx2) + cx2))) + (ax1 * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 138)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 138)							if ((ax1 > bx2)) {
HXLINE( 138)								if ((ax1 > cx2)) {
HXLINE( 138)									int min;
HXDLIN( 138)									if ((bx2 > cx2)) {
HXLINE( 138)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE( 138)										min = ::Math_obj::floor(bx2);
            									}
HXDLIN( 138)									int ii_min = min;
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(ax1);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									xIter3 = this1;
            								}
            								else {
HXLINE( 138)									int ii_min = ::Math_obj::floor(bx2);
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE( 138)								if ((bx2 > cx2)) {
HXLINE( 138)									int min;
HXDLIN( 138)									if ((ax1 > cx2)) {
HXLINE( 138)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE( 138)										min = ::Math_obj::ceil(ax1);
            									}
HXDLIN( 138)									int ii_min = min;
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(bx2);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									xIter3 = this1;
            								}
            								else {
HXLINE( 138)									int ii_min = ::Math_obj::floor(ax1);
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									xIter3 = this1;
            								}
            							}
HXDLIN( 138)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 138)							if ((ay1 > by2)) {
HXLINE( 138)								if ((ay1 > cy2)) {
HXLINE( 138)									int min;
HXDLIN( 138)									if ((by2 > cy2)) {
HXLINE( 138)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE( 138)										min = ::Math_obj::floor(by2);
            									}
HXDLIN( 138)									int ii_min = min;
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(ay1);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									yIter3 = this1;
            								}
            								else {
HXLINE( 138)									int ii_min = ::Math_obj::floor(by2);
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE( 138)								if ((by2 > cy2)) {
HXLINE( 138)									int min;
HXDLIN( 138)									if ((ay1 > cy2)) {
HXLINE( 138)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE( 138)										min = ::Math_obj::ceil(ay1);
            									}
HXDLIN( 138)									int ii_min = min;
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(by2);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									yIter3 = this1;
            								}
            								else {
HXLINE( 138)									int ii_min = ::Math_obj::floor(ay1);
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									yIter3 = this1;
            								}
            							}
HXDLIN( 138)							::pixelimage::ImageStruct undoImage = null();
HXDLIN( 138)							if (hasUndo) {
HXLINE( 138)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 138)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 138)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 138)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 138)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 138)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 138)								undoImage = this3;
HXDLIN( 138)								{
HXLINE( 138)									int rectLeft = xIter3->start;
HXDLIN( 138)									int rectTop = yIter3->start;
HXDLIN( 138)									int rectRight = xIter3->max;
HXDLIN( 138)									bool forceClear = false;
HXDLIN( 138)									{
HXLINE( 138)										int _g = rectTop;
HXDLIN( 138)										int _g1 = yIter3->max;
HXDLIN( 138)										while((_g < _g1)){
HXLINE( 138)											_g = (_g + 1);
HXDLIN( 138)											int dy = (_g - 1);
HXDLIN( 138)											{
HXLINE( 138)												int _g1 = rectLeft;
HXDLIN( 138)												int _g2 = rectRight;
HXDLIN( 138)												while((_g1 < _g2)){
HXLINE( 138)													_g1 = (_g1 + 1);
HXDLIN( 138)													int dx = (_g1 - 1);
HXDLIN( 138)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)													int index;
HXDLIN( 138)													if (temp->useVirtualPos) {
HXLINE( 138)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE( 138)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN( 138)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)													int col;
HXDLIN( 138)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 138)														col = c;
            													}
HXDLIN( 138)													bool _hx_tmp;
HXDLIN( 138)													if (temp->useMask) {
HXLINE( 138)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE( 138)														_hx_tmp = false;
            													}
HXDLIN( 138)													if (_hx_tmp) {
HXLINE( 138)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 138)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 138)														int index;
HXDLIN( 138)														if (this1->useVirtualPos) {
HXLINE( 138)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE( 138)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN( 138)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 138)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 138)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)														int v;
HXDLIN( 138)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 138)															v = c;
            														}
HXDLIN( 138)														int this3 = v;
HXDLIN( 138)														int maskPixel = this3;
HXDLIN( 138)														int this4 = col;
HXDLIN( 138)														int this5 = this4;
HXDLIN( 138)														if ((maskPixel == 0)) {
HXLINE( 138)															int this1 = this5;
HXDLIN( 138)															col = this1;
            														}
            														else {
HXLINE( 138)															Float m0;
HXDLIN( 138)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 138)															if ((this1 == 0)) {
HXLINE( 138)																m0 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float m1;
HXDLIN( 138)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 138)															if ((this2 == 0)) {
HXLINE( 138)																m1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float m2;
HXDLIN( 138)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 138)															if ((this3 == 0)) {
HXLINE( 138)																m2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float m3;
HXDLIN( 138)															int this4 = (maskPixel & 255);
HXDLIN( 138)															if ((this4 == 0)) {
HXLINE( 138)																m3 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 138)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 138)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 138)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 138)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 138)													if ((col != 0)) {
HXLINE( 138)														int x = (dx - rectLeft);
HXDLIN( 138)														int y = (dy - rectTop);
HXDLIN( 138)														int this1 = col;
HXDLIN( 138)														int c = this1;
HXDLIN( 138)														bool _hx_tmp;
HXDLIN( 138)														if ((((c >> 24) & 255) < 254)) {
HXLINE( 138)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE( 138)															_hx_tmp = false;
            														}
HXDLIN( 138)														if (_hx_tmp) {
HXLINE( 138)															int location;
HXDLIN( 138)															if (undoImage->useVirtualPos) {
HXLINE( 138)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE( 138)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN( 138)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 138)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 138)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)															int this3 = this2;
HXDLIN( 138)															int this4;
HXDLIN( 138)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE( 138)																this4 = this3;
            															}
HXDLIN( 138)															Float a1;
HXDLIN( 138)															int this5 = ((this4 >> 24) & 255);
HXDLIN( 138)															if ((this5 == 0)) {
HXLINE( 138)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float r1;
HXDLIN( 138)															int this6 = ((this4 >> 16) & 255);
HXDLIN( 138)															if ((this6 == 0)) {
HXLINE( 138)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float g1;
HXDLIN( 138)															int this7 = ((this4 >> 8) & 255);
HXDLIN( 138)															if ((this7 == 0)) {
HXLINE( 138)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float b1;
HXDLIN( 138)															int this8 = (this4 & 255);
HXDLIN( 138)															if ((this8 == 0)) {
HXLINE( 138)																b1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float a2;
HXDLIN( 138)															int this9 = ((col >> 24) & 255);
HXDLIN( 138)															if ((this9 == 0)) {
HXLINE( 138)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float r2;
HXDLIN( 138)															int this10 = ((col >> 16) & 255);
HXDLIN( 138)															if ((this10 == 0)) {
HXLINE( 138)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float g2;
HXDLIN( 138)															int this11 = ((col >> 8) & 255);
HXDLIN( 138)															if ((this11 == 0)) {
HXLINE( 138)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float b2;
HXDLIN( 138)															int this12 = (col & 255);
HXDLIN( 138)															if ((this12 == 0)) {
HXLINE( 138)																b2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)															{
HXLINE( 138)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 138)																int value;
HXDLIN( 138)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 138)																	value = blended;
            																}
HXDLIN( 138)																bool _hx_tmp;
HXDLIN( 138)																if ((location >= 0)) {
HXLINE( 138)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE( 138)																	_hx_tmp = false;
            																}
HXDLIN( 138)																if (_hx_tmp) {
HXLINE( 138)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 138)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 138)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 138)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 138)															int index;
HXDLIN( 138)															if (undoImage->useVirtualPos) {
HXLINE( 138)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE( 138)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN( 138)															int value;
HXDLIN( 138)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE( 138)																value = c;
            															}
HXDLIN( 138)															bool _hx_tmp;
HXDLIN( 138)															if ((index >= 0)) {
HXLINE( 138)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 138)																_hx_tmp = false;
            															}
HXDLIN( 138)															if (_hx_tmp) {
HXLINE( 138)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 138)														if (forceClear) {
HXLINE( 138)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 138)															int x = (dx - rectLeft);
HXDLIN( 138)															int y = (dy - rectTop);
HXDLIN( 138)															int index;
HXDLIN( 138)															if (undoImage->useVirtualPos) {
HXLINE( 138)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE( 138)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN( 138)															bool _hx_tmp;
HXDLIN( 138)															if ((index >= 0)) {
HXLINE( 138)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 138)																_hx_tmp = false;
            															}
HXDLIN( 138)															if (_hx_tmp) {
HXLINE( 138)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 138)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 138)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 138)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 138)							bool foundY = false;
HXDLIN( 138)							Float s = ((Float)0.);
HXDLIN( 138)							Float t = ((Float)0.);
HXDLIN( 138)							Float sxx = ((Float)0.);
HXDLIN( 138)							Float txx = ((Float)0.);
HXDLIN( 138)							{
HXLINE( 138)								int _g_min = xIter3->start;
HXDLIN( 138)								int _g_max = xIter3->max;
HXDLIN( 138)								while((_g_min < _g_max)){
HXLINE( 138)									_g_min = (_g_min + 1);
HXDLIN( 138)									int x = (_g_min - 1);
HXLINE( 223)									sxx = (sx * ( (Float)(x) ));
HXLINE( 224)									txx = (tx * ( (Float)(x) ));
HXLINE( 225)									foundY = false;
HXLINE( 138)									{
HXLINE( 138)										int _g_min1 = yIter3->start;
HXDLIN( 138)										int _g_max = yIter3->max;
HXDLIN( 138)										while((_g_min1 < _g_max)){
HXLINE( 138)											_g_min1 = (_g_min1 + 1);
HXDLIN( 138)											int y = (_g_min1 - 1);
HXLINE( 227)											s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)											t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 138)											bool _hx_tmp;
HXDLIN( 138)											if (!((s <= 0))) {
HXLINE( 138)												_hx_tmp = (t <= 0);
            											}
            											else {
HXLINE( 138)												_hx_tmp = true;
            											}
HXDLIN( 138)											if (_hx_tmp) {
HXLINE( 138)												if (foundY) {
HXLINE( 138)													goto _hx_goto_63;
            												}
            											}
            											else {
HXLINE( 138)												if (((s + t) < A)) {
HXLINE( 138)													int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN( 138)													int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN( 138)													::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN( 138)													int index;
HXDLIN( 138)													if (tileImage->useVirtualPos) {
HXLINE( 138)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            													}
            													else {
HXLINE( 138)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            													}
HXDLIN( 138)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)													int color;
HXDLIN( 138)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 138)														color = c;
            													}
HXDLIN( 138)													{
HXLINE( 138)														int this2 = color;
HXDLIN( 138)														int c1 = this2;
HXDLIN( 138)														bool _hx_tmp;
HXDLIN( 138)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 138)															_hx_tmp = temp->transparent;
            														}
            														else {
HXLINE( 138)															_hx_tmp = false;
            														}
HXDLIN( 138)														if (_hx_tmp) {
HXLINE( 138)															int location;
HXDLIN( 138)															if (temp->useVirtualPos) {
HXLINE( 138)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE( 138)																location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN( 138)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 138)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)															int this3 = this2;
HXDLIN( 138)															int this4;
HXDLIN( 138)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE( 138)																this4 = this3;
            															}
HXDLIN( 138)															Float a1;
HXDLIN( 138)															int this5 = ((this4 >> 24) & 255);
HXDLIN( 138)															if ((this5 == 0)) {
HXLINE( 138)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float r1;
HXDLIN( 138)															int this6 = ((this4 >> 16) & 255);
HXDLIN( 138)															if ((this6 == 0)) {
HXLINE( 138)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float g1;
HXDLIN( 138)															int this7 = ((this4 >> 8) & 255);
HXDLIN( 138)															if ((this7 == 0)) {
HXLINE( 138)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float b1;
HXDLIN( 138)															int this8 = (this4 & 255);
HXDLIN( 138)															if ((this8 == 0)) {
HXLINE( 138)																b1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float a2;
HXDLIN( 138)															int this9 = ((color >> 24) & 255);
HXDLIN( 138)															if ((this9 == 0)) {
HXLINE( 138)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float r2;
HXDLIN( 138)															int this10 = ((color >> 16) & 255);
HXDLIN( 138)															if ((this10 == 0)) {
HXLINE( 138)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float g2;
HXDLIN( 138)															int this11 = ((color >> 8) & 255);
HXDLIN( 138)															if ((this11 == 0)) {
HXLINE( 138)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float b2;
HXDLIN( 138)															int this12 = (color & 255);
HXDLIN( 138)															if ((this12 == 0)) {
HXLINE( 138)																b2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)															{
HXLINE( 138)																::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 138)																int value;
HXDLIN( 138)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 138)																	value = blended;
            																}
HXDLIN( 138)																bool _hx_tmp;
HXDLIN( 138)																if ((location >= 0)) {
HXLINE( 138)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE( 138)																	_hx_tmp = false;
            																}
HXDLIN( 138)																if (_hx_tmp) {
HXLINE( 138)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 138)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 138)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 138)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)															int index;
HXDLIN( 138)															if (temp->useVirtualPos) {
HXLINE( 138)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE( 138)																index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN( 138)															int value;
HXDLIN( 138)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE( 138)																value = c1;
            															}
HXDLIN( 138)															bool _hx_tmp;
HXDLIN( 138)															if ((index >= 0)) {
HXLINE( 138)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 138)																_hx_tmp = false;
            															}
HXDLIN( 138)															if (_hx_tmp) {
HXLINE( 138)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY = true;
            												}
            												else {
HXLINE( 138)													if (foundY) {
HXLINE( 138)														goto _hx_goto_63;
            													}
            												}
            											}
            										}
            										_hx_goto_63:;
            									}
            								}
            							}
HXDLIN( 138)							if ((hasHit == false)) {
HXLINE( 138)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx2,by2,cx2,cy2,true);
HXDLIN( 138)								if (hasUndo) {
HXLINE( 138)									v->undoImage = undoImage;
HXDLIN( 138)									v->undoX = xIter3->start;
HXDLIN( 138)									v->undoY = yIter3->start;
            								}
            							}
            						}
            					}
HXDLIN( 138)					{
HXLINE( 138)						Float bx3 = cx1;
HXDLIN( 138)						Float by3 = cy1;
HXDLIN( 138)						Float cx3 = dx;
HXDLIN( 138)						Float cy3 = dy;
HXDLIN( 138)						bool adjustWinding1 = (((((bx1 * by3) - (bx3 * by1)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by1) - (bx1 * cy3))) > 0);
HXDLIN( 138)						if (!(adjustWinding1)) {
HXLINE( 138)							Float bx_ = bx3;
HXDLIN( 138)							Float by_ = by3;
HXLINE( 188)							bx3 = cx3;
HXLINE( 189)							by3 = cy3;
HXLINE( 190)							cx3 = bx_;
HXLINE( 191)							cy3 = by_;
            						}
HXLINE( 138)						{
HXLINE( 138)							bool hasUndo1 = false;
HXDLIN( 138)							Float s01 = ((by1 * cx3) - (bx1 * cy3));
HXDLIN( 138)							Float sx1 = (cy3 - by1);
HXDLIN( 138)							Float sy1 = (bx1 - cx3);
HXDLIN( 138)							Float t01 = ((bx1 * by3) - (by1 * bx3));
HXDLIN( 138)							Float tx1 = (by1 - by3);
HXDLIN( 138)							Float ty1 = (bx3 - bx1);
HXDLIN( 138)							Float A1 = ((((-(by3) * cx3) + (by1 * (-(bx3) + cx3))) + (bx1 * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 138)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 138)							if ((bx1 > bx3)) {
HXLINE( 138)								if ((bx1 > cx3)) {
HXLINE( 138)									int min;
HXDLIN( 138)									if ((bx3 > cx3)) {
HXLINE( 138)										min = ::Math_obj::floor(cx3);
            									}
            									else {
HXLINE( 138)										min = ::Math_obj::floor(bx3);
            									}
HXDLIN( 138)									int ii_min = min;
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(bx1);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									xIter31 = this1;
            								}
            								else {
HXLINE( 138)									int ii_min = ::Math_obj::floor(bx3);
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE( 138)								if ((bx3 > cx3)) {
HXLINE( 138)									int min;
HXDLIN( 138)									if ((bx1 > cx3)) {
HXLINE( 138)										min = ::Math_obj::floor(cx3);
            									}
            									else {
HXLINE( 138)										min = ::Math_obj::ceil(bx1);
            									}
HXDLIN( 138)									int ii_min = min;
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(bx3);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									xIter31 = this1;
            								}
            								else {
HXLINE( 138)									int ii_min = ::Math_obj::floor(bx1);
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									xIter31 = this1;
            								}
            							}
HXDLIN( 138)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 138)							if ((by1 > by3)) {
HXLINE( 138)								if ((by1 > cy3)) {
HXLINE( 138)									int min;
HXDLIN( 138)									if ((by3 > cy3)) {
HXLINE( 138)										min = ::Math_obj::floor(cy3);
            									}
            									else {
HXLINE( 138)										min = ::Math_obj::floor(by3);
            									}
HXDLIN( 138)									int ii_min = min;
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(by1);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									yIter31 = this1;
            								}
            								else {
HXLINE( 138)									int ii_min = ::Math_obj::floor(by3);
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE( 138)								if ((by3 > cy3)) {
HXLINE( 138)									int min;
HXDLIN( 138)									if ((by1 > cy3)) {
HXLINE( 138)										min = ::Math_obj::floor(cy3);
            									}
            									else {
HXLINE( 138)										min = ::Math_obj::ceil(by1);
            									}
HXDLIN( 138)									int ii_min = min;
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(by3);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									yIter31 = this1;
            								}
            								else {
HXLINE( 138)									int ii_min = ::Math_obj::floor(by1);
HXDLIN( 138)									int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 138)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 138)									yIter31 = this1;
            								}
            							}
HXDLIN( 138)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 138)							if (hasUndo1) {
HXLINE( 138)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 138)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 138)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 138)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 138)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 138)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 138)								undoImage1 = this3;
HXDLIN( 138)								{
HXLINE( 138)									int rectLeft = xIter31->start;
HXDLIN( 138)									int rectTop = yIter31->start;
HXDLIN( 138)									int rectRight = xIter31->max;
HXDLIN( 138)									bool forceClear = false;
HXDLIN( 138)									{
HXLINE( 138)										int _g = rectTop;
HXDLIN( 138)										int _g1 = yIter31->max;
HXDLIN( 138)										while((_g < _g1)){
HXLINE( 138)											_g = (_g + 1);
HXDLIN( 138)											int dy = (_g - 1);
HXDLIN( 138)											{
HXLINE( 138)												int _g1 = rectLeft;
HXDLIN( 138)												int _g2 = rectRight;
HXDLIN( 138)												while((_g1 < _g2)){
HXLINE( 138)													_g1 = (_g1 + 1);
HXDLIN( 138)													int dx = (_g1 - 1);
HXDLIN( 138)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)													int index;
HXDLIN( 138)													if (temp->useVirtualPos) {
HXLINE( 138)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE( 138)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN( 138)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)													int col;
HXDLIN( 138)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 138)														col = c;
            													}
HXDLIN( 138)													bool _hx_tmp;
HXDLIN( 138)													if (temp->useMask) {
HXLINE( 138)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE( 138)														_hx_tmp = false;
            													}
HXDLIN( 138)													if (_hx_tmp) {
HXLINE( 138)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 138)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 138)														int index;
HXDLIN( 138)														if (this1->useVirtualPos) {
HXLINE( 138)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE( 138)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN( 138)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 138)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 138)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)														int v;
HXDLIN( 138)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 138)															v = c;
            														}
HXDLIN( 138)														int this3 = v;
HXDLIN( 138)														int maskPixel = this3;
HXDLIN( 138)														int this4 = col;
HXDLIN( 138)														int this5 = this4;
HXDLIN( 138)														if ((maskPixel == 0)) {
HXLINE( 138)															int this1 = this5;
HXDLIN( 138)															col = this1;
            														}
            														else {
HXLINE( 138)															Float m0;
HXDLIN( 138)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 138)															if ((this1 == 0)) {
HXLINE( 138)																m0 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float m1;
HXDLIN( 138)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 138)															if ((this2 == 0)) {
HXLINE( 138)																m1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float m2;
HXDLIN( 138)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 138)															if ((this3 == 0)) {
HXLINE( 138)																m2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float m3;
HXDLIN( 138)															int this4 = (maskPixel & 255);
HXDLIN( 138)															if ((this4 == 0)) {
HXLINE( 138)																m3 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 138)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 138)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 138)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 138)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 138)													if ((col != 0)) {
HXLINE( 138)														int x = (dx - rectLeft);
HXDLIN( 138)														int y = (dy - rectTop);
HXDLIN( 138)														int this1 = col;
HXDLIN( 138)														int c = this1;
HXDLIN( 138)														bool _hx_tmp;
HXDLIN( 138)														if ((((c >> 24) & 255) < 254)) {
HXLINE( 138)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE( 138)															_hx_tmp = false;
            														}
HXDLIN( 138)														if (_hx_tmp) {
HXLINE( 138)															int location;
HXDLIN( 138)															if (undoImage1->useVirtualPos) {
HXLINE( 138)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE( 138)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN( 138)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 138)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 138)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)															int this3 = this2;
HXDLIN( 138)															int this4;
HXDLIN( 138)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE( 138)																this4 = this3;
            															}
HXDLIN( 138)															Float a1;
HXDLIN( 138)															int this5 = ((this4 >> 24) & 255);
HXDLIN( 138)															if ((this5 == 0)) {
HXLINE( 138)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float r1;
HXDLIN( 138)															int this6 = ((this4 >> 16) & 255);
HXDLIN( 138)															if ((this6 == 0)) {
HXLINE( 138)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float g1;
HXDLIN( 138)															int this7 = ((this4 >> 8) & 255);
HXDLIN( 138)															if ((this7 == 0)) {
HXLINE( 138)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float b1;
HXDLIN( 138)															int this8 = (this4 & 255);
HXDLIN( 138)															if ((this8 == 0)) {
HXLINE( 138)																b1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float a2;
HXDLIN( 138)															int this9 = ((col >> 24) & 255);
HXDLIN( 138)															if ((this9 == 0)) {
HXLINE( 138)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float r2;
HXDLIN( 138)															int this10 = ((col >> 16) & 255);
HXDLIN( 138)															if ((this10 == 0)) {
HXLINE( 138)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float g2;
HXDLIN( 138)															int this11 = ((col >> 8) & 255);
HXDLIN( 138)															if ((this11 == 0)) {
HXLINE( 138)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float b2;
HXDLIN( 138)															int this12 = (col & 255);
HXDLIN( 138)															if ((this12 == 0)) {
HXLINE( 138)																b2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)															{
HXLINE( 138)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 138)																int value;
HXDLIN( 138)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 138)																	value = blended;
            																}
HXDLIN( 138)																bool _hx_tmp;
HXDLIN( 138)																if ((location >= 0)) {
HXLINE( 138)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE( 138)																	_hx_tmp = false;
            																}
HXDLIN( 138)																if (_hx_tmp) {
HXLINE( 138)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 138)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 138)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 138)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 138)															int index;
HXDLIN( 138)															if (undoImage1->useVirtualPos) {
HXLINE( 138)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE( 138)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN( 138)															int value;
HXDLIN( 138)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE( 138)																value = c;
            															}
HXDLIN( 138)															bool _hx_tmp;
HXDLIN( 138)															if ((index >= 0)) {
HXLINE( 138)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 138)																_hx_tmp = false;
            															}
HXDLIN( 138)															if (_hx_tmp) {
HXLINE( 138)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 138)														if (forceClear) {
HXLINE( 138)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 138)															int x = (dx - rectLeft);
HXDLIN( 138)															int y = (dy - rectTop);
HXDLIN( 138)															int index;
HXDLIN( 138)															if (undoImage1->useVirtualPos) {
HXLINE( 138)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE( 138)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN( 138)															bool _hx_tmp;
HXDLIN( 138)															if ((index >= 0)) {
HXLINE( 138)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 138)																_hx_tmp = false;
            															}
HXDLIN( 138)															if (_hx_tmp) {
HXLINE( 138)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 138)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 138)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 138)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 138)							bool foundY1 = false;
HXDLIN( 138)							Float s1 = ((Float)0.);
HXDLIN( 138)							Float t1 = ((Float)0.);
HXDLIN( 138)							Float sxx1 = ((Float)0.);
HXDLIN( 138)							Float txx1 = ((Float)0.);
HXDLIN( 138)							{
HXLINE( 138)								int _g_min1 = xIter31->start;
HXDLIN( 138)								int _g_max1 = xIter31->max;
HXDLIN( 138)								while((_g_min1 < _g_max1)){
HXLINE( 138)									_g_min1 = (_g_min1 + 1);
HXDLIN( 138)									int x = (_g_min1 - 1);
HXLINE( 223)									sxx1 = (sx1 * ( (Float)(x) ));
HXLINE( 224)									txx1 = (tx1 * ( (Float)(x) ));
HXLINE( 225)									foundY1 = false;
HXLINE( 138)									{
HXLINE( 138)										int _g_min = yIter31->start;
HXDLIN( 138)										int _g_max = yIter31->max;
HXDLIN( 138)										while((_g_min < _g_max)){
HXLINE( 138)											_g_min = (_g_min + 1);
HXDLIN( 138)											int y = (_g_min - 1);
HXLINE( 227)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE( 228)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE( 138)											bool _hx_tmp;
HXDLIN( 138)											if (!((s1 <= 0))) {
HXLINE( 138)												_hx_tmp = (t1 <= 0);
            											}
            											else {
HXLINE( 138)												_hx_tmp = true;
            											}
HXDLIN( 138)											if (_hx_tmp) {
HXLINE( 138)												if (foundY1) {
HXLINE( 138)													goto _hx_goto_67;
            												}
            											}
            											else {
HXLINE( 138)												if (((s1 + t1) < A1)) {
HXLINE( 138)													int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN( 138)													int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN( 138)													::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN( 138)													int index;
HXDLIN( 138)													if (tileImage->useVirtualPos) {
HXLINE( 138)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            													}
            													else {
HXLINE( 138)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            													}
HXDLIN( 138)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)													int color;
HXDLIN( 138)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 138)														color = c;
            													}
HXDLIN( 138)													{
HXLINE( 138)														int this2 = color;
HXDLIN( 138)														int c1 = this2;
HXDLIN( 138)														bool _hx_tmp;
HXDLIN( 138)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 138)															_hx_tmp = temp->transparent;
            														}
            														else {
HXLINE( 138)															_hx_tmp = false;
            														}
HXDLIN( 138)														if (_hx_tmp) {
HXLINE( 138)															int location;
HXDLIN( 138)															if (temp->useVirtualPos) {
HXLINE( 138)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE( 138)																location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN( 138)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 138)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 138)															int this3 = this2;
HXDLIN( 138)															int this4;
HXDLIN( 138)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE( 138)																this4 = this3;
            															}
HXDLIN( 138)															Float a1;
HXDLIN( 138)															int this5 = ((this4 >> 24) & 255);
HXDLIN( 138)															if ((this5 == 0)) {
HXLINE( 138)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float r1;
HXDLIN( 138)															int this6 = ((this4 >> 16) & 255);
HXDLIN( 138)															if ((this6 == 0)) {
HXLINE( 138)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float g1;
HXDLIN( 138)															int this7 = ((this4 >> 8) & 255);
HXDLIN( 138)															if ((this7 == 0)) {
HXLINE( 138)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float b1;
HXDLIN( 138)															int this8 = (this4 & 255);
HXDLIN( 138)															if ((this8 == 0)) {
HXLINE( 138)																b1 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float a2;
HXDLIN( 138)															int this9 = ((color >> 24) & 255);
HXDLIN( 138)															if ((this9 == 0)) {
HXLINE( 138)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float r2;
HXDLIN( 138)															int this10 = ((color >> 16) & 255);
HXDLIN( 138)															if ((this10 == 0)) {
HXLINE( 138)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float g2;
HXDLIN( 138)															int this11 = ((color >> 8) & 255);
HXDLIN( 138)															if ((this11 == 0)) {
HXLINE( 138)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float b2;
HXDLIN( 138)															int this12 = (color & 255);
HXDLIN( 138)															if ((this12 == 0)) {
HXLINE( 138)																b2 = ((Float)0.);
            															}
            															else {
HXLINE( 138)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN( 138)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 138)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 138)															{
HXLINE( 138)																::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 138)																int value;
HXDLIN( 138)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 138)																	value = blended;
            																}
HXDLIN( 138)																bool _hx_tmp;
HXDLIN( 138)																if ((location >= 0)) {
HXLINE( 138)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE( 138)																	_hx_tmp = false;
            																}
HXDLIN( 138)																if (_hx_tmp) {
HXLINE( 138)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 138)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 138)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 138)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 138)															int index;
HXDLIN( 138)															if (temp->useVirtualPos) {
HXLINE( 138)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE( 138)																index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN( 138)															int value;
HXDLIN( 138)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE( 138)																value = c1;
            															}
HXDLIN( 138)															bool _hx_tmp;
HXDLIN( 138)															if ((index >= 0)) {
HXLINE( 138)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 138)																_hx_tmp = false;
            															}
HXDLIN( 138)															if (_hx_tmp) {
HXLINE( 138)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 138)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 138)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 138)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 138)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 138)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY1 = true;
            												}
            												else {
HXLINE( 138)													if (foundY1) {
HXLINE( 138)														goto _hx_goto_67;
            													}
            												}
            											}
            										}
            										_hx_goto_67:;
            									}
            								}
            							}
HXDLIN( 138)							if ((hasHit == false)) {
HXLINE( 138)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx1,by1,bx3,by3,cx3,cy3,true);
HXDLIN( 138)								if (hasUndo1) {
HXLINE( 138)									v->undoImage = undoImage1;
HXDLIN( 138)									v->undoX = xIter31->start;
HXDLIN( 138)									v->undoY = yIter31->start;
            								}
            							}
            						}
            					}
HXDLIN( 138)					if ((hasHit == true)) {
HXLINE( 138)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax1,ay1,bx1,by1,cx1,cy1,dx,dy,true);
            					}
            				}
            			}
            		}
HXLINE( 139)		{
HXLINE( 139)			Float px1 = this->rx;
HXDLIN( 139)			Float py1 = this->ry;
HXDLIN( 139)			::pixelimage::ImageStruct tileImage1 = this->tileImageStroke;
HXDLIN( 139)			bool hasHit1 = false;
HXDLIN( 139)			Float o1 = (cy - py1);
HXDLIN( 139)			Float a1 = (cx - px1);
HXDLIN( 139)			Float h1 = ::Math_obj::pow(((o1 * o1) + (a1 * a1)),((Float)0.5));
HXDLIN( 139)			Float theta1 = ::Math_obj::atan2(o1,a1);
HXDLIN( 139)			{
HXLINE( 139)				 ::Dynamic debugCorners1 = false;
HXDLIN( 139)				if (::hx::IsNull( debugCorners1 )) {
HXLINE( 893)					debugCorners1 = false;
            				}
HXLINE( 139)				Float sin1 = ::Math_obj::sin(theta1);
HXDLIN( 139)				Float cos1 = ::Math_obj::cos(theta1);
HXDLIN( 139)				Float radius1 = (this->strokeWidth / ( (Float)(2) ));
HXDLIN( 139)				Float dx1 = ((Float)0.1);
HXDLIN( 139)				Float dy1 = radius1;
HXDLIN( 139)				Float cx4 = h1;
HXDLIN( 139)				Float cy4 = radius1;
HXDLIN( 139)				Float bx4 = h1;
HXDLIN( 139)				Float by4 = -(radius1);
HXDLIN( 139)				Float ax2 = ((Float)0.1);
HXDLIN( 139)				Float ay2 = -(radius1);
HXDLIN( 139)				Float temp2 = ((Float)0.);
HXLINE( 380)				temp2 = (px1 + ((ax2 * cos1) - (ay2 * sin1)));
HXLINE( 381)				ay2 = (py1 + ((ay2 * cos1) + (ax2 * sin1)));
HXLINE( 382)				ax2 = temp2;
HXLINE( 384)				temp2 = (px1 + ((bx4 * cos1) - (by4 * sin1)));
HXLINE( 385)				by4 = (py1 + ((by4 * cos1) + (bx4 * sin1)));
HXLINE( 386)				bx4 = temp2;
HXLINE( 388)				temp2 = (px1 + ((cx4 * cos1) - (cy4 * sin1)));
HXLINE( 389)				cy4 = (py1 + ((cy4 * cos1) + (cx4 * sin1)));
HXLINE( 390)				cx4 = temp2;
HXLINE( 392)				temp2 = (px1 + ((dx1 * cos1) - (dy1 * sin1)));
HXLINE( 393)				dy1 = (py1 + ((dy1 * cos1) + (dx1 * sin1)));
HXLINE( 394)				dx1 = temp2;
HXLINE( 139)				if (( (bool)(debugCorners1) )) {
HXLINE( 139)					{
HXLINE( 139)						Float x = (ax2 - ((Float)6.));
HXDLIN( 139)						Float y = (ay2 - ((Float)6.));
HXDLIN( 139)						int p = ::Std_obj::_hx_int(x);
HXDLIN( 139)						int xx = p;
HXDLIN( 139)						int q = ::Std_obj::_hx_int(y);
HXDLIN( 139)						int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN( 139)						int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN( 139)						while(true){
HXLINE( 139)							{
HXLINE( 139)								p = (p + 1);
HXDLIN( 139)								int x = (p - 1);
HXDLIN( 139)								int this1 = -65536;
HXDLIN( 139)								int c = this1;
HXDLIN( 139)								bool _hx_tmp;
HXDLIN( 139)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 139)									_hx_tmp = temp->transparent;
            								}
            								else {
HXLINE( 139)									_hx_tmp = false;
            								}
HXDLIN( 139)								if (_hx_tmp) {
HXLINE( 139)									int location;
HXDLIN( 139)									if (temp->useVirtualPos) {
HXLINE( 139)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 139)										location = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            									}
HXDLIN( 139)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 139)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)									int this3 = this2;
HXDLIN( 139)									int this4;
HXDLIN( 139)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 139)										this4 = this3;
            									}
HXDLIN( 139)									Float a1;
HXDLIN( 139)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 139)									if ((this5 == 0)) {
HXLINE( 139)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r1;
HXDLIN( 139)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 139)									if ((this6 == 0)) {
HXLINE( 139)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g1;
HXDLIN( 139)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 139)									if ((this7 == 0)) {
HXLINE( 139)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b1;
HXDLIN( 139)									int this8 = (this4 & 255);
HXDLIN( 139)									if ((this8 == 0)) {
HXLINE( 139)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a2;
HXDLIN( 139)									int this9 = ((-65536 >> 24) & 255);
HXDLIN( 139)									if ((this9 == 0)) {
HXLINE( 139)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r2;
HXDLIN( 139)									int this10 = ((-65536 >> 16) & 255);
HXDLIN( 139)									if ((this10 == 0)) {
HXLINE( 139)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g2;
HXDLIN( 139)									int this11 = ((-65536 >> 8) & 255);
HXDLIN( 139)									if ((this11 == 0)) {
HXLINE( 139)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b2;
HXDLIN( 139)									int this12 = (-65536 & 255);
HXDLIN( 139)									if ((this12 == 0)) {
HXLINE( 139)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 139)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 139)									{
HXLINE( 139)										::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 139)										int value;
HXDLIN( 139)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 139)											value = blended;
            										}
HXDLIN( 139)										bool _hx_tmp;
HXDLIN( 139)										if ((location >= 0)) {
HXLINE( 139)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 139)											_hx_tmp = false;
            										}
HXDLIN( 139)										if (_hx_tmp) {
HXLINE( 139)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 139)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 139)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 139)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)									int index;
HXDLIN( 139)									if (temp->useVirtualPos) {
HXLINE( 139)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 139)										index = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            									}
HXDLIN( 139)									int value;
HXDLIN( 139)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 139)										value = c;
            									}
HXDLIN( 139)									bool _hx_tmp;
HXDLIN( 139)									if ((index >= 0)) {
HXLINE( 139)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 139)										_hx_tmp = false;
            									}
HXDLIN( 139)									if (_hx_tmp) {
HXLINE( 139)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN( 139)							if ((p > maxX)) {
HXLINE( 247)								p = xx;
HXLINE( 139)								q = (q + 1);
            							}
HXDLIN( 139)							if ((q > maxY)) {
HXLINE( 139)								goto _hx_goto_68;
            							}
            						}
            						_hx_goto_68:;
            					}
HXDLIN( 139)					{
HXLINE( 139)						Float x1 = (bx4 - ((Float)6.));
HXDLIN( 139)						Float y1 = (by4 - ((Float)6.));
HXDLIN( 139)						int p1 = ::Std_obj::_hx_int(x1);
HXDLIN( 139)						int xx1 = p1;
HXDLIN( 139)						int q1 = ::Std_obj::_hx_int(y1);
HXDLIN( 139)						int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN( 139)						int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN( 139)						while(true){
HXLINE( 139)							{
HXLINE( 139)								p1 = (p1 + 1);
HXDLIN( 139)								int x = (p1 - 1);
HXDLIN( 139)								int this1 = -16711936;
HXDLIN( 139)								int c = this1;
HXDLIN( 139)								bool _hx_tmp;
HXDLIN( 139)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 139)									_hx_tmp = temp->transparent;
            								}
            								else {
HXLINE( 139)									_hx_tmp = false;
            								}
HXDLIN( 139)								if (_hx_tmp) {
HXLINE( 139)									int location;
HXDLIN( 139)									if (temp->useVirtualPos) {
HXLINE( 139)										location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 139)										location = ::Std_obj::_hx_int(( (Float)(((q1 * temp->width) + x)) ));
            									}
HXDLIN( 139)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 139)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)									int this3 = this2;
HXDLIN( 139)									int this4;
HXDLIN( 139)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 139)										this4 = this3;
            									}
HXDLIN( 139)									Float a1;
HXDLIN( 139)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 139)									if ((this5 == 0)) {
HXLINE( 139)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r1;
HXDLIN( 139)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 139)									if ((this6 == 0)) {
HXLINE( 139)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g1;
HXDLIN( 139)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 139)									if ((this7 == 0)) {
HXLINE( 139)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b1;
HXDLIN( 139)									int this8 = (this4 & 255);
HXDLIN( 139)									if ((this8 == 0)) {
HXLINE( 139)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a2;
HXDLIN( 139)									int this9 = ((-16711936 >> 24) & 255);
HXDLIN( 139)									if ((this9 == 0)) {
HXLINE( 139)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r2;
HXDLIN( 139)									int this10 = ((-16711936 >> 16) & 255);
HXDLIN( 139)									if ((this10 == 0)) {
HXLINE( 139)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g2;
HXDLIN( 139)									int this11 = ((-16711936 >> 8) & 255);
HXDLIN( 139)									if ((this11 == 0)) {
HXLINE( 139)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b2;
HXDLIN( 139)									int this12 = (-16711936 & 255);
HXDLIN( 139)									if ((this12 == 0)) {
HXLINE( 139)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 139)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 139)									{
HXLINE( 139)										::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 139)										int value;
HXDLIN( 139)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 139)											value = blended;
            										}
HXDLIN( 139)										bool _hx_tmp;
HXDLIN( 139)										if ((location >= 0)) {
HXLINE( 139)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 139)											_hx_tmp = false;
            										}
HXDLIN( 139)										if (_hx_tmp) {
HXLINE( 139)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 139)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 139)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 139)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)									int index;
HXDLIN( 139)									if (temp->useVirtualPos) {
HXLINE( 139)										index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 139)										index = ::Std_obj::_hx_int(( (Float)(((q1 * temp->width) + x)) ));
            									}
HXDLIN( 139)									int value;
HXDLIN( 139)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 139)										value = c;
            									}
HXDLIN( 139)									bool _hx_tmp;
HXDLIN( 139)									if ((index >= 0)) {
HXLINE( 139)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 139)										_hx_tmp = false;
            									}
HXDLIN( 139)									if (_hx_tmp) {
HXLINE( 139)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN( 139)							if ((p1 > maxX1)) {
HXLINE( 247)								p1 = xx1;
HXLINE( 139)								q1 = (q1 + 1);
            							}
HXDLIN( 139)							if ((q1 > maxY1)) {
HXLINE( 139)								goto _hx_goto_69;
            							}
            						}
            						_hx_goto_69:;
            					}
HXDLIN( 139)					{
HXLINE( 139)						Float x2 = (cx4 - ((Float)6.));
HXDLIN( 139)						Float y2 = (cy4 - ((Float)6.));
HXDLIN( 139)						int p2 = ::Std_obj::_hx_int(x2);
HXDLIN( 139)						int xx2 = p2;
HXDLIN( 139)						int q2 = ::Std_obj::_hx_int(y2);
HXDLIN( 139)						int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN( 139)						int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN( 139)						while(true){
HXLINE( 139)							{
HXLINE( 139)								p2 = (p2 + 1);
HXDLIN( 139)								int x = (p2 - 1);
HXDLIN( 139)								int this1 = -16776961;
HXDLIN( 139)								int c = this1;
HXDLIN( 139)								bool _hx_tmp;
HXDLIN( 139)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 139)									_hx_tmp = temp->transparent;
            								}
            								else {
HXLINE( 139)									_hx_tmp = false;
            								}
HXDLIN( 139)								if (_hx_tmp) {
HXLINE( 139)									int location;
HXDLIN( 139)									if (temp->useVirtualPos) {
HXLINE( 139)										location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 139)										location = ::Std_obj::_hx_int(( (Float)(((q2 * temp->width) + x)) ));
            									}
HXDLIN( 139)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 139)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)									int this3 = this2;
HXDLIN( 139)									int this4;
HXDLIN( 139)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 139)										this4 = this3;
            									}
HXDLIN( 139)									Float a1;
HXDLIN( 139)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 139)									if ((this5 == 0)) {
HXLINE( 139)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r1;
HXDLIN( 139)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 139)									if ((this6 == 0)) {
HXLINE( 139)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g1;
HXDLIN( 139)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 139)									if ((this7 == 0)) {
HXLINE( 139)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b1;
HXDLIN( 139)									int this8 = (this4 & 255);
HXDLIN( 139)									if ((this8 == 0)) {
HXLINE( 139)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a2;
HXDLIN( 139)									int this9 = ((-16776961 >> 24) & 255);
HXDLIN( 139)									if ((this9 == 0)) {
HXLINE( 139)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r2;
HXDLIN( 139)									int this10 = ((-16776961 >> 16) & 255);
HXDLIN( 139)									if ((this10 == 0)) {
HXLINE( 139)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g2;
HXDLIN( 139)									int this11 = ((-16776961 >> 8) & 255);
HXDLIN( 139)									if ((this11 == 0)) {
HXLINE( 139)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b2;
HXDLIN( 139)									int this12 = (-16776961 & 255);
HXDLIN( 139)									if ((this12 == 0)) {
HXLINE( 139)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 139)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 139)									{
HXLINE( 139)										::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 139)										int value;
HXDLIN( 139)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 139)											value = blended;
            										}
HXDLIN( 139)										bool _hx_tmp;
HXDLIN( 139)										if ((location >= 0)) {
HXLINE( 139)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 139)											_hx_tmp = false;
            										}
HXDLIN( 139)										if (_hx_tmp) {
HXLINE( 139)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 139)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 139)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 139)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)									int index;
HXDLIN( 139)									if (temp->useVirtualPos) {
HXLINE( 139)										index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 139)										index = ::Std_obj::_hx_int(( (Float)(((q2 * temp->width) + x)) ));
            									}
HXDLIN( 139)									int value;
HXDLIN( 139)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 139)										value = c;
            									}
HXDLIN( 139)									bool _hx_tmp;
HXDLIN( 139)									if ((index >= 0)) {
HXLINE( 139)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 139)										_hx_tmp = false;
            									}
HXDLIN( 139)									if (_hx_tmp) {
HXLINE( 139)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN( 139)							if ((p2 > maxX2)) {
HXLINE( 247)								p2 = xx2;
HXLINE( 139)								q2 = (q2 + 1);
            							}
HXDLIN( 139)							if ((q2 > maxY2)) {
HXLINE( 139)								goto _hx_goto_70;
            							}
            						}
            						_hx_goto_70:;
            					}
HXDLIN( 139)					{
HXLINE( 139)						Float x3 = (dx1 - ((Float)6.));
HXDLIN( 139)						Float y3 = (dy1 - ((Float)6.));
HXDLIN( 139)						int p3 = ::Std_obj::_hx_int(x3);
HXDLIN( 139)						int xx3 = p3;
HXDLIN( 139)						int q3 = ::Std_obj::_hx_int(y3);
HXDLIN( 139)						int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN( 139)						int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN( 139)						while(true){
HXLINE( 139)							{
HXLINE( 139)								p3 = (p3 + 1);
HXDLIN( 139)								int x = (p3 - 1);
HXDLIN( 139)								int this1 = -1048336;
HXDLIN( 139)								int c = this1;
HXDLIN( 139)								bool _hx_tmp;
HXDLIN( 139)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 139)									_hx_tmp = temp->transparent;
            								}
            								else {
HXLINE( 139)									_hx_tmp = false;
            								}
HXDLIN( 139)								if (_hx_tmp) {
HXLINE( 139)									int location;
HXDLIN( 139)									if (temp->useVirtualPos) {
HXLINE( 139)										location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 139)										location = ::Std_obj::_hx_int(( (Float)(((q3 * temp->width) + x)) ));
            									}
HXDLIN( 139)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 139)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)									int this3 = this2;
HXDLIN( 139)									int this4;
HXDLIN( 139)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 139)										this4 = this3;
            									}
HXDLIN( 139)									Float a1;
HXDLIN( 139)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 139)									if ((this5 == 0)) {
HXLINE( 139)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r1;
HXDLIN( 139)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 139)									if ((this6 == 0)) {
HXLINE( 139)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g1;
HXDLIN( 139)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 139)									if ((this7 == 0)) {
HXLINE( 139)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b1;
HXDLIN( 139)									int this8 = (this4 & 255);
HXDLIN( 139)									if ((this8 == 0)) {
HXLINE( 139)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a2;
HXDLIN( 139)									int this9 = ((-1048336 >> 24) & 255);
HXDLIN( 139)									if ((this9 == 0)) {
HXLINE( 139)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float r2;
HXDLIN( 139)									int this10 = ((-1048336 >> 16) & 255);
HXDLIN( 139)									if ((this10 == 0)) {
HXLINE( 139)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float g2;
HXDLIN( 139)									int this11 = ((-1048336 >> 8) & 255);
HXDLIN( 139)									if ((this11 == 0)) {
HXLINE( 139)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float b2;
HXDLIN( 139)									int this12 = (-1048336 & 255);
HXDLIN( 139)									if ((this12 == 0)) {
HXLINE( 139)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 139)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 139)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 139)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 139)									{
HXLINE( 139)										::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 139)										int value;
HXDLIN( 139)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 139)											value = blended;
            										}
HXDLIN( 139)										bool _hx_tmp;
HXDLIN( 139)										if ((location >= 0)) {
HXLINE( 139)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 139)											_hx_tmp = false;
            										}
HXDLIN( 139)										if (_hx_tmp) {
HXLINE( 139)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 139)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 139)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 139)									::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)									int index;
HXDLIN( 139)									if (temp->useVirtualPos) {
HXLINE( 139)										index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            									}
            									else {
HXLINE( 139)										index = ::Std_obj::_hx_int(( (Float)(((q3 * temp->width) + x)) ));
            									}
HXDLIN( 139)									int value;
HXDLIN( 139)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 139)										value = c;
            									}
HXDLIN( 139)									bool _hx_tmp;
HXDLIN( 139)									if ((index >= 0)) {
HXLINE( 139)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 139)										_hx_tmp = false;
            									}
HXDLIN( 139)									if (_hx_tmp) {
HXLINE( 139)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN( 139)							if ((p3 > maxX3)) {
HXLINE( 247)								p3 = xx3;
HXLINE( 139)								q3 = (q3 + 1);
            							}
HXDLIN( 139)							if ((q3 > maxY3)) {
HXLINE( 139)								goto _hx_goto_71;
            							}
            						}
            						_hx_goto_71:;
            					}
            				}
HXDLIN( 139)				{
HXLINE( 139)					{
HXLINE( 139)						Float bx5 = bx4;
HXDLIN( 139)						Float by5 = by4;
HXDLIN( 139)						Float cx5 = dx1;
HXDLIN( 139)						Float cy5 = dy1;
HXDLIN( 139)						bool adjustWinding2 = (((((ax2 * by5) - (bx5 * ay2)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay2) - (ax2 * cy5))) > 0);
HXDLIN( 139)						if (!(adjustWinding2)) {
HXLINE( 139)							Float bx_ = bx5;
HXDLIN( 139)							Float by_ = by5;
HXLINE( 188)							bx5 = cx5;
HXLINE( 189)							by5 = cy5;
HXLINE( 190)							cx5 = bx_;
HXLINE( 191)							cy5 = by_;
            						}
HXLINE( 139)						{
HXLINE( 139)							bool hasUndo2 = false;
HXDLIN( 139)							Float s02 = ((ay2 * cx5) - (ax2 * cy5));
HXDLIN( 139)							Float sx2 = (cy5 - ay2);
HXDLIN( 139)							Float sy2 = (ax2 - cx5);
HXDLIN( 139)							Float t02 = ((ax2 * by5) - (ay2 * bx5));
HXDLIN( 139)							Float tx2 = (ay2 - by5);
HXDLIN( 139)							Float ty2 = (bx5 - ax2);
HXDLIN( 139)							Float A2 = ((((-(by5) * cx5) + (ay2 * (-(bx5) + cx5))) + (ax2 * (by5 - cy5))) + (bx5 * cy5));
HXDLIN( 139)							::pixelimage::iter::IntIterStart xIter32;
HXDLIN( 139)							if ((ax2 > bx5)) {
HXLINE( 139)								if ((ax2 > cx5)) {
HXLINE( 139)									int min;
HXDLIN( 139)									if ((bx5 > cx5)) {
HXLINE( 139)										min = ::Math_obj::floor(cx5);
            									}
            									else {
HXLINE( 139)										min = ::Math_obj::floor(bx5);
            									}
HXDLIN( 139)									int ii_min = min;
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(ax2);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									xIter32 = this1;
            								}
            								else {
HXLINE( 139)									int ii_min = ::Math_obj::floor(bx5);
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(cx5);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									xIter32 = this1;
            								}
            							}
            							else {
HXLINE( 139)								if ((bx5 > cx5)) {
HXLINE( 139)									int min;
HXDLIN( 139)									if ((ax2 > cx5)) {
HXLINE( 139)										min = ::Math_obj::floor(cx5);
            									}
            									else {
HXLINE( 139)										min = ::Math_obj::ceil(ax2);
            									}
HXDLIN( 139)									int ii_min = min;
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(bx5);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									xIter32 = this1;
            								}
            								else {
HXLINE( 139)									int ii_min = ::Math_obj::floor(ax2);
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(cx5);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									xIter32 = this1;
            								}
            							}
HXDLIN( 139)							::pixelimage::iter::IntIterStart yIter32;
HXDLIN( 139)							if ((ay2 > by5)) {
HXLINE( 139)								if ((ay2 > cy5)) {
HXLINE( 139)									int min;
HXDLIN( 139)									if ((by5 > cy5)) {
HXLINE( 139)										min = ::Math_obj::floor(cy5);
            									}
            									else {
HXLINE( 139)										min = ::Math_obj::floor(by5);
            									}
HXDLIN( 139)									int ii_min = min;
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(ay2);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									yIter32 = this1;
            								}
            								else {
HXLINE( 139)									int ii_min = ::Math_obj::floor(by5);
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(cy5);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									yIter32 = this1;
            								}
            							}
            							else {
HXLINE( 139)								if ((by5 > cy5)) {
HXLINE( 139)									int min;
HXDLIN( 139)									if ((ay2 > cy5)) {
HXLINE( 139)										min = ::Math_obj::floor(cy5);
            									}
            									else {
HXLINE( 139)										min = ::Math_obj::ceil(ay2);
            									}
HXDLIN( 139)									int ii_min = min;
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(by5);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									yIter32 = this1;
            								}
            								else {
HXLINE( 139)									int ii_min = ::Math_obj::floor(ay2);
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(cy5);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									yIter32 = this1;
            								}
            							}
HXDLIN( 139)							::pixelimage::ImageStruct undoImage2 = null();
HXDLIN( 139)							if (hasUndo2) {
HXLINE( 139)								int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 139)								int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 139)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 139)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 139)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 139)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 139)								undoImage2 = this3;
HXDLIN( 139)								{
HXLINE( 139)									int rectLeft = xIter32->start;
HXDLIN( 139)									int rectTop = yIter32->start;
HXDLIN( 139)									int rectRight = xIter32->max;
HXDLIN( 139)									bool forceClear = false;
HXDLIN( 139)									{
HXLINE( 139)										int _g = rectTop;
HXDLIN( 139)										int _g1 = yIter32->max;
HXDLIN( 139)										while((_g < _g1)){
HXLINE( 139)											_g = (_g + 1);
HXDLIN( 139)											int dy = (_g - 1);
HXDLIN( 139)											{
HXLINE( 139)												int _g1 = rectLeft;
HXDLIN( 139)												int _g2 = rectRight;
HXDLIN( 139)												while((_g1 < _g2)){
HXLINE( 139)													_g1 = (_g1 + 1);
HXDLIN( 139)													int dx = (_g1 - 1);
HXDLIN( 139)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)													int index;
HXDLIN( 139)													if (temp->useVirtualPos) {
HXLINE( 139)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE( 139)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN( 139)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)													int col;
HXDLIN( 139)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 139)														col = c;
            													}
HXDLIN( 139)													bool _hx_tmp;
HXDLIN( 139)													if (temp->useMask) {
HXLINE( 139)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE( 139)														_hx_tmp = false;
            													}
HXDLIN( 139)													if (_hx_tmp) {
HXLINE( 139)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 139)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 139)														int index;
HXDLIN( 139)														if (this1->useVirtualPos) {
HXLINE( 139)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE( 139)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN( 139)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 139)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 139)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)														int v;
HXDLIN( 139)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 139)															v = c;
            														}
HXDLIN( 139)														int this3 = v;
HXDLIN( 139)														int maskPixel = this3;
HXDLIN( 139)														int this4 = col;
HXDLIN( 139)														int this5 = this4;
HXDLIN( 139)														if ((maskPixel == 0)) {
HXLINE( 139)															int this1 = this5;
HXDLIN( 139)															col = this1;
            														}
            														else {
HXLINE( 139)															Float m0;
HXDLIN( 139)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 139)															if ((this1 == 0)) {
HXLINE( 139)																m0 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float m1;
HXDLIN( 139)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 139)															if ((this2 == 0)) {
HXLINE( 139)																m1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float m2;
HXDLIN( 139)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 139)															if ((this3 == 0)) {
HXLINE( 139)																m2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float m3;
HXDLIN( 139)															int this4 = (maskPixel & 255);
HXDLIN( 139)															if ((this4 == 0)) {
HXLINE( 139)																m3 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 139)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 139)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 139)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 139)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 139)													if ((col != 0)) {
HXLINE( 139)														int x = (dx - rectLeft);
HXDLIN( 139)														int y = (dy - rectTop);
HXDLIN( 139)														int this1 = col;
HXDLIN( 139)														int c = this1;
HXDLIN( 139)														bool _hx_tmp;
HXDLIN( 139)														if ((((c >> 24) & 255) < 254)) {
HXLINE( 139)															_hx_tmp = undoImage2->transparent;
            														}
            														else {
HXLINE( 139)															_hx_tmp = false;
            														}
HXDLIN( 139)														if (_hx_tmp) {
HXLINE( 139)															int location;
HXDLIN( 139)															if (undoImage2->useVirtualPos) {
HXLINE( 139)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE( 139)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN( 139)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 139)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 139)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)															int this3 = this2;
HXDLIN( 139)															int this4;
HXDLIN( 139)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE( 139)																this4 = this3;
            															}
HXDLIN( 139)															Float a1;
HXDLIN( 139)															int this5 = ((this4 >> 24) & 255);
HXDLIN( 139)															if ((this5 == 0)) {
HXLINE( 139)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float r1;
HXDLIN( 139)															int this6 = ((this4 >> 16) & 255);
HXDLIN( 139)															if ((this6 == 0)) {
HXLINE( 139)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float g1;
HXDLIN( 139)															int this7 = ((this4 >> 8) & 255);
HXDLIN( 139)															if ((this7 == 0)) {
HXLINE( 139)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float b1;
HXDLIN( 139)															int this8 = (this4 & 255);
HXDLIN( 139)															if ((this8 == 0)) {
HXLINE( 139)																b1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float a2;
HXDLIN( 139)															int this9 = ((col >> 24) & 255);
HXDLIN( 139)															if ((this9 == 0)) {
HXLINE( 139)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float r2;
HXDLIN( 139)															int this10 = ((col >> 16) & 255);
HXDLIN( 139)															if ((this10 == 0)) {
HXLINE( 139)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float g2;
HXDLIN( 139)															int this11 = ((col >> 8) & 255);
HXDLIN( 139)															if ((this11 == 0)) {
HXLINE( 139)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float b2;
HXDLIN( 139)															int this12 = (col & 255);
HXDLIN( 139)															if ((this12 == 0)) {
HXLINE( 139)																b2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 139)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 139)															{
HXLINE( 139)																::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN( 139)																int value;
HXDLIN( 139)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 139)																	value = blended;
            																}
HXDLIN( 139)																bool _hx_tmp;
HXDLIN( 139)																if ((location >= 0)) {
HXLINE( 139)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE( 139)																	_hx_tmp = false;
            																}
HXDLIN( 139)																if (_hx_tmp) {
HXLINE( 139)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 139)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 139)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 139)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 139)															int index;
HXDLIN( 139)															if (undoImage2->useVirtualPos) {
HXLINE( 139)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE( 139)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN( 139)															int value;
HXDLIN( 139)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE( 139)																value = c;
            															}
HXDLIN( 139)															bool _hx_tmp;
HXDLIN( 139)															if ((index >= 0)) {
HXLINE( 139)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 139)																_hx_tmp = false;
            															}
HXDLIN( 139)															if (_hx_tmp) {
HXLINE( 139)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 139)														if (forceClear) {
HXLINE( 139)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 139)															int x = (dx - rectLeft);
HXDLIN( 139)															int y = (dy - rectTop);
HXDLIN( 139)															int index;
HXDLIN( 139)															if (undoImage2->useVirtualPos) {
HXLINE( 139)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE( 139)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN( 139)															bool _hx_tmp;
HXDLIN( 139)															if ((index >= 0)) {
HXLINE( 139)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 139)																_hx_tmp = false;
            															}
HXDLIN( 139)															if (_hx_tmp) {
HXLINE( 139)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 139)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 139)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 139)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 139)							bool foundY2 = false;
HXDLIN( 139)							Float s2 = ((Float)0.);
HXDLIN( 139)							Float t2 = ((Float)0.);
HXDLIN( 139)							Float sxx2 = ((Float)0.);
HXDLIN( 139)							Float txx2 = ((Float)0.);
HXDLIN( 139)							{
HXLINE( 139)								int _g_min2 = xIter32->start;
HXDLIN( 139)								int _g_max2 = xIter32->max;
HXDLIN( 139)								while((_g_min2 < _g_max2)){
HXLINE( 139)									_g_min2 = (_g_min2 + 1);
HXDLIN( 139)									int x = (_g_min2 - 1);
HXLINE( 223)									sxx2 = (sx2 * ( (Float)(x) ));
HXLINE( 224)									txx2 = (tx2 * ( (Float)(x) ));
HXLINE( 225)									foundY2 = false;
HXLINE( 139)									{
HXLINE( 139)										int _g_min = yIter32->start;
HXDLIN( 139)										int _g_max = yIter32->max;
HXDLIN( 139)										while((_g_min < _g_max)){
HXLINE( 139)											_g_min = (_g_min + 1);
HXDLIN( 139)											int y = (_g_min - 1);
HXLINE( 227)											s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE( 228)											t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE( 139)											bool _hx_tmp;
HXDLIN( 139)											if (!((s2 <= 0))) {
HXLINE( 139)												_hx_tmp = (t2 <= 0);
            											}
            											else {
HXLINE( 139)												_hx_tmp = true;
            											}
HXDLIN( 139)											if (_hx_tmp) {
HXLINE( 139)												if (foundY2) {
HXLINE( 139)													goto _hx_goto_75;
            												}
            											}
            											else {
HXLINE( 139)												if (((s2 + t2) < A2)) {
HXLINE( 139)													int x1 = ::hx::Mod(x,tileImage1->width);
HXDLIN( 139)													int y1 = ::hx::Mod(y,tileImage1->height);
HXDLIN( 139)													::haxe::io::ArrayBufferViewImpl this1 = tileImage1->image;
HXDLIN( 139)													int index;
HXDLIN( 139)													if (tileImage1->useVirtualPos) {
HXLINE( 139)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage1->virtualY) * ( (Float)(tileImage1->width) )) + x1) - tileImage1->virtualX));
            													}
            													else {
HXLINE( 139)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage1->width) + x1)) ));
            													}
HXDLIN( 139)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)													int color;
HXDLIN( 139)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 139)														color = c;
            													}
HXDLIN( 139)													{
HXLINE( 139)														int this2 = color;
HXDLIN( 139)														int c1 = this2;
HXDLIN( 139)														bool _hx_tmp;
HXDLIN( 139)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 139)															_hx_tmp = temp->transparent;
            														}
            														else {
HXLINE( 139)															_hx_tmp = false;
            														}
HXDLIN( 139)														if (_hx_tmp) {
HXLINE( 139)															int location;
HXDLIN( 139)															if (temp->useVirtualPos) {
HXLINE( 139)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE( 139)																location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN( 139)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 139)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)															int this3 = this2;
HXDLIN( 139)															int this4;
HXDLIN( 139)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE( 139)																this4 = this3;
            															}
HXDLIN( 139)															Float a1;
HXDLIN( 139)															int this5 = ((this4 >> 24) & 255);
HXDLIN( 139)															if ((this5 == 0)) {
HXLINE( 139)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float r1;
HXDLIN( 139)															int this6 = ((this4 >> 16) & 255);
HXDLIN( 139)															if ((this6 == 0)) {
HXLINE( 139)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float g1;
HXDLIN( 139)															int this7 = ((this4 >> 8) & 255);
HXDLIN( 139)															if ((this7 == 0)) {
HXLINE( 139)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float b1;
HXDLIN( 139)															int this8 = (this4 & 255);
HXDLIN( 139)															if ((this8 == 0)) {
HXLINE( 139)																b1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float a2;
HXDLIN( 139)															int this9 = ((color >> 24) & 255);
HXDLIN( 139)															if ((this9 == 0)) {
HXLINE( 139)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float r2;
HXDLIN( 139)															int this10 = ((color >> 16) & 255);
HXDLIN( 139)															if ((this10 == 0)) {
HXLINE( 139)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float g2;
HXDLIN( 139)															int this11 = ((color >> 8) & 255);
HXDLIN( 139)															if ((this11 == 0)) {
HXLINE( 139)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float b2;
HXDLIN( 139)															int this12 = (color & 255);
HXDLIN( 139)															if ((this12 == 0)) {
HXLINE( 139)																b2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 139)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 139)															{
HXLINE( 139)																::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 139)																int value;
HXDLIN( 139)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 139)																	value = blended;
            																}
HXDLIN( 139)																bool _hx_tmp;
HXDLIN( 139)																if ((location >= 0)) {
HXLINE( 139)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE( 139)																	_hx_tmp = false;
            																}
HXDLIN( 139)																if (_hx_tmp) {
HXLINE( 139)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 139)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 139)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 139)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)															int index;
HXDLIN( 139)															if (temp->useVirtualPos) {
HXLINE( 139)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE( 139)																index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN( 139)															int value;
HXDLIN( 139)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE( 139)																value = c1;
            															}
HXDLIN( 139)															bool _hx_tmp;
HXDLIN( 139)															if ((index >= 0)) {
HXLINE( 139)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 139)																_hx_tmp = false;
            															}
HXDLIN( 139)															if (_hx_tmp) {
HXLINE( 139)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY2 = true;
            												}
            												else {
HXLINE( 139)													if (foundY2) {
HXLINE( 139)														goto _hx_goto_75;
            													}
            												}
            											}
            										}
            										_hx_goto_75:;
            									}
            								}
            							}
HXDLIN( 139)							if ((hasHit1 == false)) {
HXLINE( 139)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax2,ay2,bx5,by5,cx5,cy5,true);
HXDLIN( 139)								if (hasUndo2) {
HXLINE( 139)									v->undoImage = undoImage2;
HXDLIN( 139)									v->undoX = xIter32->start;
HXDLIN( 139)									v->undoY = yIter32->start;
            								}
            							}
            						}
            					}
HXDLIN( 139)					{
HXLINE( 139)						Float bx6 = cx4;
HXDLIN( 139)						Float by6 = cy4;
HXDLIN( 139)						Float cx6 = dx1;
HXDLIN( 139)						Float cy6 = dy1;
HXDLIN( 139)						bool adjustWinding3 = (((((bx4 * by6) - (bx6 * by4)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * by4) - (bx4 * cy6))) > 0);
HXDLIN( 139)						if (!(adjustWinding3)) {
HXLINE( 139)							Float bx_ = bx6;
HXDLIN( 139)							Float by_ = by6;
HXLINE( 188)							bx6 = cx6;
HXLINE( 189)							by6 = cy6;
HXLINE( 190)							cx6 = bx_;
HXLINE( 191)							cy6 = by_;
            						}
HXLINE( 139)						{
HXLINE( 139)							bool hasUndo3 = false;
HXDLIN( 139)							Float s03 = ((by4 * cx6) - (bx4 * cy6));
HXDLIN( 139)							Float sx3 = (cy6 - by4);
HXDLIN( 139)							Float sy3 = (bx4 - cx6);
HXDLIN( 139)							Float t03 = ((bx4 * by6) - (by4 * bx6));
HXDLIN( 139)							Float tx3 = (by4 - by6);
HXDLIN( 139)							Float ty3 = (bx6 - bx4);
HXDLIN( 139)							Float A3 = ((((-(by6) * cx6) + (by4 * (-(bx6) + cx6))) + (bx4 * (by6 - cy6))) + (bx6 * cy6));
HXDLIN( 139)							::pixelimage::iter::IntIterStart xIter33;
HXDLIN( 139)							if ((bx4 > bx6)) {
HXLINE( 139)								if ((bx4 > cx6)) {
HXLINE( 139)									int min;
HXDLIN( 139)									if ((bx6 > cx6)) {
HXLINE( 139)										min = ::Math_obj::floor(cx6);
            									}
            									else {
HXLINE( 139)										min = ::Math_obj::floor(bx6);
            									}
HXDLIN( 139)									int ii_min = min;
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(bx4);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									xIter33 = this1;
            								}
            								else {
HXLINE( 139)									int ii_min = ::Math_obj::floor(bx6);
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(cx6);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									xIter33 = this1;
            								}
            							}
            							else {
HXLINE( 139)								if ((bx6 > cx6)) {
HXLINE( 139)									int min;
HXDLIN( 139)									if ((bx4 > cx6)) {
HXLINE( 139)										min = ::Math_obj::floor(cx6);
            									}
            									else {
HXLINE( 139)										min = ::Math_obj::ceil(bx4);
            									}
HXDLIN( 139)									int ii_min = min;
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(bx6);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									xIter33 = this1;
            								}
            								else {
HXLINE( 139)									int ii_min = ::Math_obj::floor(bx4);
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(cx6);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									xIter33 = this1;
            								}
            							}
HXDLIN( 139)							::pixelimage::iter::IntIterStart yIter33;
HXDLIN( 139)							if ((by4 > by6)) {
HXLINE( 139)								if ((by4 > cy6)) {
HXLINE( 139)									int min;
HXDLIN( 139)									if ((by6 > cy6)) {
HXLINE( 139)										min = ::Math_obj::floor(cy6);
            									}
            									else {
HXLINE( 139)										min = ::Math_obj::floor(by6);
            									}
HXDLIN( 139)									int ii_min = min;
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(by4);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									yIter33 = this1;
            								}
            								else {
HXLINE( 139)									int ii_min = ::Math_obj::floor(by6);
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(cy6);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									yIter33 = this1;
            								}
            							}
            							else {
HXLINE( 139)								if ((by6 > cy6)) {
HXLINE( 139)									int min;
HXDLIN( 139)									if ((by4 > cy6)) {
HXLINE( 139)										min = ::Math_obj::floor(cy6);
            									}
            									else {
HXLINE( 139)										min = ::Math_obj::ceil(by4);
            									}
HXDLIN( 139)									int ii_min = min;
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(by6);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									yIter33 = this1;
            								}
            								else {
HXLINE( 139)									int ii_min = ::Math_obj::floor(by4);
HXDLIN( 139)									int ii_max = ::Math_obj::ceil(cy6);
HXDLIN( 139)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 139)									yIter33 = this1;
            								}
            							}
HXDLIN( 139)							::pixelimage::ImageStruct undoImage3 = null();
HXDLIN( 139)							if (hasUndo3) {
HXLINE( 139)								int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 139)								int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 139)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 139)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 139)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 139)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 139)								undoImage3 = this3;
HXDLIN( 139)								{
HXLINE( 139)									int rectLeft = xIter33->start;
HXDLIN( 139)									int rectTop = yIter33->start;
HXDLIN( 139)									int rectRight = xIter33->max;
HXDLIN( 139)									bool forceClear = false;
HXDLIN( 139)									{
HXLINE( 139)										int _g = rectTop;
HXDLIN( 139)										int _g1 = yIter33->max;
HXDLIN( 139)										while((_g < _g1)){
HXLINE( 139)											_g = (_g + 1);
HXDLIN( 139)											int dy = (_g - 1);
HXDLIN( 139)											{
HXLINE( 139)												int _g1 = rectLeft;
HXDLIN( 139)												int _g2 = rectRight;
HXDLIN( 139)												while((_g1 < _g2)){
HXLINE( 139)													_g1 = (_g1 + 1);
HXDLIN( 139)													int dx = (_g1 - 1);
HXDLIN( 139)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)													int index;
HXDLIN( 139)													if (temp->useVirtualPos) {
HXLINE( 139)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            													}
            													else {
HXLINE( 139)														index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            													}
HXDLIN( 139)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)													int col;
HXDLIN( 139)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 139)														col = c;
            													}
HXDLIN( 139)													bool _hx_tmp;
HXDLIN( 139)													if (temp->useMask) {
HXLINE( 139)														_hx_tmp = ::hx::IsNotNull( temp->mask );
            													}
            													else {
HXLINE( 139)														_hx_tmp = false;
            													}
HXDLIN( 139)													if (_hx_tmp) {
HXLINE( 139)														::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 139)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 139)														int index;
HXDLIN( 139)														if (this1->useVirtualPos) {
HXLINE( 139)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE( 139)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN( 139)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 139)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 139)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)														int v;
HXDLIN( 139)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 139)															v = c;
            														}
HXDLIN( 139)														int this3 = v;
HXDLIN( 139)														int maskPixel = this3;
HXDLIN( 139)														int this4 = col;
HXDLIN( 139)														int this5 = this4;
HXDLIN( 139)														if ((maskPixel == 0)) {
HXLINE( 139)															int this1 = this5;
HXDLIN( 139)															col = this1;
            														}
            														else {
HXLINE( 139)															Float m0;
HXDLIN( 139)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 139)															if ((this1 == 0)) {
HXLINE( 139)																m0 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float m1;
HXDLIN( 139)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 139)															if ((this2 == 0)) {
HXLINE( 139)																m1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float m2;
HXDLIN( 139)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 139)															if ((this3 == 0)) {
HXLINE( 139)																m2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float m3;
HXDLIN( 139)															int this4 = (maskPixel & 255);
HXDLIN( 139)															if ((this4 == 0)) {
HXLINE( 139)																m3 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 139)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 139)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 139)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 139)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 139)													if ((col != 0)) {
HXLINE( 139)														int x = (dx - rectLeft);
HXDLIN( 139)														int y = (dy - rectTop);
HXDLIN( 139)														int this1 = col;
HXDLIN( 139)														int c = this1;
HXDLIN( 139)														bool _hx_tmp;
HXDLIN( 139)														if ((((c >> 24) & 255) < 254)) {
HXLINE( 139)															_hx_tmp = undoImage3->transparent;
            														}
            														else {
HXLINE( 139)															_hx_tmp = false;
            														}
HXDLIN( 139)														if (_hx_tmp) {
HXLINE( 139)															int location;
HXDLIN( 139)															if (undoImage3->useVirtualPos) {
HXLINE( 139)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 139)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN( 139)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 139)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 139)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)															int this3 = this2;
HXDLIN( 139)															int this4;
HXDLIN( 139)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE( 139)																this4 = this3;
            															}
HXDLIN( 139)															Float a1;
HXDLIN( 139)															int this5 = ((this4 >> 24) & 255);
HXDLIN( 139)															if ((this5 == 0)) {
HXLINE( 139)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float r1;
HXDLIN( 139)															int this6 = ((this4 >> 16) & 255);
HXDLIN( 139)															if ((this6 == 0)) {
HXLINE( 139)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float g1;
HXDLIN( 139)															int this7 = ((this4 >> 8) & 255);
HXDLIN( 139)															if ((this7 == 0)) {
HXLINE( 139)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float b1;
HXDLIN( 139)															int this8 = (this4 & 255);
HXDLIN( 139)															if ((this8 == 0)) {
HXLINE( 139)																b1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float a2;
HXDLIN( 139)															int this9 = ((col >> 24) & 255);
HXDLIN( 139)															if ((this9 == 0)) {
HXLINE( 139)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float r2;
HXDLIN( 139)															int this10 = ((col >> 16) & 255);
HXDLIN( 139)															if ((this10 == 0)) {
HXLINE( 139)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float g2;
HXDLIN( 139)															int this11 = ((col >> 8) & 255);
HXDLIN( 139)															if ((this11 == 0)) {
HXLINE( 139)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float b2;
HXDLIN( 139)															int this12 = (col & 255);
HXDLIN( 139)															if ((this12 == 0)) {
HXLINE( 139)																b2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 139)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 139)															{
HXLINE( 139)																::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN( 139)																int value;
HXDLIN( 139)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 139)																	value = blended;
            																}
HXDLIN( 139)																bool _hx_tmp;
HXDLIN( 139)																if ((location >= 0)) {
HXLINE( 139)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE( 139)																	_hx_tmp = false;
            																}
HXDLIN( 139)																if (_hx_tmp) {
HXLINE( 139)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 139)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 139)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 139)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 139)															int index;
HXDLIN( 139)															if (undoImage3->useVirtualPos) {
HXLINE( 139)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 139)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN( 139)															int value;
HXDLIN( 139)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE( 139)																value = c;
            															}
HXDLIN( 139)															bool _hx_tmp;
HXDLIN( 139)															if ((index >= 0)) {
HXLINE( 139)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 139)																_hx_tmp = false;
            															}
HXDLIN( 139)															if (_hx_tmp) {
HXLINE( 139)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 139)														if (forceClear) {
HXLINE( 139)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 139)															int x = (dx - rectLeft);
HXDLIN( 139)															int y = (dy - rectTop);
HXDLIN( 139)															int index;
HXDLIN( 139)															if (undoImage3->useVirtualPos) {
HXLINE( 139)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 139)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN( 139)															bool _hx_tmp;
HXDLIN( 139)															if ((index >= 0)) {
HXLINE( 139)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 139)																_hx_tmp = false;
            															}
HXDLIN( 139)															if (_hx_tmp) {
HXLINE( 139)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 139)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 139)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 139)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 139)							bool foundY3 = false;
HXDLIN( 139)							Float s3 = ((Float)0.);
HXDLIN( 139)							Float t3 = ((Float)0.);
HXDLIN( 139)							Float sxx3 = ((Float)0.);
HXDLIN( 139)							Float txx3 = ((Float)0.);
HXDLIN( 139)							{
HXLINE( 139)								int _g_min3 = xIter33->start;
HXDLIN( 139)								int _g_max3 = xIter33->max;
HXDLIN( 139)								while((_g_min3 < _g_max3)){
HXLINE( 139)									_g_min3 = (_g_min3 + 1);
HXDLIN( 139)									int x = (_g_min3 - 1);
HXLINE( 223)									sxx3 = (sx3 * ( (Float)(x) ));
HXLINE( 224)									txx3 = (tx3 * ( (Float)(x) ));
HXLINE( 225)									foundY3 = false;
HXLINE( 139)									{
HXLINE( 139)										int _g_min = yIter33->start;
HXDLIN( 139)										int _g_max = yIter33->max;
HXDLIN( 139)										while((_g_min < _g_max)){
HXLINE( 139)											_g_min = (_g_min + 1);
HXDLIN( 139)											int y = (_g_min - 1);
HXLINE( 227)											s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE( 228)											t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE( 139)											bool _hx_tmp;
HXDLIN( 139)											if (!((s3 <= 0))) {
HXLINE( 139)												_hx_tmp = (t3 <= 0);
            											}
            											else {
HXLINE( 139)												_hx_tmp = true;
            											}
HXDLIN( 139)											if (_hx_tmp) {
HXLINE( 139)												if (foundY3) {
HXLINE( 139)													goto _hx_goto_79;
            												}
            											}
            											else {
HXLINE( 139)												if (((s3 + t3) < A3)) {
HXLINE( 139)													int x1 = ::hx::Mod(x,tileImage1->width);
HXDLIN( 139)													int y1 = ::hx::Mod(y,tileImage1->height);
HXDLIN( 139)													::haxe::io::ArrayBufferViewImpl this1 = tileImage1->image;
HXDLIN( 139)													int index;
HXDLIN( 139)													if (tileImage1->useVirtualPos) {
HXLINE( 139)														index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage1->virtualY) * ( (Float)(tileImage1->width) )) + x1) - tileImage1->virtualX));
            													}
            													else {
HXLINE( 139)														index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage1->width) + x1)) ));
            													}
HXDLIN( 139)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)													int color;
HXDLIN( 139)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)														color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 139)														color = c;
            													}
HXDLIN( 139)													{
HXLINE( 139)														int this2 = color;
HXDLIN( 139)														int c1 = this2;
HXDLIN( 139)														bool _hx_tmp;
HXDLIN( 139)														if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 139)															_hx_tmp = temp->transparent;
            														}
            														else {
HXLINE( 139)															_hx_tmp = false;
            														}
HXDLIN( 139)														if (_hx_tmp) {
HXLINE( 139)															int location;
HXDLIN( 139)															if (temp->useVirtualPos) {
HXLINE( 139)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE( 139)																location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN( 139)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 139)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 139)															int this3 = this2;
HXDLIN( 139)															int this4;
HXDLIN( 139)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE( 139)																this4 = this3;
            															}
HXDLIN( 139)															Float a1;
HXDLIN( 139)															int this5 = ((this4 >> 24) & 255);
HXDLIN( 139)															if ((this5 == 0)) {
HXLINE( 139)																a1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float r1;
HXDLIN( 139)															int this6 = ((this4 >> 16) & 255);
HXDLIN( 139)															if ((this6 == 0)) {
HXLINE( 139)																r1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float g1;
HXDLIN( 139)															int this7 = ((this4 >> 8) & 255);
HXDLIN( 139)															if ((this7 == 0)) {
HXLINE( 139)																g1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float b1;
HXDLIN( 139)															int this8 = (this4 & 255);
HXDLIN( 139)															if ((this8 == 0)) {
HXLINE( 139)																b1 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float a2;
HXDLIN( 139)															int this9 = ((color >> 24) & 255);
HXDLIN( 139)															if ((this9 == 0)) {
HXLINE( 139)																a2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float r2;
HXDLIN( 139)															int this10 = ((color >> 16) & 255);
HXDLIN( 139)															if ((this10 == 0)) {
HXLINE( 139)																r2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float g2;
HXDLIN( 139)															int this11 = ((color >> 8) & 255);
HXDLIN( 139)															if ((this11 == 0)) {
HXLINE( 139)																g2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float b2;
HXDLIN( 139)															int this12 = (color & 255);
HXDLIN( 139)															if ((this12 == 0)) {
HXLINE( 139)																b2 = ((Float)0.);
            															}
            															else {
HXLINE( 139)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN( 139)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 139)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 139)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 139)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 139)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 139)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 139)															{
HXLINE( 139)																::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 139)																int value;
HXDLIN( 139)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE( 139)																	value = blended;
            																}
HXDLIN( 139)																bool _hx_tmp;
HXDLIN( 139)																if ((location >= 0)) {
HXLINE( 139)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE( 139)																	_hx_tmp = false;
            																}
HXDLIN( 139)																if (_hx_tmp) {
HXLINE( 139)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 139)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 139)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE( 139)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 139)															int index;
HXDLIN( 139)															if (temp->useVirtualPos) {
HXLINE( 139)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            															}
            															else {
HXLINE( 139)																index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            															}
HXDLIN( 139)															int value;
HXDLIN( 139)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 139)																value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE( 139)																value = c1;
            															}
HXDLIN( 139)															bool _hx_tmp;
HXDLIN( 139)															if ((index >= 0)) {
HXLINE( 139)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE( 139)																_hx_tmp = false;
            															}
HXDLIN( 139)															if (_hx_tmp) {
HXLINE( 139)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 139)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 139)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 139)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 139)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 139)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 237)													foundY3 = true;
            												}
            												else {
HXLINE( 139)													if (foundY3) {
HXLINE( 139)														goto _hx_goto_79;
            													}
            												}
            											}
            										}
            										_hx_goto_79:;
            									}
            								}
            							}
HXDLIN( 139)							if ((hasHit1 == false)) {
HXLINE( 139)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx4,by4,bx6,by6,cx6,cy6,true);
HXDLIN( 139)								if (hasUndo3) {
HXLINE( 139)									v->undoImage = undoImage3;
HXDLIN( 139)									v->undoX = xIter33->start;
HXDLIN( 139)									v->undoY = yIter33->start;
            								}
            							}
            						}
            					}
HXDLIN( 139)					if ((hasHit1 == true)) {
HXLINE( 139)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax2,ay2,bx4,by4,cx4,cy4,dx1,dy1,true);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ArcPattern_obj,pie,(void))


::hx::ObjectPtr< ArcPattern_obj > ArcPattern_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_startAngle,::hx::Null< Float >  __o_sweepAngle,::String __o_arcType) {
	::hx::ObjectPtr< ArcPattern_obj > __this = new ArcPattern_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale,__o_left,__o_top,__o_width,__o_height,__o_startAngle,__o_sweepAngle,__o_arcType);
	return __this;
}

::hx::ObjectPtr< ArcPattern_obj > ArcPattern_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_startAngle,::hx::Null< Float >  __o_sweepAngle,::String __o_arcType) {
	ArcPattern_obj *__this = (ArcPattern_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ArcPattern_obj), true, "pixelimage.triangleGML.patternShape.ArcPattern"));
	*(void **)__this = ArcPattern_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale,__o_left,__o_top,__o_width,__o_height,__o_startAngle,__o_sweepAngle,__o_arcType);
	return __this;
}

ArcPattern_obj::ArcPattern_obj()
{
}

void ArcPattern_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ArcPattern);
	HX_MARK_MEMBER_NAME(left,"left");
	HX_MARK_MEMBER_NAME(top,"top");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(startAngle,"startAngle");
	HX_MARK_MEMBER_NAME(sweepAngle,"sweepAngle");
	HX_MARK_MEMBER_NAME(arcType,"arcType");
	HX_MARK_MEMBER_NAME(rx,"rx");
	HX_MARK_MEMBER_NAME(ry,"ry");
	::pixelimage::triangleGML::coreShape::PatternShape_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ArcPattern_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(left,"left");
	HX_VISIT_MEMBER_NAME(top,"top");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(startAngle,"startAngle");
	HX_VISIT_MEMBER_NAME(sweepAngle,"sweepAngle");
	HX_VISIT_MEMBER_NAME(arcType,"arcType");
	HX_VISIT_MEMBER_NAME(rx,"rx");
	HX_VISIT_MEMBER_NAME(ry,"ry");
	::pixelimage::triangleGML::coreShape::PatternShape_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val ArcPattern_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"rx") ) { return ::hx::Val( rx ); }
		if (HX_FIELD_EQ(inName,"ry") ) { return ::hx::Val( ry ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { return ::hx::Val( top ); }
		if (HX_FIELD_EQ(inName,"pie") ) { return ::hx::Val( pie_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { return ::hx::Val( left ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"chord") ) { return ::hx::Val( chord_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"arcType") ) { return ::hx::Val( arcType ); }
		if (HX_FIELD_EQ(inName,"ellipse") ) { return ::hx::Val( ellipse_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"startAngle") ) { return ::hx::Val( startAngle ); }
		if (HX_FIELD_EQ(inName,"sweepAngle") ) { return ::hx::Val( sweepAngle ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ArcPattern_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"rx") ) { rx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ry") ) { ry=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { top=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { left=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"arcType") ) { arcType=inValue.Cast< ::String >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"startAngle") ) { startAngle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sweepAngle") ) { sweepAngle=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ArcPattern_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("left",07,08,b0,47));
	outFields->push(HX_("top",95,66,58,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("startAngle",11,1c,f9,3e));
	outFields->push(HX_("sweepAngle",47,a6,92,e6));
	outFields->push(HX_("arcType",2c,ae,de,8e));
	outFields->push(HX_("rx",c6,63,00,00));
	outFields->push(HX_("ry",c7,63,00,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ArcPattern_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(ArcPattern_obj,left),HX_("left",07,08,b0,47)},
	{::hx::fsFloat,(int)offsetof(ArcPattern_obj,top),HX_("top",95,66,58,00)},
	{::hx::fsFloat,(int)offsetof(ArcPattern_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsFloat,(int)offsetof(ArcPattern_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsFloat,(int)offsetof(ArcPattern_obj,startAngle),HX_("startAngle",11,1c,f9,3e)},
	{::hx::fsFloat,(int)offsetof(ArcPattern_obj,sweepAngle),HX_("sweepAngle",47,a6,92,e6)},
	{::hx::fsString,(int)offsetof(ArcPattern_obj,arcType),HX_("arcType",2c,ae,de,8e)},
	{::hx::fsFloat,(int)offsetof(ArcPattern_obj,rx),HX_("rx",c6,63,00,00)},
	{::hx::fsFloat,(int)offsetof(ArcPattern_obj,ry),HX_("ry",c7,63,00,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ArcPattern_obj_sStaticStorageInfo = 0;
#endif

static ::String ArcPattern_obj_sMemberFields[] = {
	HX_("left",07,08,b0,47),
	HX_("top",95,66,58,00),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("startAngle",11,1c,f9,3e),
	HX_("sweepAngle",47,a6,92,e6),
	HX_("arcType",2c,ae,de,8e),
	HX_("rx",c6,63,00,00),
	HX_("ry",c7,63,00,00),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	HX_("chord",5c,3c,be,45),
	HX_("ellipse",de,40,86,0b),
	HX_("pie",4c,58,55,00),
	::String(null()) };

::hx::Class ArcPattern_obj::__mClass;

void ArcPattern_obj::__register()
{
	ArcPattern_obj _hx_dummy;
	ArcPattern_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.patternShape.ArcPattern",32,58,7e,41);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ArcPattern_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ArcPattern_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ArcPattern_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ArcPattern_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace patternShape
