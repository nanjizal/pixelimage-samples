// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_PatternShape
#include <pixelimage/triangleGML/coreShape/PatternShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_patternShape_CirclePattern
#include <pixelimage/triangleGML/patternShape/CirclePattern.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fecc67401f7310c1_37_new,"pixelimage.triangleGML.patternShape.CirclePattern","new",0x334d9f7e,"pixelimage.triangleGML.patternShape.CirclePattern.new","pixelimage/triangleGML/patternShape/CirclePattern.hx",37,0xd421c0f1)
HX_LOCAL_STACK_FRAME(_hx_pos_fecc67401f7310c1_47_setParameter,"pixelimage.triangleGML.patternShape.CirclePattern","setParameter",0x528e52c9,"pixelimage.triangleGML.patternShape.CirclePattern.setParameter","pixelimage/triangleGML/patternShape/CirclePattern.hx",47,0xd421c0f1)
HX_LOCAL_STACK_FRAME(_hx_pos_fecc67401f7310c1_58_render,"pixelimage.triangleGML.patternShape.CirclePattern","render",0x1acf62f8,"pixelimage.triangleGML.patternShape.CirclePattern.render","pixelimage/triangleGML/patternShape/CirclePattern.hx",58,0xd421c0f1)
HX_LOCAL_STACK_FRAME(_hx_pos_fecc67401f7310c1_70_buildCircle,"pixelimage.triangleGML.patternShape.CirclePattern","buildCircle",0xe6a974fc,"pixelimage.triangleGML.patternShape.CirclePattern.buildCircle","pixelimage/triangleGML/patternShape/CirclePattern.hx",70,0xd421c0f1)
namespace pixelimage{
namespace triangleGML{
namespace patternShape{

void CirclePattern_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_diameter){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int strokeColor0 = __o_strokeColor0.Default(0);
            		int strokeColor1 = __o_strokeColor1.Default(0);
            		int fillColor0 = __o_fillColor0.Default(0);
            		int fillColor1 = __o_fillColor1.Default(0);
            		bool strokePatternAcross = __o_strokePatternAcross.Default(true);
            		int strokePatternScale = __o_strokePatternScale.Default(1);
            		int fillPatternWidth = __o_fillPatternWidth.Default(16);
            		int fillPatternHeight = __o_fillPatternHeight.Default(16);
            		bool fillPatternAcross = __o_fillPatternAcross.Default(true);
            		int fillPatternScale = __o_fillPatternScale.Default(1);
            		Float left = __o_left.Default(((Float)0.));
            		Float top = __o_top.Default(((Float)0.));
            		Float diameter = __o_diameter.Default(((Float)1.));
            	HX_STACKFRAME(&_hx_pos_fecc67401f7310c1_37_new)
HXLINE(  38)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,strokeColor0,strokeColor1,fillColor0,fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,strokePatternAcross,strokePatternScale,fillPatternFill,fillPatternWidth,fillPatternHeight,fillPatternAcross,fillPatternScale);
HXLINE(  42)		this->left = left;
HXLINE(  43)		this->top = top;
HXLINE(  44)		this->diameter = diameter;
            	}

Dynamic CirclePattern_obj::__CreateEmpty() { return new CirclePattern_obj; }

void *CirclePattern_obj::_hx_vtable = 0;

Dynamic CirclePattern_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< CirclePattern_obj > _hx_result = new CirclePattern_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14],inArgs[15],inArgs[16],inArgs[17],inArgs[18],inArgs[19],inArgs[20],inArgs[21]);
	return _hx_result;
}

bool CirclePattern_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2091632c) {
		if (inClassId<=(int)0x02c3e8ca) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x02c3e8ca;
		} else {
			return inClassId==(int)0x2091632c;
		}
	} else {
		return inClassId==(int)0x24e92cfb || inClassId==(int)0x6e596dee;
	}
}

void CirclePattern_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_fecc67401f7310c1_47_setParameter)
HXDLIN(  47)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("diameter",cd,6e,68,34)) ){
HXLINE(  53)			this->diameter = ::Std_obj::parseFloat(value);
HXDLIN(  53)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("left",07,08,b0,47)) ){
HXLINE(  49)			this->left = ::Std_obj::parseFloat(value);
HXDLIN(  49)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("top",95,66,58,00)) ){
HXLINE(  51)			this->top = ::Std_obj::parseFloat(value);
HXDLIN(  51)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  55)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct CirclePattern_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_fecc67401f7310c1_58_render)
HXLINE(  59)		int w = ::Math_obj::ceil(this->diameter);
HXDLIN(  59)		int h = ::Math_obj::ceil(this->diameter);
HXDLIN(  59)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  59)		::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  59)		::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  59)		::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  59)		::pixelimage::ImageStruct this4 = this3;
HXDLIN(  59)		::pixelimage::ImageStruct temp = this4;
HXLINE(  60)		temp->transparent = false;
HXLINE(  62)		this->buildPatternTemplates();
HXLINE(  63)		this->buildCircle(temp);
HXLINE(  65)		{
HXLINE(  65)			int x = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  65)			int y = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  65)			bool forceClear = false;
HXDLIN(  65)			{
HXLINE(  65)				int _g = 0;
HXDLIN(  65)				int _g1 = temp->height;
HXDLIN(  65)				while((_g < _g1)){
HXLINE(  65)					_g = (_g + 1);
HXDLIN(  65)					int dy = (_g - 1);
HXDLIN(  65)					{
HXLINE(  65)						int _g1 = 0;
HXDLIN(  65)						int _g2 = temp->width;
HXDLIN(  65)						while((_g1 < _g2)){
HXLINE(  65)							_g1 = (_g1 + 1);
HXDLIN(  65)							int dx = (_g1 - 1);
HXDLIN(  65)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  65)							int index;
HXDLIN(  65)							if (temp->useVirtualPos) {
HXLINE(  65)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  65)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  65)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)							int col;
HXDLIN(  65)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  65)								col = c;
            							}
HXDLIN(  65)							bool _hx_tmp;
HXDLIN(  65)							if (temp->useMask) {
HXLINE(  65)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  65)								_hx_tmp = false;
            							}
HXDLIN(  65)							if (_hx_tmp) {
HXLINE(  65)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  65)								int index;
HXDLIN(  65)								if (this1->useVirtualPos) {
HXLINE(  65)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  65)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  65)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  65)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  65)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)								int v;
HXDLIN(  65)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  65)									v = c;
            								}
HXDLIN(  65)								int this3 = v;
HXDLIN(  65)								int maskPixel = this3;
HXDLIN(  65)								int this4 = col;
HXDLIN(  65)								int this5 = this4;
HXDLIN(  65)								if ((maskPixel == 0)) {
HXLINE(  65)									int this1 = this5;
HXDLIN(  65)									col = this1;
            								}
            								else {
HXLINE(  65)									Float m0;
HXDLIN(  65)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  65)									if ((this1 == 0)) {
HXLINE(  65)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float m1;
HXDLIN(  65)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  65)									if ((this2 == 0)) {
HXLINE(  65)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float m2;
HXDLIN(  65)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  65)									if ((this3 == 0)) {
HXLINE(  65)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float m3;
HXDLIN(  65)									int this4 = (maskPixel & 255);
HXDLIN(  65)									if ((this4 == 0)) {
HXLINE(  65)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  65)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  65)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  65)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  65)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  65)							if ((col != 0)) {
HXLINE(  65)								int x1 = (x + dx);
HXDLIN(  65)								int y1 = (y + dy);
HXDLIN(  65)								int this1 = col;
HXDLIN(  65)								int c = this1;
HXDLIN(  65)								bool _hx_tmp;
HXDLIN(  65)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  65)									_hx_tmp = false;
            								}
HXDLIN(  65)								if (_hx_tmp) {
HXLINE(  65)									int location;
HXDLIN(  65)									if (pixelShape->useVirtualPos) {
HXLINE(  65)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  65)										location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  65)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)									int this3 = this2;
HXDLIN(  65)									int this4;
HXDLIN(  65)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  65)										this4 = this3;
            									}
HXDLIN(  65)									Float a1;
HXDLIN(  65)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)									if ((this5 == 0)) {
HXLINE(  65)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float r1;
HXDLIN(  65)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)									if ((this6 == 0)) {
HXLINE(  65)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float g1;
HXDLIN(  65)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)									if ((this7 == 0)) {
HXLINE(  65)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float b1;
HXDLIN(  65)									int this8 = (this4 & 255);
HXDLIN(  65)									if ((this8 == 0)) {
HXLINE(  65)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float a2;
HXDLIN(  65)									int this9 = ((col >> 24) & 255);
HXDLIN(  65)									if ((this9 == 0)) {
HXLINE(  65)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float r2;
HXDLIN(  65)									int this10 = ((col >> 16) & 255);
HXDLIN(  65)									if ((this10 == 0)) {
HXLINE(  65)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float g2;
HXDLIN(  65)									int this11 = ((col >> 8) & 255);
HXDLIN(  65)									if ((this11 == 0)) {
HXLINE(  65)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float b2;
HXDLIN(  65)									int this12 = (col & 255);
HXDLIN(  65)									if ((this12 == 0)) {
HXLINE(  65)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  65)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  65)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)									{
HXLINE(  65)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  65)										int value;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  65)											value = blended;
            										}
HXDLIN(  65)										bool _hx_tmp;
HXDLIN(  65)										if ((location >= 0)) {
HXLINE(  65)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  65)											_hx_tmp = false;
            										}
HXDLIN(  65)										if (_hx_tmp) {
HXLINE(  65)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  65)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)									int index;
HXDLIN(  65)									if (pixelShape->useVirtualPos) {
HXLINE(  65)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  65)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  65)									int value;
HXDLIN(  65)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  65)										value = c;
            									}
HXDLIN(  65)									bool _hx_tmp;
HXDLIN(  65)									if ((index >= 0)) {
HXLINE(  65)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  65)										_hx_tmp = false;
            									}
HXDLIN(  65)									if (_hx_tmp) {
HXLINE(  65)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  65)								if (forceClear) {
HXLINE(  65)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)									int x1 = (x + dx);
HXDLIN(  65)									int y1 = (y + dy);
HXDLIN(  65)									int index;
HXDLIN(  65)									if (pixelShape->useVirtualPos) {
HXLINE(  65)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  65)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  65)									bool _hx_tmp;
HXDLIN(  65)									if ((index >= 0)) {
HXLINE(  65)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  65)										_hx_tmp = false;
            									}
HXDLIN(  65)									if (_hx_tmp) {
HXLINE(  65)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  65)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  65)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  65)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  66)		temp = null();
HXLINE(  68)		return this->super::render(pixelShape);
            	}


void CirclePattern_obj::buildCircle(::pixelimage::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_fecc67401f7310c1_70_buildCircle)
HXLINE(  71)		int w = ::Math_obj::round((this->strokeWidth / ( (Float)(2) )));
HXLINE(  72)		Float r = (this->diameter / ( (Float)(2) ));
HXLINE(  73)		Float innerR = ((this->diameter / ( (Float)(2) )) - ( (Float)((4 * w)) ));
HXLINE(  74)		Float cx = (this->diameter / ( (Float)(2) ));
HXLINE(  75)		Float cy = (this->diameter / ( (Float)(2) ));
HXLINE(  76)		Float phi = ((Float)0.);
HXLINE(  77)		Float innerCx = (cx - (( (Float)(w) ) / ( (Float)(4) )));
HXLINE(  78)		Float innerCy = (cy - (( (Float)(w) ) / ( (Float)(4) )));
HXLINE(  79)		if (this->tiledBorder) {
HXLINE(  80)			::pixelimage::ImageStruct tileImage = this->tileImageStroke;
HXDLIN(  80)			 ::Dynamic phi1 = phi;
HXDLIN(  80)			if (::hx::IsNull( phi1 )) {
HXLINE(  80)				phi1 = 0;
            			}
HXDLIN(  80)			Float rSmall;
HXDLIN(  80)			if ((r > r)) {
HXLINE(  80)				rSmall = r;
            			}
            			else {
HXLINE(  80)				rSmall = r;
            			}
HXDLIN(  80)			 ::Dynamic targetE = ((Float)1.05);
HXDLIN(  80)			if (::hx::IsNull( targetE )) {
HXLINE( 710)				targetE = ((Float)1.05);
            			}
HXLINE(  80)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  80)			int noSides;
HXDLIN(  80)			if ((result < 12)) {
HXLINE(  80)				noSides = 12;
            			}
            			else {
HXLINE(  80)				if ((result > 500)) {
HXLINE(  80)					noSides = 500;
            				}
            				else {
HXLINE(  80)					noSides = result;
            				}
            			}
HXDLIN(  80)			{
HXLINE(  80)				 ::Dynamic phi2 = phi1;
HXDLIN(  80)				 ::Dynamic sides = noSides;
HXDLIN(  80)				if (::hx::IsNull( sides )) {
HXLINE( 712)					sides = 36;
            				}
HXLINE(  80)				if (::hx::IsNull( phi2 )) {
HXLINE( 712)					phi2 = ((Float)0.);
            				}
HXLINE(  80)				{
HXLINE(  80)					 ::Dynamic phi3 = phi2;
HXDLIN(  80)					 ::Dynamic sides1 = sides;
HXDLIN(  80)					if (::hx::IsNull( sides1 )) {
HXLINE( 887)						sides1 = 36;
            					}
HXLINE(  80)					if (::hx::IsNull( phi3 )) {
HXLINE( 887)						phi3 = ((Float)0.);
            					}
HXLINE(  80)					Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  80)					Float omega;
HXDLIN(  80)					omega = ((Float)0.);
HXDLIN(  80)					Float lastX = ((Float)0.);
HXDLIN(  80)					Float lastY = ((Float)0.);
HXDLIN(  80)					if (::hx::IsNotEq( phi3,0 )) {
HXLINE( 154)						lastX = ((((r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) ))) - ((r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) )))) + cx);
HXLINE( 155)						lastY = ((((r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) ))) + ((r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) )))) + cy);
            					}
            					else {
HXLINE( 157)						lastX = (cx + (r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE( 158)						lastY = (cy + (r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            					}
HXLINE(  80)					if (::hx::IsNotEq( phi3,0 )) {
HXLINE(  80)						Float cphi = ::Math_obj::cos(( (Float)(phi3) ));
HXDLIN(  80)						Float sphi = ::Math_obj::sin(( (Float)(phi3) ));
HXDLIN(  80)						{
HXLINE(  80)							int _g = 0;
HXDLIN(  80)							int _g1 = (sides1 + 1);
HXDLIN(  80)							while((_g < _g1)){
HXLINE(  80)								_g = (_g + 1);
HXDLIN(  80)								int i = (_g - 1);
HXDLIN(  80)								Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  80)								Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  80)								Float nextX = ((((r * ctheta) * cphi) - ((r * stheta) * sphi)) + cx);
HXDLIN(  80)								Float nextY = ((((r * ctheta) * sphi) + ((r * stheta) * cphi)) + cy);
HXDLIN(  80)								{
HXLINE(  80)									bool hasHit = false;
HXDLIN(  80)									{
HXLINE(  80)										Float bx = lastX;
HXDLIN(  80)										Float by = lastY;
HXDLIN(  80)										Float cx1 = nextX;
HXDLIN(  80)										Float cy1 = nextY;
HXDLIN(  80)										bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  80)										if (!(adjustWinding)) {
HXLINE(  80)											Float bx_ = bx;
HXDLIN(  80)											Float by_ = by;
HXLINE( 188)											bx = cx1;
HXLINE( 189)											by = cy1;
HXLINE( 190)											cx1 = bx_;
HXLINE( 191)											cy1 = by_;
            										}
HXLINE(  80)										{
HXLINE(  80)											bool hasUndo = false;
HXDLIN(  80)											Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  80)											Float sx = (cy1 - cy);
HXDLIN(  80)											Float sy = (cx - cx1);
HXDLIN(  80)											Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  80)											Float tx = (cy - by);
HXDLIN(  80)											Float ty = (bx - cx);
HXDLIN(  80)											Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  80)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  80)											if ((cx > bx)) {
HXLINE(  80)												if ((cx > cx1)) {
HXLINE(  80)													int min;
HXDLIN(  80)													if ((bx > cx1)) {
HXLINE(  80)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  80)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  80)													int ii_min = min;
HXDLIN(  80)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  80)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)													xIter3 = this1;
            												}
            												else {
HXLINE(  80)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  80)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  80)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  80)												if ((bx > cx1)) {
HXLINE(  80)													int min;
HXDLIN(  80)													if ((cx > cx1)) {
HXLINE(  80)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  80)														min = ::Math_obj::ceil(cx);
            													}
HXDLIN(  80)													int ii_min = min;
HXDLIN(  80)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  80)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)													xIter3 = this1;
            												}
            												else {
HXLINE(  80)													int ii_min = ::Math_obj::floor(cx);
HXDLIN(  80)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  80)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)													xIter3 = this1;
            												}
            											}
HXDLIN(  80)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  80)											if ((cy > by)) {
HXLINE(  80)												if ((cy > cy1)) {
HXLINE(  80)													int min;
HXDLIN(  80)													if ((by > cy1)) {
HXLINE(  80)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  80)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  80)													int ii_min = min;
HXDLIN(  80)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  80)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)													yIter3 = this1;
            												}
            												else {
HXLINE(  80)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  80)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  80)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  80)												if ((by > cy1)) {
HXLINE(  80)													int min;
HXDLIN(  80)													if ((cy > cy1)) {
HXLINE(  80)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  80)														min = ::Math_obj::ceil(cy);
            													}
HXDLIN(  80)													int ii_min = min;
HXDLIN(  80)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  80)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)													yIter3 = this1;
            												}
            												else {
HXLINE(  80)													int ii_min = ::Math_obj::floor(cy);
HXDLIN(  80)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  80)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)													yIter3 = this1;
            												}
            											}
HXDLIN(  80)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  80)											if (hasUndo) {
HXLINE(  80)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  80)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  80)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  80)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  80)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  80)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  80)												undoImage = this3;
HXDLIN(  80)												{
HXLINE(  80)													int rectLeft = xIter3->start;
HXDLIN(  80)													int rectTop = yIter3->start;
HXDLIN(  80)													int rectRight = xIter3->max;
HXDLIN(  80)													bool forceClear = false;
HXDLIN(  80)													{
HXLINE(  80)														int _g = rectTop;
HXDLIN(  80)														int _g1 = yIter3->max;
HXDLIN(  80)														while((_g < _g1)){
HXLINE(  80)															_g = (_g + 1);
HXDLIN(  80)															int dy = (_g - 1);
HXDLIN(  80)															{
HXLINE(  80)																int _g1 = rectLeft;
HXDLIN(  80)																int _g2 = rectRight;
HXDLIN(  80)																while((_g1 < _g2)){
HXLINE(  80)																	_g1 = (_g1 + 1);
HXDLIN(  80)																	int dx = (_g1 - 1);
HXDLIN(  80)																	::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  80)																	int index;
HXDLIN(  80)																	if (temp->useVirtualPos) {
HXLINE(  80)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            																	}
            																	else {
HXLINE(  80)																		index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            																	}
HXDLIN(  80)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																	int col;
HXDLIN(  80)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  80)																		col = c;
            																	}
HXDLIN(  80)																	bool _hx_tmp;
HXDLIN(  80)																	if (temp->useMask) {
HXLINE(  80)																		_hx_tmp = ::hx::IsNotNull( temp->mask );
            																	}
            																	else {
HXLINE(  80)																		_hx_tmp = false;
            																	}
HXDLIN(  80)																	if (_hx_tmp) {
HXLINE(  80)																		::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  80)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  80)																		int index;
HXDLIN(  80)																		if (this1->useVirtualPos) {
HXLINE(  80)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  80)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  80)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  80)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  80)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																		int v;
HXDLIN(  80)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  80)																			v = c;
            																		}
HXDLIN(  80)																		int this3 = v;
HXDLIN(  80)																		int maskPixel = this3;
HXDLIN(  80)																		int this4 = col;
HXDLIN(  80)																		int this5 = this4;
HXDLIN(  80)																		if ((maskPixel == 0)) {
HXLINE(  80)																			int this1 = this5;
HXDLIN(  80)																			col = this1;
            																		}
            																		else {
HXLINE(  80)																			Float m0;
HXDLIN(  80)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  80)																			if ((this1 == 0)) {
HXLINE(  80)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float m1;
HXDLIN(  80)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  80)																			if ((this2 == 0)) {
HXLINE(  80)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float m2;
HXDLIN(  80)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  80)																			if ((this3 == 0)) {
HXLINE(  80)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float m3;
HXDLIN(  80)																			int this4 = (maskPixel & 255);
HXDLIN(  80)																			if ((this4 == 0)) {
HXLINE(  80)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  80)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  80)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  80)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  80)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  80)																	if ((col != 0)) {
HXLINE(  80)																		int x = (dx - rectLeft);
HXDLIN(  80)																		int y = (dy - rectTop);
HXDLIN(  80)																		int this1 = col;
HXDLIN(  80)																		int c = this1;
HXDLIN(  80)																		bool _hx_tmp;
HXDLIN(  80)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  80)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  80)																			_hx_tmp = false;
            																		}
HXDLIN(  80)																		if (_hx_tmp) {
HXLINE(  80)																			int location;
HXDLIN(  80)																			if (undoImage->useVirtualPos) {
HXLINE(  80)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  80)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  80)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  80)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  80)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																			int this3 = this2;
HXDLIN(  80)																			int this4;
HXDLIN(  80)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  80)																				this4 = this3;
            																			}
HXDLIN(  80)																			Float a1;
HXDLIN(  80)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  80)																			if ((this5 == 0)) {
HXLINE(  80)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float r1;
HXDLIN(  80)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  80)																			if ((this6 == 0)) {
HXLINE(  80)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float g1;
HXDLIN(  80)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  80)																			if ((this7 == 0)) {
HXLINE(  80)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float b1;
HXDLIN(  80)																			int this8 = (this4 & 255);
HXDLIN(  80)																			if ((this8 == 0)) {
HXLINE(  80)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float a2;
HXDLIN(  80)																			int this9 = ((col >> 24) & 255);
HXDLIN(  80)																			if ((this9 == 0)) {
HXLINE(  80)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float r2;
HXDLIN(  80)																			int this10 = ((col >> 16) & 255);
HXDLIN(  80)																			if ((this10 == 0)) {
HXLINE(  80)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float g2;
HXDLIN(  80)																			int this11 = ((col >> 8) & 255);
HXDLIN(  80)																			if ((this11 == 0)) {
HXLINE(  80)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float b2;
HXDLIN(  80)																			int this12 = (col & 255);
HXDLIN(  80)																			if ((this12 == 0)) {
HXLINE(  80)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  80)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  80)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  80)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  80)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  80)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  80)																			{
HXLINE(  80)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  80)																				int value;
HXDLIN(  80)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  80)																					value = blended;
            																				}
HXDLIN(  80)																				bool _hx_tmp;
HXDLIN(  80)																				if ((location >= 0)) {
HXLINE(  80)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  80)																					_hx_tmp = false;
            																				}
HXDLIN(  80)																				if (_hx_tmp) {
HXLINE(  80)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  80)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  80)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  80)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  80)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  80)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  80)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  80)																			int index;
HXDLIN(  80)																			if (undoImage->useVirtualPos) {
HXLINE(  80)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  80)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  80)																			int value;
HXDLIN(  80)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  80)																				value = c;
            																			}
HXDLIN(  80)																			bool _hx_tmp;
HXDLIN(  80)																			if ((index >= 0)) {
HXLINE(  80)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  80)																				_hx_tmp = false;
            																			}
HXDLIN(  80)																			if (_hx_tmp) {
HXLINE(  80)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  80)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  80)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  80)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  80)																		if (forceClear) {
HXLINE(  80)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  80)																			int x = (dx - rectLeft);
HXDLIN(  80)																			int y = (dy - rectTop);
HXDLIN(  80)																			int index;
HXDLIN(  80)																			if (undoImage->useVirtualPos) {
HXLINE(  80)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  80)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  80)																			bool _hx_tmp;
HXDLIN(  80)																			if ((index >= 0)) {
HXLINE(  80)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  80)																				_hx_tmp = false;
            																			}
HXDLIN(  80)																			if (_hx_tmp) {
HXLINE(  80)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  80)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  80)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  80)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  80)											bool foundY = false;
HXDLIN(  80)											Float s = ((Float)0.);
HXDLIN(  80)											Float t = ((Float)0.);
HXDLIN(  80)											Float sxx = ((Float)0.);
HXDLIN(  80)											Float txx = ((Float)0.);
HXDLIN(  80)											{
HXLINE(  80)												int _g_min = xIter3->start;
HXDLIN(  80)												int _g_max = xIter3->max;
HXDLIN(  80)												while((_g_min < _g_max)){
HXLINE(  80)													_g_min = (_g_min + 1);
HXDLIN(  80)													int x = (_g_min - 1);
HXLINE( 223)													sxx = (sx * ( (Float)(x) ));
HXLINE( 224)													txx = (tx * ( (Float)(x) ));
HXLINE( 225)													foundY = false;
HXLINE(  80)													{
HXLINE(  80)														int _g_min1 = yIter3->start;
HXDLIN(  80)														int _g_max = yIter3->max;
HXDLIN(  80)														while((_g_min1 < _g_max)){
HXLINE(  80)															_g_min1 = (_g_min1 + 1);
HXDLIN(  80)															int y = (_g_min1 - 1);
HXLINE( 227)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  80)															bool _hx_tmp;
HXDLIN(  80)															if (!((s <= 0))) {
HXLINE(  80)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  80)																_hx_tmp = true;
            															}
HXDLIN(  80)															if (_hx_tmp) {
HXLINE(  80)																if (foundY) {
HXLINE(  80)																	goto _hx_goto_10;
            																}
            															}
            															else {
HXLINE(  80)																if (((s + t) < A)) {
HXLINE(  80)																	int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  80)																	int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  80)																	::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  80)																	int index;
HXDLIN(  80)																	if (tileImage->useVirtualPos) {
HXLINE(  80)																		index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																	}
            																	else {
HXLINE(  80)																		index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																	}
HXDLIN(  80)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																	int color;
HXDLIN(  80)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																		color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  80)																		color = c;
            																	}
HXDLIN(  80)																	{
HXLINE(  80)																		int this2 = color;
HXDLIN(  80)																		int c1 = this2;
HXDLIN(  80)																		bool _hx_tmp;
HXDLIN(  80)																		if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  80)																			_hx_tmp = temp->transparent;
            																		}
            																		else {
HXLINE(  80)																			_hx_tmp = false;
            																		}
HXDLIN(  80)																		if (_hx_tmp) {
HXLINE(  80)																			int location;
HXDLIN(  80)																			if (temp->useVirtualPos) {
HXLINE(  80)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																			}
            																			else {
HXLINE(  80)																				location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																			}
HXDLIN(  80)																			::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  80)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  80)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																			int this3 = this2;
HXDLIN(  80)																			int this4;
HXDLIN(  80)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  80)																				this4 = this3;
            																			}
HXDLIN(  80)																			Float a1;
HXDLIN(  80)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  80)																			if ((this5 == 0)) {
HXLINE(  80)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float r1;
HXDLIN(  80)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  80)																			if ((this6 == 0)) {
HXLINE(  80)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float g1;
HXDLIN(  80)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  80)																			if ((this7 == 0)) {
HXLINE(  80)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float b1;
HXDLIN(  80)																			int this8 = (this4 & 255);
HXDLIN(  80)																			if ((this8 == 0)) {
HXLINE(  80)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float a2;
HXDLIN(  80)																			int this9 = ((color >> 24) & 255);
HXDLIN(  80)																			if ((this9 == 0)) {
HXLINE(  80)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float r2;
HXDLIN(  80)																			int this10 = ((color >> 16) & 255);
HXDLIN(  80)																			if ((this10 == 0)) {
HXLINE(  80)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float g2;
HXDLIN(  80)																			int this11 = ((color >> 8) & 255);
HXDLIN(  80)																			if ((this11 == 0)) {
HXLINE(  80)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float b2;
HXDLIN(  80)																			int this12 = (color & 255);
HXDLIN(  80)																			if ((this12 == 0)) {
HXLINE(  80)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  80)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  80)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  80)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  80)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  80)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  80)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  80)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  80)																			{
HXLINE(  80)																				::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  80)																				int value;
HXDLIN(  80)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  80)																					value = blended;
            																				}
HXDLIN(  80)																				bool _hx_tmp;
HXDLIN(  80)																				if ((location >= 0)) {
HXLINE(  80)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  80)																					_hx_tmp = false;
            																				}
HXDLIN(  80)																				if (_hx_tmp) {
HXLINE(  80)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  80)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  80)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  80)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  80)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  80)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  80)																			::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  80)																			int index;
HXDLIN(  80)																			if (temp->useVirtualPos) {
HXLINE(  80)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																			}
            																			else {
HXLINE(  80)																				index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																			}
HXDLIN(  80)																			int value;
HXDLIN(  80)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																				value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																			}
            																			else {
HXLINE(  80)																				value = c1;
            																			}
HXDLIN(  80)																			bool _hx_tmp;
HXDLIN(  80)																			if ((index >= 0)) {
HXLINE(  80)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  80)																				_hx_tmp = false;
            																			}
HXDLIN(  80)																			if (_hx_tmp) {
HXLINE(  80)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  80)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  80)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  80)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE( 237)																	foundY = true;
            																}
            																else {
HXLINE(  80)																	if (foundY) {
HXLINE(  80)																		goto _hx_goto_10;
            																	}
            																}
            															}
            														}
            														_hx_goto_10:;
            													}
            												}
            											}
HXDLIN(  80)											if ((hasHit == false)) {
HXLINE(  80)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  80)												if (hasUndo) {
HXLINE(  80)													v->undoImage = undoImage;
HXDLIN(  80)													v->undoX = xIter3->start;
HXDLIN(  80)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE( 169)								lastX = nextX;
HXLINE( 170)								lastY = nextY;
            							}
            						}
            					}
            					else {
HXLINE(  80)						int _g = 0;
HXDLIN(  80)						int _g1 = (sides1 + 1);
HXDLIN(  80)						while((_g < _g1)){
HXLINE(  80)							_g = (_g + 1);
HXDLIN(  80)							int i = (_g - 1);
HXDLIN(  80)							Float nextX = (cx + (r * ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  80)							Float nextY = (cy + (r * ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  80)							{
HXLINE(  80)								bool hasHit = false;
HXDLIN(  80)								{
HXLINE(  80)									Float bx = lastX;
HXDLIN(  80)									Float by = lastY;
HXDLIN(  80)									Float cx1 = nextX;
HXDLIN(  80)									Float cy1 = nextY;
HXDLIN(  80)									bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  80)									if (!(adjustWinding)) {
HXLINE(  80)										Float bx_ = bx;
HXDLIN(  80)										Float by_ = by;
HXLINE( 188)										bx = cx1;
HXLINE( 189)										by = cy1;
HXLINE( 190)										cx1 = bx_;
HXLINE( 191)										cy1 = by_;
            									}
HXLINE(  80)									{
HXLINE(  80)										bool hasUndo = false;
HXDLIN(  80)										Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  80)										Float sx = (cy1 - cy);
HXDLIN(  80)										Float sy = (cx - cx1);
HXDLIN(  80)										Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  80)										Float tx = (cy - by);
HXDLIN(  80)										Float ty = (bx - cx);
HXDLIN(  80)										Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  80)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  80)										if ((cx > bx)) {
HXLINE(  80)											if ((cx > cx1)) {
HXLINE(  80)												int min;
HXDLIN(  80)												if ((bx > cx1)) {
HXLINE(  80)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  80)													min = ::Math_obj::floor(bx);
            												}
HXDLIN(  80)												int ii_min = min;
HXDLIN(  80)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  80)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)												xIter3 = this1;
            											}
            											else {
HXLINE(  80)												int ii_min = ::Math_obj::floor(bx);
HXDLIN(  80)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  80)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  80)											if ((bx > cx1)) {
HXLINE(  80)												int min;
HXDLIN(  80)												if ((cx > cx1)) {
HXLINE(  80)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  80)													min = ::Math_obj::ceil(cx);
            												}
HXDLIN(  80)												int ii_min = min;
HXDLIN(  80)												int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  80)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)												xIter3 = this1;
            											}
            											else {
HXLINE(  80)												int ii_min = ::Math_obj::floor(cx);
HXDLIN(  80)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  80)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)												xIter3 = this1;
            											}
            										}
HXDLIN(  80)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  80)										if ((cy > by)) {
HXLINE(  80)											if ((cy > cy1)) {
HXLINE(  80)												int min;
HXDLIN(  80)												if ((by > cy1)) {
HXLINE(  80)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  80)													min = ::Math_obj::floor(by);
            												}
HXDLIN(  80)												int ii_min = min;
HXDLIN(  80)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  80)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)												yIter3 = this1;
            											}
            											else {
HXLINE(  80)												int ii_min = ::Math_obj::floor(by);
HXDLIN(  80)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  80)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  80)											if ((by > cy1)) {
HXLINE(  80)												int min;
HXDLIN(  80)												if ((cy > cy1)) {
HXLINE(  80)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  80)													min = ::Math_obj::ceil(cy);
            												}
HXDLIN(  80)												int ii_min = min;
HXDLIN(  80)												int ii_max = ::Math_obj::ceil(by);
HXDLIN(  80)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)												yIter3 = this1;
            											}
            											else {
HXLINE(  80)												int ii_min = ::Math_obj::floor(cy);
HXDLIN(  80)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  80)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  80)												yIter3 = this1;
            											}
            										}
HXDLIN(  80)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  80)										if (hasUndo) {
HXLINE(  80)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  80)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  80)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  80)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  80)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  80)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  80)											undoImage = this3;
HXDLIN(  80)											{
HXLINE(  80)												int rectLeft = xIter3->start;
HXDLIN(  80)												int rectTop = yIter3->start;
HXDLIN(  80)												int rectRight = xIter3->max;
HXDLIN(  80)												bool forceClear = false;
HXDLIN(  80)												{
HXLINE(  80)													int _g = rectTop;
HXDLIN(  80)													int _g1 = yIter3->max;
HXDLIN(  80)													while((_g < _g1)){
HXLINE(  80)														_g = (_g + 1);
HXDLIN(  80)														int dy = (_g - 1);
HXDLIN(  80)														{
HXLINE(  80)															int _g1 = rectLeft;
HXDLIN(  80)															int _g2 = rectRight;
HXDLIN(  80)															while((_g1 < _g2)){
HXLINE(  80)																_g1 = (_g1 + 1);
HXDLIN(  80)																int dx = (_g1 - 1);
HXDLIN(  80)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  80)																int index;
HXDLIN(  80)																if (temp->useVirtualPos) {
HXLINE(  80)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            																}
            																else {
HXLINE(  80)																	index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            																}
HXDLIN(  80)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																int col;
HXDLIN(  80)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  80)																	col = c;
            																}
HXDLIN(  80)																bool _hx_tmp;
HXDLIN(  80)																if (temp->useMask) {
HXLINE(  80)																	_hx_tmp = ::hx::IsNotNull( temp->mask );
            																}
            																else {
HXLINE(  80)																	_hx_tmp = false;
            																}
HXDLIN(  80)																if (_hx_tmp) {
HXLINE(  80)																	::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  80)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  80)																	int index;
HXDLIN(  80)																	if (this1->useVirtualPos) {
HXLINE(  80)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  80)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  80)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  80)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  80)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																	int v;
HXDLIN(  80)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  80)																		v = c;
            																	}
HXDLIN(  80)																	int this3 = v;
HXDLIN(  80)																	int maskPixel = this3;
HXDLIN(  80)																	int this4 = col;
HXDLIN(  80)																	int this5 = this4;
HXDLIN(  80)																	if ((maskPixel == 0)) {
HXLINE(  80)																		int this1 = this5;
HXDLIN(  80)																		col = this1;
            																	}
            																	else {
HXLINE(  80)																		Float m0;
HXDLIN(  80)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  80)																		if ((this1 == 0)) {
HXLINE(  80)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float m1;
HXDLIN(  80)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  80)																		if ((this2 == 0)) {
HXLINE(  80)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float m2;
HXDLIN(  80)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  80)																		if ((this3 == 0)) {
HXLINE(  80)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float m3;
HXDLIN(  80)																		int this4 = (maskPixel & 255);
HXDLIN(  80)																		if ((this4 == 0)) {
HXLINE(  80)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  80)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  80)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  80)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  80)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  80)																if ((col != 0)) {
HXLINE(  80)																	int x = (dx - rectLeft);
HXDLIN(  80)																	int y = (dy - rectTop);
HXDLIN(  80)																	int this1 = col;
HXDLIN(  80)																	int c = this1;
HXDLIN(  80)																	bool _hx_tmp;
HXDLIN(  80)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  80)																		_hx_tmp = undoImage->transparent;
            																	}
            																	else {
HXLINE(  80)																		_hx_tmp = false;
            																	}
HXDLIN(  80)																	if (_hx_tmp) {
HXLINE(  80)																		int location;
HXDLIN(  80)																		if (undoImage->useVirtualPos) {
HXLINE(  80)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  80)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  80)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  80)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  80)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																		int this3 = this2;
HXDLIN(  80)																		int this4;
HXDLIN(  80)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  80)																			this4 = this3;
            																		}
HXDLIN(  80)																		Float a1;
HXDLIN(  80)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  80)																		if ((this5 == 0)) {
HXLINE(  80)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float r1;
HXDLIN(  80)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  80)																		if ((this6 == 0)) {
HXLINE(  80)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float g1;
HXDLIN(  80)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  80)																		if ((this7 == 0)) {
HXLINE(  80)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float b1;
HXDLIN(  80)																		int this8 = (this4 & 255);
HXDLIN(  80)																		if ((this8 == 0)) {
HXLINE(  80)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float a2;
HXDLIN(  80)																		int this9 = ((col >> 24) & 255);
HXDLIN(  80)																		if ((this9 == 0)) {
HXLINE(  80)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float r2;
HXDLIN(  80)																		int this10 = ((col >> 16) & 255);
HXDLIN(  80)																		if ((this10 == 0)) {
HXLINE(  80)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float g2;
HXDLIN(  80)																		int this11 = ((col >> 8) & 255);
HXDLIN(  80)																		if ((this11 == 0)) {
HXLINE(  80)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float b2;
HXDLIN(  80)																		int this12 = (col & 255);
HXDLIN(  80)																		if ((this12 == 0)) {
HXLINE(  80)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  80)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  80)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  80)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  80)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  80)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  80)																		{
HXLINE(  80)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  80)																			int value;
HXDLIN(  80)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  80)																				value = blended;
            																			}
HXDLIN(  80)																			bool _hx_tmp;
HXDLIN(  80)																			if ((location >= 0)) {
HXLINE(  80)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  80)																				_hx_tmp = false;
            																			}
HXDLIN(  80)																			if (_hx_tmp) {
HXLINE(  80)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  80)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  80)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  80)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  80)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  80)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  80)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  80)																		int index;
HXDLIN(  80)																		if (undoImage->useVirtualPos) {
HXLINE(  80)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  80)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  80)																		int value;
HXDLIN(  80)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  80)																			value = c;
            																		}
HXDLIN(  80)																		bool _hx_tmp;
HXDLIN(  80)																		if ((index >= 0)) {
HXLINE(  80)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  80)																			_hx_tmp = false;
            																		}
HXDLIN(  80)																		if (_hx_tmp) {
HXLINE(  80)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  80)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  80)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  80)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  80)																	if (forceClear) {
HXLINE(  80)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  80)																		int x = (dx - rectLeft);
HXDLIN(  80)																		int y = (dy - rectTop);
HXDLIN(  80)																		int index;
HXDLIN(  80)																		if (undoImage->useVirtualPos) {
HXLINE(  80)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  80)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  80)																		bool _hx_tmp;
HXDLIN(  80)																		if ((index >= 0)) {
HXLINE(  80)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  80)																			_hx_tmp = false;
            																		}
HXDLIN(  80)																		if (_hx_tmp) {
HXLINE(  80)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  80)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  80)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  80)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  80)										bool foundY = false;
HXDLIN(  80)										Float s = ((Float)0.);
HXDLIN(  80)										Float t = ((Float)0.);
HXDLIN(  80)										Float sxx = ((Float)0.);
HXDLIN(  80)										Float txx = ((Float)0.);
HXDLIN(  80)										{
HXLINE(  80)											int _g_min = xIter3->start;
HXDLIN(  80)											int _g_max = xIter3->max;
HXDLIN(  80)											while((_g_min < _g_max)){
HXLINE(  80)												_g_min = (_g_min + 1);
HXDLIN(  80)												int x = (_g_min - 1);
HXLINE( 223)												sxx = (sx * ( (Float)(x) ));
HXLINE( 224)												txx = (tx * ( (Float)(x) ));
HXLINE( 225)												foundY = false;
HXLINE(  80)												{
HXLINE(  80)													int _g_min1 = yIter3->start;
HXDLIN(  80)													int _g_max = yIter3->max;
HXDLIN(  80)													while((_g_min1 < _g_max)){
HXLINE(  80)														_g_min1 = (_g_min1 + 1);
HXDLIN(  80)														int y = (_g_min1 - 1);
HXLINE( 227)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  80)														bool _hx_tmp;
HXDLIN(  80)														if (!((s <= 0))) {
HXLINE(  80)															_hx_tmp = (t <= 0);
            														}
            														else {
HXLINE(  80)															_hx_tmp = true;
            														}
HXDLIN(  80)														if (_hx_tmp) {
HXLINE(  80)															if (foundY) {
HXLINE(  80)																goto _hx_goto_15;
            															}
            														}
            														else {
HXLINE(  80)															if (((s + t) < A)) {
HXLINE(  80)																int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  80)																int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  80)																::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  80)																int index;
HXDLIN(  80)																if (tileImage->useVirtualPos) {
HXLINE(  80)																	index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																}
            																else {
HXLINE(  80)																	index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																}
HXDLIN(  80)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																int color;
HXDLIN(  80)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																	color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  80)																	color = c;
            																}
HXDLIN(  80)																{
HXLINE(  80)																	int this2 = color;
HXDLIN(  80)																	int c1 = this2;
HXDLIN(  80)																	bool _hx_tmp;
HXDLIN(  80)																	if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  80)																		_hx_tmp = temp->transparent;
            																	}
            																	else {
HXLINE(  80)																		_hx_tmp = false;
            																	}
HXDLIN(  80)																	if (_hx_tmp) {
HXLINE(  80)																		int location;
HXDLIN(  80)																		if (temp->useVirtualPos) {
HXLINE(  80)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																		}
            																		else {
HXLINE(  80)																			location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																		}
HXDLIN(  80)																		::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  80)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  80)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  80)																		int this3 = this2;
HXDLIN(  80)																		int this4;
HXDLIN(  80)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  80)																			this4 = this3;
            																		}
HXDLIN(  80)																		Float a1;
HXDLIN(  80)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  80)																		if ((this5 == 0)) {
HXLINE(  80)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float r1;
HXDLIN(  80)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  80)																		if ((this6 == 0)) {
HXLINE(  80)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float g1;
HXDLIN(  80)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  80)																		if ((this7 == 0)) {
HXLINE(  80)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float b1;
HXDLIN(  80)																		int this8 = (this4 & 255);
HXDLIN(  80)																		if ((this8 == 0)) {
HXLINE(  80)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float a2;
HXDLIN(  80)																		int this9 = ((color >> 24) & 255);
HXDLIN(  80)																		if ((this9 == 0)) {
HXLINE(  80)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float r2;
HXDLIN(  80)																		int this10 = ((color >> 16) & 255);
HXDLIN(  80)																		if ((this10 == 0)) {
HXLINE(  80)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float g2;
HXDLIN(  80)																		int this11 = ((color >> 8) & 255);
HXDLIN(  80)																		if ((this11 == 0)) {
HXLINE(  80)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float b2;
HXDLIN(  80)																		int this12 = (color & 255);
HXDLIN(  80)																		if ((this12 == 0)) {
HXLINE(  80)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  80)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  80)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  80)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  80)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  80)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  80)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  80)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  80)																		{
HXLINE(  80)																			::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  80)																			int value;
HXDLIN(  80)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  80)																				value = blended;
            																			}
HXDLIN(  80)																			bool _hx_tmp;
HXDLIN(  80)																			if ((location >= 0)) {
HXLINE(  80)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  80)																				_hx_tmp = false;
            																			}
HXDLIN(  80)																			if (_hx_tmp) {
HXLINE(  80)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  80)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  80)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  80)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  80)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  80)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  80)																		::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  80)																		int index;
HXDLIN(  80)																		if (temp->useVirtualPos) {
HXLINE(  80)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																		}
            																		else {
HXLINE(  80)																			index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																		}
HXDLIN(  80)																		int value;
HXDLIN(  80)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)																			value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																		}
            																		else {
HXLINE(  80)																			value = c1;
            																		}
HXDLIN(  80)																		bool _hx_tmp;
HXDLIN(  80)																		if ((index >= 0)) {
HXLINE(  80)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  80)																			_hx_tmp = false;
            																		}
HXDLIN(  80)																		if (_hx_tmp) {
HXLINE(  80)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  80)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  80)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  80)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  80)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  80)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE( 237)																foundY = true;
            															}
            															else {
HXLINE(  80)																if (foundY) {
HXLINE(  80)																	goto _hx_goto_15;
            																}
            															}
            														}
            													}
            													_hx_goto_15:;
            												}
            											}
            										}
HXDLIN(  80)										if ((hasHit == false)) {
HXLINE(  80)											::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  80)											if (hasUndo) {
HXLINE(  80)												v->undoImage = undoImage;
HXDLIN(  80)												v->undoX = xIter3->start;
HXDLIN(  80)												v->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE( 177)							lastX = nextX;
HXLINE( 178)							lastY = nextY;
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE(  82)			int color = this->strokeColor;
HXDLIN(  82)			 ::Dynamic phi1 = phi;
HXDLIN(  82)			if (::hx::IsNull( phi1 )) {
HXLINE(  82)				phi1 = 0;
            			}
HXDLIN(  82)			Float rSmall;
HXDLIN(  82)			if ((r > r)) {
HXLINE(  82)				rSmall = r;
            			}
            			else {
HXLINE(  82)				rSmall = r;
            			}
HXDLIN(  82)			 ::Dynamic targetE = ((Float)1.05);
HXDLIN(  82)			if (::hx::IsNull( targetE )) {
HXLINE( 692)				targetE = ((Float)1.05);
            			}
HXLINE(  82)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  82)			int noSides;
HXDLIN(  82)			if ((result < 12)) {
HXLINE(  82)				noSides = 12;
            			}
            			else {
HXLINE(  82)				if ((result > 500)) {
HXLINE(  82)					noSides = 500;
            				}
            				else {
HXLINE(  82)					noSides = result;
            				}
            			}
HXDLIN(  82)			{
HXLINE(  82)				 ::Dynamic phi2 = phi1;
HXDLIN(  82)				 ::Dynamic sides = noSides;
HXDLIN(  82)				if (::hx::IsNull( sides )) {
HXLINE( 694)					sides = 36;
            				}
HXLINE(  82)				if (::hx::IsNull( phi2 )) {
HXLINE( 694)					phi2 = ((Float)0.);
            				}
HXLINE(  82)				{
HXLINE(  82)					 ::Dynamic phi3 = phi2;
HXDLIN(  82)					 ::Dynamic sides1 = sides;
HXDLIN(  82)					if (::hx::IsNull( sides1 )) {
HXLINE( 865)						sides1 = 36;
            					}
HXLINE(  82)					if (::hx::IsNull( phi3 )) {
HXLINE( 865)						phi3 = ((Float)0.);
            					}
HXLINE(  82)					Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  82)					Float omega;
HXDLIN(  82)					omega = ((Float)0.);
HXDLIN(  82)					Float lastX = ((Float)0.);
HXDLIN(  82)					Float lastY = ((Float)0.);
HXDLIN(  82)					if (::hx::IsNotEq( phi3,0 )) {
HXLINE(  35)						lastX = ((((r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) ))) - ((r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) )))) + cx);
HXLINE(  36)						lastY = ((((r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) ))) + ((r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) )))) + cy);
            					}
            					else {
HXLINE(  38)						lastX = (cx + (r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)						lastY = (cy + (r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            					}
HXLINE(  82)					if (::hx::IsNotEq( phi3,0 )) {
HXLINE(  82)						Float cphi = ::Math_obj::cos(( (Float)(phi3) ));
HXDLIN(  82)						Float sphi = ::Math_obj::sin(( (Float)(phi3) ));
HXDLIN(  82)						{
HXLINE(  82)							int _g = 0;
HXDLIN(  82)							int _g1 = (sides1 + 1);
HXDLIN(  82)							while((_g < _g1)){
HXLINE(  82)								_g = (_g + 1);
HXDLIN(  82)								int i = (_g - 1);
HXDLIN(  82)								Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  82)								Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  82)								Float nextX = ((((r * ctheta) * cphi) - ((r * stheta) * sphi)) + cx);
HXDLIN(  82)								Float nextY = ((((r * ctheta) * sphi) + ((r * stheta) * cphi)) + cy);
HXDLIN(  82)								{
HXLINE(  82)									bool hasHit = false;
HXDLIN(  82)									bool hasUndo = false;
HXDLIN(  82)									{
HXLINE(  82)										Float bx = lastX;
HXDLIN(  82)										Float by = lastY;
HXDLIN(  82)										Float cx1 = nextX;
HXDLIN(  82)										Float cy1 = nextY;
HXDLIN(  82)										bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  82)										if (!(adjustWinding)) {
HXLINE(  82)											Float bx_ = bx;
HXDLIN(  82)											Float by_ = by;
HXLINE(  26)											bx = cx1;
HXLINE(  27)											by = cy1;
HXLINE(  28)											cx1 = bx_;
HXLINE(  29)											cy1 = by_;
            										}
HXLINE(  82)										{
HXLINE(  82)											Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  82)											Float sx = (cy1 - cy);
HXDLIN(  82)											Float sy = (cx - cx1);
HXDLIN(  82)											Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  82)											Float tx = (cy - by);
HXDLIN(  82)											Float ty = (bx - cx);
HXDLIN(  82)											Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  82)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  82)											if ((cx > bx)) {
HXLINE(  82)												if ((cx > cx1)) {
HXLINE(  82)													int min;
HXDLIN(  82)													if ((bx > cx1)) {
HXLINE(  82)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  82)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  82)													int ii_min = min;
HXDLIN(  82)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  82)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)													xIter3 = this1;
            												}
            												else {
HXLINE(  82)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  82)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  82)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  82)												if ((bx > cx1)) {
HXLINE(  82)													int min;
HXDLIN(  82)													if ((cx > cx1)) {
HXLINE(  82)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  82)														min = ::Math_obj::ceil(cx);
            													}
HXDLIN(  82)													int ii_min = min;
HXDLIN(  82)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  82)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)													xIter3 = this1;
            												}
            												else {
HXLINE(  82)													int ii_min = ::Math_obj::floor(cx);
HXDLIN(  82)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  82)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)													xIter3 = this1;
            												}
            											}
HXDLIN(  82)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  82)											if ((cy > by)) {
HXLINE(  82)												if ((cy > cy1)) {
HXLINE(  82)													int min;
HXDLIN(  82)													if ((by > cy1)) {
HXLINE(  82)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  82)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  82)													int ii_min = min;
HXDLIN(  82)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  82)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)													yIter3 = this1;
            												}
            												else {
HXLINE(  82)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  82)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  82)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  82)												if ((by > cy1)) {
HXLINE(  82)													int min;
HXDLIN(  82)													if ((cy > cy1)) {
HXLINE(  82)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  82)														min = ::Math_obj::ceil(cy);
            													}
HXDLIN(  82)													int ii_min = min;
HXDLIN(  82)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  82)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)													yIter3 = this1;
            												}
            												else {
HXLINE(  82)													int ii_min = ::Math_obj::floor(cy);
HXDLIN(  82)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  82)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)													yIter3 = this1;
            												}
            											}
HXDLIN(  82)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  82)											if (hasUndo) {
HXLINE(  82)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  82)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  82)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  82)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  82)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  82)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  82)												undoImage = this3;
HXDLIN(  82)												{
HXLINE(  82)													int rectLeft = xIter3->start;
HXDLIN(  82)													int rectTop = yIter3->start;
HXDLIN(  82)													int rectRight = xIter3->max;
HXDLIN(  82)													bool forceClear = false;
HXDLIN(  82)													{
HXLINE(  82)														int _g = rectTop;
HXDLIN(  82)														int _g1 = yIter3->max;
HXDLIN(  82)														while((_g < _g1)){
HXLINE(  82)															_g = (_g + 1);
HXDLIN(  82)															int dy = (_g - 1);
HXDLIN(  82)															{
HXLINE(  82)																int _g1 = rectLeft;
HXDLIN(  82)																int _g2 = rectRight;
HXDLIN(  82)																while((_g1 < _g2)){
HXLINE(  82)																	_g1 = (_g1 + 1);
HXDLIN(  82)																	int dx = (_g1 - 1);
HXDLIN(  82)																	::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  82)																	int index;
HXDLIN(  82)																	if (temp->useVirtualPos) {
HXLINE(  82)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            																	}
            																	else {
HXLINE(  82)																		index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            																	}
HXDLIN(  82)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  82)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  82)																	int col;
HXDLIN(  82)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  82)																		col = c;
            																	}
HXDLIN(  82)																	bool _hx_tmp;
HXDLIN(  82)																	if (temp->useMask) {
HXLINE(  82)																		_hx_tmp = ::hx::IsNotNull( temp->mask );
            																	}
            																	else {
HXLINE(  82)																		_hx_tmp = false;
            																	}
HXDLIN(  82)																	if (_hx_tmp) {
HXLINE(  82)																		::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  82)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  82)																		int index;
HXDLIN(  82)																		if (this1->useVirtualPos) {
HXLINE(  82)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  82)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  82)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  82)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  82)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  82)																		int v;
HXDLIN(  82)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  82)																			v = c;
            																		}
HXDLIN(  82)																		int this3 = v;
HXDLIN(  82)																		int maskPixel = this3;
HXDLIN(  82)																		int this4 = col;
HXDLIN(  82)																		int this5 = this4;
HXDLIN(  82)																		if ((maskPixel == 0)) {
HXLINE(  82)																			int this1 = this5;
HXDLIN(  82)																			col = this1;
            																		}
            																		else {
HXLINE(  82)																			Float m0;
HXDLIN(  82)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  82)																			if ((this1 == 0)) {
HXLINE(  82)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float m1;
HXDLIN(  82)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  82)																			if ((this2 == 0)) {
HXLINE(  82)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float m2;
HXDLIN(  82)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  82)																			if ((this3 == 0)) {
HXLINE(  82)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float m3;
HXDLIN(  82)																			int this4 = (maskPixel & 255);
HXDLIN(  82)																			if ((this4 == 0)) {
HXLINE(  82)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  82)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  82)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  82)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  82)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  82)																	if ((col != 0)) {
HXLINE(  82)																		int x = (dx - rectLeft);
HXDLIN(  82)																		int y = (dy - rectTop);
HXDLIN(  82)																		int this1 = col;
HXDLIN(  82)																		int c = this1;
HXDLIN(  82)																		bool _hx_tmp;
HXDLIN(  82)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  82)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  82)																			_hx_tmp = false;
            																		}
HXDLIN(  82)																		if (_hx_tmp) {
HXLINE(  82)																			int location;
HXDLIN(  82)																			if (undoImage->useVirtualPos) {
HXLINE(  82)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  82)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  82)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  82)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  82)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  82)																			int this3 = this2;
HXDLIN(  82)																			int this4;
HXDLIN(  82)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  82)																				this4 = this3;
            																			}
HXDLIN(  82)																			Float a1;
HXDLIN(  82)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  82)																			if ((this5 == 0)) {
HXLINE(  82)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float r1;
HXDLIN(  82)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  82)																			if ((this6 == 0)) {
HXLINE(  82)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float g1;
HXDLIN(  82)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  82)																			if ((this7 == 0)) {
HXLINE(  82)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float b1;
HXDLIN(  82)																			int this8 = (this4 & 255);
HXDLIN(  82)																			if ((this8 == 0)) {
HXLINE(  82)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float a2;
HXDLIN(  82)																			int this9 = ((col >> 24) & 255);
HXDLIN(  82)																			if ((this9 == 0)) {
HXLINE(  82)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float r2;
HXDLIN(  82)																			int this10 = ((col >> 16) & 255);
HXDLIN(  82)																			if ((this10 == 0)) {
HXLINE(  82)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float g2;
HXDLIN(  82)																			int this11 = ((col >> 8) & 255);
HXDLIN(  82)																			if ((this11 == 0)) {
HXLINE(  82)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float b2;
HXDLIN(  82)																			int this12 = (col & 255);
HXDLIN(  82)																			if ((this12 == 0)) {
HXLINE(  82)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  82)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  82)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  82)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  82)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  82)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  82)																			{
HXLINE(  82)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  82)																				int value;
HXDLIN(  82)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  82)																					value = blended;
            																				}
HXDLIN(  82)																				bool _hx_tmp;
HXDLIN(  82)																				if ((location >= 0)) {
HXLINE(  82)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  82)																					_hx_tmp = false;
            																				}
HXDLIN(  82)																				if (_hx_tmp) {
HXLINE(  82)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  82)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  82)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  82)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  82)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  82)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  82)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  82)																			int index;
HXDLIN(  82)																			if (undoImage->useVirtualPos) {
HXLINE(  82)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  82)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  82)																			int value;
HXDLIN(  82)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  82)																				value = c;
            																			}
HXDLIN(  82)																			bool _hx_tmp;
HXDLIN(  82)																			if ((index >= 0)) {
HXLINE(  82)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  82)																				_hx_tmp = false;
            																			}
HXDLIN(  82)																			if (_hx_tmp) {
HXLINE(  82)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  82)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  82)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  82)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  82)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  82)																		if (forceClear) {
HXLINE(  82)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  82)																			int x = (dx - rectLeft);
HXDLIN(  82)																			int y = (dy - rectTop);
HXDLIN(  82)																			int index;
HXDLIN(  82)																			if (undoImage->useVirtualPos) {
HXLINE(  82)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  82)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  82)																			bool _hx_tmp;
HXDLIN(  82)																			if ((index >= 0)) {
HXLINE(  82)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  82)																				_hx_tmp = false;
            																			}
HXDLIN(  82)																			if (_hx_tmp) {
HXLINE(  82)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  82)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  82)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  82)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  82)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  82)											bool found = false;
HXDLIN(  82)											Float s = ((Float)0.);
HXDLIN(  82)											Float t = ((Float)0.);
HXDLIN(  82)											Float sxx = ((Float)0.);
HXDLIN(  82)											Float txx = ((Float)0.);
HXDLIN(  82)											{
HXLINE(  82)												int _g_min = xIter3->start;
HXDLIN(  82)												int _g_max = xIter3->max;
HXDLIN(  82)												while((_g_min < _g_max)){
HXLINE(  82)													_g_min = (_g_min + 1);
HXDLIN(  82)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXLINE(  82)													{
HXLINE(  82)														int _g_min1 = yIter3->start;
HXDLIN(  82)														int _g_max = yIter3->max;
HXDLIN(  82)														while((_g_min1 < _g_max)){
HXLINE(  82)															_g_min1 = (_g_min1 + 1);
HXDLIN(  82)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  82)															bool _hx_tmp;
HXDLIN(  82)															if (!((s <= 0))) {
HXLINE(  82)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  82)																_hx_tmp = true;
            															}
HXDLIN(  82)															if (_hx_tmp) {
HXLINE(  82)																if (found) {
HXLINE(  82)																	goto _hx_goto_20;
            																}
            															}
            															else {
HXLINE(  82)																if (((s + t) < A)) {
HXLINE(  82)																	{
HXLINE(  82)																		int this1 = color;
HXDLIN(  82)																		int c = this1;
HXDLIN(  82)																		bool _hx_tmp;
HXDLIN(  82)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  82)																			_hx_tmp = temp->transparent;
            																		}
            																		else {
HXLINE(  82)																			_hx_tmp = false;
            																		}
HXDLIN(  82)																		if (_hx_tmp) {
HXLINE(  82)																			int location;
HXDLIN(  82)																			if (temp->useVirtualPos) {
HXLINE(  82)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																			}
            																			else {
HXLINE(  82)																				location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																			}
HXDLIN(  82)																			::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  82)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  82)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  82)																			int this3 = this2;
HXDLIN(  82)																			int this4;
HXDLIN(  82)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  82)																				this4 = this3;
            																			}
HXDLIN(  82)																			Float a1;
HXDLIN(  82)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  82)																			if ((this5 == 0)) {
HXLINE(  82)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float r1;
HXDLIN(  82)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  82)																			if ((this6 == 0)) {
HXLINE(  82)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float g1;
HXDLIN(  82)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  82)																			if ((this7 == 0)) {
HXLINE(  82)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float b1;
HXDLIN(  82)																			int this8 = (this4 & 255);
HXDLIN(  82)																			if ((this8 == 0)) {
HXLINE(  82)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float a2;
HXDLIN(  82)																			int this9 = ((color >> 24) & 255);
HXDLIN(  82)																			if ((this9 == 0)) {
HXLINE(  82)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float r2;
HXDLIN(  82)																			int this10 = ((color >> 16) & 255);
HXDLIN(  82)																			if ((this10 == 0)) {
HXLINE(  82)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float g2;
HXDLIN(  82)																			int this11 = ((color >> 8) & 255);
HXDLIN(  82)																			if ((this11 == 0)) {
HXLINE(  82)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float b2;
HXDLIN(  82)																			int this12 = (color & 255);
HXDLIN(  82)																			if ((this12 == 0)) {
HXLINE(  82)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  82)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  82)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  82)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  82)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  82)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  82)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  82)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  82)																			{
HXLINE(  82)																				::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  82)																				int value;
HXDLIN(  82)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  82)																					value = blended;
            																				}
HXDLIN(  82)																				bool _hx_tmp;
HXDLIN(  82)																				if ((location >= 0)) {
HXLINE(  82)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  82)																					_hx_tmp = false;
            																				}
HXDLIN(  82)																				if (_hx_tmp) {
HXLINE(  82)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  82)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  82)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  82)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  82)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  82)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  82)																			::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  82)																			int index;
HXDLIN(  82)																			if (temp->useVirtualPos) {
HXLINE(  82)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																			}
            																			else {
HXLINE(  82)																				index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																			}
HXDLIN(  82)																			int value;
HXDLIN(  82)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  82)																				value = c;
            																			}
HXDLIN(  82)																			bool _hx_tmp;
HXDLIN(  82)																			if ((index >= 0)) {
HXLINE(  82)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  82)																				_hx_tmp = false;
            																			}
HXDLIN(  82)																			if (_hx_tmp) {
HXLINE(  82)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  82)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  82)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  82)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  82)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  82)																	if (found) {
HXLINE(  82)																		goto _hx_goto_20;
            																	}
            																}
            															}
            														}
            														_hx_goto_20:;
            													}
            												}
            											}
HXDLIN(  82)											if ((hasHit == true)) {
HXLINE(  82)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  82)												if (hasUndo) {
HXLINE(  82)													v->undoImage = undoImage;
HXDLIN(  82)													v->undoX = xIter3->start;
HXDLIN(  82)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  51)								lastX = nextX;
HXLINE(  52)								lastY = nextY;
            							}
            						}
            					}
            					else {
HXLINE(  82)						int _g = 0;
HXDLIN(  82)						int _g1 = (sides1 + 1);
HXDLIN(  82)						while((_g < _g1)){
HXLINE(  82)							_g = (_g + 1);
HXDLIN(  82)							int i = (_g - 1);
HXDLIN(  82)							Float nextX = (cx + (r * ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  82)							Float nextY = (cy + (r * ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  82)							{
HXLINE(  82)								bool hasHit = false;
HXDLIN(  82)								bool hasUndo = false;
HXDLIN(  82)								{
HXLINE(  82)									Float bx = lastX;
HXDLIN(  82)									Float by = lastY;
HXDLIN(  82)									Float cx1 = nextX;
HXDLIN(  82)									Float cy1 = nextY;
HXDLIN(  82)									bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  82)									if (!(adjustWinding)) {
HXLINE(  82)										Float bx_ = bx;
HXDLIN(  82)										Float by_ = by;
HXLINE(  26)										bx = cx1;
HXLINE(  27)										by = cy1;
HXLINE(  28)										cx1 = bx_;
HXLINE(  29)										cy1 = by_;
            									}
HXLINE(  82)									{
HXLINE(  82)										Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  82)										Float sx = (cy1 - cy);
HXDLIN(  82)										Float sy = (cx - cx1);
HXDLIN(  82)										Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  82)										Float tx = (cy - by);
HXDLIN(  82)										Float ty = (bx - cx);
HXDLIN(  82)										Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  82)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  82)										if ((cx > bx)) {
HXLINE(  82)											if ((cx > cx1)) {
HXLINE(  82)												int min;
HXDLIN(  82)												if ((bx > cx1)) {
HXLINE(  82)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  82)													min = ::Math_obj::floor(bx);
            												}
HXDLIN(  82)												int ii_min = min;
HXDLIN(  82)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  82)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)												xIter3 = this1;
            											}
            											else {
HXLINE(  82)												int ii_min = ::Math_obj::floor(bx);
HXDLIN(  82)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  82)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  82)											if ((bx > cx1)) {
HXLINE(  82)												int min;
HXDLIN(  82)												if ((cx > cx1)) {
HXLINE(  82)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  82)													min = ::Math_obj::ceil(cx);
            												}
HXDLIN(  82)												int ii_min = min;
HXDLIN(  82)												int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  82)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)												xIter3 = this1;
            											}
            											else {
HXLINE(  82)												int ii_min = ::Math_obj::floor(cx);
HXDLIN(  82)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  82)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)												xIter3 = this1;
            											}
            										}
HXDLIN(  82)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  82)										if ((cy > by)) {
HXLINE(  82)											if ((cy > cy1)) {
HXLINE(  82)												int min;
HXDLIN(  82)												if ((by > cy1)) {
HXLINE(  82)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  82)													min = ::Math_obj::floor(by);
            												}
HXDLIN(  82)												int ii_min = min;
HXDLIN(  82)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  82)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)												yIter3 = this1;
            											}
            											else {
HXLINE(  82)												int ii_min = ::Math_obj::floor(by);
HXDLIN(  82)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  82)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  82)											if ((by > cy1)) {
HXLINE(  82)												int min;
HXDLIN(  82)												if ((cy > cy1)) {
HXLINE(  82)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  82)													min = ::Math_obj::ceil(cy);
            												}
HXDLIN(  82)												int ii_min = min;
HXDLIN(  82)												int ii_max = ::Math_obj::ceil(by);
HXDLIN(  82)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)												yIter3 = this1;
            											}
            											else {
HXLINE(  82)												int ii_min = ::Math_obj::floor(cy);
HXDLIN(  82)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  82)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  82)												yIter3 = this1;
            											}
            										}
HXDLIN(  82)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  82)										if (hasUndo) {
HXLINE(  82)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  82)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  82)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  82)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  82)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  82)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  82)											undoImage = this3;
HXDLIN(  82)											{
HXLINE(  82)												int rectLeft = xIter3->start;
HXDLIN(  82)												int rectTop = yIter3->start;
HXDLIN(  82)												int rectRight = xIter3->max;
HXDLIN(  82)												bool forceClear = false;
HXDLIN(  82)												{
HXLINE(  82)													int _g = rectTop;
HXDLIN(  82)													int _g1 = yIter3->max;
HXDLIN(  82)													while((_g < _g1)){
HXLINE(  82)														_g = (_g + 1);
HXDLIN(  82)														int dy = (_g - 1);
HXDLIN(  82)														{
HXLINE(  82)															int _g1 = rectLeft;
HXDLIN(  82)															int _g2 = rectRight;
HXDLIN(  82)															while((_g1 < _g2)){
HXLINE(  82)																_g1 = (_g1 + 1);
HXDLIN(  82)																int dx = (_g1 - 1);
HXDLIN(  82)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  82)																int index;
HXDLIN(  82)																if (temp->useVirtualPos) {
HXLINE(  82)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            																}
            																else {
HXLINE(  82)																	index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            																}
HXDLIN(  82)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  82)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  82)																int col;
HXDLIN(  82)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  82)																	col = c;
            																}
HXDLIN(  82)																bool _hx_tmp;
HXDLIN(  82)																if (temp->useMask) {
HXLINE(  82)																	_hx_tmp = ::hx::IsNotNull( temp->mask );
            																}
            																else {
HXLINE(  82)																	_hx_tmp = false;
            																}
HXDLIN(  82)																if (_hx_tmp) {
HXLINE(  82)																	::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  82)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  82)																	int index;
HXDLIN(  82)																	if (this1->useVirtualPos) {
HXLINE(  82)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  82)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  82)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  82)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  82)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  82)																	int v;
HXDLIN(  82)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  82)																		v = c;
            																	}
HXDLIN(  82)																	int this3 = v;
HXDLIN(  82)																	int maskPixel = this3;
HXDLIN(  82)																	int this4 = col;
HXDLIN(  82)																	int this5 = this4;
HXDLIN(  82)																	if ((maskPixel == 0)) {
HXLINE(  82)																		int this1 = this5;
HXDLIN(  82)																		col = this1;
            																	}
            																	else {
HXLINE(  82)																		Float m0;
HXDLIN(  82)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  82)																		if ((this1 == 0)) {
HXLINE(  82)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float m1;
HXDLIN(  82)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  82)																		if ((this2 == 0)) {
HXLINE(  82)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float m2;
HXDLIN(  82)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  82)																		if ((this3 == 0)) {
HXLINE(  82)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float m3;
HXDLIN(  82)																		int this4 = (maskPixel & 255);
HXDLIN(  82)																		if ((this4 == 0)) {
HXLINE(  82)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  82)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  82)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  82)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  82)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  82)																if ((col != 0)) {
HXLINE(  82)																	int x = (dx - rectLeft);
HXDLIN(  82)																	int y = (dy - rectTop);
HXDLIN(  82)																	int this1 = col;
HXDLIN(  82)																	int c = this1;
HXDLIN(  82)																	bool _hx_tmp;
HXDLIN(  82)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  82)																		_hx_tmp = undoImage->transparent;
            																	}
            																	else {
HXLINE(  82)																		_hx_tmp = false;
            																	}
HXDLIN(  82)																	if (_hx_tmp) {
HXLINE(  82)																		int location;
HXDLIN(  82)																		if (undoImage->useVirtualPos) {
HXLINE(  82)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  82)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  82)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  82)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  82)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  82)																		int this3 = this2;
HXDLIN(  82)																		int this4;
HXDLIN(  82)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  82)																			this4 = this3;
            																		}
HXDLIN(  82)																		Float a1;
HXDLIN(  82)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  82)																		if ((this5 == 0)) {
HXLINE(  82)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float r1;
HXDLIN(  82)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  82)																		if ((this6 == 0)) {
HXLINE(  82)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float g1;
HXDLIN(  82)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  82)																		if ((this7 == 0)) {
HXLINE(  82)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float b1;
HXDLIN(  82)																		int this8 = (this4 & 255);
HXDLIN(  82)																		if ((this8 == 0)) {
HXLINE(  82)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float a2;
HXDLIN(  82)																		int this9 = ((col >> 24) & 255);
HXDLIN(  82)																		if ((this9 == 0)) {
HXLINE(  82)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float r2;
HXDLIN(  82)																		int this10 = ((col >> 16) & 255);
HXDLIN(  82)																		if ((this10 == 0)) {
HXLINE(  82)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float g2;
HXDLIN(  82)																		int this11 = ((col >> 8) & 255);
HXDLIN(  82)																		if ((this11 == 0)) {
HXLINE(  82)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float b2;
HXDLIN(  82)																		int this12 = (col & 255);
HXDLIN(  82)																		if ((this12 == 0)) {
HXLINE(  82)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  82)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  82)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  82)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  82)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  82)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  82)																		{
HXLINE(  82)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  82)																			int value;
HXDLIN(  82)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  82)																				value = blended;
            																			}
HXDLIN(  82)																			bool _hx_tmp;
HXDLIN(  82)																			if ((location >= 0)) {
HXLINE(  82)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  82)																				_hx_tmp = false;
            																			}
HXDLIN(  82)																			if (_hx_tmp) {
HXLINE(  82)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  82)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  82)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  82)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  82)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  82)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  82)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  82)																		int index;
HXDLIN(  82)																		if (undoImage->useVirtualPos) {
HXLINE(  82)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  82)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  82)																		int value;
HXDLIN(  82)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  82)																			value = c;
            																		}
HXDLIN(  82)																		bool _hx_tmp;
HXDLIN(  82)																		if ((index >= 0)) {
HXLINE(  82)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  82)																			_hx_tmp = false;
            																		}
HXDLIN(  82)																		if (_hx_tmp) {
HXLINE(  82)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  82)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  82)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  82)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  82)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  82)																	if (forceClear) {
HXLINE(  82)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  82)																		int x = (dx - rectLeft);
HXDLIN(  82)																		int y = (dy - rectTop);
HXDLIN(  82)																		int index;
HXDLIN(  82)																		if (undoImage->useVirtualPos) {
HXLINE(  82)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  82)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  82)																		bool _hx_tmp;
HXDLIN(  82)																		if ((index >= 0)) {
HXLINE(  82)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  82)																			_hx_tmp = false;
            																		}
HXDLIN(  82)																		if (_hx_tmp) {
HXLINE(  82)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  82)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  82)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  82)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  82)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  82)										bool found = false;
HXDLIN(  82)										Float s = ((Float)0.);
HXDLIN(  82)										Float t = ((Float)0.);
HXDLIN(  82)										Float sxx = ((Float)0.);
HXDLIN(  82)										Float txx = ((Float)0.);
HXDLIN(  82)										{
HXLINE(  82)											int _g_min = xIter3->start;
HXDLIN(  82)											int _g_max = xIter3->max;
HXDLIN(  82)											while((_g_min < _g_max)){
HXLINE(  82)												_g_min = (_g_min + 1);
HXDLIN(  82)												int x = (_g_min - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found = false;
HXLINE(  82)												{
HXLINE(  82)													int _g_min1 = yIter3->start;
HXDLIN(  82)													int _g_max = yIter3->max;
HXDLIN(  82)													while((_g_min1 < _g_max)){
HXLINE(  82)														_g_min1 = (_g_min1 + 1);
HXDLIN(  82)														int y = (_g_min1 - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  82)														bool _hx_tmp;
HXDLIN(  82)														if (!((s <= 0))) {
HXLINE(  82)															_hx_tmp = (t <= 0);
            														}
            														else {
HXLINE(  82)															_hx_tmp = true;
            														}
HXDLIN(  82)														if (_hx_tmp) {
HXLINE(  82)															if (found) {
HXLINE(  82)																goto _hx_goto_25;
            															}
            														}
            														else {
HXLINE(  82)															if (((s + t) < A)) {
HXLINE(  82)																{
HXLINE(  82)																	int this1 = color;
HXDLIN(  82)																	int c = this1;
HXDLIN(  82)																	bool _hx_tmp;
HXDLIN(  82)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  82)																		_hx_tmp = temp->transparent;
            																	}
            																	else {
HXLINE(  82)																		_hx_tmp = false;
            																	}
HXDLIN(  82)																	if (_hx_tmp) {
HXLINE(  82)																		int location;
HXDLIN(  82)																		if (temp->useVirtualPos) {
HXLINE(  82)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																		}
            																		else {
HXLINE(  82)																			location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																		}
HXDLIN(  82)																		::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  82)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  82)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  82)																		int this3 = this2;
HXDLIN(  82)																		int this4;
HXDLIN(  82)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  82)																			this4 = this3;
            																		}
HXDLIN(  82)																		Float a1;
HXDLIN(  82)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  82)																		if ((this5 == 0)) {
HXLINE(  82)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float r1;
HXDLIN(  82)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  82)																		if ((this6 == 0)) {
HXLINE(  82)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float g1;
HXDLIN(  82)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  82)																		if ((this7 == 0)) {
HXLINE(  82)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float b1;
HXDLIN(  82)																		int this8 = (this4 & 255);
HXDLIN(  82)																		if ((this8 == 0)) {
HXLINE(  82)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float a2;
HXDLIN(  82)																		int this9 = ((color >> 24) & 255);
HXDLIN(  82)																		if ((this9 == 0)) {
HXLINE(  82)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float r2;
HXDLIN(  82)																		int this10 = ((color >> 16) & 255);
HXDLIN(  82)																		if ((this10 == 0)) {
HXLINE(  82)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float g2;
HXDLIN(  82)																		int this11 = ((color >> 8) & 255);
HXDLIN(  82)																		if ((this11 == 0)) {
HXLINE(  82)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float b2;
HXDLIN(  82)																		int this12 = (color & 255);
HXDLIN(  82)																		if ((this12 == 0)) {
HXLINE(  82)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  82)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  82)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  82)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  82)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  82)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  82)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  82)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  82)																		{
HXLINE(  82)																			::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  82)																			int value;
HXDLIN(  82)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  82)																				value = blended;
            																			}
HXDLIN(  82)																			bool _hx_tmp;
HXDLIN(  82)																			if ((location >= 0)) {
HXLINE(  82)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  82)																				_hx_tmp = false;
            																			}
HXDLIN(  82)																			if (_hx_tmp) {
HXLINE(  82)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  82)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  82)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  82)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  82)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  82)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  82)																		::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  82)																		int index;
HXDLIN(  82)																		if (temp->useVirtualPos) {
HXLINE(  82)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																		}
            																		else {
HXLINE(  82)																			index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																		}
HXDLIN(  82)																		int value;
HXDLIN(  82)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  82)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  82)																			value = c;
            																		}
HXDLIN(  82)																		bool _hx_tmp;
HXDLIN(  82)																		if ((index >= 0)) {
HXLINE(  82)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  82)																			_hx_tmp = false;
            																		}
HXDLIN(  82)																		if (_hx_tmp) {
HXLINE(  82)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  82)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  82)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  82)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  82)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  82)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found = true;
            															}
            															else {
HXLINE(  82)																if (found) {
HXLINE(  82)																	goto _hx_goto_25;
            																}
            															}
            														}
            													}
            													_hx_goto_25:;
            												}
            											}
            										}
HXDLIN(  82)										if ((hasHit == true)) {
HXLINE(  82)											::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  82)											if (hasUndo) {
HXLINE(  82)												v->undoImage = undoImage;
HXDLIN(  82)												v->undoX = xIter3->start;
HXDLIN(  82)												v->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  59)							lastX = nextX;
HXLINE(  60)							lastY = nextY;
            						}
            					}
            				}
            			}
            		}
HXLINE(  84)		{
HXLINE(  84)			::pixelimage::ImageStruct tileImage = this->tileImageFill;
HXDLIN(  84)			 ::Dynamic phi1 = phi;
HXDLIN(  84)			if (::hx::IsNull( phi1 )) {
HXLINE(  84)				phi1 = 0;
            			}
HXDLIN(  84)			Float rSmall;
HXDLIN(  84)			if ((innerR > innerR)) {
HXLINE(  84)				rSmall = innerR;
            			}
            			else {
HXLINE(  84)				rSmall = innerR;
            			}
HXDLIN(  84)			 ::Dynamic targetE = ((Float)1.05);
HXDLIN(  84)			if (::hx::IsNull( targetE )) {
HXLINE( 710)				targetE = ((Float)1.05);
            			}
HXLINE(  84)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  84)			int noSides;
HXDLIN(  84)			if ((result < 12)) {
HXLINE(  84)				noSides = 12;
            			}
            			else {
HXLINE(  84)				if ((result > 500)) {
HXLINE(  84)					noSides = 500;
            				}
            				else {
HXLINE(  84)					noSides = result;
            				}
            			}
HXDLIN(  84)			{
HXLINE(  84)				 ::Dynamic phi2 = phi1;
HXDLIN(  84)				 ::Dynamic sides = noSides;
HXDLIN(  84)				if (::hx::IsNull( sides )) {
HXLINE( 712)					sides = 36;
            				}
HXLINE(  84)				if (::hx::IsNull( phi2 )) {
HXLINE( 712)					phi2 = ((Float)0.);
            				}
HXLINE(  84)				{
HXLINE(  84)					 ::Dynamic phi3 = phi2;
HXDLIN(  84)					 ::Dynamic sides1 = sides;
HXDLIN(  84)					if (::hx::IsNull( sides1 )) {
HXLINE( 887)						sides1 = 36;
            					}
HXLINE(  84)					if (::hx::IsNull( phi3 )) {
HXLINE( 887)						phi3 = ((Float)0.);
            					}
HXLINE(  84)					Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  84)					Float omega;
HXDLIN(  84)					omega = ((Float)0.);
HXDLIN(  84)					Float lastX = ((Float)0.);
HXDLIN(  84)					Float lastY = ((Float)0.);
HXDLIN(  84)					if (::hx::IsNotEq( phi3,0 )) {
HXLINE( 154)						lastX = ((((innerR * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) ))) - ((innerR * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) )))) + innerCx);
HXLINE( 155)						lastY = ((((innerR * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) ))) + ((innerR * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) )))) + innerCy);
            					}
            					else {
HXLINE( 157)						lastX = (innerCx + (innerR * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE( 158)						lastY = (innerCy + (innerR * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            					}
HXLINE(  84)					if (::hx::IsNotEq( phi3,0 )) {
HXLINE(  84)						Float cphi = ::Math_obj::cos(( (Float)(phi3) ));
HXDLIN(  84)						Float sphi = ::Math_obj::sin(( (Float)(phi3) ));
HXDLIN(  84)						{
HXLINE(  84)							int _g = 0;
HXDLIN(  84)							int _g1 = (sides1 + 1);
HXDLIN(  84)							while((_g < _g1)){
HXLINE(  84)								_g = (_g + 1);
HXDLIN(  84)								int i = (_g - 1);
HXDLIN(  84)								Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  84)								Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  84)								Float nextX = ((((innerR * ctheta) * cphi) - ((innerR * stheta) * sphi)) + innerCx);
HXDLIN(  84)								Float nextY = ((((innerR * ctheta) * sphi) + ((innerR * stheta) * cphi)) + innerCy);
HXDLIN(  84)								{
HXLINE(  84)									bool hasHit = false;
HXDLIN(  84)									{
HXLINE(  84)										Float bx = lastX;
HXDLIN(  84)										Float by = lastY;
HXDLIN(  84)										Float cx = nextX;
HXDLIN(  84)										Float cy = nextY;
HXDLIN(  84)										bool adjustWinding = (((((innerCx * by) - (bx * innerCy)) + ((bx * cy) - (cx * by))) + ((cx * innerCy) - (innerCx * cy))) > 0);
HXDLIN(  84)										if (!(adjustWinding)) {
HXLINE(  84)											Float bx_ = bx;
HXDLIN(  84)											Float by_ = by;
HXLINE( 188)											bx = cx;
HXLINE( 189)											by = cy;
HXLINE( 190)											cx = bx_;
HXLINE( 191)											cy = by_;
            										}
HXLINE(  84)										{
HXLINE(  84)											bool hasUndo = false;
HXDLIN(  84)											Float s0 = ((innerCy * cx) - (innerCx * cy));
HXDLIN(  84)											Float sx = (cy - innerCy);
HXDLIN(  84)											Float sy = (innerCx - cx);
HXDLIN(  84)											Float t0 = ((innerCx * by) - (innerCy * bx));
HXDLIN(  84)											Float tx = (innerCy - by);
HXDLIN(  84)											Float ty = (bx - innerCx);
HXDLIN(  84)											Float A = ((((-(by) * cx) + (innerCy * (-(bx) + cx))) + (innerCx * (by - cy))) + (bx * cy));
HXDLIN(  84)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  84)											if ((innerCx > bx)) {
HXLINE(  84)												if ((innerCx > cx)) {
HXLINE(  84)													int min;
HXDLIN(  84)													if ((bx > cx)) {
HXLINE(  84)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  84)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  84)													int ii_min = min;
HXDLIN(  84)													int ii_max = ::Math_obj::ceil(innerCx);
HXDLIN(  84)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)													xIter3 = this1;
            												}
            												else {
HXLINE(  84)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  84)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  84)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  84)												if ((bx > cx)) {
HXLINE(  84)													int min;
HXDLIN(  84)													if ((innerCx > cx)) {
HXLINE(  84)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  84)														min = ::Math_obj::ceil(innerCx);
            													}
HXDLIN(  84)													int ii_min = min;
HXDLIN(  84)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  84)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)													xIter3 = this1;
            												}
            												else {
HXLINE(  84)													int ii_min = ::Math_obj::floor(innerCx);
HXDLIN(  84)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  84)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)													xIter3 = this1;
            												}
            											}
HXDLIN(  84)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  84)											if ((innerCy > by)) {
HXLINE(  84)												if ((innerCy > cy)) {
HXLINE(  84)													int min;
HXDLIN(  84)													if ((by > cy)) {
HXLINE(  84)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  84)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  84)													int ii_min = min;
HXDLIN(  84)													int ii_max = ::Math_obj::ceil(innerCy);
HXDLIN(  84)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)													yIter3 = this1;
            												}
            												else {
HXLINE(  84)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  84)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  84)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  84)												if ((by > cy)) {
HXLINE(  84)													int min;
HXDLIN(  84)													if ((innerCy > cy)) {
HXLINE(  84)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  84)														min = ::Math_obj::ceil(innerCy);
            													}
HXDLIN(  84)													int ii_min = min;
HXDLIN(  84)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  84)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)													yIter3 = this1;
            												}
            												else {
HXLINE(  84)													int ii_min = ::Math_obj::floor(innerCy);
HXDLIN(  84)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  84)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)													yIter3 = this1;
            												}
            											}
HXDLIN(  84)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  84)											if (hasUndo) {
HXLINE(  84)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  84)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  84)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  84)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  84)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  84)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  84)												undoImage = this3;
HXDLIN(  84)												{
HXLINE(  84)													int rectLeft = xIter3->start;
HXDLIN(  84)													int rectTop = yIter3->start;
HXDLIN(  84)													int rectRight = xIter3->max;
HXDLIN(  84)													bool forceClear = false;
HXDLIN(  84)													{
HXLINE(  84)														int _g = rectTop;
HXDLIN(  84)														int _g1 = yIter3->max;
HXDLIN(  84)														while((_g < _g1)){
HXLINE(  84)															_g = (_g + 1);
HXDLIN(  84)															int dy = (_g - 1);
HXDLIN(  84)															{
HXLINE(  84)																int _g1 = rectLeft;
HXDLIN(  84)																int _g2 = rectRight;
HXDLIN(  84)																while((_g1 < _g2)){
HXLINE(  84)																	_g1 = (_g1 + 1);
HXDLIN(  84)																	int dx = (_g1 - 1);
HXDLIN(  84)																	::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)																	int index;
HXDLIN(  84)																	if (temp->useVirtualPos) {
HXLINE(  84)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            																	}
            																	else {
HXLINE(  84)																		index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            																	}
HXDLIN(  84)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																	int col;
HXDLIN(  84)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  84)																		col = c;
            																	}
HXDLIN(  84)																	bool _hx_tmp;
HXDLIN(  84)																	if (temp->useMask) {
HXLINE(  84)																		_hx_tmp = ::hx::IsNotNull( temp->mask );
            																	}
            																	else {
HXLINE(  84)																		_hx_tmp = false;
            																	}
HXDLIN(  84)																	if (_hx_tmp) {
HXLINE(  84)																		::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  84)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  84)																		int index;
HXDLIN(  84)																		if (this1->useVirtualPos) {
HXLINE(  84)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  84)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  84)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  84)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  84)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																		int v;
HXDLIN(  84)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  84)																			v = c;
            																		}
HXDLIN(  84)																		int this3 = v;
HXDLIN(  84)																		int maskPixel = this3;
HXDLIN(  84)																		int this4 = col;
HXDLIN(  84)																		int this5 = this4;
HXDLIN(  84)																		if ((maskPixel == 0)) {
HXLINE(  84)																			int this1 = this5;
HXDLIN(  84)																			col = this1;
            																		}
            																		else {
HXLINE(  84)																			Float m0;
HXDLIN(  84)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  84)																			if ((this1 == 0)) {
HXLINE(  84)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float m1;
HXDLIN(  84)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  84)																			if ((this2 == 0)) {
HXLINE(  84)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float m2;
HXDLIN(  84)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  84)																			if ((this3 == 0)) {
HXLINE(  84)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float m3;
HXDLIN(  84)																			int this4 = (maskPixel & 255);
HXDLIN(  84)																			if ((this4 == 0)) {
HXLINE(  84)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  84)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  84)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  84)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  84)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  84)																	if ((col != 0)) {
HXLINE(  84)																		int x = (dx - rectLeft);
HXDLIN(  84)																		int y = (dy - rectTop);
HXDLIN(  84)																		int this1 = col;
HXDLIN(  84)																		int c = this1;
HXDLIN(  84)																		bool _hx_tmp;
HXDLIN(  84)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  84)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  84)																			_hx_tmp = false;
            																		}
HXDLIN(  84)																		if (_hx_tmp) {
HXLINE(  84)																			int location;
HXDLIN(  84)																			if (undoImage->useVirtualPos) {
HXLINE(  84)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  84)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  84)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  84)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																			int this3 = this2;
HXDLIN(  84)																			int this4;
HXDLIN(  84)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  84)																				this4 = this3;
            																			}
HXDLIN(  84)																			Float a1;
HXDLIN(  84)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  84)																			if ((this5 == 0)) {
HXLINE(  84)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float r1;
HXDLIN(  84)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  84)																			if ((this6 == 0)) {
HXLINE(  84)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float g1;
HXDLIN(  84)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  84)																			if ((this7 == 0)) {
HXLINE(  84)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float b1;
HXDLIN(  84)																			int this8 = (this4 & 255);
HXDLIN(  84)																			if ((this8 == 0)) {
HXLINE(  84)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float a2;
HXDLIN(  84)																			int this9 = ((col >> 24) & 255);
HXDLIN(  84)																			if ((this9 == 0)) {
HXLINE(  84)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float r2;
HXDLIN(  84)																			int this10 = ((col >> 16) & 255);
HXDLIN(  84)																			if ((this10 == 0)) {
HXLINE(  84)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float g2;
HXDLIN(  84)																			int this11 = ((col >> 8) & 255);
HXDLIN(  84)																			if ((this11 == 0)) {
HXLINE(  84)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float b2;
HXDLIN(  84)																			int this12 = (col & 255);
HXDLIN(  84)																			if ((this12 == 0)) {
HXLINE(  84)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  84)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  84)																			{
HXLINE(  84)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  84)																				int value;
HXDLIN(  84)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  84)																					value = blended;
            																				}
HXDLIN(  84)																				bool _hx_tmp;
HXDLIN(  84)																				if ((location >= 0)) {
HXLINE(  84)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  84)																					_hx_tmp = false;
            																				}
HXDLIN(  84)																				if (_hx_tmp) {
HXLINE(  84)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  84)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  84)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  84)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)																			int index;
HXDLIN(  84)																			if (undoImage->useVirtualPos) {
HXLINE(  84)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  84)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  84)																			int value;
HXDLIN(  84)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  84)																				value = c;
            																			}
HXDLIN(  84)																			bool _hx_tmp;
HXDLIN(  84)																			if ((index >= 0)) {
HXLINE(  84)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  84)																				_hx_tmp = false;
            																			}
HXDLIN(  84)																			if (_hx_tmp) {
HXLINE(  84)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  84)																		if (forceClear) {
HXLINE(  84)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)																			int x = (dx - rectLeft);
HXDLIN(  84)																			int y = (dy - rectTop);
HXDLIN(  84)																			int index;
HXDLIN(  84)																			if (undoImage->useVirtualPos) {
HXLINE(  84)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  84)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  84)																			bool _hx_tmp;
HXDLIN(  84)																			if ((index >= 0)) {
HXLINE(  84)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  84)																				_hx_tmp = false;
            																			}
HXDLIN(  84)																			if (_hx_tmp) {
HXLINE(  84)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  84)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  84)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  84)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  84)											bool foundY = false;
HXDLIN(  84)											Float s = ((Float)0.);
HXDLIN(  84)											Float t = ((Float)0.);
HXDLIN(  84)											Float sxx = ((Float)0.);
HXDLIN(  84)											Float txx = ((Float)0.);
HXDLIN(  84)											{
HXLINE(  84)												int _g_min = xIter3->start;
HXDLIN(  84)												int _g_max = xIter3->max;
HXDLIN(  84)												while((_g_min < _g_max)){
HXLINE(  84)													_g_min = (_g_min + 1);
HXDLIN(  84)													int x = (_g_min - 1);
HXLINE( 223)													sxx = (sx * ( (Float)(x) ));
HXLINE( 224)													txx = (tx * ( (Float)(x) ));
HXLINE( 225)													foundY = false;
HXLINE(  84)													{
HXLINE(  84)														int _g_min1 = yIter3->start;
HXDLIN(  84)														int _g_max = yIter3->max;
HXDLIN(  84)														while((_g_min1 < _g_max)){
HXLINE(  84)															_g_min1 = (_g_min1 + 1);
HXDLIN(  84)															int y = (_g_min1 - 1);
HXLINE( 227)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  84)															bool _hx_tmp;
HXDLIN(  84)															if (!((s <= 0))) {
HXLINE(  84)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  84)																_hx_tmp = true;
            															}
HXDLIN(  84)															if (_hx_tmp) {
HXLINE(  84)																if (foundY) {
HXLINE(  84)																	goto _hx_goto_30;
            																}
            															}
            															else {
HXLINE(  84)																if (((s + t) < A)) {
HXLINE(  84)																	int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  84)																	int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  84)																	::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  84)																	int index;
HXDLIN(  84)																	if (tileImage->useVirtualPos) {
HXLINE(  84)																		index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																	}
            																	else {
HXLINE(  84)																		index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																	}
HXDLIN(  84)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																	int color;
HXDLIN(  84)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																		color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  84)																		color = c;
            																	}
HXDLIN(  84)																	{
HXLINE(  84)																		int this2 = color;
HXDLIN(  84)																		int c1 = this2;
HXDLIN(  84)																		bool _hx_tmp;
HXDLIN(  84)																		if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  84)																			_hx_tmp = temp->transparent;
            																		}
            																		else {
HXLINE(  84)																			_hx_tmp = false;
            																		}
HXDLIN(  84)																		if (_hx_tmp) {
HXLINE(  84)																			int location;
HXDLIN(  84)																			if (temp->useVirtualPos) {
HXLINE(  84)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																			}
            																			else {
HXLINE(  84)																				location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																			}
HXDLIN(  84)																			::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  84)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																			int this3 = this2;
HXDLIN(  84)																			int this4;
HXDLIN(  84)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  84)																				this4 = this3;
            																			}
HXDLIN(  84)																			Float a1;
HXDLIN(  84)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  84)																			if ((this5 == 0)) {
HXLINE(  84)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float r1;
HXDLIN(  84)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  84)																			if ((this6 == 0)) {
HXLINE(  84)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float g1;
HXDLIN(  84)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  84)																			if ((this7 == 0)) {
HXLINE(  84)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float b1;
HXDLIN(  84)																			int this8 = (this4 & 255);
HXDLIN(  84)																			if ((this8 == 0)) {
HXLINE(  84)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float a2;
HXDLIN(  84)																			int this9 = ((color >> 24) & 255);
HXDLIN(  84)																			if ((this9 == 0)) {
HXLINE(  84)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float r2;
HXDLIN(  84)																			int this10 = ((color >> 16) & 255);
HXDLIN(  84)																			if ((this10 == 0)) {
HXLINE(  84)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float g2;
HXDLIN(  84)																			int this11 = ((color >> 8) & 255);
HXDLIN(  84)																			if ((this11 == 0)) {
HXLINE(  84)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float b2;
HXDLIN(  84)																			int this12 = (color & 255);
HXDLIN(  84)																			if ((this12 == 0)) {
HXLINE(  84)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  84)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  84)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  84)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  84)																			{
HXLINE(  84)																				::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  84)																				int value;
HXDLIN(  84)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  84)																					value = blended;
            																				}
HXDLIN(  84)																				bool _hx_tmp;
HXDLIN(  84)																				if ((location >= 0)) {
HXLINE(  84)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  84)																					_hx_tmp = false;
            																				}
HXDLIN(  84)																				if (_hx_tmp) {
HXLINE(  84)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  84)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  84)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  84)																			::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)																			int index;
HXDLIN(  84)																			if (temp->useVirtualPos) {
HXLINE(  84)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																			}
            																			else {
HXLINE(  84)																				index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																			}
HXDLIN(  84)																			int value;
HXDLIN(  84)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																				value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																			}
            																			else {
HXLINE(  84)																				value = c1;
            																			}
HXDLIN(  84)																			bool _hx_tmp;
HXDLIN(  84)																			if ((index >= 0)) {
HXLINE(  84)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  84)																				_hx_tmp = false;
            																			}
HXDLIN(  84)																			if (_hx_tmp) {
HXLINE(  84)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE( 237)																	foundY = true;
            																}
            																else {
HXLINE(  84)																	if (foundY) {
HXLINE(  84)																		goto _hx_goto_30;
            																	}
            																}
            															}
            														}
            														_hx_goto_30:;
            													}
            												}
            											}
HXDLIN(  84)											if ((hasHit == false)) {
HXLINE(  84)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,innerCx,innerCy,bx,by,cx,cy,true);
HXDLIN(  84)												if (hasUndo) {
HXLINE(  84)													v->undoImage = undoImage;
HXDLIN(  84)													v->undoX = xIter3->start;
HXDLIN(  84)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE( 169)								lastX = nextX;
HXLINE( 170)								lastY = nextY;
            							}
            						}
            					}
            					else {
HXLINE(  84)						int _g = 0;
HXDLIN(  84)						int _g1 = (sides1 + 1);
HXDLIN(  84)						while((_g < _g1)){
HXLINE(  84)							_g = (_g + 1);
HXDLIN(  84)							int i = (_g - 1);
HXDLIN(  84)							Float nextX = (innerCx + (innerR * ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  84)							Float nextY = (innerCy + (innerR * ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  84)							{
HXLINE(  84)								bool hasHit = false;
HXDLIN(  84)								{
HXLINE(  84)									Float bx = lastX;
HXDLIN(  84)									Float by = lastY;
HXDLIN(  84)									Float cx = nextX;
HXDLIN(  84)									Float cy = nextY;
HXDLIN(  84)									bool adjustWinding = (((((innerCx * by) - (bx * innerCy)) + ((bx * cy) - (cx * by))) + ((cx * innerCy) - (innerCx * cy))) > 0);
HXDLIN(  84)									if (!(adjustWinding)) {
HXLINE(  84)										Float bx_ = bx;
HXDLIN(  84)										Float by_ = by;
HXLINE( 188)										bx = cx;
HXLINE( 189)										by = cy;
HXLINE( 190)										cx = bx_;
HXLINE( 191)										cy = by_;
            									}
HXLINE(  84)									{
HXLINE(  84)										bool hasUndo = false;
HXDLIN(  84)										Float s0 = ((innerCy * cx) - (innerCx * cy));
HXDLIN(  84)										Float sx = (cy - innerCy);
HXDLIN(  84)										Float sy = (innerCx - cx);
HXDLIN(  84)										Float t0 = ((innerCx * by) - (innerCy * bx));
HXDLIN(  84)										Float tx = (innerCy - by);
HXDLIN(  84)										Float ty = (bx - innerCx);
HXDLIN(  84)										Float A = ((((-(by) * cx) + (innerCy * (-(bx) + cx))) + (innerCx * (by - cy))) + (bx * cy));
HXDLIN(  84)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  84)										if ((innerCx > bx)) {
HXLINE(  84)											if ((innerCx > cx)) {
HXLINE(  84)												int min;
HXDLIN(  84)												if ((bx > cx)) {
HXLINE(  84)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  84)													min = ::Math_obj::floor(bx);
            												}
HXDLIN(  84)												int ii_min = min;
HXDLIN(  84)												int ii_max = ::Math_obj::ceil(innerCx);
HXDLIN(  84)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)												xIter3 = this1;
            											}
            											else {
HXLINE(  84)												int ii_min = ::Math_obj::floor(bx);
HXDLIN(  84)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  84)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  84)											if ((bx > cx)) {
HXLINE(  84)												int min;
HXDLIN(  84)												if ((innerCx > cx)) {
HXLINE(  84)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  84)													min = ::Math_obj::ceil(innerCx);
            												}
HXDLIN(  84)												int ii_min = min;
HXDLIN(  84)												int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  84)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)												xIter3 = this1;
            											}
            											else {
HXLINE(  84)												int ii_min = ::Math_obj::floor(innerCx);
HXDLIN(  84)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  84)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)												xIter3 = this1;
            											}
            										}
HXDLIN(  84)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  84)										if ((innerCy > by)) {
HXLINE(  84)											if ((innerCy > cy)) {
HXLINE(  84)												int min;
HXDLIN(  84)												if ((by > cy)) {
HXLINE(  84)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  84)													min = ::Math_obj::floor(by);
            												}
HXDLIN(  84)												int ii_min = min;
HXDLIN(  84)												int ii_max = ::Math_obj::ceil(innerCy);
HXDLIN(  84)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)												yIter3 = this1;
            											}
            											else {
HXLINE(  84)												int ii_min = ::Math_obj::floor(by);
HXDLIN(  84)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  84)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  84)											if ((by > cy)) {
HXLINE(  84)												int min;
HXDLIN(  84)												if ((innerCy > cy)) {
HXLINE(  84)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  84)													min = ::Math_obj::ceil(innerCy);
            												}
HXDLIN(  84)												int ii_min = min;
HXDLIN(  84)												int ii_max = ::Math_obj::ceil(by);
HXDLIN(  84)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)												yIter3 = this1;
            											}
            											else {
HXLINE(  84)												int ii_min = ::Math_obj::floor(innerCy);
HXDLIN(  84)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  84)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  84)												yIter3 = this1;
            											}
            										}
HXDLIN(  84)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  84)										if (hasUndo) {
HXLINE(  84)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  84)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  84)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  84)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  84)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  84)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  84)											undoImage = this3;
HXDLIN(  84)											{
HXLINE(  84)												int rectLeft = xIter3->start;
HXDLIN(  84)												int rectTop = yIter3->start;
HXDLIN(  84)												int rectRight = xIter3->max;
HXDLIN(  84)												bool forceClear = false;
HXDLIN(  84)												{
HXLINE(  84)													int _g = rectTop;
HXDLIN(  84)													int _g1 = yIter3->max;
HXDLIN(  84)													while((_g < _g1)){
HXLINE(  84)														_g = (_g + 1);
HXDLIN(  84)														int dy = (_g - 1);
HXDLIN(  84)														{
HXLINE(  84)															int _g1 = rectLeft;
HXDLIN(  84)															int _g2 = rectRight;
HXDLIN(  84)															while((_g1 < _g2)){
HXLINE(  84)																_g1 = (_g1 + 1);
HXDLIN(  84)																int dx = (_g1 - 1);
HXDLIN(  84)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)																int index;
HXDLIN(  84)																if (temp->useVirtualPos) {
HXLINE(  84)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            																}
            																else {
HXLINE(  84)																	index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            																}
HXDLIN(  84)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																int col;
HXDLIN(  84)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	col = c;
            																}
HXDLIN(  84)																bool _hx_tmp;
HXDLIN(  84)																if (temp->useMask) {
HXLINE(  84)																	_hx_tmp = ::hx::IsNotNull( temp->mask );
            																}
            																else {
HXLINE(  84)																	_hx_tmp = false;
            																}
HXDLIN(  84)																if (_hx_tmp) {
HXLINE(  84)																	::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  84)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  84)																	int index;
HXDLIN(  84)																	if (this1->useVirtualPos) {
HXLINE(  84)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  84)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  84)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  84)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  84)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																	int v;
HXDLIN(  84)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  84)																		v = c;
            																	}
HXDLIN(  84)																	int this3 = v;
HXDLIN(  84)																	int maskPixel = this3;
HXDLIN(  84)																	int this4 = col;
HXDLIN(  84)																	int this5 = this4;
HXDLIN(  84)																	if ((maskPixel == 0)) {
HXLINE(  84)																		int this1 = this5;
HXDLIN(  84)																		col = this1;
            																	}
            																	else {
HXLINE(  84)																		Float m0;
HXDLIN(  84)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  84)																		if ((this1 == 0)) {
HXLINE(  84)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float m1;
HXDLIN(  84)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  84)																		if ((this2 == 0)) {
HXLINE(  84)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float m2;
HXDLIN(  84)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  84)																		if ((this3 == 0)) {
HXLINE(  84)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float m3;
HXDLIN(  84)																		int this4 = (maskPixel & 255);
HXDLIN(  84)																		if ((this4 == 0)) {
HXLINE(  84)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  84)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  84)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  84)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  84)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  84)																if ((col != 0)) {
HXLINE(  84)																	int x = (dx - rectLeft);
HXDLIN(  84)																	int y = (dy - rectTop);
HXDLIN(  84)																	int this1 = col;
HXDLIN(  84)																	int c = this1;
HXDLIN(  84)																	bool _hx_tmp;
HXDLIN(  84)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  84)																		_hx_tmp = undoImage->transparent;
            																	}
            																	else {
HXLINE(  84)																		_hx_tmp = false;
            																	}
HXDLIN(  84)																	if (_hx_tmp) {
HXLINE(  84)																		int location;
HXDLIN(  84)																		if (undoImage->useVirtualPos) {
HXLINE(  84)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  84)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  84)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  84)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																		int this3 = this2;
HXDLIN(  84)																		int this4;
HXDLIN(  84)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  84)																			this4 = this3;
            																		}
HXDLIN(  84)																		Float a1;
HXDLIN(  84)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  84)																		if ((this5 == 0)) {
HXLINE(  84)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float r1;
HXDLIN(  84)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  84)																		if ((this6 == 0)) {
HXLINE(  84)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float g1;
HXDLIN(  84)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  84)																		if ((this7 == 0)) {
HXLINE(  84)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float b1;
HXDLIN(  84)																		int this8 = (this4 & 255);
HXDLIN(  84)																		if ((this8 == 0)) {
HXLINE(  84)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float a2;
HXDLIN(  84)																		int this9 = ((col >> 24) & 255);
HXDLIN(  84)																		if ((this9 == 0)) {
HXLINE(  84)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float r2;
HXDLIN(  84)																		int this10 = ((col >> 16) & 255);
HXDLIN(  84)																		if ((this10 == 0)) {
HXLINE(  84)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float g2;
HXDLIN(  84)																		int this11 = ((col >> 8) & 255);
HXDLIN(  84)																		if ((this11 == 0)) {
HXLINE(  84)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float b2;
HXDLIN(  84)																		int this12 = (col & 255);
HXDLIN(  84)																		if ((this12 == 0)) {
HXLINE(  84)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  84)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  84)																		{
HXLINE(  84)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  84)																			int value;
HXDLIN(  84)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  84)																				value = blended;
            																			}
HXDLIN(  84)																			bool _hx_tmp;
HXDLIN(  84)																			if ((location >= 0)) {
HXLINE(  84)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  84)																				_hx_tmp = false;
            																			}
HXDLIN(  84)																			if (_hx_tmp) {
HXLINE(  84)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  84)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  84)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  84)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)																		int index;
HXDLIN(  84)																		if (undoImage->useVirtualPos) {
HXLINE(  84)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  84)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  84)																		int value;
HXDLIN(  84)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  84)																			value = c;
            																		}
HXDLIN(  84)																		bool _hx_tmp;
HXDLIN(  84)																		if ((index >= 0)) {
HXLINE(  84)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  84)																			_hx_tmp = false;
            																		}
HXDLIN(  84)																		if (_hx_tmp) {
HXLINE(  84)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  84)																	if (forceClear) {
HXLINE(  84)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  84)																		int x = (dx - rectLeft);
HXDLIN(  84)																		int y = (dy - rectTop);
HXDLIN(  84)																		int index;
HXDLIN(  84)																		if (undoImage->useVirtualPos) {
HXLINE(  84)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  84)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  84)																		bool _hx_tmp;
HXDLIN(  84)																		if ((index >= 0)) {
HXLINE(  84)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  84)																			_hx_tmp = false;
            																		}
HXDLIN(  84)																		if (_hx_tmp) {
HXLINE(  84)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  84)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  84)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  84)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  84)										bool foundY = false;
HXDLIN(  84)										Float s = ((Float)0.);
HXDLIN(  84)										Float t = ((Float)0.);
HXDLIN(  84)										Float sxx = ((Float)0.);
HXDLIN(  84)										Float txx = ((Float)0.);
HXDLIN(  84)										{
HXLINE(  84)											int _g_min = xIter3->start;
HXDLIN(  84)											int _g_max = xIter3->max;
HXDLIN(  84)											while((_g_min < _g_max)){
HXLINE(  84)												_g_min = (_g_min + 1);
HXDLIN(  84)												int x = (_g_min - 1);
HXLINE( 223)												sxx = (sx * ( (Float)(x) ));
HXLINE( 224)												txx = (tx * ( (Float)(x) ));
HXLINE( 225)												foundY = false;
HXLINE(  84)												{
HXLINE(  84)													int _g_min1 = yIter3->start;
HXDLIN(  84)													int _g_max = yIter3->max;
HXDLIN(  84)													while((_g_min1 < _g_max)){
HXLINE(  84)														_g_min1 = (_g_min1 + 1);
HXDLIN(  84)														int y = (_g_min1 - 1);
HXLINE( 227)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE( 228)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  84)														bool _hx_tmp;
HXDLIN(  84)														if (!((s <= 0))) {
HXLINE(  84)															_hx_tmp = (t <= 0);
            														}
            														else {
HXLINE(  84)															_hx_tmp = true;
            														}
HXDLIN(  84)														if (_hx_tmp) {
HXLINE(  84)															if (foundY) {
HXLINE(  84)																goto _hx_goto_35;
            															}
            														}
            														else {
HXLINE(  84)															if (((s + t) < A)) {
HXLINE(  84)																int x1 = ::hx::Mod(x,tileImage->width);
HXDLIN(  84)																int y1 = ::hx::Mod(y,tileImage->height);
HXDLIN(  84)																::haxe::io::ArrayBufferViewImpl this1 = tileImage->image;
HXDLIN(  84)																int index;
HXDLIN(  84)																if (tileImage->useVirtualPos) {
HXLINE(  84)																	index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x1) - tileImage->virtualX));
            																}
            																else {
HXLINE(  84)																	index = ::Std_obj::_hx_int(( (Float)(((y1 * tileImage->width) + x1)) ));
            																}
HXDLIN(  84)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																int color;
HXDLIN(  84)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	color = c;
            																}
HXDLIN(  84)																{
HXLINE(  84)																	int this2 = color;
HXDLIN(  84)																	int c1 = this2;
HXDLIN(  84)																	bool _hx_tmp;
HXDLIN(  84)																	if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  84)																		_hx_tmp = temp->transparent;
            																	}
            																	else {
HXLINE(  84)																		_hx_tmp = false;
            																	}
HXDLIN(  84)																	if (_hx_tmp) {
HXLINE(  84)																		int location;
HXDLIN(  84)																		if (temp->useVirtualPos) {
HXLINE(  84)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																		}
            																		else {
HXLINE(  84)																			location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																		}
HXDLIN(  84)																		::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  84)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  84)																		int this3 = this2;
HXDLIN(  84)																		int this4;
HXDLIN(  84)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  84)																			this4 = this3;
            																		}
HXDLIN(  84)																		Float a1;
HXDLIN(  84)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  84)																		if ((this5 == 0)) {
HXLINE(  84)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float r1;
HXDLIN(  84)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  84)																		if ((this6 == 0)) {
HXLINE(  84)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float g1;
HXDLIN(  84)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  84)																		if ((this7 == 0)) {
HXLINE(  84)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float b1;
HXDLIN(  84)																		int this8 = (this4 & 255);
HXDLIN(  84)																		if ((this8 == 0)) {
HXLINE(  84)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float a2;
HXDLIN(  84)																		int this9 = ((color >> 24) & 255);
HXDLIN(  84)																		if ((this9 == 0)) {
HXLINE(  84)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float r2;
HXDLIN(  84)																		int this10 = ((color >> 16) & 255);
HXDLIN(  84)																		if ((this10 == 0)) {
HXLINE(  84)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float g2;
HXDLIN(  84)																		int this11 = ((color >> 8) & 255);
HXDLIN(  84)																		if ((this11 == 0)) {
HXLINE(  84)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float b2;
HXDLIN(  84)																		int this12 = (color & 255);
HXDLIN(  84)																		if ((this12 == 0)) {
HXLINE(  84)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  84)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  84)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  84)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  84)																		{
HXLINE(  84)																			::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  84)																			int value;
HXDLIN(  84)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  84)																				value = blended;
            																			}
HXDLIN(  84)																			bool _hx_tmp;
HXDLIN(  84)																			if ((location >= 0)) {
HXLINE(  84)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  84)																				_hx_tmp = false;
            																			}
HXDLIN(  84)																			if (_hx_tmp) {
HXLINE(  84)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  84)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  84)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  84)																		::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  84)																		int index;
HXDLIN(  84)																		if (temp->useVirtualPos) {
HXLINE(  84)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            																		}
            																		else {
HXLINE(  84)																			index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            																		}
HXDLIN(  84)																		int value;
HXDLIN(  84)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																			value = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																		}
            																		else {
HXLINE(  84)																			value = c1;
            																		}
HXDLIN(  84)																		bool _hx_tmp;
HXDLIN(  84)																		if ((index >= 0)) {
HXLINE(  84)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  84)																			_hx_tmp = false;
            																		}
HXDLIN(  84)																		if (_hx_tmp) {
HXLINE(  84)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  84)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  84)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  84)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  84)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  84)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE( 237)																foundY = true;
            															}
            															else {
HXLINE(  84)																if (foundY) {
HXLINE(  84)																	goto _hx_goto_35;
            																}
            															}
            														}
            													}
            													_hx_goto_35:;
            												}
            											}
            										}
HXDLIN(  84)										if ((hasHit == false)) {
HXLINE(  84)											::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,innerCx,innerCy,bx,by,cx,cy,true);
HXDLIN(  84)											if (hasUndo) {
HXLINE(  84)												v->undoImage = undoImage;
HXDLIN(  84)												v->undoX = xIter3->start;
HXDLIN(  84)												v->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE( 177)							lastX = nextX;
HXLINE( 178)							lastY = nextY;
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(CirclePattern_obj,buildCircle,(void))


::hx::ObjectPtr< CirclePattern_obj > CirclePattern_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_diameter) {
	::hx::ObjectPtr< CirclePattern_obj > __this = new CirclePattern_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale,__o_left,__o_top,__o_diameter);
	return __this;
}

::hx::ObjectPtr< CirclePattern_obj > CirclePattern_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_strokeColor0,::hx::Null< int >  __o_strokeColor1,::hx::Null< int >  __o_fillColor0,::hx::Null< int >  __o_fillColor1,::Array< bool > strokePatternFill, ::Dynamic strokePatternWidth, ::Dynamic strokePatternHeight,::hx::Null< bool >  __o_strokePatternAcross,::hx::Null< int >  __o_strokePatternScale,::Array< bool > fillPatternFill,::hx::Null< int >  __o_fillPatternWidth,::hx::Null< int >  __o_fillPatternHeight,::hx::Null< bool >  __o_fillPatternAcross,::hx::Null< int >  __o_fillPatternScale,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_diameter) {
	CirclePattern_obj *__this = (CirclePattern_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(CirclePattern_obj), true, "pixelimage.triangleGML.patternShape.CirclePattern"));
	*(void **)__this = CirclePattern_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_strokeColor0,__o_strokeColor1,__o_fillColor0,__o_fillColor1,strokePatternFill,strokePatternWidth,strokePatternHeight,__o_strokePatternAcross,__o_strokePatternScale,fillPatternFill,__o_fillPatternWidth,__o_fillPatternHeight,__o_fillPatternAcross,__o_fillPatternScale,__o_left,__o_top,__o_diameter);
	return __this;
}

CirclePattern_obj::CirclePattern_obj()
{
}

::hx::Val CirclePattern_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { return ::hx::Val( top ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { return ::hx::Val( left ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"diameter") ) { return ::hx::Val( diameter ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"buildCircle") ) { return ::hx::Val( buildCircle_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val CirclePattern_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { top=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { left=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"diameter") ) { diameter=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void CirclePattern_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("left",07,08,b0,47));
	outFields->push(HX_("top",95,66,58,00));
	outFields->push(HX_("diameter",cd,6e,68,34));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo CirclePattern_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(CirclePattern_obj,left),HX_("left",07,08,b0,47)},
	{::hx::fsFloat,(int)offsetof(CirclePattern_obj,top),HX_("top",95,66,58,00)},
	{::hx::fsFloat,(int)offsetof(CirclePattern_obj,diameter),HX_("diameter",cd,6e,68,34)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *CirclePattern_obj_sStaticStorageInfo = 0;
#endif

static ::String CirclePattern_obj_sMemberFields[] = {
	HX_("left",07,08,b0,47),
	HX_("top",95,66,58,00),
	HX_("diameter",cd,6e,68,34),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	HX_("buildCircle",de,57,7e,a6),
	::String(null()) };

::hx::Class CirclePattern_obj::__mClass;

void CirclePattern_obj::__register()
{
	CirclePattern_obj _hx_dummy;
	CirclePattern_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.patternShape.CirclePattern",8c,c8,74,0a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(CirclePattern_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< CirclePattern_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CirclePattern_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CirclePattern_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace patternShape
