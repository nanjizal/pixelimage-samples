// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicGradient
#include <pixelimage/triangleGML/coreShape/BasicGradient.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_gradientContour_PolyLineGradient
#include <pixelimage/triangleGML/gradientContour/PolyLineGradient.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_89ddf991eed8df6c_22_new,"pixelimage.triangleGML.gradientContour.PolyLineGradient","new",0xbdedfeef,"pixelimage.triangleGML.gradientContour.PolyLineGradient.new","pixelimage/triangleGML/gradientContour/PolyLineGradient.hx",22,0x62992fbe)
HX_LOCAL_STACK_FRAME(_hx_pos_89ddf991eed8df6c_29_setParameter,"pixelimage.triangleGML.gradientContour.PolyLineGradient","setParameter",0xf748fd38,"pixelimage.triangleGML.gradientContour.PolyLineGradient.setParameter","pixelimage/triangleGML/gradientContour/PolyLineGradient.hx",29,0x62992fbe)
HX_LOCAL_STACK_FRAME(_hx_pos_89ddf991eed8df6c_44_render,"pixelimage.triangleGML.gradientContour.PolyLineGradient","render",0x0a258027,"pixelimage.triangleGML.gradientContour.PolyLineGradient.render","pixelimage/triangleGML/gradientContour/PolyLineGradient.hx",44,0x62992fbe)
namespace pixelimage{
namespace triangleGML{
namespace gradientContour{

void PolyLineGradient_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< Float >  __o_strokeWidth,::Array< Float > points,::String __o_colorDirection,::Array< int > colors){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		::String colorDirection = __o_colorDirection;
            		if (::hx::IsNull(__o_colorDirection)) colorDirection = HX_("longways",e0,7b,90,c1);
            	HX_STACKFRAME(&_hx_pos_89ddf991eed8df6c_22_new)
HXLINE(  23)		super::__construct(opacity,visibility,colors);
HXLINE(  24)		this->strokeWidth = strokeWidth;
HXLINE(  25)		this->colorDirection = colorDirection;
HXLINE(  26)		this->points = points;
            	}

Dynamic PolyLineGradient_obj::__CreateEmpty() { return new PolyLineGradient_obj; }

void *PolyLineGradient_obj::_hx_vtable = 0;

Dynamic PolyLineGradient_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PolyLineGradient_obj > _hx_result = new PolyLineGradient_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5]);
	return _hx_result;
}

bool PolyLineGradient_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x1c0b7691) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x1c0b7691;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x68e012c5;
	}
}

void PolyLineGradient_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_89ddf991eed8df6c_29_setParameter)
HXDLIN(  29)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("colorDirection",5c,0c,ed,77)) ){
HXLINE(  36)			::String _hx_tmp;
HXDLIN(  36)			if ((value == HX_("widthways",6a,99,4f,54))) {
HXLINE(  36)				_hx_tmp = HX_("widthways",6a,99,4f,54);
            			}
            			else {
HXLINE(  36)				_hx_tmp = HX_("longways",e0,7b,90,c1);
            			}
HXDLIN(  36)			this->colorDirection = _hx_tmp;
HXDLIN(  36)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("colors",b0,c5,86,c6)) ){
HXLINE(  38)			value = value.split(HX_("[",5b,00,00,00))->__get(1).split(HX_("]",5d,00,00,00))->__get(0);
HXLINE(  39)			::Array< int > _g = ::Array_obj< int >::__new(0);
HXDLIN(  39)			{
HXLINE(  39)				int _g1 = 0;
HXDLIN(  39)				::Array< ::String > _g2 = value.split(HX_(",",2c,00,00,00));
HXDLIN(  39)				while((_g1 < _g2->length)){
HXLINE(  39)					::String n = _g2->__get(_g1);
HXDLIN(  39)					_g1 = (_g1 + 1);
HXDLIN(  39)					_g->push(::Std_obj::parseInt(n));
            				}
            			}
HXDLIN(  39)			this->cornerColors = _g;
HXLINE(  37)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("points",23,12,2e,f7)) ){
HXLINE(  33)			value = value.split(HX_("[",5b,00,00,00))->__get(1).split(HX_("]",5d,00,00,00))->__get(0);
HXLINE(  34)			::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN(  34)			{
HXLINE(  34)				int _g1 = 0;
HXDLIN(  34)				::Array< ::String > _g2 = value.split(HX_(",",2c,00,00,00));
HXDLIN(  34)				while((_g1 < _g2->length)){
HXLINE(  34)					::String n = _g2->__get(_g1);
HXDLIN(  34)					_g1 = (_g1 + 1);
HXDLIN(  34)					_g->push(::Std_obj::parseFloat(n));
            				}
            			}
HXDLIN(  34)			this->points = _g;
HXLINE(  32)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("strokeWidth",2e,f7,1c,e3)) ){
HXLINE(  31)			this->strokeWidth = ::Std_obj::parseFloat(value);
HXDLIN(  31)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  41)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct PolyLineGradient_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_89ddf991eed8df6c_44_render)
HXLINE(  45)		{
HXLINE(  46)			int l = this->points->length;
HXLINE(  47)			if ((l < 4)) {
HXLINE(  47)				return pixelShape;
            			}
HXLINE(  48)			if ((::hx::Mod(l,2) != 0)) {
HXLINE(  48)				return pixelShape;
            			}
HXLINE(  49)			int i = 0;
HXLINE(  50)			Float x = ((Float)0.);
HXLINE(  51)			Float y = ((Float)0.);
HXLINE(  52)			Float nextX = ((Float)0.);
HXLINE(  53)			Float nextY = ((Float)0.);
HXLINE(  54)			x = (this->points->__get(i) + this->offX);
HXLINE(  55)			i = (i + 1);
HXLINE(  56)			y = (this->points->__get(i) + this->offY);
HXLINE(  57)			i = (i + 1);
HXLINE(  58)			int colorCount = 0;
HXLINE(  59)			int colorLen = this->cornerColors->length;
HXLINE(  60)			int colorA = 0;
HXLINE(  61)			int colorB = 0;
HXLINE(  62)			int colorC = 0;
HXLINE(  63)			int colorD = 0;
HXLINE(  64)			while((i < l)){
HXLINE(  65)				x = (this->points->__get(i) + this->offX);
HXLINE(  66)				i = (i + 1);
HXLINE(  67)				y = (this->points->__get(i) + this->offY);
HXLINE(  68)				i = (i + 1);
HXLINE(  69)				nextX = x;
HXLINE(  70)				nextY = y;
HXLINE(  71)				if ((this->colorDirection == HX_("longways",e0,7b,90,c1))) {
HXLINE(  72)					if ((colorCount >= colorLen)) {
HXLINE(  72)						colorCount = 0;
            					}
HXLINE(  73)					colorA = this->cornerColors->__get(colorCount);
HXLINE(  74)					colorD = colorA;
HXLINE(  75)					colorCount = (colorCount + 1);
HXLINE(  76)					if ((colorCount >= colorLen)) {
HXLINE(  76)						colorCount = 0;
            					}
HXLINE(  77)					colorB = this->cornerColors->__get(colorCount);
HXLINE(  78)					colorC = colorB;
            				}
            				else {
HXLINE(  80)					if ((colorCount >= colorLen)) {
HXLINE(  80)						colorCount = 0;
            					}
HXLINE(  81)					colorA = this->cornerColors->__get(colorCount);
HXLINE(  82)					colorB = colorA;
HXLINE(  83)					colorCount = (colorCount + 1);
HXLINE(  84)					if ((colorCount >= colorLen)) {
HXLINE(  84)						colorCount = 0;
            					}
HXLINE(  85)					colorD = this->cornerColors->__get(colorCount);
HXLINE(  86)					colorC = colorD;
HXLINE(  88)					colorCount = (colorCount + 1);
HXLINE(  89)					if ((colorCount >= colorLen)) {
HXLINE(  89)						colorCount = 0;
            					}
            				}
HXLINE(  91)				{
HXLINE(  91)					bool hasHit = false;
HXDLIN(  91)					Float o = (nextY - y);
HXDLIN(  91)					Float a = (nextX - x);
HXDLIN(  91)					Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  91)					Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  91)					{
HXLINE(  91)						 ::Dynamic debugCorners = false;
HXDLIN(  91)						if (::hx::IsNull( debugCorners )) {
HXLINE( 910)							debugCorners = false;
            						}
HXLINE(  91)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  91)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  91)						Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  91)						Float dx = ((Float)0.1);
HXDLIN(  91)						Float dy = radius;
HXDLIN(  91)						Float cx = h;
HXDLIN(  91)						Float cy = radius;
HXDLIN(  91)						Float bx = h;
HXDLIN(  91)						Float by = -(radius);
HXDLIN(  91)						Float ax = ((Float)0.1);
HXDLIN(  91)						Float ay = -(radius);
HXDLIN(  91)						Float temp = ((Float)0.);
HXLINE( 474)						temp = (x + ((ax * cos) - (ay * sin)));
HXLINE( 475)						ay = (y + ((ay * cos) + (ax * sin)));
HXLINE( 476)						ax = temp;
HXLINE( 478)						temp = (x + ((bx * cos) - (by * sin)));
HXLINE( 479)						by = (y + ((by * cos) + (bx * sin)));
HXLINE( 480)						bx = temp;
HXLINE( 482)						temp = (x + ((cx * cos) - (cy * sin)));
HXLINE( 483)						cy = (y + ((cy * cos) + (cx * sin)));
HXLINE( 484)						cx = temp;
HXLINE( 486)						temp = (x + ((dx * cos) - (dy * sin)));
HXLINE( 487)						dy = (y + ((dy * cos) + (dx * sin)));
HXLINE( 488)						dx = temp;
HXLINE(  91)						if (( (bool)(debugCorners) )) {
HXLINE(  91)							{
HXLINE(  91)								Float x = (ax - ((Float)6.));
HXDLIN(  91)								Float y = (ay - ((Float)6.));
HXDLIN(  91)								int p = ::Std_obj::_hx_int(x);
HXDLIN(  91)								int xx = p;
HXDLIN(  91)								int q = ::Std_obj::_hx_int(y);
HXDLIN(  91)								int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  91)								int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  91)								while(true){
HXLINE(  91)									{
HXLINE(  91)										p = (p + 1);
HXDLIN(  91)										int x = (p - 1);
HXDLIN(  91)										int this1 = colorA;
HXDLIN(  91)										int c = this1;
HXDLIN(  91)										bool _hx_tmp;
HXDLIN(  91)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  91)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  91)											_hx_tmp = false;
            										}
HXDLIN(  91)										if (_hx_tmp) {
HXLINE(  91)											int location;
HXDLIN(  91)											if (pixelShape->useVirtualPos) {
HXLINE(  91)												location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  91)												location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            											}
HXDLIN(  91)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)											int this3 = this2;
HXDLIN(  91)											int this4;
HXDLIN(  91)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  91)												this4 = this3;
            											}
HXDLIN(  91)											Float a1;
HXDLIN(  91)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  91)											if ((this5 == 0)) {
HXLINE(  91)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float r1;
HXDLIN(  91)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  91)											if ((this6 == 0)) {
HXLINE(  91)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float g1;
HXDLIN(  91)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  91)											if ((this7 == 0)) {
HXLINE(  91)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float b1;
HXDLIN(  91)											int this8 = (this4 & 255);
HXDLIN(  91)											if ((this8 == 0)) {
HXLINE(  91)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float a2;
HXDLIN(  91)											int this9 = ((colorA >> 24) & 255);
HXDLIN(  91)											if ((this9 == 0)) {
HXLINE(  91)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float r2;
HXDLIN(  91)											int this10 = ((colorA >> 16) & 255);
HXDLIN(  91)											if ((this10 == 0)) {
HXLINE(  91)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float g2;
HXDLIN(  91)											int this11 = ((colorA >> 8) & 255);
HXDLIN(  91)											if ((this11 == 0)) {
HXLINE(  91)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float b2;
HXDLIN(  91)											int this12 = (colorA & 255);
HXDLIN(  91)											if ((this12 == 0)) {
HXLINE(  91)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)											{
HXLINE(  91)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  91)												int value;
HXDLIN(  91)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  91)													value = blended;
            												}
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												if ((location >= 0)) {
HXLINE(  91)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  91)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)											int index;
HXDLIN(  91)											if (pixelShape->useVirtualPos) {
HXLINE(  91)												index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  91)												index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            											}
HXDLIN(  91)											int value;
HXDLIN(  91)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  91)												value = c;
            											}
HXDLIN(  91)											bool _hx_tmp;
HXDLIN(  91)											if ((index >= 0)) {
HXLINE(  91)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  91)												_hx_tmp = false;
            											}
HXDLIN(  91)											if (_hx_tmp) {
HXLINE(  91)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXDLIN(  91)									if ((p > maxX)) {
HXLINE( 247)										p = xx;
HXLINE(  91)										q = (q + 1);
            									}
HXDLIN(  91)									if ((q > maxY)) {
HXLINE(  91)										goto _hx_goto_6;
            									}
            								}
            								_hx_goto_6:;
            							}
HXDLIN(  91)							{
HXLINE(  91)								Float x1 = (bx - ((Float)6.));
HXDLIN(  91)								Float y1 = (by - ((Float)6.));
HXDLIN(  91)								int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  91)								int xx1 = p1;
HXDLIN(  91)								int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  91)								int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  91)								int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  91)								while(true){
HXLINE(  91)									{
HXLINE(  91)										p1 = (p1 + 1);
HXDLIN(  91)										int x = (p1 - 1);
HXDLIN(  91)										int this1 = colorB;
HXDLIN(  91)										int c = this1;
HXDLIN(  91)										bool _hx_tmp;
HXDLIN(  91)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  91)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  91)											_hx_tmp = false;
            										}
HXDLIN(  91)										if (_hx_tmp) {
HXLINE(  91)											int location;
HXDLIN(  91)											if (pixelShape->useVirtualPos) {
HXLINE(  91)												location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  91)												location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            											}
HXDLIN(  91)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)											int this3 = this2;
HXDLIN(  91)											int this4;
HXDLIN(  91)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  91)												this4 = this3;
            											}
HXDLIN(  91)											Float a1;
HXDLIN(  91)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  91)											if ((this5 == 0)) {
HXLINE(  91)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float r1;
HXDLIN(  91)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  91)											if ((this6 == 0)) {
HXLINE(  91)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float g1;
HXDLIN(  91)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  91)											if ((this7 == 0)) {
HXLINE(  91)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float b1;
HXDLIN(  91)											int this8 = (this4 & 255);
HXDLIN(  91)											if ((this8 == 0)) {
HXLINE(  91)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float a2;
HXDLIN(  91)											int this9 = ((colorB >> 24) & 255);
HXDLIN(  91)											if ((this9 == 0)) {
HXLINE(  91)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float r2;
HXDLIN(  91)											int this10 = ((colorB >> 16) & 255);
HXDLIN(  91)											if ((this10 == 0)) {
HXLINE(  91)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float g2;
HXDLIN(  91)											int this11 = ((colorB >> 8) & 255);
HXDLIN(  91)											if ((this11 == 0)) {
HXLINE(  91)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float b2;
HXDLIN(  91)											int this12 = (colorB & 255);
HXDLIN(  91)											if ((this12 == 0)) {
HXLINE(  91)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)											{
HXLINE(  91)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  91)												int value;
HXDLIN(  91)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  91)													value = blended;
            												}
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												if ((location >= 0)) {
HXLINE(  91)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  91)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)											int index;
HXDLIN(  91)											if (pixelShape->useVirtualPos) {
HXLINE(  91)												index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  91)												index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            											}
HXDLIN(  91)											int value;
HXDLIN(  91)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  91)												value = c;
            											}
HXDLIN(  91)											bool _hx_tmp;
HXDLIN(  91)											if ((index >= 0)) {
HXLINE(  91)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  91)												_hx_tmp = false;
            											}
HXDLIN(  91)											if (_hx_tmp) {
HXLINE(  91)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXDLIN(  91)									if ((p1 > maxX1)) {
HXLINE( 247)										p1 = xx1;
HXLINE(  91)										q1 = (q1 + 1);
            									}
HXDLIN(  91)									if ((q1 > maxY1)) {
HXLINE(  91)										goto _hx_goto_7;
            									}
            								}
            								_hx_goto_7:;
            							}
HXDLIN(  91)							{
HXLINE(  91)								Float x2 = (cx - ((Float)6.));
HXDLIN(  91)								Float y2 = (cy - ((Float)6.));
HXDLIN(  91)								int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  91)								int xx2 = p2;
HXDLIN(  91)								int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  91)								int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  91)								int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  91)								while(true){
HXLINE(  91)									{
HXLINE(  91)										p2 = (p2 + 1);
HXDLIN(  91)										int x = (p2 - 1);
HXDLIN(  91)										int this1 = colorC;
HXDLIN(  91)										int c = this1;
HXDLIN(  91)										bool _hx_tmp;
HXDLIN(  91)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  91)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  91)											_hx_tmp = false;
            										}
HXDLIN(  91)										if (_hx_tmp) {
HXLINE(  91)											int location;
HXDLIN(  91)											if (pixelShape->useVirtualPos) {
HXLINE(  91)												location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  91)												location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            											}
HXDLIN(  91)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)											int this3 = this2;
HXDLIN(  91)											int this4;
HXDLIN(  91)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  91)												this4 = this3;
            											}
HXDLIN(  91)											Float a1;
HXDLIN(  91)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  91)											if ((this5 == 0)) {
HXLINE(  91)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float r1;
HXDLIN(  91)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  91)											if ((this6 == 0)) {
HXLINE(  91)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float g1;
HXDLIN(  91)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  91)											if ((this7 == 0)) {
HXLINE(  91)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float b1;
HXDLIN(  91)											int this8 = (this4 & 255);
HXDLIN(  91)											if ((this8 == 0)) {
HXLINE(  91)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float a2;
HXDLIN(  91)											int this9 = ((colorC >> 24) & 255);
HXDLIN(  91)											if ((this9 == 0)) {
HXLINE(  91)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float r2;
HXDLIN(  91)											int this10 = ((colorC >> 16) & 255);
HXDLIN(  91)											if ((this10 == 0)) {
HXLINE(  91)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float g2;
HXDLIN(  91)											int this11 = ((colorC >> 8) & 255);
HXDLIN(  91)											if ((this11 == 0)) {
HXLINE(  91)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float b2;
HXDLIN(  91)											int this12 = (colorC & 255);
HXDLIN(  91)											if ((this12 == 0)) {
HXLINE(  91)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)											{
HXLINE(  91)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  91)												int value;
HXDLIN(  91)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  91)													value = blended;
            												}
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												if ((location >= 0)) {
HXLINE(  91)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  91)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)											int index;
HXDLIN(  91)											if (pixelShape->useVirtualPos) {
HXLINE(  91)												index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  91)												index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            											}
HXDLIN(  91)											int value;
HXDLIN(  91)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  91)												value = c;
            											}
HXDLIN(  91)											bool _hx_tmp;
HXDLIN(  91)											if ((index >= 0)) {
HXLINE(  91)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  91)												_hx_tmp = false;
            											}
HXDLIN(  91)											if (_hx_tmp) {
HXLINE(  91)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXDLIN(  91)									if ((p2 > maxX2)) {
HXLINE( 247)										p2 = xx2;
HXLINE(  91)										q2 = (q2 + 1);
            									}
HXDLIN(  91)									if ((q2 > maxY2)) {
HXLINE(  91)										goto _hx_goto_8;
            									}
            								}
            								_hx_goto_8:;
            							}
HXDLIN(  91)							{
HXLINE(  91)								Float x3 = (dx - ((Float)6.));
HXDLIN(  91)								Float y3 = (dy - ((Float)6.));
HXDLIN(  91)								int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  91)								int xx3 = p3;
HXDLIN(  91)								int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  91)								int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  91)								int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  91)								while(true){
HXLINE(  91)									{
HXLINE(  91)										p3 = (p3 + 1);
HXDLIN(  91)										int x = (p3 - 1);
HXDLIN(  91)										int this1 = colorD;
HXDLIN(  91)										int c = this1;
HXDLIN(  91)										bool _hx_tmp;
HXDLIN(  91)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  91)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  91)											_hx_tmp = false;
            										}
HXDLIN(  91)										if (_hx_tmp) {
HXLINE(  91)											int location;
HXDLIN(  91)											if (pixelShape->useVirtualPos) {
HXLINE(  91)												location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  91)												location = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            											}
HXDLIN(  91)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)											int this3 = this2;
HXDLIN(  91)											int this4;
HXDLIN(  91)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  91)												this4 = this3;
            											}
HXDLIN(  91)											Float a1;
HXDLIN(  91)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  91)											if ((this5 == 0)) {
HXLINE(  91)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float r1;
HXDLIN(  91)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  91)											if ((this6 == 0)) {
HXLINE(  91)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float g1;
HXDLIN(  91)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  91)											if ((this7 == 0)) {
HXLINE(  91)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float b1;
HXDLIN(  91)											int this8 = (this4 & 255);
HXDLIN(  91)											if ((this8 == 0)) {
HXLINE(  91)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float a2;
HXDLIN(  91)											int this9 = ((colorD >> 24) & 255);
HXDLIN(  91)											if ((this9 == 0)) {
HXLINE(  91)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float r2;
HXDLIN(  91)											int this10 = ((colorD >> 16) & 255);
HXDLIN(  91)											if ((this10 == 0)) {
HXLINE(  91)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float g2;
HXDLIN(  91)											int this11 = ((colorD >> 8) & 255);
HXDLIN(  91)											if ((this11 == 0)) {
HXLINE(  91)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float b2;
HXDLIN(  91)											int this12 = (colorD & 255);
HXDLIN(  91)											if ((this12 == 0)) {
HXLINE(  91)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  91)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  91)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)											{
HXLINE(  91)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  91)												int value;
HXDLIN(  91)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  91)													value = blended;
            												}
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												if ((location >= 0)) {
HXLINE(  91)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  91)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)											int index;
HXDLIN(  91)											if (pixelShape->useVirtualPos) {
HXLINE(  91)												index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  91)												index = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            											}
HXDLIN(  91)											int value;
HXDLIN(  91)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  91)												value = c;
            											}
HXDLIN(  91)											bool _hx_tmp;
HXDLIN(  91)											if ((index >= 0)) {
HXLINE(  91)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  91)												_hx_tmp = false;
            											}
HXDLIN(  91)											if (_hx_tmp) {
HXLINE(  91)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXDLIN(  91)									if ((p3 > maxX3)) {
HXLINE( 247)										p3 = xx3;
HXLINE(  91)										q3 = (q3 + 1);
            									}
HXDLIN(  91)									if ((q3 > maxY3)) {
HXLINE(  91)										goto _hx_goto_9;
            									}
            								}
            								_hx_goto_9:;
            							}
            						}
HXDLIN(  91)						{
HXLINE(  91)							{
HXLINE(  91)								bool hasUndo = false;
HXDLIN(  91)								int aA = ((colorB >> 24) & 255);
HXDLIN(  91)								int rA = ((colorB >> 16) & 255);
HXDLIN(  91)								int gA = ((colorB >> 8) & 255);
HXDLIN(  91)								int bA = (colorB & 255);
HXDLIN(  91)								int aB = ((colorA >> 24) & 255);
HXDLIN(  91)								int rB = ((colorA >> 16) & 255);
HXDLIN(  91)								int gB = ((colorA >> 8) & 255);
HXDLIN(  91)								int bB = (colorA & 255);
HXDLIN(  91)								int aC = ((colorD >> 24) & 255);
HXDLIN(  91)								int rC = ((colorD >> 16) & 255);
HXDLIN(  91)								int gC = ((colorD >> 8) & 255);
HXDLIN(  91)								int bC = (colorD & 255);
HXDLIN(  91)								Float bcx = (bx - dx);
HXDLIN(  91)								Float bcy = (by - dy);
HXDLIN(  91)								Float acx = (ax - dx);
HXDLIN(  91)								Float acy = (ay - dy);
HXDLIN(  91)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  91)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  91)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  91)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  91)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  91)								if ((ax > bx)) {
HXLINE(  91)									if ((ax > dx)) {
HXLINE(  91)										int min;
HXDLIN(  91)										if ((bx > dx)) {
HXLINE(  91)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  91)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  91)										int ii_min = min;
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										xIter3 = this1;
            									}
            									else {
HXLINE(  91)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  91)									if ((bx > dx)) {
HXLINE(  91)										int min;
HXDLIN(  91)										if ((ax > dx)) {
HXLINE(  91)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  91)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  91)										int ii_min = min;
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										xIter3 = this1;
            									}
            									else {
HXLINE(  91)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										xIter3 = this1;
            									}
            								}
HXDLIN(  91)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  91)								if ((ay > by)) {
HXLINE(  91)									if ((ay > dy)) {
HXLINE(  91)										int min;
HXDLIN(  91)										if ((by > dy)) {
HXLINE(  91)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  91)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  91)										int ii_min = min;
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										yIter3 = this1;
            									}
            									else {
HXLINE(  91)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  91)									if ((by > dy)) {
HXLINE(  91)										int min;
HXDLIN(  91)										if ((ay > dy)) {
HXLINE(  91)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  91)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  91)										int ii_min = min;
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										yIter3 = this1;
            									}
            									else {
HXLINE(  91)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										yIter3 = this1;
            									}
            								}
HXDLIN(  91)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  91)								if (hasUndo) {
HXLINE(  91)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  91)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  91)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  91)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  91)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  91)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  91)									undoImage = this3;
HXDLIN(  91)									{
HXLINE(  91)										int rectLeft = xIter3->start;
HXDLIN(  91)										int rectTop = yIter3->start;
HXDLIN(  91)										int rectRight = xIter3->max;
HXDLIN(  91)										bool forceClear = false;
HXDLIN(  91)										{
HXLINE(  91)											int _g = rectTop;
HXDLIN(  91)											int _g1 = yIter3->max;
HXDLIN(  91)											while((_g < _g1)){
HXLINE(  91)												_g = (_g + 1);
HXDLIN(  91)												int dy = (_g - 1);
HXDLIN(  91)												{
HXLINE(  91)													int _g1 = rectLeft;
HXDLIN(  91)													int _g2 = rectRight;
HXDLIN(  91)													while((_g1 < _g2)){
HXLINE(  91)														_g1 = (_g1 + 1);
HXDLIN(  91)														int dx = (_g1 - 1);
HXDLIN(  91)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)														int index;
HXDLIN(  91)														if (pixelShape->useVirtualPos) {
HXLINE(  91)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  91)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  91)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)														int col;
HXDLIN(  91)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  91)															col = c;
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if (pixelShape->useMask) {
HXLINE(  91)															_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  91)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  91)															int index;
HXDLIN(  91)															if (this1->useVirtualPos) {
HXLINE(  91)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  91)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  91)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  91)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  91)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)															int v;
HXDLIN(  91)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  91)																v = c;
            															}
HXDLIN(  91)															int this3 = v;
HXDLIN(  91)															int maskPixel = this3;
HXDLIN(  91)															int this4 = col;
HXDLIN(  91)															int this5 = this4;
HXDLIN(  91)															if ((maskPixel == 0)) {
HXLINE(  91)																int this1 = this5;
HXDLIN(  91)																col = this1;
            															}
            															else {
HXLINE(  91)																Float m0;
HXDLIN(  91)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  91)																if ((this1 == 0)) {
HXLINE(  91)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float m1;
HXDLIN(  91)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  91)																if ((this2 == 0)) {
HXLINE(  91)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float m2;
HXDLIN(  91)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  91)																if ((this3 == 0)) {
HXLINE(  91)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float m3;
HXDLIN(  91)																int this4 = (maskPixel & 255);
HXDLIN(  91)																if ((this4 == 0)) {
HXLINE(  91)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  91)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  91)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  91)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  91)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  91)														if ((col != 0)) {
HXLINE(  91)															int x = (dx - rectLeft);
HXDLIN(  91)															int y = (dy - rectTop);
HXDLIN(  91)															int this1 = col;
HXDLIN(  91)															int c = this1;
HXDLIN(  91)															bool _hx_tmp;
HXDLIN(  91)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  91)																_hx_tmp = undoImage->transparent;
            															}
            															else {
HXLINE(  91)																_hx_tmp = false;
            															}
HXDLIN(  91)															if (_hx_tmp) {
HXLINE(  91)																int location;
HXDLIN(  91)																if (undoImage->useVirtualPos) {
HXLINE(  91)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  91)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  91)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  91)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)																int this3 = this2;
HXDLIN(  91)																int this4;
HXDLIN(  91)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  91)																	this4 = this3;
            																}
HXDLIN(  91)																Float a1;
HXDLIN(  91)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  91)																if ((this5 == 0)) {
HXLINE(  91)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float r1;
HXDLIN(  91)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  91)																if ((this6 == 0)) {
HXLINE(  91)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float g1;
HXDLIN(  91)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  91)																if ((this7 == 0)) {
HXLINE(  91)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float b1;
HXDLIN(  91)																int this8 = (this4 & 255);
HXDLIN(  91)																if ((this8 == 0)) {
HXLINE(  91)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float a2;
HXDLIN(  91)																int this9 = ((col >> 24) & 255);
HXDLIN(  91)																if ((this9 == 0)) {
HXLINE(  91)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float r2;
HXDLIN(  91)																int this10 = ((col >> 16) & 255);
HXDLIN(  91)																if ((this10 == 0)) {
HXLINE(  91)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float g2;
HXDLIN(  91)																int this11 = ((col >> 8) & 255);
HXDLIN(  91)																if ((this11 == 0)) {
HXLINE(  91)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float b2;
HXDLIN(  91)																int this12 = (col & 255);
HXDLIN(  91)																if ((this12 == 0)) {
HXLINE(  91)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)																{
HXLINE(  91)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  91)																	int value;
HXDLIN(  91)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  91)																		value = blended;
            																	}
HXDLIN(  91)																	bool _hx_tmp;
HXDLIN(  91)																	if ((location >= 0)) {
HXLINE(  91)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  91)																		_hx_tmp = false;
            																	}
HXDLIN(  91)																	if (_hx_tmp) {
HXLINE(  91)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  91)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  91)																int index;
HXDLIN(  91)																if (undoImage->useVirtualPos) {
HXLINE(  91)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  91)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  91)																int value;
HXDLIN(  91)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  91)																	value = c;
            																}
HXDLIN(  91)																bool _hx_tmp;
HXDLIN(  91)																if ((index >= 0)) {
HXLINE(  91)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  91)																	_hx_tmp = false;
            																}
HXDLIN(  91)																if (_hx_tmp) {
HXLINE(  91)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  91)															if (forceClear) {
HXLINE(  91)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  91)																int x = (dx - rectLeft);
HXDLIN(  91)																int y = (dy - rectTop);
HXDLIN(  91)																int index;
HXDLIN(  91)																if (undoImage->useVirtualPos) {
HXLINE(  91)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  91)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  91)																bool _hx_tmp;
HXDLIN(  91)																if ((index >= 0)) {
HXLINE(  91)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  91)																	_hx_tmp = false;
            																}
HXDLIN(  91)																if (_hx_tmp) {
HXLINE(  91)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  91)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  91)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  91)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  91)								{
HXLINE(  91)									int _g_min = xIter3->start;
HXDLIN(  91)									int _g_max = xIter3->max;
HXDLIN(  91)									while((_g_min < _g_max)){
HXLINE(  91)										_g_min = (_g_min + 1);
HXDLIN(  91)										int px = (_g_min - 1);
HXDLIN(  91)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  91)										{
HXLINE(  91)											int _g_min1 = yIter3->start;
HXDLIN(  91)											int _g_max = yIter3->max;
HXDLIN(  91)											while((_g_min1 < _g_max)){
HXLINE(  91)												_g_min1 = (_g_min1 + 1);
HXDLIN(  91)												int py = (_g_min1 - 1);
HXDLIN(  91)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  91)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  91)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  91)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  91)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  91)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												bool _hx_tmp1;
HXDLIN(  91)												if ((ratioA >= 0)) {
HXLINE(  91)													_hx_tmp1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  91)													_hx_tmp1 = false;
            												}
HXDLIN(  91)												if (_hx_tmp1) {
HXLINE(  91)													_hx_tmp = (ratioC >= 0);
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													int i = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  91)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  91)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  91)													int this1 = i;
HXDLIN(  91)													int a = this1;
HXDLIN(  91)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  91)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  91)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  91)													int this2 = i1;
HXDLIN(  91)													int r = this2;
HXDLIN(  91)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  91)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  91)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  91)													int this3 = i2;
HXDLIN(  91)													int g = this3;
HXDLIN(  91)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  91)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  91)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  91)													int this4 = i3;
HXDLIN(  91)													int b = this4;
HXDLIN(  91)													{
HXLINE(  91)														int location;
HXDLIN(  91)														if (pixelShape->useVirtualPos) {
HXLINE(  91)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  91)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if (pixelShape->transparent) {
HXLINE(  91)															_hx_tmp = (a < 254);
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)															int this3 = this2;
HXDLIN(  91)															int old;
HXDLIN(  91)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  91)																old = this3;
            															}
HXDLIN(  91)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)															Float a1;
HXDLIN(  91)															int this4 = ((old >> 24) & 255);
HXDLIN(  91)															if ((this4 == 0)) {
HXLINE(  91)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float r1;
HXDLIN(  91)															int this5 = ((old >> 16) & 255);
HXDLIN(  91)															if ((this5 == 0)) {
HXLINE(  91)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float g1;
HXDLIN(  91)															int this6 = ((old >> 8) & 255);
HXDLIN(  91)															if ((this6 == 0)) {
HXLINE(  91)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float b1;
HXDLIN(  91)															int this7 = (old & 255);
HXDLIN(  91)															if ((this7 == 0)) {
HXLINE(  91)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float a2;
HXDLIN(  91)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  91)															if ((this8 == 0)) {
HXLINE(  91)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float r2;
HXDLIN(  91)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  91)															if ((this9 == 0)) {
HXLINE(  91)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float g2;
HXDLIN(  91)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  91)															if ((this10 == 0)) {
HXLINE(  91)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float b2;
HXDLIN(  91)															int this11 = (rhs & 255);
HXDLIN(  91)															if ((this11 == 0)) {
HXLINE(  91)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  91)															{
HXLINE(  91)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  91)																int value;
HXDLIN(  91)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  91)																	value = blended;
            																}
HXDLIN(  91)																bool _hx_tmp;
HXDLIN(  91)																if ((location >= 0)) {
HXLINE(  91)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  91)																	_hx_tmp = false;
            																}
HXDLIN(  91)																if (_hx_tmp) {
HXLINE(  91)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  91)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  91)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  91)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)															int value;
HXDLIN(  91)															if (pixelShape->isLittle) {
HXLINE(  91)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  91)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  91)															bool _hx_tmp;
HXDLIN(  91)															if ((location >= 0)) {
HXLINE(  91)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  91)																_hx_tmp = false;
            															}
HXDLIN(  91)															if (_hx_tmp) {
HXLINE(  91)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  91)								if ((hasHit == false)) {
HXLINE(  91)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  91)									if (hasUndo) {
HXLINE(  91)										v->undoImage = undoImage;
HXDLIN(  91)										v->undoX = xIter3->start;
HXDLIN(  91)										v->undoY = yIter3->start;
            									}
            								}
            							}
HXDLIN(  91)							{
HXLINE(  91)								bool hasHit1 = false;
HXDLIN(  91)								bool hasUndo1 = false;
HXDLIN(  91)								int aA1 = ((colorC >> 24) & 255);
HXDLIN(  91)								int rA1 = ((colorC >> 16) & 255);
HXDLIN(  91)								int gA1 = ((colorC >> 8) & 255);
HXDLIN(  91)								int bA1 = (colorC & 255);
HXDLIN(  91)								int aB1 = ((colorB >> 24) & 255);
HXDLIN(  91)								int rB1 = ((colorB >> 16) & 255);
HXDLIN(  91)								int gB1 = ((colorB >> 8) & 255);
HXDLIN(  91)								int bB1 = (colorB & 255);
HXDLIN(  91)								int aC1 = ((colorD >> 24) & 255);
HXDLIN(  91)								int rC1 = ((colorD >> 16) & 255);
HXDLIN(  91)								int gC1 = ((colorD >> 8) & 255);
HXDLIN(  91)								int bC1 = (colorD & 255);
HXDLIN(  91)								Float bcx1 = (cx - dx);
HXDLIN(  91)								Float bcy1 = (cy - dy);
HXDLIN(  91)								Float acx1 = (bx - dx);
HXDLIN(  91)								Float acy1 = (by - dy);
HXDLIN(  91)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  91)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  91)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  91)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  91)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  91)								if ((bx > cx)) {
HXLINE(  91)									if ((bx > dx)) {
HXLINE(  91)										int min;
HXDLIN(  91)										if ((cx > dx)) {
HXLINE(  91)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  91)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  91)										int ii_min = min;
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										xIter31 = this1;
            									}
            									else {
HXLINE(  91)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  91)									if ((cx > dx)) {
HXLINE(  91)										int min;
HXDLIN(  91)										if ((bx > dx)) {
HXLINE(  91)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  91)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  91)										int ii_min = min;
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										xIter31 = this1;
            									}
            									else {
HXLINE(  91)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										xIter31 = this1;
            									}
            								}
HXDLIN(  91)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  91)								if ((by > cy)) {
HXLINE(  91)									if ((by > dy)) {
HXLINE(  91)										int min;
HXDLIN(  91)										if ((cy > dy)) {
HXLINE(  91)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  91)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  91)										int ii_min = min;
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										yIter31 = this1;
            									}
            									else {
HXLINE(  91)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  91)									if ((cy > dy)) {
HXLINE(  91)										int min;
HXDLIN(  91)										if ((by > dy)) {
HXLINE(  91)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  91)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  91)										int ii_min = min;
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										yIter31 = this1;
            									}
            									else {
HXLINE(  91)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  91)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  91)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  91)										yIter31 = this1;
            									}
            								}
HXDLIN(  91)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  91)								if (hasUndo1) {
HXLINE(  91)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  91)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  91)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  91)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  91)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  91)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  91)									undoImage1 = this3;
HXDLIN(  91)									{
HXLINE(  91)										int rectLeft = xIter31->start;
HXDLIN(  91)										int rectTop = yIter31->start;
HXDLIN(  91)										int rectRight = xIter31->max;
HXDLIN(  91)										bool forceClear = false;
HXDLIN(  91)										{
HXLINE(  91)											int _g = rectTop;
HXDLIN(  91)											int _g1 = yIter31->max;
HXDLIN(  91)											while((_g < _g1)){
HXLINE(  91)												_g = (_g + 1);
HXDLIN(  91)												int dy = (_g - 1);
HXDLIN(  91)												{
HXLINE(  91)													int _g1 = rectLeft;
HXDLIN(  91)													int _g2 = rectRight;
HXDLIN(  91)													while((_g1 < _g2)){
HXLINE(  91)														_g1 = (_g1 + 1);
HXDLIN(  91)														int dx = (_g1 - 1);
HXDLIN(  91)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)														int index;
HXDLIN(  91)														if (pixelShape->useVirtualPos) {
HXLINE(  91)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  91)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  91)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)														int col;
HXDLIN(  91)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  91)															col = c;
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if (pixelShape->useMask) {
HXLINE(  91)															_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  91)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  91)															int index;
HXDLIN(  91)															if (this1->useVirtualPos) {
HXLINE(  91)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  91)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  91)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  91)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  91)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)															int v;
HXDLIN(  91)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  91)																v = c;
            															}
HXDLIN(  91)															int this3 = v;
HXDLIN(  91)															int maskPixel = this3;
HXDLIN(  91)															int this4 = col;
HXDLIN(  91)															int this5 = this4;
HXDLIN(  91)															if ((maskPixel == 0)) {
HXLINE(  91)																int this1 = this5;
HXDLIN(  91)																col = this1;
            															}
            															else {
HXLINE(  91)																Float m0;
HXDLIN(  91)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  91)																if ((this1 == 0)) {
HXLINE(  91)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float m1;
HXDLIN(  91)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  91)																if ((this2 == 0)) {
HXLINE(  91)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float m2;
HXDLIN(  91)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  91)																if ((this3 == 0)) {
HXLINE(  91)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float m3;
HXDLIN(  91)																int this4 = (maskPixel & 255);
HXDLIN(  91)																if ((this4 == 0)) {
HXLINE(  91)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  91)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  91)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  91)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  91)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  91)														if ((col != 0)) {
HXLINE(  91)															int x = (dx - rectLeft);
HXDLIN(  91)															int y = (dy - rectTop);
HXDLIN(  91)															int this1 = col;
HXDLIN(  91)															int c = this1;
HXDLIN(  91)															bool _hx_tmp;
HXDLIN(  91)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  91)																_hx_tmp = undoImage1->transparent;
            															}
            															else {
HXLINE(  91)																_hx_tmp = false;
            															}
HXDLIN(  91)															if (_hx_tmp) {
HXLINE(  91)																int location;
HXDLIN(  91)																if (undoImage1->useVirtualPos) {
HXLINE(  91)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  91)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  91)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  91)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)																int this3 = this2;
HXDLIN(  91)																int this4;
HXDLIN(  91)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  91)																	this4 = this3;
            																}
HXDLIN(  91)																Float a1;
HXDLIN(  91)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  91)																if ((this5 == 0)) {
HXLINE(  91)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float r1;
HXDLIN(  91)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  91)																if ((this6 == 0)) {
HXLINE(  91)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float g1;
HXDLIN(  91)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  91)																if ((this7 == 0)) {
HXLINE(  91)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float b1;
HXDLIN(  91)																int this8 = (this4 & 255);
HXDLIN(  91)																if ((this8 == 0)) {
HXLINE(  91)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float a2;
HXDLIN(  91)																int this9 = ((col >> 24) & 255);
HXDLIN(  91)																if ((this9 == 0)) {
HXLINE(  91)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float r2;
HXDLIN(  91)																int this10 = ((col >> 16) & 255);
HXDLIN(  91)																if ((this10 == 0)) {
HXLINE(  91)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float g2;
HXDLIN(  91)																int this11 = ((col >> 8) & 255);
HXDLIN(  91)																if ((this11 == 0)) {
HXLINE(  91)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float b2;
HXDLIN(  91)																int this12 = (col & 255);
HXDLIN(  91)																if ((this12 == 0)) {
HXLINE(  91)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  91)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  91)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)																{
HXLINE(  91)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  91)																	int value;
HXDLIN(  91)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  91)																		value = blended;
            																	}
HXDLIN(  91)																	bool _hx_tmp;
HXDLIN(  91)																	if ((location >= 0)) {
HXLINE(  91)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  91)																		_hx_tmp = false;
            																	}
HXDLIN(  91)																	if (_hx_tmp) {
HXLINE(  91)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  91)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  91)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  91)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  91)																int index;
HXDLIN(  91)																if (undoImage1->useVirtualPos) {
HXLINE(  91)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  91)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  91)																int value;
HXDLIN(  91)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  91)																	value = c;
            																}
HXDLIN(  91)																bool _hx_tmp;
HXDLIN(  91)																if ((index >= 0)) {
HXLINE(  91)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  91)																	_hx_tmp = false;
            																}
HXDLIN(  91)																if (_hx_tmp) {
HXLINE(  91)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  91)															if (forceClear) {
HXLINE(  91)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  91)																int x = (dx - rectLeft);
HXDLIN(  91)																int y = (dy - rectTop);
HXDLIN(  91)																int index;
HXDLIN(  91)																if (undoImage1->useVirtualPos) {
HXLINE(  91)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  91)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  91)																bool _hx_tmp;
HXDLIN(  91)																if ((index >= 0)) {
HXLINE(  91)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  91)																	_hx_tmp = false;
            																}
HXDLIN(  91)																if (_hx_tmp) {
HXLINE(  91)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  91)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  91)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  91)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  91)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  91)								{
HXLINE(  91)									int _g_min1 = xIter31->start;
HXDLIN(  91)									int _g_max1 = xIter31->max;
HXDLIN(  91)									while((_g_min1 < _g_max1)){
HXLINE(  91)										_g_min1 = (_g_min1 + 1);
HXDLIN(  91)										int px = (_g_min1 - 1);
HXDLIN(  91)										Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  91)										{
HXLINE(  91)											int _g_min = yIter31->start;
HXDLIN(  91)											int _g_max = yIter31->max;
HXDLIN(  91)											while((_g_min < _g_max)){
HXLINE(  91)												_g_min = (_g_min + 1);
HXDLIN(  91)												int py = (_g_min - 1);
HXDLIN(  91)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  91)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  91)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  91)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  91)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  91)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  91)												bool _hx_tmp;
HXDLIN(  91)												bool _hx_tmp1;
HXDLIN(  91)												if ((ratioA >= 0)) {
HXLINE(  91)													_hx_tmp1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  91)													_hx_tmp1 = false;
            												}
HXDLIN(  91)												if (_hx_tmp1) {
HXLINE(  91)													_hx_tmp = (ratioC >= 0);
            												}
            												else {
HXLINE(  91)													_hx_tmp = false;
            												}
HXDLIN(  91)												if (_hx_tmp) {
HXLINE(  91)													int i = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA) + (( (Float)(aB1) ) * ratioB)) + (( (Float)(aC1) ) * ratioC)));
HXDLIN(  91)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  91)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  91)													int this1 = i;
HXDLIN(  91)													int a = this1;
HXDLIN(  91)													int i1 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA) + (( (Float)(rB1) ) * ratioB)) + (( (Float)(rC1) ) * ratioC)));
HXDLIN(  91)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  91)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  91)													int this2 = i1;
HXDLIN(  91)													int r = this2;
HXDLIN(  91)													int i2 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA) + (( (Float)(gB1) ) * ratioB)) + (( (Float)(gC1) ) * ratioC)));
HXDLIN(  91)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  91)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  91)													int this3 = i2;
HXDLIN(  91)													int g = this3;
HXDLIN(  91)													int i3 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA) + (( (Float)(bB1) ) * ratioB)) + (( (Float)(bC1) ) * ratioC)));
HXDLIN(  91)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  91)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  91)													int this4 = i3;
HXDLIN(  91)													int b = this4;
HXDLIN(  91)													{
HXLINE(  91)														int location;
HXDLIN(  91)														if (pixelShape->useVirtualPos) {
HXLINE(  91)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  91)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  91)														bool _hx_tmp;
HXDLIN(  91)														if (pixelShape->transparent) {
HXLINE(  91)															_hx_tmp = (a < 254);
            														}
            														else {
HXLINE(  91)															_hx_tmp = false;
            														}
HXDLIN(  91)														if (_hx_tmp) {
HXLINE(  91)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  91)															int this3 = this2;
HXDLIN(  91)															int old;
HXDLIN(  91)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  91)																old = this3;
            															}
HXDLIN(  91)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  91)															Float a1;
HXDLIN(  91)															int this4 = ((old >> 24) & 255);
HXDLIN(  91)															if ((this4 == 0)) {
HXLINE(  91)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float r1;
HXDLIN(  91)															int this5 = ((old >> 16) & 255);
HXDLIN(  91)															if ((this5 == 0)) {
HXLINE(  91)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float g1;
HXDLIN(  91)															int this6 = ((old >> 8) & 255);
HXDLIN(  91)															if ((this6 == 0)) {
HXLINE(  91)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float b1;
HXDLIN(  91)															int this7 = (old & 255);
HXDLIN(  91)															if ((this7 == 0)) {
HXLINE(  91)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float a2;
HXDLIN(  91)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  91)															if ((this8 == 0)) {
HXLINE(  91)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float r2;
HXDLIN(  91)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  91)															if ((this9 == 0)) {
HXLINE(  91)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float g2;
HXDLIN(  91)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  91)															if ((this10 == 0)) {
HXLINE(  91)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float b2;
HXDLIN(  91)															int this11 = (rhs & 255);
HXDLIN(  91)															if ((this11 == 0)) {
HXLINE(  91)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  91)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  91)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  91)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  91)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  91)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  91)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  91)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  91)															{
HXLINE(  91)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  91)																int value;
HXDLIN(  91)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  91)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  91)																	value = blended;
            																}
HXDLIN(  91)																bool _hx_tmp;
HXDLIN(  91)																if ((location >= 0)) {
HXLINE(  91)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  91)																	_hx_tmp = false;
            																}
HXDLIN(  91)																if (_hx_tmp) {
HXLINE(  91)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  91)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  91)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  91)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  91)															int value;
HXDLIN(  91)															if (pixelShape->isLittle) {
HXLINE(  91)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  91)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  91)															bool _hx_tmp;
HXDLIN(  91)															if ((location >= 0)) {
HXLINE(  91)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  91)																_hx_tmp = false;
            															}
HXDLIN(  91)															if (_hx_tmp) {
HXLINE(  91)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  91)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  91)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  91)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  91)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  91)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  91)								if ((hasHit1 == false)) {
HXLINE(  91)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  91)									if (hasUndo1) {
HXLINE(  91)										v->undoImage = undoImage1;
HXDLIN(  91)										v->undoX = xIter31->start;
HXDLIN(  91)										v->undoY = yIter31->start;
            									}
            								}
            							}
HXDLIN(  91)							if ((hasHit == true)) {
HXLINE(  91)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  95)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< PolyLineGradient_obj > PolyLineGradient_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< Float >  __o_strokeWidth,::Array< Float > points,::String __o_colorDirection,::Array< int > colors) {
	::hx::ObjectPtr< PolyLineGradient_obj > __this = new PolyLineGradient_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeWidth,points,__o_colorDirection,colors);
	return __this;
}

::hx::ObjectPtr< PolyLineGradient_obj > PolyLineGradient_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< Float >  __o_strokeWidth,::Array< Float > points,::String __o_colorDirection,::Array< int > colors) {
	PolyLineGradient_obj *__this = (PolyLineGradient_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PolyLineGradient_obj), true, "pixelimage.triangleGML.gradientContour.PolyLineGradient"));
	*(void **)__this = PolyLineGradient_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeWidth,points,__o_colorDirection,colors);
	return __this;
}

PolyLineGradient_obj::PolyLineGradient_obj()
{
}

void PolyLineGradient_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PolyLineGradient);
	HX_MARK_MEMBER_NAME(points,"points");
	HX_MARK_MEMBER_NAME(strokeWidth,"strokeWidth");
	HX_MARK_MEMBER_NAME(colorDirection,"colorDirection");
	::pixelimage::triangleGML::coreShape::BasicGradient_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PolyLineGradient_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(points,"points");
	HX_VISIT_MEMBER_NAME(strokeWidth,"strokeWidth");
	HX_VISIT_MEMBER_NAME(colorDirection,"colorDirection");
	::pixelimage::triangleGML::coreShape::BasicGradient_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val PolyLineGradient_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { return ::hx::Val( points ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"strokeWidth") ) { return ::hx::Val( strokeWidth ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorDirection") ) { return ::hx::Val( colorDirection ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val PolyLineGradient_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { points=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"strokeWidth") ) { strokeWidth=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorDirection") ) { colorDirection=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PolyLineGradient_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("points",23,12,2e,f7));
	outFields->push(HX_("strokeWidth",2e,f7,1c,e3));
	outFields->push(HX_("colorDirection",5c,0c,ed,77));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PolyLineGradient_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(PolyLineGradient_obj,points),HX_("points",23,12,2e,f7)},
	{::hx::fsFloat,(int)offsetof(PolyLineGradient_obj,strokeWidth),HX_("strokeWidth",2e,f7,1c,e3)},
	{::hx::fsString,(int)offsetof(PolyLineGradient_obj,colorDirection),HX_("colorDirection",5c,0c,ed,77)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *PolyLineGradient_obj_sStaticStorageInfo = 0;
#endif

static ::String PolyLineGradient_obj_sMemberFields[] = {
	HX_("points",23,12,2e,f7),
	HX_("strokeWidth",2e,f7,1c,e3),
	HX_("colorDirection",5c,0c,ed,77),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class PolyLineGradient_obj::__mClass;

void PolyLineGradient_obj::__register()
{
	PolyLineGradient_obj _hx_dummy;
	PolyLineGradient_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.gradientContour.PolyLineGradient",7d,5b,52,9e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PolyLineGradient_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PolyLineGradient_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PolyLineGradient_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PolyLineGradient_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace gradientContour
