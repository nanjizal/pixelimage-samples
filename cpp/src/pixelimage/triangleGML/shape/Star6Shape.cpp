// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_FillShape
#include <pixelimage/triangleGML/coreShape/FillShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_shape_Star6Shape
#include <pixelimage/triangleGML/shape/Star6Shape.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d3e17b0c84246a0e_27_new,"pixelimage.triangleGML.shape.Star6Shape","new",0x4e7d26e5,"pixelimage.triangleGML.shape.Star6Shape.new","pixelimage/triangleGML/shape/Star6Shape.hx",27,0x4d6e8b48)
HX_LOCAL_STACK_FRAME(_hx_pos_d3e17b0c84246a0e_35_setParameter,"pixelimage.triangleGML.shape.Star6Shape","setParameter",0x7cac2682,"pixelimage.triangleGML.shape.Star6Shape.setParameter","pixelimage/triangleGML/shape/Star6Shape.hx",35,0x4d6e8b48)
HX_LOCAL_STACK_FRAME(_hx_pos_d3e17b0c84246a0e_49_render,"pixelimage.triangleGML.shape.Star6Shape","render",0x66e335f1,"pixelimage.triangleGML.shape.Star6Shape.render","pixelimage/triangleGML/shape/Star6Shape.hx",49,0x4d6e8b48)
namespace pixelimage{
namespace triangleGML{
namespace shape{

void Star6Shape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_diameter,::hx::Null< Float >  __o_rotation){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int fill = __o_fill.Default(0);
            		Float left = __o_left.Default(((Float)0.));
            		Float top = __o_top.Default(((Float)0.));
            		Float diameter = __o_diameter.Default(((Float)1.));
            		Float rotation = __o_rotation.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_d3e17b0c84246a0e_27_new)
HXLINE(  28)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
HXLINE(  29)		this->left = left;
HXLINE(  30)		this->top = top;
HXLINE(  31)		this->diameter = diameter;
HXLINE(  32)		this->rotation = rotation;
            	}

Dynamic Star6Shape_obj::__CreateEmpty() { return new Star6Shape_obj; }

void *Star6Shape_obj::_hx_vtable = 0;

Dynamic Star6Shape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Star6Shape_obj > _hx_result = new Star6Shape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9]);
	return _hx_result;
}

bool Star6Shape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x389f4e25 || inClassId==(int)0x4ccbbed5;
	}
}

void Star6Shape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_d3e17b0c84246a0e_35_setParameter)
HXDLIN(  35)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("diameter",cd,6e,68,34)) ){
HXLINE(  41)			this->diameter = ::Std_obj::parseFloat(value);
HXDLIN(  41)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("left",07,08,b0,47)) ){
HXLINE(  37)			this->left = ::Std_obj::parseFloat(value);
HXDLIN(  37)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("rotation",3e,3d,86,08)) ){
HXLINE(  43)			Float degree = ::Std_obj::parseFloat(value);
HXLINE(  44)			Float _hx_tmp;
HXDLIN(  44)			if ((degree == 0)) {
HXLINE(  44)				_hx_tmp = ( (Float)(0) );
            			}
            			else {
HXLINE(  44)				_hx_tmp = ((::Math_obj::PI * degree) / ( (Float)(180) ));
            			}
HXDLIN(  44)			this->rotation = _hx_tmp;
HXLINE(  42)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("top",95,66,58,00)) ){
HXLINE(  39)			this->top = ::Std_obj::parseFloat(value);
HXDLIN(  39)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  46)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct Star6Shape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_d3e17b0c84246a0e_49_render)
HXLINE(  50)		int w = ::Math_obj::ceil(this->width);
HXDLIN(  50)		int h = ::Math_obj::ceil(this->height);
HXDLIN(  50)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  50)		::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  50)		::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  50)		::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  50)		::pixelimage::ImageStruct this4 = this3;
HXDLIN(  50)		::pixelimage::ImageStruct temp = this4;
HXLINE(  51)		temp->transparent = false;
HXLINE(  53)		Float r_ = (this->diameter / ( (Float)(2) ));
HXLINE(  55)		Float _r = (r_ - this->strokeWidth);
HXLINE(  56)		Float px = (this->left + r_);
HXLINE(  57)		Float py = (this->top + r_);
HXLINE(  58)		Float pi = ::Math_obj::PI;
HXLINE(  59)		Float omega = (-(pi) + this->rotation);
HXLINE(  61)		Float s = ::Math_obj::sin(omega);
HXLINE(  62)		Float c = ::Math_obj::cos(omega);
HXLINE(  63)		Float a0x_ = (px + (r_ * s));
HXLINE(  64)		Float a0y_ = (py + (r_ * c));
HXLINE(  65)		Float _a0x = (px + (_r * s));
HXLINE(  66)		Float _a0y = (py + (_r * c));
HXLINE(  67)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE(  69)		s = ::Math_obj::sin(omega);
HXLINE(  70)		c = ::Math_obj::cos(omega);
HXLINE(  71)		Float a1x_ = (px + (r_ * s));
HXLINE(  72)		Float a1y_ = (py + (r_ * c));
HXLINE(  73)		Float _a1x = (px + (_r * s));
HXLINE(  74)		Float _a1y = (py + (_r * c));
HXLINE(  76)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE(  77)		s = ::Math_obj::sin(omega);
HXLINE(  78)		c = ::Math_obj::cos(omega);
HXLINE(  79)		Float b0x_ = (px + (r_ * s));
HXLINE(  80)		Float b0y_ = (py + (r_ * c));
HXLINE(  81)		Float _b0x = (px + (_r * s));
HXLINE(  82)		Float _b0y = (py + (_r * c));
HXLINE(  84)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE(  85)		s = ::Math_obj::sin(omega);
HXLINE(  86)		c = ::Math_obj::cos(omega);
HXLINE(  87)		Float b1x_ = (px + (r_ * s));
HXLINE(  88)		Float b1y_ = (py + (r_ * c));
HXLINE(  89)		Float _b1x = (px + (_r * s));
HXLINE(  90)		Float _b1y = (py + (_r * c));
HXLINE(  92)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE(  93)		s = ::Math_obj::sin(omega);
HXLINE(  94)		c = ::Math_obj::cos(omega);
HXLINE(  95)		Float c0x_ = (px + (r_ * s));
HXLINE(  96)		Float c0y_ = (py + (r_ * c));
HXLINE(  97)		Float _c0x = (px + (_r * s));
HXLINE(  98)		Float _c0y = (py + (_r * c));
HXLINE( 100)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE( 101)		s = ::Math_obj::sin(omega);
HXLINE( 102)		c = ::Math_obj::cos(omega);
HXLINE( 103)		Float c1x_ = (px + (r_ * s));
HXLINE( 104)		Float c1y_ = (py + (r_ * c));
HXLINE( 105)		Float _c1x = (px + (_r * s));
HXLINE( 106)		Float _c1y = (py + (_r * c));
HXLINE( 109)		{
HXLINE( 109)			int color = this->strokeColor;
HXDLIN( 109)			bool hasHit = false;
HXDLIN( 109)			bool hasUndo = false;
HXDLIN( 109)			{
HXLINE( 109)				Float bx = b0x_;
HXDLIN( 109)				Float by = b0y_;
HXDLIN( 109)				Float cx = c0x_;
HXDLIN( 109)				Float cy = c0y_;
HXDLIN( 109)				bool adjustWinding = (((((a0x_ * by) - (bx * a0y_)) + ((bx * cy) - (cx * by))) + ((cx * a0y_) - (a0x_ * cy))) > 0);
HXDLIN( 109)				if (!(adjustWinding)) {
HXLINE( 109)					Float bx_ = bx;
HXDLIN( 109)					Float by_ = by;
HXLINE(  26)					bx = cx;
HXLINE(  27)					by = cy;
HXLINE(  28)					cx = bx_;
HXLINE(  29)					cy = by_;
            				}
HXLINE( 109)				{
HXLINE( 109)					Float s0 = ((a0y_ * cx) - (a0x_ * cy));
HXDLIN( 109)					Float sx = (cy - a0y_);
HXDLIN( 109)					Float sy = (a0x_ - cx);
HXDLIN( 109)					Float t0 = ((a0x_ * by) - (a0y_ * bx));
HXDLIN( 109)					Float tx = (a0y_ - by);
HXDLIN( 109)					Float ty = (bx - a0x_);
HXDLIN( 109)					Float A = ((((-(by) * cx) + (a0y_ * (-(bx) + cx))) + (a0x_ * (by - cy))) + (bx * cy));
HXDLIN( 109)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 109)					if ((a0x_ > bx)) {
HXLINE( 109)						if ((a0x_ > cx)) {
HXLINE( 109)							int min;
HXDLIN( 109)							if ((bx > cx)) {
HXLINE( 109)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE( 109)								min = ::Math_obj::floor(bx);
            							}
HXDLIN( 109)							int ii_min = min;
HXDLIN( 109)							int ii_max = ::Math_obj::ceil(a0x_);
HXDLIN( 109)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 109)							xIter3 = this1;
            						}
            						else {
HXLINE( 109)							int ii_min = ::Math_obj::floor(bx);
HXDLIN( 109)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 109)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 109)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE( 109)						if ((bx > cx)) {
HXLINE( 109)							int min;
HXDLIN( 109)							if ((a0x_ > cx)) {
HXLINE( 109)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE( 109)								min = ::Math_obj::ceil(a0x_);
            							}
HXDLIN( 109)							int ii_min = min;
HXDLIN( 109)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 109)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 109)							xIter3 = this1;
            						}
            						else {
HXLINE( 109)							int ii_min = ::Math_obj::floor(a0x_);
HXDLIN( 109)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 109)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 109)							xIter3 = this1;
            						}
            					}
HXDLIN( 109)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 109)					if ((a0y_ > by)) {
HXLINE( 109)						if ((a0y_ > cy)) {
HXLINE( 109)							int min;
HXDLIN( 109)							if ((by > cy)) {
HXLINE( 109)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE( 109)								min = ::Math_obj::floor(by);
            							}
HXDLIN( 109)							int ii_min = min;
HXDLIN( 109)							int ii_max = ::Math_obj::ceil(a0y_);
HXDLIN( 109)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 109)							yIter3 = this1;
            						}
            						else {
HXLINE( 109)							int ii_min = ::Math_obj::floor(by);
HXDLIN( 109)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN( 109)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 109)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE( 109)						if ((by > cy)) {
HXLINE( 109)							int min;
HXDLIN( 109)							if ((a0y_ > cy)) {
HXLINE( 109)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE( 109)								min = ::Math_obj::ceil(a0y_);
            							}
HXDLIN( 109)							int ii_min = min;
HXDLIN( 109)							int ii_max = ::Math_obj::ceil(by);
HXDLIN( 109)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 109)							yIter3 = this1;
            						}
            						else {
HXLINE( 109)							int ii_min = ::Math_obj::floor(a0y_);
HXDLIN( 109)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN( 109)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 109)							yIter3 = this1;
            						}
            					}
HXDLIN( 109)					::pixelimage::ImageStruct undoImage = null();
HXDLIN( 109)					if (hasUndo) {
HXLINE( 109)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 109)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 109)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 109)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 109)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 109)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 109)						undoImage = this3;
HXDLIN( 109)						{
HXLINE( 109)							int rectLeft = xIter3->start;
HXDLIN( 109)							int rectTop = yIter3->start;
HXDLIN( 109)							int rectRight = xIter3->max;
HXDLIN( 109)							bool forceClear = false;
HXDLIN( 109)							{
HXLINE( 109)								int _g = rectTop;
HXDLIN( 109)								int _g1 = yIter3->max;
HXDLIN( 109)								while((_g < _g1)){
HXLINE( 109)									_g = (_g + 1);
HXDLIN( 109)									int dy = (_g - 1);
HXDLIN( 109)									{
HXLINE( 109)										int _g1 = rectLeft;
HXDLIN( 109)										int _g2 = rectRight;
HXDLIN( 109)										while((_g1 < _g2)){
HXLINE( 109)											_g1 = (_g1 + 1);
HXDLIN( 109)											int dx = (_g1 - 1);
HXDLIN( 109)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 109)											int index;
HXDLIN( 109)											if (temp->useVirtualPos) {
HXLINE( 109)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            											}
            											else {
HXLINE( 109)												index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            											}
HXDLIN( 109)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 109)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 109)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 109)											int col;
HXDLIN( 109)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 109)												col = c;
            											}
HXDLIN( 109)											bool _hx_tmp;
HXDLIN( 109)											if (temp->useMask) {
HXLINE( 109)												_hx_tmp = ::hx::IsNotNull( temp->mask );
            											}
            											else {
HXLINE( 109)												_hx_tmp = false;
            											}
HXDLIN( 109)											if (_hx_tmp) {
HXLINE( 109)												::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 109)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 109)												int index;
HXDLIN( 109)												if (this1->useVirtualPos) {
HXLINE( 109)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE( 109)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN( 109)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 109)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 109)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 109)												int v;
HXDLIN( 109)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 109)													v = c;
            												}
HXDLIN( 109)												int this3 = v;
HXDLIN( 109)												int maskPixel = this3;
HXDLIN( 109)												int this4 = col;
HXDLIN( 109)												int this5 = this4;
HXDLIN( 109)												if ((maskPixel == 0)) {
HXLINE( 109)													int this1 = this5;
HXDLIN( 109)													col = this1;
            												}
            												else {
HXLINE( 109)													Float m0;
HXDLIN( 109)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 109)													if ((this1 == 0)) {
HXLINE( 109)														m0 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float m1;
HXDLIN( 109)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 109)													if ((this2 == 0)) {
HXLINE( 109)														m1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float m2;
HXDLIN( 109)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 109)													if ((this3 == 0)) {
HXLINE( 109)														m2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float m3;
HXDLIN( 109)													int this4 = (maskPixel & 255);
HXDLIN( 109)													if ((this4 == 0)) {
HXLINE( 109)														m3 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 109)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 109)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 109)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 109)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 109)											if ((col != 0)) {
HXLINE( 109)												int x = (dx - rectLeft);
HXDLIN( 109)												int y = (dy - rectTop);
HXDLIN( 109)												int this1 = col;
HXDLIN( 109)												int c = this1;
HXDLIN( 109)												bool _hx_tmp;
HXDLIN( 109)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 109)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE( 109)													_hx_tmp = false;
            												}
HXDLIN( 109)												if (_hx_tmp) {
HXLINE( 109)													int location;
HXDLIN( 109)													if (undoImage->useVirtualPos) {
HXLINE( 109)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 109)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 109)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 109)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 109)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 109)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 109)													int this3 = this2;
HXDLIN( 109)													int this4;
HXDLIN( 109)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 109)														this4 = this3;
            													}
HXDLIN( 109)													Float a1;
HXDLIN( 109)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 109)													if ((this5 == 0)) {
HXLINE( 109)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float r1;
HXDLIN( 109)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 109)													if ((this6 == 0)) {
HXLINE( 109)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float g1;
HXDLIN( 109)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 109)													if ((this7 == 0)) {
HXLINE( 109)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float b1;
HXDLIN( 109)													int this8 = (this4 & 255);
HXDLIN( 109)													if ((this8 == 0)) {
HXLINE( 109)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float a2;
HXDLIN( 109)													int this9 = ((col >> 24) & 255);
HXDLIN( 109)													if ((this9 == 0)) {
HXLINE( 109)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float r2;
HXDLIN( 109)													int this10 = ((col >> 16) & 255);
HXDLIN( 109)													if ((this10 == 0)) {
HXLINE( 109)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float g2;
HXDLIN( 109)													int this11 = ((col >> 8) & 255);
HXDLIN( 109)													if ((this11 == 0)) {
HXLINE( 109)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float b2;
HXDLIN( 109)													int this12 = (col & 255);
HXDLIN( 109)													if ((this12 == 0)) {
HXLINE( 109)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 109)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 109)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 109)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 109)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 109)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 109)													{
HXLINE( 109)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 109)														int value;
HXDLIN( 109)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 109)															value = blended;
            														}
HXDLIN( 109)														bool _hx_tmp;
HXDLIN( 109)														if ((location >= 0)) {
HXLINE( 109)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 109)															_hx_tmp = false;
            														}
HXDLIN( 109)														if (_hx_tmp) {
HXLINE( 109)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 109)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 109)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 109)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 109)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 109)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 109)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 109)													int index;
HXDLIN( 109)													if (undoImage->useVirtualPos) {
HXLINE( 109)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 109)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 109)													int value;
HXDLIN( 109)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 109)														value = c;
            													}
HXDLIN( 109)													bool _hx_tmp;
HXDLIN( 109)													if ((index >= 0)) {
HXLINE( 109)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 109)														_hx_tmp = false;
            													}
HXDLIN( 109)													if (_hx_tmp) {
HXLINE( 109)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 109)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 109)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 109)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 109)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 109)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 109)												if (forceClear) {
HXLINE( 109)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 109)													int x = (dx - rectLeft);
HXDLIN( 109)													int y = (dy - rectTop);
HXDLIN( 109)													int index;
HXDLIN( 109)													if (undoImage->useVirtualPos) {
HXLINE( 109)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE( 109)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN( 109)													bool _hx_tmp;
HXDLIN( 109)													if ((index >= 0)) {
HXLINE( 109)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 109)														_hx_tmp = false;
            													}
HXDLIN( 109)													if (_hx_tmp) {
HXLINE( 109)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 109)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 109)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 109)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 109)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 109)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 109)					bool found = false;
HXDLIN( 109)					Float s1 = ((Float)0.);
HXDLIN( 109)					Float t = ((Float)0.);
HXDLIN( 109)					Float sxx = ((Float)0.);
HXDLIN( 109)					Float txx = ((Float)0.);
HXDLIN( 109)					{
HXLINE( 109)						int _g_min = xIter3->start;
HXDLIN( 109)						int _g_max = xIter3->max;
HXDLIN( 109)						while((_g_min < _g_max)){
HXLINE( 109)							_g_min = (_g_min + 1);
HXDLIN( 109)							int x = (_g_min - 1);
HXLINE(  61)							sxx = (sx * ( (Float)(x) ));
HXLINE(  62)							txx = (tx * ( (Float)(x) ));
HXLINE(  63)							found = false;
HXLINE( 109)							{
HXLINE( 109)								int _g_min1 = yIter3->start;
HXDLIN( 109)								int _g_max = yIter3->max;
HXDLIN( 109)								while((_g_min1 < _g_max)){
HXLINE( 109)									_g_min1 = (_g_min1 + 1);
HXDLIN( 109)									int y = (_g_min1 - 1);
HXLINE(  65)									s1 = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)									t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 109)									bool _hx_tmp;
HXDLIN( 109)									if (!((s1 <= 0))) {
HXLINE( 109)										_hx_tmp = (t <= 0);
            									}
            									else {
HXLINE( 109)										_hx_tmp = true;
            									}
HXDLIN( 109)									if (_hx_tmp) {
HXLINE( 109)										if (found) {
HXLINE( 109)											goto _hx_goto_6;
            										}
            									}
            									else {
HXLINE( 109)										if (((s1 + t) < A)) {
HXLINE( 109)											{
HXLINE( 109)												int this1 = color;
HXDLIN( 109)												int c = this1;
HXDLIN( 109)												bool _hx_tmp;
HXDLIN( 109)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 109)													_hx_tmp = temp->transparent;
            												}
            												else {
HXLINE( 109)													_hx_tmp = false;
            												}
HXDLIN( 109)												if (_hx_tmp) {
HXLINE( 109)													int location;
HXDLIN( 109)													if (temp->useVirtualPos) {
HXLINE( 109)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 109)														location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 109)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 109)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 109)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 109)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 109)													int this3 = this2;
HXDLIN( 109)													int this4;
HXDLIN( 109)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 109)														this4 = this3;
            													}
HXDLIN( 109)													Float a1;
HXDLIN( 109)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 109)													if ((this5 == 0)) {
HXLINE( 109)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float r1;
HXDLIN( 109)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 109)													if ((this6 == 0)) {
HXLINE( 109)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float g1;
HXDLIN( 109)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 109)													if ((this7 == 0)) {
HXLINE( 109)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float b1;
HXDLIN( 109)													int this8 = (this4 & 255);
HXDLIN( 109)													if ((this8 == 0)) {
HXLINE( 109)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float a2;
HXDLIN( 109)													int this9 = ((color >> 24) & 255);
HXDLIN( 109)													if ((this9 == 0)) {
HXLINE( 109)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float r2;
HXDLIN( 109)													int this10 = ((color >> 16) & 255);
HXDLIN( 109)													if ((this10 == 0)) {
HXLINE( 109)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float g2;
HXDLIN( 109)													int this11 = ((color >> 8) & 255);
HXDLIN( 109)													if ((this11 == 0)) {
HXLINE( 109)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float b2;
HXDLIN( 109)													int this12 = (color & 255);
HXDLIN( 109)													if ((this12 == 0)) {
HXLINE( 109)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 109)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 109)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 109)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 109)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 109)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 109)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 109)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 109)													{
HXLINE( 109)														::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 109)														int value;
HXDLIN( 109)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 109)															value = blended;
            														}
HXDLIN( 109)														bool _hx_tmp;
HXDLIN( 109)														if ((location >= 0)) {
HXLINE( 109)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 109)															_hx_tmp = false;
            														}
HXDLIN( 109)														if (_hx_tmp) {
HXLINE( 109)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 109)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 109)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 109)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 109)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 109)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 109)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 109)													int index;
HXDLIN( 109)													if (temp->useVirtualPos) {
HXLINE( 109)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 109)														index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 109)													int value;
HXDLIN( 109)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 109)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 109)														value = c;
            													}
HXDLIN( 109)													bool _hx_tmp;
HXDLIN( 109)													if ((index >= 0)) {
HXLINE( 109)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 109)														_hx_tmp = false;
            													}
HXDLIN( 109)													if (_hx_tmp) {
HXLINE( 109)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 109)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 109)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 109)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 109)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 109)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE(  74)											found = true;
            										}
            										else {
HXLINE( 109)											if (found) {
HXLINE( 109)												goto _hx_goto_6;
            											}
            										}
            									}
            								}
            								_hx_goto_6:;
            							}
            						}
            					}
HXDLIN( 109)					if ((hasHit == true)) {
HXLINE( 109)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,a0x_,a0y_,bx,by,cx,cy,true);
HXDLIN( 109)						if (hasUndo) {
HXLINE( 109)							v->undoImage = undoImage;
HXDLIN( 109)							v->undoX = xIter3->start;
HXDLIN( 109)							v->undoY = yIter3->start;
            						}
            					}
            				}
            			}
            		}
HXLINE( 110)		{
HXLINE( 110)			int color1 = this->strokeColor;
HXDLIN( 110)			bool hasHit1 = false;
HXDLIN( 110)			bool hasUndo1 = false;
HXDLIN( 110)			{
HXLINE( 110)				Float bx1 = b1x_;
HXDLIN( 110)				Float by1 = b1y_;
HXDLIN( 110)				Float cx1 = c1x_;
HXDLIN( 110)				Float cy1 = c1y_;
HXDLIN( 110)				bool adjustWinding1 = (((((a1x_ * by1) - (bx1 * a1y_)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * a1y_) - (a1x_ * cy1))) > 0);
HXDLIN( 110)				if (!(adjustWinding1)) {
HXLINE( 110)					Float bx_ = bx1;
HXDLIN( 110)					Float by_ = by1;
HXLINE(  26)					bx1 = cx1;
HXLINE(  27)					by1 = cy1;
HXLINE(  28)					cx1 = bx_;
HXLINE(  29)					cy1 = by_;
            				}
HXLINE( 110)				{
HXLINE( 110)					Float s01 = ((a1y_ * cx1) - (a1x_ * cy1));
HXDLIN( 110)					Float sx1 = (cy1 - a1y_);
HXDLIN( 110)					Float sy1 = (a1x_ - cx1);
HXDLIN( 110)					Float t01 = ((a1x_ * by1) - (a1y_ * bx1));
HXDLIN( 110)					Float tx1 = (a1y_ - by1);
HXDLIN( 110)					Float ty1 = (bx1 - a1x_);
HXDLIN( 110)					Float A1 = ((((-(by1) * cx1) + (a1y_ * (-(bx1) + cx1))) + (a1x_ * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 110)					::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 110)					if ((a1x_ > bx1)) {
HXLINE( 110)						if ((a1x_ > cx1)) {
HXLINE( 110)							int min;
HXDLIN( 110)							if ((bx1 > cx1)) {
HXLINE( 110)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE( 110)								min = ::Math_obj::floor(bx1);
            							}
HXDLIN( 110)							int ii_min = min;
HXDLIN( 110)							int ii_max = ::Math_obj::ceil(a1x_);
HXDLIN( 110)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 110)							xIter31 = this1;
            						}
            						else {
HXLINE( 110)							int ii_min = ::Math_obj::floor(bx1);
HXDLIN( 110)							int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 110)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 110)							xIter31 = this1;
            						}
            					}
            					else {
HXLINE( 110)						if ((bx1 > cx1)) {
HXLINE( 110)							int min;
HXDLIN( 110)							if ((a1x_ > cx1)) {
HXLINE( 110)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE( 110)								min = ::Math_obj::ceil(a1x_);
            							}
HXDLIN( 110)							int ii_min = min;
HXDLIN( 110)							int ii_max = ::Math_obj::ceil(bx1);
HXDLIN( 110)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 110)							xIter31 = this1;
            						}
            						else {
HXLINE( 110)							int ii_min = ::Math_obj::floor(a1x_);
HXDLIN( 110)							int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 110)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 110)							xIter31 = this1;
            						}
            					}
HXDLIN( 110)					::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 110)					if ((a1y_ > by1)) {
HXLINE( 110)						if ((a1y_ > cy1)) {
HXLINE( 110)							int min;
HXDLIN( 110)							if ((by1 > cy1)) {
HXLINE( 110)								min = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE( 110)								min = ::Math_obj::floor(by1);
            							}
HXDLIN( 110)							int ii_min = min;
HXDLIN( 110)							int ii_max = ::Math_obj::ceil(a1y_);
HXDLIN( 110)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 110)							yIter31 = this1;
            						}
            						else {
HXLINE( 110)							int ii_min = ::Math_obj::floor(by1);
HXDLIN( 110)							int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 110)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 110)							yIter31 = this1;
            						}
            					}
            					else {
HXLINE( 110)						if ((by1 > cy1)) {
HXLINE( 110)							int min;
HXDLIN( 110)							if ((a1y_ > cy1)) {
HXLINE( 110)								min = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE( 110)								min = ::Math_obj::ceil(a1y_);
            							}
HXDLIN( 110)							int ii_min = min;
HXDLIN( 110)							int ii_max = ::Math_obj::ceil(by1);
HXDLIN( 110)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 110)							yIter31 = this1;
            						}
            						else {
HXLINE( 110)							int ii_min = ::Math_obj::floor(a1y_);
HXDLIN( 110)							int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 110)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 110)							yIter31 = this1;
            						}
            					}
HXDLIN( 110)					::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 110)					if (hasUndo1) {
HXLINE( 110)						int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 110)						int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 110)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 110)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 110)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 110)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 110)						undoImage1 = this3;
HXDLIN( 110)						{
HXLINE( 110)							int rectLeft = xIter31->start;
HXDLIN( 110)							int rectTop = yIter31->start;
HXDLIN( 110)							int rectRight = xIter31->max;
HXDLIN( 110)							bool forceClear = false;
HXDLIN( 110)							{
HXLINE( 110)								int _g = rectTop;
HXDLIN( 110)								int _g1 = yIter31->max;
HXDLIN( 110)								while((_g < _g1)){
HXLINE( 110)									_g = (_g + 1);
HXDLIN( 110)									int dy = (_g - 1);
HXDLIN( 110)									{
HXLINE( 110)										int _g1 = rectLeft;
HXDLIN( 110)										int _g2 = rectRight;
HXDLIN( 110)										while((_g1 < _g2)){
HXLINE( 110)											_g1 = (_g1 + 1);
HXDLIN( 110)											int dx = (_g1 - 1);
HXDLIN( 110)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 110)											int index;
HXDLIN( 110)											if (temp->useVirtualPos) {
HXLINE( 110)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            											}
            											else {
HXLINE( 110)												index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            											}
HXDLIN( 110)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 110)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 110)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 110)											int col;
HXDLIN( 110)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 110)												col = c;
            											}
HXDLIN( 110)											bool _hx_tmp;
HXDLIN( 110)											if (temp->useMask) {
HXLINE( 110)												_hx_tmp = ::hx::IsNotNull( temp->mask );
            											}
            											else {
HXLINE( 110)												_hx_tmp = false;
            											}
HXDLIN( 110)											if (_hx_tmp) {
HXLINE( 110)												::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 110)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 110)												int index;
HXDLIN( 110)												if (this1->useVirtualPos) {
HXLINE( 110)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE( 110)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN( 110)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 110)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 110)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 110)												int v;
HXDLIN( 110)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 110)													v = c;
            												}
HXDLIN( 110)												int this3 = v;
HXDLIN( 110)												int maskPixel = this3;
HXDLIN( 110)												int this4 = col;
HXDLIN( 110)												int this5 = this4;
HXDLIN( 110)												if ((maskPixel == 0)) {
HXLINE( 110)													int this1 = this5;
HXDLIN( 110)													col = this1;
            												}
            												else {
HXLINE( 110)													Float m0;
HXDLIN( 110)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 110)													if ((this1 == 0)) {
HXLINE( 110)														m0 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float m1;
HXDLIN( 110)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 110)													if ((this2 == 0)) {
HXLINE( 110)														m1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float m2;
HXDLIN( 110)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 110)													if ((this3 == 0)) {
HXLINE( 110)														m2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float m3;
HXDLIN( 110)													int this4 = (maskPixel & 255);
HXDLIN( 110)													if ((this4 == 0)) {
HXLINE( 110)														m3 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 110)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 110)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 110)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 110)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 110)											if ((col != 0)) {
HXLINE( 110)												int x = (dx - rectLeft);
HXDLIN( 110)												int y = (dy - rectTop);
HXDLIN( 110)												int this1 = col;
HXDLIN( 110)												int c = this1;
HXDLIN( 110)												bool _hx_tmp;
HXDLIN( 110)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 110)													_hx_tmp = undoImage1->transparent;
            												}
            												else {
HXLINE( 110)													_hx_tmp = false;
            												}
HXDLIN( 110)												if (_hx_tmp) {
HXLINE( 110)													int location;
HXDLIN( 110)													if (undoImage1->useVirtualPos) {
HXLINE( 110)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE( 110)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN( 110)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 110)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 110)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 110)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 110)													int this3 = this2;
HXDLIN( 110)													int this4;
HXDLIN( 110)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 110)														this4 = this3;
            													}
HXDLIN( 110)													Float a1;
HXDLIN( 110)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 110)													if ((this5 == 0)) {
HXLINE( 110)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float r1;
HXDLIN( 110)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 110)													if ((this6 == 0)) {
HXLINE( 110)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float g1;
HXDLIN( 110)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 110)													if ((this7 == 0)) {
HXLINE( 110)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float b1;
HXDLIN( 110)													int this8 = (this4 & 255);
HXDLIN( 110)													if ((this8 == 0)) {
HXLINE( 110)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float a2;
HXDLIN( 110)													int this9 = ((col >> 24) & 255);
HXDLIN( 110)													if ((this9 == 0)) {
HXLINE( 110)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float r2;
HXDLIN( 110)													int this10 = ((col >> 16) & 255);
HXDLIN( 110)													if ((this10 == 0)) {
HXLINE( 110)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float g2;
HXDLIN( 110)													int this11 = ((col >> 8) & 255);
HXDLIN( 110)													if ((this11 == 0)) {
HXLINE( 110)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float b2;
HXDLIN( 110)													int this12 = (col & 255);
HXDLIN( 110)													if ((this12 == 0)) {
HXLINE( 110)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 110)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 110)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 110)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 110)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 110)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 110)													{
HXLINE( 110)														::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 110)														int value;
HXDLIN( 110)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 110)															value = blended;
            														}
HXDLIN( 110)														bool _hx_tmp;
HXDLIN( 110)														if ((location >= 0)) {
HXLINE( 110)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 110)															_hx_tmp = false;
            														}
HXDLIN( 110)														if (_hx_tmp) {
HXLINE( 110)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 110)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 110)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 110)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 110)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 110)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 110)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 110)													int index;
HXDLIN( 110)													if (undoImage1->useVirtualPos) {
HXLINE( 110)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE( 110)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN( 110)													int value;
HXDLIN( 110)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 110)														value = c;
            													}
HXDLIN( 110)													bool _hx_tmp;
HXDLIN( 110)													if ((index >= 0)) {
HXLINE( 110)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 110)														_hx_tmp = false;
            													}
HXDLIN( 110)													if (_hx_tmp) {
HXLINE( 110)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 110)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 110)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 110)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 110)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 110)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 110)												if (forceClear) {
HXLINE( 110)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 110)													int x = (dx - rectLeft);
HXDLIN( 110)													int y = (dy - rectTop);
HXDLIN( 110)													int index;
HXDLIN( 110)													if (undoImage1->useVirtualPos) {
HXLINE( 110)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE( 110)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN( 110)													bool _hx_tmp;
HXDLIN( 110)													if ((index >= 0)) {
HXLINE( 110)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 110)														_hx_tmp = false;
            													}
HXDLIN( 110)													if (_hx_tmp) {
HXLINE( 110)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 110)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 110)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 110)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 110)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 110)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 110)					bool found1 = false;
HXDLIN( 110)					Float s2 = ((Float)0.);
HXDLIN( 110)					Float t1 = ((Float)0.);
HXDLIN( 110)					Float sxx1 = ((Float)0.);
HXDLIN( 110)					Float txx1 = ((Float)0.);
HXDLIN( 110)					{
HXLINE( 110)						int _g_min1 = xIter31->start;
HXDLIN( 110)						int _g_max1 = xIter31->max;
HXDLIN( 110)						while((_g_min1 < _g_max1)){
HXLINE( 110)							_g_min1 = (_g_min1 + 1);
HXDLIN( 110)							int x = (_g_min1 - 1);
HXLINE(  61)							sxx1 = (sx1 * ( (Float)(x) ));
HXLINE(  62)							txx1 = (tx1 * ( (Float)(x) ));
HXLINE(  63)							found1 = false;
HXLINE( 110)							{
HXLINE( 110)								int _g_min = yIter31->start;
HXDLIN( 110)								int _g_max = yIter31->max;
HXDLIN( 110)								while((_g_min < _g_max)){
HXLINE( 110)									_g_min = (_g_min + 1);
HXDLIN( 110)									int y = (_g_min - 1);
HXLINE(  65)									s2 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE(  66)									t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE( 110)									bool _hx_tmp;
HXDLIN( 110)									if (!((s2 <= 0))) {
HXLINE( 110)										_hx_tmp = (t1 <= 0);
            									}
            									else {
HXLINE( 110)										_hx_tmp = true;
            									}
HXDLIN( 110)									if (_hx_tmp) {
HXLINE( 110)										if (found1) {
HXLINE( 110)											goto _hx_goto_10;
            										}
            									}
            									else {
HXLINE( 110)										if (((s2 + t1) < A1)) {
HXLINE( 110)											{
HXLINE( 110)												int this1 = color1;
HXDLIN( 110)												int c = this1;
HXDLIN( 110)												bool _hx_tmp;
HXDLIN( 110)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 110)													_hx_tmp = temp->transparent;
            												}
            												else {
HXLINE( 110)													_hx_tmp = false;
            												}
HXDLIN( 110)												if (_hx_tmp) {
HXLINE( 110)													int location;
HXDLIN( 110)													if (temp->useVirtualPos) {
HXLINE( 110)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 110)														location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 110)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 110)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 110)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 110)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 110)													int this3 = this2;
HXDLIN( 110)													int this4;
HXDLIN( 110)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 110)														this4 = this3;
            													}
HXDLIN( 110)													Float a1;
HXDLIN( 110)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 110)													if ((this5 == 0)) {
HXLINE( 110)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float r1;
HXDLIN( 110)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 110)													if ((this6 == 0)) {
HXLINE( 110)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float g1;
HXDLIN( 110)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 110)													if ((this7 == 0)) {
HXLINE( 110)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float b1;
HXDLIN( 110)													int this8 = (this4 & 255);
HXDLIN( 110)													if ((this8 == 0)) {
HXLINE( 110)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float a2;
HXDLIN( 110)													int this9 = ((color1 >> 24) & 255);
HXDLIN( 110)													if ((this9 == 0)) {
HXLINE( 110)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float r2;
HXDLIN( 110)													int this10 = ((color1 >> 16) & 255);
HXDLIN( 110)													if ((this10 == 0)) {
HXLINE( 110)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float g2;
HXDLIN( 110)													int this11 = ((color1 >> 8) & 255);
HXDLIN( 110)													if ((this11 == 0)) {
HXLINE( 110)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float b2;
HXDLIN( 110)													int this12 = (color1 & 255);
HXDLIN( 110)													if ((this12 == 0)) {
HXLINE( 110)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 110)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 110)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 110)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 110)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 110)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 110)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 110)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 110)													{
HXLINE( 110)														::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 110)														int value;
HXDLIN( 110)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 110)															value = blended;
            														}
HXDLIN( 110)														bool _hx_tmp;
HXDLIN( 110)														if ((location >= 0)) {
HXLINE( 110)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 110)															_hx_tmp = false;
            														}
HXDLIN( 110)														if (_hx_tmp) {
HXLINE( 110)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 110)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 110)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 110)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 110)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 110)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 110)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 110)													int index;
HXDLIN( 110)													if (temp->useVirtualPos) {
HXLINE( 110)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 110)														index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 110)													int value;
HXDLIN( 110)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 110)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 110)														value = c;
            													}
HXDLIN( 110)													bool _hx_tmp;
HXDLIN( 110)													if ((index >= 0)) {
HXLINE( 110)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 110)														_hx_tmp = false;
            													}
HXDLIN( 110)													if (_hx_tmp) {
HXLINE( 110)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 110)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 110)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 110)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 110)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 110)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE(  74)											found1 = true;
            										}
            										else {
HXLINE( 110)											if (found1) {
HXLINE( 110)												goto _hx_goto_10;
            											}
            										}
            									}
            								}
            								_hx_goto_10:;
            							}
            						}
            					}
HXDLIN( 110)					if ((hasHit1 == true)) {
HXLINE( 110)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,a1x_,a1y_,bx1,by1,cx1,cy1,true);
HXDLIN( 110)						if (hasUndo1) {
HXLINE( 110)							v->undoImage = undoImage1;
HXDLIN( 110)							v->undoX = xIter31->start;
HXDLIN( 110)							v->undoY = yIter31->start;
            						}
            					}
            				}
            			}
            		}
HXLINE( 112)		{
HXLINE( 112)			int color2 = this->fill;
HXDLIN( 112)			bool hasHit2 = false;
HXDLIN( 112)			bool hasUndo2 = false;
HXDLIN( 112)			{
HXLINE( 112)				Float bx2 = _b0x;
HXDLIN( 112)				Float by2 = _b0y;
HXDLIN( 112)				Float cx2 = _c0x;
HXDLIN( 112)				Float cy2 = _c0y;
HXDLIN( 112)				bool adjustWinding2 = (((((_a0x * by2) - (bx2 * _a0y)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * _a0y) - (_a0x * cy2))) > 0);
HXDLIN( 112)				if (!(adjustWinding2)) {
HXLINE( 112)					Float bx_ = bx2;
HXDLIN( 112)					Float by_ = by2;
HXLINE(  26)					bx2 = cx2;
HXLINE(  27)					by2 = cy2;
HXLINE(  28)					cx2 = bx_;
HXLINE(  29)					cy2 = by_;
            				}
HXLINE( 112)				{
HXLINE( 112)					Float s02 = ((_a0y * cx2) - (_a0x * cy2));
HXDLIN( 112)					Float sx2 = (cy2 - _a0y);
HXDLIN( 112)					Float sy2 = (_a0x - cx2);
HXDLIN( 112)					Float t02 = ((_a0x * by2) - (_a0y * bx2));
HXDLIN( 112)					Float tx2 = (_a0y - by2);
HXDLIN( 112)					Float ty2 = (bx2 - _a0x);
HXDLIN( 112)					Float A2 = ((((-(by2) * cx2) + (_a0y * (-(bx2) + cx2))) + (_a0x * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 112)					::pixelimage::iter::IntIterStart xIter32;
HXDLIN( 112)					if ((_a0x > bx2)) {
HXLINE( 112)						if ((_a0x > cx2)) {
HXLINE( 112)							int min;
HXDLIN( 112)							if ((bx2 > cx2)) {
HXLINE( 112)								min = ::Math_obj::floor(cx2);
            							}
            							else {
HXLINE( 112)								min = ::Math_obj::floor(bx2);
            							}
HXDLIN( 112)							int ii_min = min;
HXDLIN( 112)							int ii_max = ::Math_obj::ceil(_a0x);
HXDLIN( 112)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 112)							xIter32 = this1;
            						}
            						else {
HXLINE( 112)							int ii_min = ::Math_obj::floor(bx2);
HXDLIN( 112)							int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 112)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 112)							xIter32 = this1;
            						}
            					}
            					else {
HXLINE( 112)						if ((bx2 > cx2)) {
HXLINE( 112)							int min;
HXDLIN( 112)							if ((_a0x > cx2)) {
HXLINE( 112)								min = ::Math_obj::floor(cx2);
            							}
            							else {
HXLINE( 112)								min = ::Math_obj::ceil(_a0x);
            							}
HXDLIN( 112)							int ii_min = min;
HXDLIN( 112)							int ii_max = ::Math_obj::ceil(bx2);
HXDLIN( 112)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 112)							xIter32 = this1;
            						}
            						else {
HXLINE( 112)							int ii_min = ::Math_obj::floor(_a0x);
HXDLIN( 112)							int ii_max = ::Math_obj::ceil(cx2);
HXDLIN( 112)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 112)							xIter32 = this1;
            						}
            					}
HXDLIN( 112)					::pixelimage::iter::IntIterStart yIter32;
HXDLIN( 112)					if ((_a0y > by2)) {
HXLINE( 112)						if ((_a0y > cy2)) {
HXLINE( 112)							int min;
HXDLIN( 112)							if ((by2 > cy2)) {
HXLINE( 112)								min = ::Math_obj::floor(cy2);
            							}
            							else {
HXLINE( 112)								min = ::Math_obj::floor(by2);
            							}
HXDLIN( 112)							int ii_min = min;
HXDLIN( 112)							int ii_max = ::Math_obj::ceil(_a0y);
HXDLIN( 112)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 112)							yIter32 = this1;
            						}
            						else {
HXLINE( 112)							int ii_min = ::Math_obj::floor(by2);
HXDLIN( 112)							int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 112)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 112)							yIter32 = this1;
            						}
            					}
            					else {
HXLINE( 112)						if ((by2 > cy2)) {
HXLINE( 112)							int min;
HXDLIN( 112)							if ((_a0y > cy2)) {
HXLINE( 112)								min = ::Math_obj::floor(cy2);
            							}
            							else {
HXLINE( 112)								min = ::Math_obj::ceil(_a0y);
            							}
HXDLIN( 112)							int ii_min = min;
HXDLIN( 112)							int ii_max = ::Math_obj::ceil(by2);
HXDLIN( 112)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 112)							yIter32 = this1;
            						}
            						else {
HXLINE( 112)							int ii_min = ::Math_obj::floor(_a0y);
HXDLIN( 112)							int ii_max = ::Math_obj::ceil(cy2);
HXDLIN( 112)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 112)							yIter32 = this1;
            						}
            					}
HXDLIN( 112)					::pixelimage::ImageStruct undoImage2 = null();
HXDLIN( 112)					if (hasUndo2) {
HXLINE( 112)						int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 112)						int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 112)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 112)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 112)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 112)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 112)						undoImage2 = this3;
HXDLIN( 112)						{
HXLINE( 112)							int rectLeft = xIter32->start;
HXDLIN( 112)							int rectTop = yIter32->start;
HXDLIN( 112)							int rectRight = xIter32->max;
HXDLIN( 112)							bool forceClear = false;
HXDLIN( 112)							{
HXLINE( 112)								int _g = rectTop;
HXDLIN( 112)								int _g1 = yIter32->max;
HXDLIN( 112)								while((_g < _g1)){
HXLINE( 112)									_g = (_g + 1);
HXDLIN( 112)									int dy = (_g - 1);
HXDLIN( 112)									{
HXLINE( 112)										int _g1 = rectLeft;
HXDLIN( 112)										int _g2 = rectRight;
HXDLIN( 112)										while((_g1 < _g2)){
HXLINE( 112)											_g1 = (_g1 + 1);
HXDLIN( 112)											int dx = (_g1 - 1);
HXDLIN( 112)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 112)											int index;
HXDLIN( 112)											if (temp->useVirtualPos) {
HXLINE( 112)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            											}
            											else {
HXLINE( 112)												index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            											}
HXDLIN( 112)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 112)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 112)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 112)											int col;
HXDLIN( 112)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 112)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 112)												col = c;
            											}
HXDLIN( 112)											bool _hx_tmp;
HXDLIN( 112)											if (temp->useMask) {
HXLINE( 112)												_hx_tmp = ::hx::IsNotNull( temp->mask );
            											}
            											else {
HXLINE( 112)												_hx_tmp = false;
            											}
HXDLIN( 112)											if (_hx_tmp) {
HXLINE( 112)												::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 112)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 112)												int index;
HXDLIN( 112)												if (this1->useVirtualPos) {
HXLINE( 112)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE( 112)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN( 112)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 112)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 112)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 112)												int v;
HXDLIN( 112)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 112)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 112)													v = c;
            												}
HXDLIN( 112)												int this3 = v;
HXDLIN( 112)												int maskPixel = this3;
HXDLIN( 112)												int this4 = col;
HXDLIN( 112)												int this5 = this4;
HXDLIN( 112)												if ((maskPixel == 0)) {
HXLINE( 112)													int this1 = this5;
HXDLIN( 112)													col = this1;
            												}
            												else {
HXLINE( 112)													Float m0;
HXDLIN( 112)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 112)													if ((this1 == 0)) {
HXLINE( 112)														m0 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float m1;
HXDLIN( 112)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 112)													if ((this2 == 0)) {
HXLINE( 112)														m1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float m2;
HXDLIN( 112)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 112)													if ((this3 == 0)) {
HXLINE( 112)														m2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float m3;
HXDLIN( 112)													int this4 = (maskPixel & 255);
HXDLIN( 112)													if ((this4 == 0)) {
HXLINE( 112)														m3 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 112)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 112)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 112)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 112)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 112)											if ((col != 0)) {
HXLINE( 112)												int x = (dx - rectLeft);
HXDLIN( 112)												int y = (dy - rectTop);
HXDLIN( 112)												int this1 = col;
HXDLIN( 112)												int c = this1;
HXDLIN( 112)												bool _hx_tmp;
HXDLIN( 112)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 112)													_hx_tmp = undoImage2->transparent;
            												}
            												else {
HXLINE( 112)													_hx_tmp = false;
            												}
HXDLIN( 112)												if (_hx_tmp) {
HXLINE( 112)													int location;
HXDLIN( 112)													if (undoImage2->useVirtualPos) {
HXLINE( 112)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE( 112)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN( 112)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 112)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 112)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 112)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 112)													int this3 = this2;
HXDLIN( 112)													int this4;
HXDLIN( 112)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 112)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 112)														this4 = this3;
            													}
HXDLIN( 112)													Float a1;
HXDLIN( 112)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 112)													if ((this5 == 0)) {
HXLINE( 112)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float r1;
HXDLIN( 112)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 112)													if ((this6 == 0)) {
HXLINE( 112)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float g1;
HXDLIN( 112)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 112)													if ((this7 == 0)) {
HXLINE( 112)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float b1;
HXDLIN( 112)													int this8 = (this4 & 255);
HXDLIN( 112)													if ((this8 == 0)) {
HXLINE( 112)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float a2;
HXDLIN( 112)													int this9 = ((col >> 24) & 255);
HXDLIN( 112)													if ((this9 == 0)) {
HXLINE( 112)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float r2;
HXDLIN( 112)													int this10 = ((col >> 16) & 255);
HXDLIN( 112)													if ((this10 == 0)) {
HXLINE( 112)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float g2;
HXDLIN( 112)													int this11 = ((col >> 8) & 255);
HXDLIN( 112)													if ((this11 == 0)) {
HXLINE( 112)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float b2;
HXDLIN( 112)													int this12 = (col & 255);
HXDLIN( 112)													if ((this12 == 0)) {
HXLINE( 112)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 112)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 112)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 112)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 112)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 112)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 112)													{
HXLINE( 112)														::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN( 112)														int value;
HXDLIN( 112)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 112)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 112)															value = blended;
            														}
HXDLIN( 112)														bool _hx_tmp;
HXDLIN( 112)														if ((location >= 0)) {
HXLINE( 112)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 112)															_hx_tmp = false;
            														}
HXDLIN( 112)														if (_hx_tmp) {
HXLINE( 112)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 112)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 112)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 112)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 112)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 112)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 112)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 112)													int index;
HXDLIN( 112)													if (undoImage2->useVirtualPos) {
HXLINE( 112)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE( 112)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN( 112)													int value;
HXDLIN( 112)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 112)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 112)														value = c;
            													}
HXDLIN( 112)													bool _hx_tmp;
HXDLIN( 112)													if ((index >= 0)) {
HXLINE( 112)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 112)														_hx_tmp = false;
            													}
HXDLIN( 112)													if (_hx_tmp) {
HXLINE( 112)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 112)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 112)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 112)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 112)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 112)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 112)												if (forceClear) {
HXLINE( 112)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 112)													int x = (dx - rectLeft);
HXDLIN( 112)													int y = (dy - rectTop);
HXDLIN( 112)													int index;
HXDLIN( 112)													if (undoImage2->useVirtualPos) {
HXLINE( 112)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE( 112)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN( 112)													bool _hx_tmp;
HXDLIN( 112)													if ((index >= 0)) {
HXLINE( 112)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 112)														_hx_tmp = false;
            													}
HXDLIN( 112)													if (_hx_tmp) {
HXLINE( 112)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 112)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 112)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 112)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 112)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 112)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 112)					bool found2 = false;
HXDLIN( 112)					Float s3 = ((Float)0.);
HXDLIN( 112)					Float t2 = ((Float)0.);
HXDLIN( 112)					Float sxx2 = ((Float)0.);
HXDLIN( 112)					Float txx2 = ((Float)0.);
HXDLIN( 112)					{
HXLINE( 112)						int _g_min2 = xIter32->start;
HXDLIN( 112)						int _g_max2 = xIter32->max;
HXDLIN( 112)						while((_g_min2 < _g_max2)){
HXLINE( 112)							_g_min2 = (_g_min2 + 1);
HXDLIN( 112)							int x = (_g_min2 - 1);
HXLINE(  61)							sxx2 = (sx2 * ( (Float)(x) ));
HXLINE(  62)							txx2 = (tx2 * ( (Float)(x) ));
HXLINE(  63)							found2 = false;
HXLINE( 112)							{
HXLINE( 112)								int _g_min = yIter32->start;
HXDLIN( 112)								int _g_max = yIter32->max;
HXDLIN( 112)								while((_g_min < _g_max)){
HXLINE( 112)									_g_min = (_g_min + 1);
HXDLIN( 112)									int y = (_g_min - 1);
HXLINE(  65)									s3 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE(  66)									t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE( 112)									bool _hx_tmp;
HXDLIN( 112)									if (!((s3 <= 0))) {
HXLINE( 112)										_hx_tmp = (t2 <= 0);
            									}
            									else {
HXLINE( 112)										_hx_tmp = true;
            									}
HXDLIN( 112)									if (_hx_tmp) {
HXLINE( 112)										if (found2) {
HXLINE( 112)											goto _hx_goto_14;
            										}
            									}
            									else {
HXLINE( 112)										if (((s3 + t2) < A2)) {
HXLINE( 112)											{
HXLINE( 112)												int this1 = color2;
HXDLIN( 112)												int c = this1;
HXDLIN( 112)												bool _hx_tmp;
HXDLIN( 112)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 112)													_hx_tmp = temp->transparent;
            												}
            												else {
HXLINE( 112)													_hx_tmp = false;
            												}
HXDLIN( 112)												if (_hx_tmp) {
HXLINE( 112)													int location;
HXDLIN( 112)													if (temp->useVirtualPos) {
HXLINE( 112)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 112)														location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 112)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 112)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 112)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 112)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 112)													int this3 = this2;
HXDLIN( 112)													int this4;
HXDLIN( 112)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 112)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 112)														this4 = this3;
            													}
HXDLIN( 112)													Float a1;
HXDLIN( 112)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 112)													if ((this5 == 0)) {
HXLINE( 112)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float r1;
HXDLIN( 112)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 112)													if ((this6 == 0)) {
HXLINE( 112)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float g1;
HXDLIN( 112)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 112)													if ((this7 == 0)) {
HXLINE( 112)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float b1;
HXDLIN( 112)													int this8 = (this4 & 255);
HXDLIN( 112)													if ((this8 == 0)) {
HXLINE( 112)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float a2;
HXDLIN( 112)													int this9 = ((color2 >> 24) & 255);
HXDLIN( 112)													if ((this9 == 0)) {
HXLINE( 112)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float r2;
HXDLIN( 112)													int this10 = ((color2 >> 16) & 255);
HXDLIN( 112)													if ((this10 == 0)) {
HXLINE( 112)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float g2;
HXDLIN( 112)													int this11 = ((color2 >> 8) & 255);
HXDLIN( 112)													if ((this11 == 0)) {
HXLINE( 112)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float b2;
HXDLIN( 112)													int this12 = (color2 & 255);
HXDLIN( 112)													if ((this12 == 0)) {
HXLINE( 112)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 112)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 112)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 112)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 112)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 112)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 112)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 112)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 112)													{
HXLINE( 112)														::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 112)														int value;
HXDLIN( 112)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 112)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 112)															value = blended;
            														}
HXDLIN( 112)														bool _hx_tmp;
HXDLIN( 112)														if ((location >= 0)) {
HXLINE( 112)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 112)															_hx_tmp = false;
            														}
HXDLIN( 112)														if (_hx_tmp) {
HXLINE( 112)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 112)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 112)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 112)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 112)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 112)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 112)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 112)													int index;
HXDLIN( 112)													if (temp->useVirtualPos) {
HXLINE( 112)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 112)														index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 112)													int value;
HXDLIN( 112)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 112)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 112)														value = c;
            													}
HXDLIN( 112)													bool _hx_tmp;
HXDLIN( 112)													if ((index >= 0)) {
HXLINE( 112)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 112)														_hx_tmp = false;
            													}
HXDLIN( 112)													if (_hx_tmp) {
HXLINE( 112)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 112)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 112)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 112)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 112)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 112)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE(  74)											found2 = true;
            										}
            										else {
HXLINE( 112)											if (found2) {
HXLINE( 112)												goto _hx_goto_14;
            											}
            										}
            									}
            								}
            								_hx_goto_14:;
            							}
            						}
            					}
HXDLIN( 112)					if ((hasHit2 == true)) {
HXLINE( 112)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,_a0x,_a0y,bx2,by2,cx2,cy2,true);
HXDLIN( 112)						if (hasUndo2) {
HXLINE( 112)							v->undoImage = undoImage2;
HXDLIN( 112)							v->undoX = xIter32->start;
HXDLIN( 112)							v->undoY = yIter32->start;
            						}
            					}
            				}
            			}
            		}
HXLINE( 113)		{
HXLINE( 113)			int color3 = this->fill;
HXDLIN( 113)			bool hasHit3 = false;
HXDLIN( 113)			bool hasUndo3 = false;
HXDLIN( 113)			{
HXLINE( 113)				Float bx3 = _b1x;
HXDLIN( 113)				Float by3 = _b1y;
HXDLIN( 113)				Float cx3 = _c1x;
HXDLIN( 113)				Float cy3 = _c1y;
HXDLIN( 113)				bool adjustWinding3 = (((((_a1x * by3) - (bx3 * _a1y)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * _a1y) - (_a1x * cy3))) > 0);
HXDLIN( 113)				if (!(adjustWinding3)) {
HXLINE( 113)					Float bx_ = bx3;
HXDLIN( 113)					Float by_ = by3;
HXLINE(  26)					bx3 = cx3;
HXLINE(  27)					by3 = cy3;
HXLINE(  28)					cx3 = bx_;
HXLINE(  29)					cy3 = by_;
            				}
HXLINE( 113)				{
HXLINE( 113)					Float s03 = ((_a1y * cx3) - (_a1x * cy3));
HXDLIN( 113)					Float sx3 = (cy3 - _a1y);
HXDLIN( 113)					Float sy3 = (_a1x - cx3);
HXDLIN( 113)					Float t03 = ((_a1x * by3) - (_a1y * bx3));
HXDLIN( 113)					Float tx3 = (_a1y - by3);
HXDLIN( 113)					Float ty3 = (bx3 - _a1x);
HXDLIN( 113)					Float A3 = ((((-(by3) * cx3) + (_a1y * (-(bx3) + cx3))) + (_a1x * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 113)					::pixelimage::iter::IntIterStart xIter33;
HXDLIN( 113)					if ((_a1x > bx3)) {
HXLINE( 113)						if ((_a1x > cx3)) {
HXLINE( 113)							int min;
HXDLIN( 113)							if ((bx3 > cx3)) {
HXLINE( 113)								min = ::Math_obj::floor(cx3);
            							}
            							else {
HXLINE( 113)								min = ::Math_obj::floor(bx3);
            							}
HXDLIN( 113)							int ii_min = min;
HXDLIN( 113)							int ii_max = ::Math_obj::ceil(_a1x);
HXDLIN( 113)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 113)							xIter33 = this1;
            						}
            						else {
HXLINE( 113)							int ii_min = ::Math_obj::floor(bx3);
HXDLIN( 113)							int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 113)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 113)							xIter33 = this1;
            						}
            					}
            					else {
HXLINE( 113)						if ((bx3 > cx3)) {
HXLINE( 113)							int min;
HXDLIN( 113)							if ((_a1x > cx3)) {
HXLINE( 113)								min = ::Math_obj::floor(cx3);
            							}
            							else {
HXLINE( 113)								min = ::Math_obj::ceil(_a1x);
            							}
HXDLIN( 113)							int ii_min = min;
HXDLIN( 113)							int ii_max = ::Math_obj::ceil(bx3);
HXDLIN( 113)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 113)							xIter33 = this1;
            						}
            						else {
HXLINE( 113)							int ii_min = ::Math_obj::floor(_a1x);
HXDLIN( 113)							int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 113)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 113)							xIter33 = this1;
            						}
            					}
HXDLIN( 113)					::pixelimage::iter::IntIterStart yIter33;
HXDLIN( 113)					if ((_a1y > by3)) {
HXLINE( 113)						if ((_a1y > cy3)) {
HXLINE( 113)							int min;
HXDLIN( 113)							if ((by3 > cy3)) {
HXLINE( 113)								min = ::Math_obj::floor(cy3);
            							}
            							else {
HXLINE( 113)								min = ::Math_obj::floor(by3);
            							}
HXDLIN( 113)							int ii_min = min;
HXDLIN( 113)							int ii_max = ::Math_obj::ceil(_a1y);
HXDLIN( 113)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 113)							yIter33 = this1;
            						}
            						else {
HXLINE( 113)							int ii_min = ::Math_obj::floor(by3);
HXDLIN( 113)							int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 113)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 113)							yIter33 = this1;
            						}
            					}
            					else {
HXLINE( 113)						if ((by3 > cy3)) {
HXLINE( 113)							int min;
HXDLIN( 113)							if ((_a1y > cy3)) {
HXLINE( 113)								min = ::Math_obj::floor(cy3);
            							}
            							else {
HXLINE( 113)								min = ::Math_obj::ceil(_a1y);
            							}
HXDLIN( 113)							int ii_min = min;
HXDLIN( 113)							int ii_max = ::Math_obj::ceil(by3);
HXDLIN( 113)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 113)							yIter33 = this1;
            						}
            						else {
HXLINE( 113)							int ii_min = ::Math_obj::floor(_a1y);
HXDLIN( 113)							int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 113)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 113)							yIter33 = this1;
            						}
            					}
HXDLIN( 113)					::pixelimage::ImageStruct undoImage3 = null();
HXDLIN( 113)					if (hasUndo3) {
HXLINE( 113)						int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 113)						int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 113)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 113)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 113)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 113)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 113)						undoImage3 = this3;
HXDLIN( 113)						{
HXLINE( 113)							int rectLeft = xIter33->start;
HXDLIN( 113)							int rectTop = yIter33->start;
HXDLIN( 113)							int rectRight = xIter33->max;
HXDLIN( 113)							bool forceClear = false;
HXDLIN( 113)							{
HXLINE( 113)								int _g = rectTop;
HXDLIN( 113)								int _g1 = yIter33->max;
HXDLIN( 113)								while((_g < _g1)){
HXLINE( 113)									_g = (_g + 1);
HXDLIN( 113)									int dy = (_g - 1);
HXDLIN( 113)									{
HXLINE( 113)										int _g1 = rectLeft;
HXDLIN( 113)										int _g2 = rectRight;
HXDLIN( 113)										while((_g1 < _g2)){
HXLINE( 113)											_g1 = (_g1 + 1);
HXDLIN( 113)											int dx = (_g1 - 1);
HXDLIN( 113)											::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 113)											int index;
HXDLIN( 113)											if (temp->useVirtualPos) {
HXLINE( 113)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            											}
            											else {
HXLINE( 113)												index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            											}
HXDLIN( 113)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 113)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 113)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 113)											int col;
HXDLIN( 113)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE( 113)												col = c;
            											}
HXDLIN( 113)											bool _hx_tmp;
HXDLIN( 113)											if (temp->useMask) {
HXLINE( 113)												_hx_tmp = ::hx::IsNotNull( temp->mask );
            											}
            											else {
HXLINE( 113)												_hx_tmp = false;
            											}
HXDLIN( 113)											if (_hx_tmp) {
HXLINE( 113)												::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 113)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 113)												int index;
HXDLIN( 113)												if (this1->useVirtualPos) {
HXLINE( 113)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE( 113)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN( 113)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 113)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 113)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 113)												int v;
HXDLIN( 113)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 113)													v = c;
            												}
HXDLIN( 113)												int this3 = v;
HXDLIN( 113)												int maskPixel = this3;
HXDLIN( 113)												int this4 = col;
HXDLIN( 113)												int this5 = this4;
HXDLIN( 113)												if ((maskPixel == 0)) {
HXLINE( 113)													int this1 = this5;
HXDLIN( 113)													col = this1;
            												}
            												else {
HXLINE( 113)													Float m0;
HXDLIN( 113)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 113)													if ((this1 == 0)) {
HXLINE( 113)														m0 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float m1;
HXDLIN( 113)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 113)													if ((this2 == 0)) {
HXLINE( 113)														m1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float m2;
HXDLIN( 113)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 113)													if ((this3 == 0)) {
HXLINE( 113)														m2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float m3;
HXDLIN( 113)													int this4 = (maskPixel & 255);
HXDLIN( 113)													if ((this4 == 0)) {
HXLINE( 113)														m3 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 113)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 113)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 113)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 113)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 113)											if ((col != 0)) {
HXLINE( 113)												int x = (dx - rectLeft);
HXDLIN( 113)												int y = (dy - rectTop);
HXDLIN( 113)												int this1 = col;
HXDLIN( 113)												int c = this1;
HXDLIN( 113)												bool _hx_tmp;
HXDLIN( 113)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 113)													_hx_tmp = undoImage3->transparent;
            												}
            												else {
HXLINE( 113)													_hx_tmp = false;
            												}
HXDLIN( 113)												if (_hx_tmp) {
HXLINE( 113)													int location;
HXDLIN( 113)													if (undoImage3->useVirtualPos) {
HXLINE( 113)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE( 113)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN( 113)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 113)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 113)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 113)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 113)													int this3 = this2;
HXDLIN( 113)													int this4;
HXDLIN( 113)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 113)														this4 = this3;
            													}
HXDLIN( 113)													Float a1;
HXDLIN( 113)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 113)													if ((this5 == 0)) {
HXLINE( 113)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float r1;
HXDLIN( 113)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 113)													if ((this6 == 0)) {
HXLINE( 113)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float g1;
HXDLIN( 113)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 113)													if ((this7 == 0)) {
HXLINE( 113)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float b1;
HXDLIN( 113)													int this8 = (this4 & 255);
HXDLIN( 113)													if ((this8 == 0)) {
HXLINE( 113)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float a2;
HXDLIN( 113)													int this9 = ((col >> 24) & 255);
HXDLIN( 113)													if ((this9 == 0)) {
HXLINE( 113)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float r2;
HXDLIN( 113)													int this10 = ((col >> 16) & 255);
HXDLIN( 113)													if ((this10 == 0)) {
HXLINE( 113)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float g2;
HXDLIN( 113)													int this11 = ((col >> 8) & 255);
HXDLIN( 113)													if ((this11 == 0)) {
HXLINE( 113)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float b2;
HXDLIN( 113)													int this12 = (col & 255);
HXDLIN( 113)													if ((this12 == 0)) {
HXLINE( 113)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 113)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 113)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 113)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 113)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 113)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 113)													{
HXLINE( 113)														::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN( 113)														int value;
HXDLIN( 113)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 113)															value = blended;
            														}
HXDLIN( 113)														bool _hx_tmp;
HXDLIN( 113)														if ((location >= 0)) {
HXLINE( 113)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 113)															_hx_tmp = false;
            														}
HXDLIN( 113)														if (_hx_tmp) {
HXLINE( 113)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 113)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 113)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 113)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 113)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 113)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 113)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 113)													int index;
HXDLIN( 113)													if (undoImage3->useVirtualPos) {
HXLINE( 113)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE( 113)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN( 113)													int value;
HXDLIN( 113)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 113)														value = c;
            													}
HXDLIN( 113)													bool _hx_tmp;
HXDLIN( 113)													if ((index >= 0)) {
HXLINE( 113)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 113)														_hx_tmp = false;
            													}
HXDLIN( 113)													if (_hx_tmp) {
HXLINE( 113)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 113)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 113)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 113)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 113)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 113)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE( 113)												if (forceClear) {
HXLINE( 113)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 113)													int x = (dx - rectLeft);
HXDLIN( 113)													int y = (dy - rectTop);
HXDLIN( 113)													int index;
HXDLIN( 113)													if (undoImage3->useVirtualPos) {
HXLINE( 113)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE( 113)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN( 113)													bool _hx_tmp;
HXDLIN( 113)													if ((index >= 0)) {
HXLINE( 113)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 113)														_hx_tmp = false;
            													}
HXDLIN( 113)													if (_hx_tmp) {
HXLINE( 113)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 113)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 113)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 113)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 113)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 113)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 113)					bool found3 = false;
HXDLIN( 113)					Float s4 = ((Float)0.);
HXDLIN( 113)					Float t3 = ((Float)0.);
HXDLIN( 113)					Float sxx3 = ((Float)0.);
HXDLIN( 113)					Float txx3 = ((Float)0.);
HXDLIN( 113)					{
HXLINE( 113)						int _g_min3 = xIter33->start;
HXDLIN( 113)						int _g_max3 = xIter33->max;
HXDLIN( 113)						while((_g_min3 < _g_max3)){
HXLINE( 113)							_g_min3 = (_g_min3 + 1);
HXDLIN( 113)							int x = (_g_min3 - 1);
HXLINE(  61)							sxx3 = (sx3 * ( (Float)(x) ));
HXLINE(  62)							txx3 = (tx3 * ( (Float)(x) ));
HXLINE(  63)							found3 = false;
HXLINE( 113)							{
HXLINE( 113)								int _g_min = yIter33->start;
HXDLIN( 113)								int _g_max = yIter33->max;
HXDLIN( 113)								while((_g_min < _g_max)){
HXLINE( 113)									_g_min = (_g_min + 1);
HXDLIN( 113)									int y = (_g_min - 1);
HXLINE(  65)									s4 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE(  66)									t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE( 113)									bool _hx_tmp;
HXDLIN( 113)									if (!((s4 <= 0))) {
HXLINE( 113)										_hx_tmp = (t3 <= 0);
            									}
            									else {
HXLINE( 113)										_hx_tmp = true;
            									}
HXDLIN( 113)									if (_hx_tmp) {
HXLINE( 113)										if (found3) {
HXLINE( 113)											goto _hx_goto_18;
            										}
            									}
            									else {
HXLINE( 113)										if (((s4 + t3) < A3)) {
HXLINE( 113)											{
HXLINE( 113)												int this1 = color3;
HXDLIN( 113)												int c = this1;
HXDLIN( 113)												bool _hx_tmp;
HXDLIN( 113)												if ((((c >> 24) & 255) < 254)) {
HXLINE( 113)													_hx_tmp = temp->transparent;
            												}
            												else {
HXLINE( 113)													_hx_tmp = false;
            												}
HXDLIN( 113)												if (_hx_tmp) {
HXLINE( 113)													int location;
HXDLIN( 113)													if (temp->useVirtualPos) {
HXLINE( 113)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 113)														location = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 113)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 113)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 113)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 113)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 113)													int this3 = this2;
HXDLIN( 113)													int this4;
HXDLIN( 113)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE( 113)														this4 = this3;
            													}
HXDLIN( 113)													Float a1;
HXDLIN( 113)													int this5 = ((this4 >> 24) & 255);
HXDLIN( 113)													if ((this5 == 0)) {
HXLINE( 113)														a1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float r1;
HXDLIN( 113)													int this6 = ((this4 >> 16) & 255);
HXDLIN( 113)													if ((this6 == 0)) {
HXLINE( 113)														r1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float g1;
HXDLIN( 113)													int this7 = ((this4 >> 8) & 255);
HXDLIN( 113)													if ((this7 == 0)) {
HXLINE( 113)														g1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float b1;
HXDLIN( 113)													int this8 = (this4 & 255);
HXDLIN( 113)													if ((this8 == 0)) {
HXLINE( 113)														b1 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float a2;
HXDLIN( 113)													int this9 = ((color3 >> 24) & 255);
HXDLIN( 113)													if ((this9 == 0)) {
HXLINE( 113)														a2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float r2;
HXDLIN( 113)													int this10 = ((color3 >> 16) & 255);
HXDLIN( 113)													if ((this10 == 0)) {
HXLINE( 113)														r2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float g2;
HXDLIN( 113)													int this11 = ((color3 >> 8) & 255);
HXDLIN( 113)													if ((this11 == 0)) {
HXLINE( 113)														g2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float b2;
HXDLIN( 113)													int this12 = (color3 & 255);
HXDLIN( 113)													if ((this12 == 0)) {
HXLINE( 113)														b2 = ((Float)0.);
            													}
            													else {
HXLINE( 113)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN( 113)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 113)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 113)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 113)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 113)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 113)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 113)													{
HXLINE( 113)														::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN( 113)														int value;
HXDLIN( 113)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE( 113)															value = blended;
            														}
HXDLIN( 113)														bool _hx_tmp;
HXDLIN( 113)														if ((location >= 0)) {
HXLINE( 113)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE( 113)															_hx_tmp = false;
            														}
HXDLIN( 113)														if (_hx_tmp) {
HXLINE( 113)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 113)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 113)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 113)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 113)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 113)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 113)													::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 113)													int index;
HXDLIN( 113)													if (temp->useVirtualPos) {
HXLINE( 113)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            													}
            													else {
HXLINE( 113)														index = ::Std_obj::_hx_int(( (Float)(((y * temp->width) + x)) ));
            													}
HXDLIN( 113)													int value;
HXDLIN( 113)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 113)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 113)														value = c;
            													}
HXDLIN( 113)													bool _hx_tmp;
HXDLIN( 113)													if ((index >= 0)) {
HXLINE( 113)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE( 113)														_hx_tmp = false;
            													}
HXDLIN( 113)													if (_hx_tmp) {
HXLINE( 113)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 113)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 113)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 113)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 113)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 113)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE(  74)											found3 = true;
            										}
            										else {
HXLINE( 113)											if (found3) {
HXLINE( 113)												goto _hx_goto_18;
            											}
            										}
            									}
            								}
            								_hx_goto_18:;
            							}
            						}
            					}
HXDLIN( 113)					if ((hasHit3 == true)) {
HXLINE( 113)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,_a1x,_a1y,bx3,by3,cx3,cy3,true);
HXDLIN( 113)						if (hasUndo3) {
HXLINE( 113)							v->undoImage = undoImage3;
HXDLIN( 113)							v->undoX = xIter33->start;
HXDLIN( 113)							v->undoY = yIter33->start;
            						}
            					}
            				}
            			}
            		}
HXLINE( 115)		{
HXLINE( 115)			int x = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN( 115)			int y = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN( 115)			bool forceClear = false;
HXDLIN( 115)			{
HXLINE( 115)				int _g = 0;
HXDLIN( 115)				int _g1 = temp->height;
HXDLIN( 115)				while((_g < _g1)){
HXLINE( 115)					_g = (_g + 1);
HXDLIN( 115)					int dy = (_g - 1);
HXDLIN( 115)					{
HXLINE( 115)						int _g1 = 0;
HXDLIN( 115)						int _g2 = temp->width;
HXDLIN( 115)						while((_g1 < _g2)){
HXLINE( 115)							_g1 = (_g1 + 1);
HXDLIN( 115)							int dx = (_g1 - 1);
HXDLIN( 115)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN( 115)							int index;
HXDLIN( 115)							if (temp->useVirtualPos) {
HXLINE( 115)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE( 115)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN( 115)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 115)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 115)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 115)							int col;
HXDLIN( 115)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 115)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 115)								col = c;
            							}
HXDLIN( 115)							bool _hx_tmp;
HXDLIN( 115)							if (temp->useMask) {
HXLINE( 115)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE( 115)								_hx_tmp = false;
            							}
HXDLIN( 115)							if (_hx_tmp) {
HXLINE( 115)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN( 115)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 115)								int index;
HXDLIN( 115)								if (this1->useVirtualPos) {
HXLINE( 115)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE( 115)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN( 115)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 115)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 115)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 115)								int v;
HXDLIN( 115)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 115)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 115)									v = c;
            								}
HXDLIN( 115)								int this3 = v;
HXDLIN( 115)								int maskPixel = this3;
HXDLIN( 115)								int this4 = col;
HXDLIN( 115)								int this5 = this4;
HXDLIN( 115)								if ((maskPixel == 0)) {
HXLINE( 115)									int this1 = this5;
HXDLIN( 115)									col = this1;
            								}
            								else {
HXLINE( 115)									Float m0;
HXDLIN( 115)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 115)									if ((this1 == 0)) {
HXLINE( 115)										m0 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float m1;
HXDLIN( 115)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 115)									if ((this2 == 0)) {
HXLINE( 115)										m1 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float m2;
HXDLIN( 115)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 115)									if ((this3 == 0)) {
HXLINE( 115)										m2 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float m3;
HXDLIN( 115)									int this4 = (maskPixel & 255);
HXDLIN( 115)									if ((this4 == 0)) {
HXLINE( 115)										m3 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 115)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 115)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 115)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 115)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 115)							if ((col != 0)) {
HXLINE( 115)								int x1 = (x + dx);
HXDLIN( 115)								int y1 = (y + dy);
HXDLIN( 115)								int this1 = col;
HXDLIN( 115)								int c = this1;
HXDLIN( 115)								bool _hx_tmp;
HXDLIN( 115)								if ((((c >> 24) & 255) < 254)) {
HXLINE( 115)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE( 115)									_hx_tmp = false;
            								}
HXDLIN( 115)								if (_hx_tmp) {
HXLINE( 115)									int location;
HXDLIN( 115)									if (pixelShape->useVirtualPos) {
HXLINE( 115)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE( 115)										location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN( 115)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN( 115)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 115)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 115)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 115)									int this3 = this2;
HXDLIN( 115)									int this4;
HXDLIN( 115)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 115)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE( 115)										this4 = this3;
            									}
HXDLIN( 115)									Float a1;
HXDLIN( 115)									int this5 = ((this4 >> 24) & 255);
HXDLIN( 115)									if ((this5 == 0)) {
HXLINE( 115)										a1 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float r1;
HXDLIN( 115)									int this6 = ((this4 >> 16) & 255);
HXDLIN( 115)									if ((this6 == 0)) {
HXLINE( 115)										r1 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float g1;
HXDLIN( 115)									int this7 = ((this4 >> 8) & 255);
HXDLIN( 115)									if ((this7 == 0)) {
HXLINE( 115)										g1 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float b1;
HXDLIN( 115)									int this8 = (this4 & 255);
HXDLIN( 115)									if ((this8 == 0)) {
HXLINE( 115)										b1 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float a2;
HXDLIN( 115)									int this9 = ((col >> 24) & 255);
HXDLIN( 115)									if ((this9 == 0)) {
HXLINE( 115)										a2 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float r2;
HXDLIN( 115)									int this10 = ((col >> 16) & 255);
HXDLIN( 115)									if ((this10 == 0)) {
HXLINE( 115)										r2 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float g2;
HXDLIN( 115)									int this11 = ((col >> 8) & 255);
HXDLIN( 115)									if ((this11 == 0)) {
HXLINE( 115)										g2 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float b2;
HXDLIN( 115)									int this12 = (col & 255);
HXDLIN( 115)									if ((this12 == 0)) {
HXLINE( 115)										b2 = ((Float)0.);
            									}
            									else {
HXLINE( 115)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN( 115)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 115)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 115)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 115)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 115)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 115)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 115)									{
HXLINE( 115)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN( 115)										int value;
HXDLIN( 115)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 115)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE( 115)											value = blended;
            										}
HXDLIN( 115)										bool _hx_tmp;
HXDLIN( 115)										if ((location >= 0)) {
HXLINE( 115)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE( 115)											_hx_tmp = false;
            										}
HXDLIN( 115)										if (_hx_tmp) {
HXLINE( 115)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 115)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 115)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 115)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 115)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 115)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE( 115)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN( 115)									int index;
HXDLIN( 115)									if (pixelShape->useVirtualPos) {
HXLINE( 115)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE( 115)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN( 115)									int value;
HXDLIN( 115)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 115)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 115)										value = c;
            									}
HXDLIN( 115)									bool _hx_tmp;
HXDLIN( 115)									if ((index >= 0)) {
HXLINE( 115)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 115)										_hx_tmp = false;
            									}
HXDLIN( 115)									if (_hx_tmp) {
HXLINE( 115)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 115)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 115)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 115)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 115)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 115)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE( 115)								if (forceClear) {
HXLINE( 115)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN( 115)									int x1 = (x + dx);
HXDLIN( 115)									int y1 = (y + dy);
HXDLIN( 115)									int index;
HXDLIN( 115)									if (pixelShape->useVirtualPos) {
HXLINE( 115)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE( 115)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN( 115)									bool _hx_tmp;
HXDLIN( 115)									if ((index >= 0)) {
HXLINE( 115)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE( 115)										_hx_tmp = false;
            									}
HXDLIN( 115)									if (_hx_tmp) {
HXLINE( 115)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 115)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 115)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 115)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 115)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 115)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 116)		temp = null();
HXLINE( 117)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< Star6Shape_obj > Star6Shape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_diameter,::hx::Null< Float >  __o_rotation) {
	::hx::ObjectPtr< Star6Shape_obj > __this = new Star6Shape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_fill,__o_left,__o_top,__o_diameter,__o_rotation);
	return __this;
}

::hx::ObjectPtr< Star6Shape_obj > Star6Shape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_diameter,::hx::Null< Float >  __o_rotation) {
	Star6Shape_obj *__this = (Star6Shape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Star6Shape_obj), true, "pixelimage.triangleGML.shape.Star6Shape"));
	*(void **)__this = Star6Shape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_fill,__o_left,__o_top,__o_diameter,__o_rotation);
	return __this;
}

Star6Shape_obj::Star6Shape_obj()
{
}

::hx::Val Star6Shape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { return ::hx::Val( top ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { return ::hx::Val( left ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"diameter") ) { return ::hx::Val( diameter ); }
		if (HX_FIELD_EQ(inName,"rotation") ) { return ::hx::Val( rotation ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Star6Shape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { top=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { left=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"diameter") ) { diameter=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rotation") ) { rotation=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Star6Shape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("left",07,08,b0,47));
	outFields->push(HX_("top",95,66,58,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("diameter",cd,6e,68,34));
	outFields->push(HX_("rotation",3e,3d,86,08));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Star6Shape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Star6Shape_obj,left),HX_("left",07,08,b0,47)},
	{::hx::fsFloat,(int)offsetof(Star6Shape_obj,top),HX_("top",95,66,58,00)},
	{::hx::fsFloat,(int)offsetof(Star6Shape_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsFloat,(int)offsetof(Star6Shape_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsFloat,(int)offsetof(Star6Shape_obj,diameter),HX_("diameter",cd,6e,68,34)},
	{::hx::fsFloat,(int)offsetof(Star6Shape_obj,rotation),HX_("rotation",3e,3d,86,08)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Star6Shape_obj_sStaticStorageInfo = 0;
#endif

static ::String Star6Shape_obj_sMemberFields[] = {
	HX_("left",07,08,b0,47),
	HX_("top",95,66,58,00),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("diameter",cd,6e,68,34),
	HX_("rotation",3e,3d,86,08),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class Star6Shape_obj::__mClass;

void Star6Shape_obj::__register()
{
	Star6Shape_obj _hx_dummy;
	Star6Shape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.shape.Star6Shape",73,d0,04,4e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Star6Shape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Star6Shape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Star6Shape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Star6Shape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace shape
