// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_FillShape
#include <pixelimage/triangleGML/coreShape/FillShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_shape_TriangleShape
#include <pixelimage/triangleGML/shape/TriangleShape.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_02f69e24ddd5564a_29_new,"pixelimage.triangleGML.shape.TriangleShape","new",0x978d0b55,"pixelimage.triangleGML.shape.TriangleShape.new","pixelimage/triangleGML/shape/TriangleShape.hx",29,0x21a276be)
HX_LOCAL_STACK_FRAME(_hx_pos_02f69e24ddd5564a_39_setParameter,"pixelimage.triangleGML.shape.TriangleShape","setParameter",0x8d143412,"pixelimage.triangleGML.shape.TriangleShape.setParameter","pixelimage/triangleGML/shape/TriangleShape.hx",39,0x21a276be)
HX_LOCAL_STACK_FRAME(_hx_pos_02f69e24ddd5564a_56_render,"pixelimage.triangleGML.shape.TriangleShape","render",0xefe1b781,"pixelimage.triangleGML.shape.TriangleShape.render","pixelimage/triangleGML/shape/TriangleShape.hx",56,0x21a276be)
namespace pixelimage{
namespace triangleGML{
namespace shape{

void TriangleShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int fill = __o_fill.Default(0);
            		Float x1 = __o_x1.Default(((Float)0.));
            		Float y1 = __o_y1.Default(((Float)0.));
            		Float x2 = __o_x2.Default(((Float)0.));
            		Float y2 = __o_y2.Default(((Float)0.));
            		Float x3 = __o_x3.Default(((Float)0.));
            		Float y3 = __o_y3.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_02f69e24ddd5564a_29_new)
HXLINE(  30)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
HXLINE(  31)		this->x1 = x1;
HXLINE(  32)		this->y1 = y1;
HXLINE(  33)		this->x2 = x2;
HXLINE(  34)		this->y2 = y2;
HXLINE(  35)		this->x3 = x3;
HXLINE(  36)		this->y3 = y3;
            	}

Dynamic TriangleShape_obj::__CreateEmpty() { return new TriangleShape_obj; }

void *TriangleShape_obj::_hx_vtable = 0;

Dynamic TriangleShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TriangleShape_obj > _hx_result = new TriangleShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11]);
	return _hx_result;
}

bool TriangleShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2091632c) {
		if (inClassId<=(int)0x038277f9) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x038277f9;
		} else {
			return inClassId==(int)0x2091632c;
		}
	} else {
		return inClassId==(int)0x24e92cfb || inClassId==(int)0x389f4e25;
	}
}

void TriangleShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_02f69e24ddd5564a_39_setParameter)
HXDLIN(  39)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("x1",b9,68,00,00)) ){
HXLINE(  41)			this->x1 = ::Std_obj::parseFloat(value);
HXDLIN(  41)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x2",ba,68,00,00)) ){
HXLINE(  45)			this->x2 = ::Std_obj::parseFloat(value);
HXDLIN(  45)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x3",bb,68,00,00)) ){
HXLINE(  49)			this->x3 = ::Std_obj::parseFloat(value);
HXDLIN(  49)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y1",98,69,00,00)) ){
HXLINE(  43)			this->y1 = ::Std_obj::parseFloat(value);
HXDLIN(  43)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y2",99,69,00,00)) ){
HXLINE(  47)			this->y2 = ::Std_obj::parseFloat(value);
HXDLIN(  47)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y3",9a,69,00,00)) ){
HXLINE(  51)			this->y3 = ::Std_obj::parseFloat(value);
HXDLIN(  51)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  53)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct TriangleShape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_02f69e24ddd5564a_56_render)
HXLINE(  57)		{
HXLINE(  57)			Float ax = this->x1;
HXDLIN(  57)			Float ay = this->y1;
HXDLIN(  57)			int color = this->fill;
HXDLIN(  57)			bool hasHit = false;
HXDLIN(  57)			bool hasUndo = false;
HXDLIN(  57)			{
HXLINE(  57)				Float bx = this->x2;
HXDLIN(  57)				Float by = this->y2;
HXDLIN(  57)				Float cx = this->x3;
HXDLIN(  57)				Float cy = this->y3;
HXDLIN(  57)				bool adjustWinding = (((((ax * by) - (bx * ay)) + ((bx * cy) - (cx * by))) + ((cx * ay) - (ax * cy))) > 0);
HXDLIN(  57)				if (!(adjustWinding)) {
HXLINE(  57)					Float bx_ = bx;
HXDLIN(  57)					Float by_ = by;
HXLINE(  26)					bx = cx;
HXLINE(  27)					by = cy;
HXLINE(  28)					cx = bx_;
HXLINE(  29)					cy = by_;
            				}
HXLINE(  57)				{
HXLINE(  57)					Float s0 = ((ay * cx) - (ax * cy));
HXDLIN(  57)					Float sx = (cy - ay);
HXDLIN(  57)					Float sy = (ax - cx);
HXDLIN(  57)					Float t0 = ((ax * by) - (ay * bx));
HXDLIN(  57)					Float tx = (ay - by);
HXDLIN(  57)					Float ty = (bx - ax);
HXDLIN(  57)					Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXDLIN(  57)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  57)					if ((ax > bx)) {
HXLINE(  57)						if ((ax > cx)) {
HXLINE(  57)							int min;
HXDLIN(  57)							if ((bx > cx)) {
HXLINE(  57)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE(  57)								min = ::Math_obj::floor(bx);
            							}
HXDLIN(  57)							int ii_min = min;
HXDLIN(  57)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  57)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  57)							xIter3 = this1;
            						}
            						else {
HXLINE(  57)							int ii_min = ::Math_obj::floor(bx);
HXDLIN(  57)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  57)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  57)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE(  57)						if ((bx > cx)) {
HXLINE(  57)							int min;
HXDLIN(  57)							if ((ax > cx)) {
HXLINE(  57)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE(  57)								min = ::Math_obj::ceil(ax);
            							}
HXDLIN(  57)							int ii_min = min;
HXDLIN(  57)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  57)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  57)							xIter3 = this1;
            						}
            						else {
HXLINE(  57)							int ii_min = ::Math_obj::floor(ax);
HXDLIN(  57)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  57)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  57)							xIter3 = this1;
            						}
            					}
HXDLIN(  57)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  57)					if ((ay > by)) {
HXLINE(  57)						if ((ay > cy)) {
HXLINE(  57)							int min;
HXDLIN(  57)							if ((by > cy)) {
HXLINE(  57)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  57)								min = ::Math_obj::floor(by);
            							}
HXDLIN(  57)							int ii_min = min;
HXDLIN(  57)							int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  57)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  57)							yIter3 = this1;
            						}
            						else {
HXLINE(  57)							int ii_min = ::Math_obj::floor(by);
HXDLIN(  57)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  57)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  57)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE(  57)						if ((by > cy)) {
HXLINE(  57)							int min;
HXDLIN(  57)							if ((ay > cy)) {
HXLINE(  57)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  57)								min = ::Math_obj::ceil(ay);
            							}
HXDLIN(  57)							int ii_min = min;
HXDLIN(  57)							int ii_max = ::Math_obj::ceil(by);
HXDLIN(  57)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  57)							yIter3 = this1;
            						}
            						else {
HXLINE(  57)							int ii_min = ::Math_obj::floor(ay);
HXDLIN(  57)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  57)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  57)							yIter3 = this1;
            						}
            					}
HXDLIN(  57)					::pixelimage::ImageStruct undoImage = null();
HXDLIN(  57)					if (hasUndo) {
HXLINE(  57)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  57)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  57)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  57)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  57)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  57)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  57)						undoImage = this3;
HXDLIN(  57)						{
HXLINE(  57)							int rectLeft = xIter3->start;
HXDLIN(  57)							int rectTop = yIter3->start;
HXDLIN(  57)							int rectRight = xIter3->max;
HXDLIN(  57)							bool forceClear = false;
HXDLIN(  57)							{
HXLINE(  57)								int _g = rectTop;
HXDLIN(  57)								int _g1 = yIter3->max;
HXDLIN(  57)								while((_g < _g1)){
HXLINE(  57)									_g = (_g + 1);
HXDLIN(  57)									int dy = (_g - 1);
HXDLIN(  57)									{
HXLINE(  57)										int _g1 = rectLeft;
HXDLIN(  57)										int _g2 = rectRight;
HXDLIN(  57)										while((_g1 < _g2)){
HXLINE(  57)											_g1 = (_g1 + 1);
HXDLIN(  57)											int dx = (_g1 - 1);
HXDLIN(  57)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  57)											int index;
HXDLIN(  57)											if (pixelShape->useVirtualPos) {
HXLINE(  57)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  57)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  57)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  57)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  57)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  57)											int col;
HXDLIN(  57)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  57)												col = c;
            											}
HXDLIN(  57)											bool _hx_tmp;
HXDLIN(  57)											if (pixelShape->useMask) {
HXLINE(  57)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  57)												_hx_tmp = false;
            											}
HXDLIN(  57)											if (_hx_tmp) {
HXLINE(  57)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  57)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  57)												int index;
HXDLIN(  57)												if (this1->useVirtualPos) {
HXLINE(  57)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  57)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  57)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  57)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  57)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  57)												int v;
HXDLIN(  57)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  57)													v = c;
            												}
HXDLIN(  57)												int this3 = v;
HXDLIN(  57)												int maskPixel = this3;
HXDLIN(  57)												int this4 = col;
HXDLIN(  57)												int this5 = this4;
HXDLIN(  57)												if ((maskPixel == 0)) {
HXLINE(  57)													int this1 = this5;
HXDLIN(  57)													col = this1;
            												}
            												else {
HXLINE(  57)													Float m0;
HXDLIN(  57)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  57)													if ((this1 == 0)) {
HXLINE(  57)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float m1;
HXDLIN(  57)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  57)													if ((this2 == 0)) {
HXLINE(  57)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float m2;
HXDLIN(  57)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  57)													if ((this3 == 0)) {
HXLINE(  57)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float m3;
HXDLIN(  57)													int this4 = (maskPixel & 255);
HXDLIN(  57)													if ((this4 == 0)) {
HXLINE(  57)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  57)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  57)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  57)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  57)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  57)											if ((col != 0)) {
HXLINE(  57)												int x = (dx - rectLeft);
HXDLIN(  57)												int y = (dy - rectTop);
HXDLIN(  57)												int this1 = col;
HXDLIN(  57)												int c = this1;
HXDLIN(  57)												bool _hx_tmp;
HXDLIN(  57)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  57)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE(  57)													_hx_tmp = false;
            												}
HXDLIN(  57)												if (_hx_tmp) {
HXLINE(  57)													int location;
HXDLIN(  57)													if (undoImage->useVirtualPos) {
HXLINE(  57)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  57)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  57)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  57)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  57)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  57)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  57)													int this3 = this2;
HXDLIN(  57)													int this4;
HXDLIN(  57)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  57)														this4 = this3;
            													}
HXDLIN(  57)													Float a1;
HXDLIN(  57)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  57)													if ((this5 == 0)) {
HXLINE(  57)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float r1;
HXDLIN(  57)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  57)													if ((this6 == 0)) {
HXLINE(  57)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float g1;
HXDLIN(  57)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  57)													if ((this7 == 0)) {
HXLINE(  57)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float b1;
HXDLIN(  57)													int this8 = (this4 & 255);
HXDLIN(  57)													if ((this8 == 0)) {
HXLINE(  57)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float a2;
HXDLIN(  57)													int this9 = ((col >> 24) & 255);
HXDLIN(  57)													if ((this9 == 0)) {
HXLINE(  57)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float r2;
HXDLIN(  57)													int this10 = ((col >> 16) & 255);
HXDLIN(  57)													if ((this10 == 0)) {
HXLINE(  57)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float g2;
HXDLIN(  57)													int this11 = ((col >> 8) & 255);
HXDLIN(  57)													if ((this11 == 0)) {
HXLINE(  57)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float b2;
HXDLIN(  57)													int this12 = (col & 255);
HXDLIN(  57)													if ((this12 == 0)) {
HXLINE(  57)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  57)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  57)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  57)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  57)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  57)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  57)													{
HXLINE(  57)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  57)														int value;
HXDLIN(  57)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  57)															value = blended;
            														}
HXDLIN(  57)														bool _hx_tmp;
HXDLIN(  57)														if ((location >= 0)) {
HXLINE(  57)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  57)															_hx_tmp = false;
            														}
HXDLIN(  57)														if (_hx_tmp) {
HXLINE(  57)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  57)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  57)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  57)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  57)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  57)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  57)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  57)													int index;
HXDLIN(  57)													if (undoImage->useVirtualPos) {
HXLINE(  57)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  57)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  57)													int value;
HXDLIN(  57)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  57)														value = c;
            													}
HXDLIN(  57)													bool _hx_tmp;
HXDLIN(  57)													if ((index >= 0)) {
HXLINE(  57)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  57)														_hx_tmp = false;
            													}
HXDLIN(  57)													if (_hx_tmp) {
HXLINE(  57)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  57)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  57)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  57)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  57)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  57)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  57)												if (forceClear) {
HXLINE(  57)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  57)													int x = (dx - rectLeft);
HXDLIN(  57)													int y = (dy - rectTop);
HXDLIN(  57)													int index;
HXDLIN(  57)													if (undoImage->useVirtualPos) {
HXLINE(  57)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  57)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  57)													bool _hx_tmp;
HXDLIN(  57)													if ((index >= 0)) {
HXLINE(  57)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  57)														_hx_tmp = false;
            													}
HXDLIN(  57)													if (_hx_tmp) {
HXLINE(  57)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  57)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  57)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  57)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  57)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  57)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  57)					bool found = false;
HXDLIN(  57)					Float s = ((Float)0.);
HXDLIN(  57)					Float t = ((Float)0.);
HXDLIN(  57)					Float sxx = ((Float)0.);
HXDLIN(  57)					Float txx = ((Float)0.);
HXDLIN(  57)					{
HXLINE(  57)						int _g_min = xIter3->start;
HXDLIN(  57)						int _g_max = xIter3->max;
HXDLIN(  57)						while((_g_min < _g_max)){
HXLINE(  57)							_g_min = (_g_min + 1);
HXDLIN(  57)							int x = (_g_min - 1);
HXLINE(  61)							sxx = (sx * ( (Float)(x) ));
HXLINE(  62)							txx = (tx * ( (Float)(x) ));
HXLINE(  63)							found = false;
HXLINE(  57)							{
HXLINE(  57)								int _g_min1 = yIter3->start;
HXDLIN(  57)								int _g_max = yIter3->max;
HXDLIN(  57)								while((_g_min1 < _g_max)){
HXLINE(  57)									_g_min1 = (_g_min1 + 1);
HXDLIN(  57)									int y = (_g_min1 - 1);
HXLINE(  65)									s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)									t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  57)									bool _hx_tmp;
HXDLIN(  57)									if (!((s <= 0))) {
HXLINE(  57)										_hx_tmp = (t <= 0);
            									}
            									else {
HXLINE(  57)										_hx_tmp = true;
            									}
HXDLIN(  57)									if (_hx_tmp) {
HXLINE(  57)										if (found) {
HXLINE(  57)											goto _hx_goto_6;
            										}
            									}
            									else {
HXLINE(  57)										if (((s + t) < A)) {
HXLINE(  57)											{
HXLINE(  57)												int this1 = color;
HXDLIN(  57)												int c = this1;
HXDLIN(  57)												bool _hx_tmp;
HXDLIN(  57)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  57)													_hx_tmp = pixelShape->transparent;
            												}
            												else {
HXLINE(  57)													_hx_tmp = false;
            												}
HXDLIN(  57)												if (_hx_tmp) {
HXLINE(  57)													int location;
HXDLIN(  57)													if (pixelShape->useVirtualPos) {
HXLINE(  57)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  57)														location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            													}
HXDLIN(  57)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  57)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  57)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  57)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  57)													int this3 = this2;
HXDLIN(  57)													int this4;
HXDLIN(  57)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  57)														this4 = this3;
            													}
HXDLIN(  57)													Float a1;
HXDLIN(  57)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  57)													if ((this5 == 0)) {
HXLINE(  57)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float r1;
HXDLIN(  57)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  57)													if ((this6 == 0)) {
HXLINE(  57)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float g1;
HXDLIN(  57)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  57)													if ((this7 == 0)) {
HXLINE(  57)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float b1;
HXDLIN(  57)													int this8 = (this4 & 255);
HXDLIN(  57)													if ((this8 == 0)) {
HXLINE(  57)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float a2;
HXDLIN(  57)													int this9 = ((color >> 24) & 255);
HXDLIN(  57)													if ((this9 == 0)) {
HXLINE(  57)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float r2;
HXDLIN(  57)													int this10 = ((color >> 16) & 255);
HXDLIN(  57)													if ((this10 == 0)) {
HXLINE(  57)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float g2;
HXDLIN(  57)													int this11 = ((color >> 8) & 255);
HXDLIN(  57)													if ((this11 == 0)) {
HXLINE(  57)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float b2;
HXDLIN(  57)													int this12 = (color & 255);
HXDLIN(  57)													if ((this12 == 0)) {
HXLINE(  57)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  57)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  57)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  57)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  57)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  57)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  57)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  57)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  57)													{
HXLINE(  57)														::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  57)														int value;
HXDLIN(  57)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  57)															value = blended;
            														}
HXDLIN(  57)														bool _hx_tmp;
HXDLIN(  57)														if ((location >= 0)) {
HXLINE(  57)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  57)															_hx_tmp = false;
            														}
HXDLIN(  57)														if (_hx_tmp) {
HXLINE(  57)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  57)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  57)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  57)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  57)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  57)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  57)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  57)													int index;
HXDLIN(  57)													if (pixelShape->useVirtualPos) {
HXLINE(  57)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  57)														index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            													}
HXDLIN(  57)													int value;
HXDLIN(  57)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  57)														value = c;
            													}
HXDLIN(  57)													bool _hx_tmp;
HXDLIN(  57)													if ((index >= 0)) {
HXLINE(  57)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  57)														_hx_tmp = false;
            													}
HXDLIN(  57)													if (_hx_tmp) {
HXLINE(  57)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  57)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  57)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  57)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  57)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  57)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE(  74)											found = true;
            										}
            										else {
HXLINE(  57)											if (found) {
HXLINE(  57)												goto _hx_goto_6;
            											}
            										}
            									}
            								}
            								_hx_goto_6:;
            							}
            						}
            					}
HXDLIN(  57)					if ((hasHit == true)) {
HXLINE(  57)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN(  57)						if (hasUndo) {
HXLINE(  57)							v->undoImage = undoImage;
HXDLIN(  57)							v->undoX = xIter3->start;
HXDLIN(  57)							v->undoY = yIter3->start;
            						}
            					}
            				}
            			}
            		}
HXLINE(  59)		{
HXLINE(  59)			Float px = this->x1;
HXDLIN(  59)			Float py = this->y1;
HXDLIN(  59)			int color1 = this->strokeColor;
HXDLIN(  59)			bool hasHit1 = true;
HXDLIN(  59)			Float o = (this->y2 - py);
HXDLIN(  59)			Float a = (this->x2 - px);
HXDLIN(  59)			Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  59)			Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  59)			{
HXLINE(  59)				 ::Dynamic debugCorners = false;
HXDLIN(  59)				if (::hx::IsNull( debugCorners )) {
HXLINE( 878)					debugCorners = false;
            				}
HXLINE(  59)				Float sin = ::Math_obj::sin(theta);
HXDLIN(  59)				Float cos = ::Math_obj::cos(theta);
HXDLIN(  59)				Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  59)				Float dx = ((Float)0.1);
HXDLIN(  59)				Float dy = radius;
HXDLIN(  59)				Float cx1 = h;
HXDLIN(  59)				Float cy1 = radius;
HXDLIN(  59)				Float bx1 = h;
HXDLIN(  59)				Float by1 = -(radius);
HXDLIN(  59)				Float ax1 = ((Float)0.1);
HXDLIN(  59)				Float ay1 = -(radius);
HXDLIN(  59)				Float temp = ((Float)0.);
HXLINE(  28)				temp = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE(  29)				ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE(  30)				ax1 = temp;
HXLINE(  32)				temp = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE(  33)				by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE(  34)				bx1 = temp;
HXLINE(  36)				temp = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE(  37)				cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE(  38)				cx1 = temp;
HXLINE(  40)				temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  41)				dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  42)				dx = temp;
HXLINE(  59)				if (( (bool)(debugCorners) )) {
HXLINE(  59)					{
HXLINE(  59)						Float x = (ax1 - ((Float)6.));
HXDLIN(  59)						Float y = (ay1 - ((Float)6.));
HXDLIN(  59)						int p = ::Std_obj::_hx_int(x);
HXDLIN(  59)						int xx = p;
HXDLIN(  59)						int q = ::Std_obj::_hx_int(y);
HXDLIN(  59)						int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  59)						int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  59)						while(true){
HXLINE(  59)							{
HXLINE(  59)								p = (p + 1);
HXDLIN(  59)								int x = (p - 1);
HXDLIN(  59)								int this1 = -65536;
HXDLIN(  59)								int c = this1;
HXDLIN(  59)								bool _hx_tmp;
HXDLIN(  59)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  59)									_hx_tmp = false;
            								}
HXDLIN(  59)								if (_hx_tmp) {
HXLINE(  59)									int location;
HXDLIN(  59)									if (pixelShape->useVirtualPos) {
HXLINE(  59)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  59)										location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  59)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  59)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)									int this3 = this2;
HXDLIN(  59)									int this4;
HXDLIN(  59)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  59)										this4 = this3;
            									}
HXDLIN(  59)									Float a1;
HXDLIN(  59)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)									if ((this5 == 0)) {
HXLINE(  59)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r1;
HXDLIN(  59)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)									if ((this6 == 0)) {
HXLINE(  59)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g1;
HXDLIN(  59)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)									if ((this7 == 0)) {
HXLINE(  59)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b1;
HXDLIN(  59)									int this8 = (this4 & 255);
HXDLIN(  59)									if ((this8 == 0)) {
HXLINE(  59)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a2;
HXDLIN(  59)									int this9 = ((-65536 >> 24) & 255);
HXDLIN(  59)									if ((this9 == 0)) {
HXLINE(  59)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r2;
HXDLIN(  59)									int this10 = ((-65536 >> 16) & 255);
HXDLIN(  59)									if ((this10 == 0)) {
HXLINE(  59)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g2;
HXDLIN(  59)									int this11 = ((-65536 >> 8) & 255);
HXDLIN(  59)									if ((this11 == 0)) {
HXLINE(  59)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b2;
HXDLIN(  59)									int this12 = (-65536 & 255);
HXDLIN(  59)									if ((this12 == 0)) {
HXLINE(  59)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)									{
HXLINE(  59)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  59)										int value;
HXDLIN(  59)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  59)											value = blended;
            										}
HXDLIN(  59)										bool _hx_tmp;
HXDLIN(  59)										if ((location >= 0)) {
HXLINE(  59)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  59)											_hx_tmp = false;
            										}
HXDLIN(  59)										if (_hx_tmp) {
HXLINE(  59)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  59)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  59)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  59)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)									int index;
HXDLIN(  59)									if (pixelShape->useVirtualPos) {
HXLINE(  59)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  59)										index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  59)									int value;
HXDLIN(  59)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  59)										value = c;
            									}
HXDLIN(  59)									bool _hx_tmp;
HXDLIN(  59)									if ((index >= 0)) {
HXLINE(  59)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  59)										_hx_tmp = false;
            									}
HXDLIN(  59)									if (_hx_tmp) {
HXLINE(  59)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  59)							if ((p > maxX)) {
HXLINE( 247)								p = xx;
HXLINE(  59)								q = (q + 1);
            							}
HXDLIN(  59)							if ((q > maxY)) {
HXLINE(  59)								goto _hx_goto_7;
            							}
            						}
            						_hx_goto_7:;
            					}
HXDLIN(  59)					{
HXLINE(  59)						Float x1 = (bx1 - ((Float)6.));
HXDLIN(  59)						Float y1 = (by1 - ((Float)6.));
HXDLIN(  59)						int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  59)						int xx1 = p1;
HXDLIN(  59)						int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  59)						int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  59)						int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  59)						while(true){
HXLINE(  59)							{
HXLINE(  59)								p1 = (p1 + 1);
HXDLIN(  59)								int x = (p1 - 1);
HXDLIN(  59)								int this1 = -16711936;
HXDLIN(  59)								int c = this1;
HXDLIN(  59)								bool _hx_tmp;
HXDLIN(  59)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  59)									_hx_tmp = false;
            								}
HXDLIN(  59)								if (_hx_tmp) {
HXLINE(  59)									int location;
HXDLIN(  59)									if (pixelShape->useVirtualPos) {
HXLINE(  59)										location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  59)										location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            									}
HXDLIN(  59)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  59)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)									int this3 = this2;
HXDLIN(  59)									int this4;
HXDLIN(  59)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  59)										this4 = this3;
            									}
HXDLIN(  59)									Float a1;
HXDLIN(  59)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)									if ((this5 == 0)) {
HXLINE(  59)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r1;
HXDLIN(  59)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)									if ((this6 == 0)) {
HXLINE(  59)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g1;
HXDLIN(  59)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)									if ((this7 == 0)) {
HXLINE(  59)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b1;
HXDLIN(  59)									int this8 = (this4 & 255);
HXDLIN(  59)									if ((this8 == 0)) {
HXLINE(  59)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a2;
HXDLIN(  59)									int this9 = ((-16711936 >> 24) & 255);
HXDLIN(  59)									if ((this9 == 0)) {
HXLINE(  59)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r2;
HXDLIN(  59)									int this10 = ((-16711936 >> 16) & 255);
HXDLIN(  59)									if ((this10 == 0)) {
HXLINE(  59)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g2;
HXDLIN(  59)									int this11 = ((-16711936 >> 8) & 255);
HXDLIN(  59)									if ((this11 == 0)) {
HXLINE(  59)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b2;
HXDLIN(  59)									int this12 = (-16711936 & 255);
HXDLIN(  59)									if ((this12 == 0)) {
HXLINE(  59)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)									{
HXLINE(  59)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  59)										int value;
HXDLIN(  59)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  59)											value = blended;
            										}
HXDLIN(  59)										bool _hx_tmp;
HXDLIN(  59)										if ((location >= 0)) {
HXLINE(  59)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  59)											_hx_tmp = false;
            										}
HXDLIN(  59)										if (_hx_tmp) {
HXLINE(  59)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  59)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  59)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  59)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)									int index;
HXDLIN(  59)									if (pixelShape->useVirtualPos) {
HXLINE(  59)										index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  59)										index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            									}
HXDLIN(  59)									int value;
HXDLIN(  59)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  59)										value = c;
            									}
HXDLIN(  59)									bool _hx_tmp;
HXDLIN(  59)									if ((index >= 0)) {
HXLINE(  59)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  59)										_hx_tmp = false;
            									}
HXDLIN(  59)									if (_hx_tmp) {
HXLINE(  59)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  59)							if ((p1 > maxX1)) {
HXLINE( 247)								p1 = xx1;
HXLINE(  59)								q1 = (q1 + 1);
            							}
HXDLIN(  59)							if ((q1 > maxY1)) {
HXLINE(  59)								goto _hx_goto_8;
            							}
            						}
            						_hx_goto_8:;
            					}
HXDLIN(  59)					{
HXLINE(  59)						Float x2 = (cx1 - ((Float)6.));
HXDLIN(  59)						Float y2 = (cy1 - ((Float)6.));
HXDLIN(  59)						int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  59)						int xx2 = p2;
HXDLIN(  59)						int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  59)						int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  59)						int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  59)						while(true){
HXLINE(  59)							{
HXLINE(  59)								p2 = (p2 + 1);
HXDLIN(  59)								int x = (p2 - 1);
HXDLIN(  59)								int this1 = -16776961;
HXDLIN(  59)								int c = this1;
HXDLIN(  59)								bool _hx_tmp;
HXDLIN(  59)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  59)									_hx_tmp = false;
            								}
HXDLIN(  59)								if (_hx_tmp) {
HXLINE(  59)									int location;
HXDLIN(  59)									if (pixelShape->useVirtualPos) {
HXLINE(  59)										location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  59)										location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            									}
HXDLIN(  59)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  59)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)									int this3 = this2;
HXDLIN(  59)									int this4;
HXDLIN(  59)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  59)										this4 = this3;
            									}
HXDLIN(  59)									Float a1;
HXDLIN(  59)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)									if ((this5 == 0)) {
HXLINE(  59)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r1;
HXDLIN(  59)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)									if ((this6 == 0)) {
HXLINE(  59)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g1;
HXDLIN(  59)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)									if ((this7 == 0)) {
HXLINE(  59)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b1;
HXDLIN(  59)									int this8 = (this4 & 255);
HXDLIN(  59)									if ((this8 == 0)) {
HXLINE(  59)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a2;
HXDLIN(  59)									int this9 = ((-16776961 >> 24) & 255);
HXDLIN(  59)									if ((this9 == 0)) {
HXLINE(  59)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r2;
HXDLIN(  59)									int this10 = ((-16776961 >> 16) & 255);
HXDLIN(  59)									if ((this10 == 0)) {
HXLINE(  59)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g2;
HXDLIN(  59)									int this11 = ((-16776961 >> 8) & 255);
HXDLIN(  59)									if ((this11 == 0)) {
HXLINE(  59)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b2;
HXDLIN(  59)									int this12 = (-16776961 & 255);
HXDLIN(  59)									if ((this12 == 0)) {
HXLINE(  59)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)									{
HXLINE(  59)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  59)										int value;
HXDLIN(  59)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  59)											value = blended;
            										}
HXDLIN(  59)										bool _hx_tmp;
HXDLIN(  59)										if ((location >= 0)) {
HXLINE(  59)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  59)											_hx_tmp = false;
            										}
HXDLIN(  59)										if (_hx_tmp) {
HXLINE(  59)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  59)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  59)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  59)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)									int index;
HXDLIN(  59)									if (pixelShape->useVirtualPos) {
HXLINE(  59)										index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  59)										index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            									}
HXDLIN(  59)									int value;
HXDLIN(  59)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  59)										value = c;
            									}
HXDLIN(  59)									bool _hx_tmp;
HXDLIN(  59)									if ((index >= 0)) {
HXLINE(  59)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  59)										_hx_tmp = false;
            									}
HXDLIN(  59)									if (_hx_tmp) {
HXLINE(  59)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  59)							if ((p2 > maxX2)) {
HXLINE( 247)								p2 = xx2;
HXLINE(  59)								q2 = (q2 + 1);
            							}
HXDLIN(  59)							if ((q2 > maxY2)) {
HXLINE(  59)								goto _hx_goto_9;
            							}
            						}
            						_hx_goto_9:;
            					}
HXDLIN(  59)					{
HXLINE(  59)						Float x3 = (dx - ((Float)6.));
HXDLIN(  59)						Float y3 = (dy - ((Float)6.));
HXDLIN(  59)						int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  59)						int xx3 = p3;
HXDLIN(  59)						int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  59)						int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  59)						int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  59)						while(true){
HXLINE(  59)							{
HXLINE(  59)								p3 = (p3 + 1);
HXDLIN(  59)								int x = (p3 - 1);
HXDLIN(  59)								int this1 = -1048336;
HXDLIN(  59)								int c = this1;
HXDLIN(  59)								bool _hx_tmp;
HXDLIN(  59)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  59)									_hx_tmp = false;
            								}
HXDLIN(  59)								if (_hx_tmp) {
HXLINE(  59)									int location;
HXDLIN(  59)									if (pixelShape->useVirtualPos) {
HXLINE(  59)										location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  59)										location = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            									}
HXDLIN(  59)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  59)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)									int this3 = this2;
HXDLIN(  59)									int this4;
HXDLIN(  59)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  59)										this4 = this3;
            									}
HXDLIN(  59)									Float a1;
HXDLIN(  59)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)									if ((this5 == 0)) {
HXLINE(  59)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r1;
HXDLIN(  59)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)									if ((this6 == 0)) {
HXLINE(  59)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g1;
HXDLIN(  59)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)									if ((this7 == 0)) {
HXLINE(  59)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b1;
HXDLIN(  59)									int this8 = (this4 & 255);
HXDLIN(  59)									if ((this8 == 0)) {
HXLINE(  59)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a2;
HXDLIN(  59)									int this9 = ((-1048336 >> 24) & 255);
HXDLIN(  59)									if ((this9 == 0)) {
HXLINE(  59)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float r2;
HXDLIN(  59)									int this10 = ((-1048336 >> 16) & 255);
HXDLIN(  59)									if ((this10 == 0)) {
HXLINE(  59)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float g2;
HXDLIN(  59)									int this11 = ((-1048336 >> 8) & 255);
HXDLIN(  59)									if ((this11 == 0)) {
HXLINE(  59)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float b2;
HXDLIN(  59)									int this12 = (-1048336 & 255);
HXDLIN(  59)									if ((this12 == 0)) {
HXLINE(  59)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  59)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  59)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)									{
HXLINE(  59)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  59)										int value;
HXDLIN(  59)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  59)											value = blended;
            										}
HXDLIN(  59)										bool _hx_tmp;
HXDLIN(  59)										if ((location >= 0)) {
HXLINE(  59)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  59)											_hx_tmp = false;
            										}
HXDLIN(  59)										if (_hx_tmp) {
HXLINE(  59)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  59)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  59)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  59)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)									int index;
HXDLIN(  59)									if (pixelShape->useVirtualPos) {
HXLINE(  59)										index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  59)										index = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            									}
HXDLIN(  59)									int value;
HXDLIN(  59)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  59)										value = c;
            									}
HXDLIN(  59)									bool _hx_tmp;
HXDLIN(  59)									if ((index >= 0)) {
HXLINE(  59)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  59)										_hx_tmp = false;
            									}
HXDLIN(  59)									if (_hx_tmp) {
HXLINE(  59)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  59)							if ((p3 > maxX3)) {
HXLINE( 247)								p3 = xx3;
HXLINE(  59)								q3 = (q3 + 1);
            							}
HXDLIN(  59)							if ((q3 > maxY3)) {
HXLINE(  59)								goto _hx_goto_10;
            							}
            						}
            						_hx_goto_10:;
            					}
            				}
HXDLIN(  59)				{
HXLINE(  59)					{
HXLINE(  59)						Float bx2 = bx1;
HXDLIN(  59)						Float by2 = by1;
HXDLIN(  59)						Float cx2 = dx;
HXDLIN(  59)						Float cy2 = dy;
HXDLIN(  59)						bool hasUndo1 = false;
HXDLIN(  59)						bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  59)						if (!(adjustWinding1)) {
HXLINE(  59)							Float bx_ = bx2;
HXDLIN(  59)							Float by_ = by2;
HXLINE(  26)							bx2 = cx2;
HXLINE(  27)							by2 = cy2;
HXLINE(  28)							cx2 = bx_;
HXLINE(  29)							cy2 = by_;
            						}
HXLINE(  59)						{
HXLINE(  59)							Float s01 = ((ay1 * cx2) - (ax1 * cy2));
HXDLIN(  59)							Float sx1 = (cy2 - ay1);
HXDLIN(  59)							Float sy1 = (ax1 - cx2);
HXDLIN(  59)							Float t01 = ((ax1 * by2) - (ay1 * bx2));
HXDLIN(  59)							Float tx1 = (ay1 - by2);
HXDLIN(  59)							Float ty1 = (bx2 - ax1);
HXDLIN(  59)							Float A1 = ((((-(by2) * cx2) + (ay1 * (-(bx2) + cx2))) + (ax1 * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  59)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  59)							if ((ax1 > bx2)) {
HXLINE(  59)								if ((ax1 > cx2)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((bx2 > cx2)) {
HXLINE(  59)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::floor(bx2);
            									}
HXDLIN(  59)									int ii_min = min;
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(ax1);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									xIter31 = this1;
            								}
            								else {
HXLINE(  59)									int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  59)								if ((bx2 > cx2)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((ax1 > cx2)) {
HXLINE(  59)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::ceil(ax1);
            									}
HXDLIN(  59)									int ii_min = min;
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									xIter31 = this1;
            								}
            								else {
HXLINE(  59)									int ii_min = ::Math_obj::floor(ax1);
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									xIter31 = this1;
            								}
            							}
HXDLIN(  59)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  59)							if ((ay1 > by2)) {
HXLINE(  59)								if ((ay1 > cy2)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((by2 > cy2)) {
HXLINE(  59)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::floor(by2);
            									}
HXDLIN(  59)									int ii_min = min;
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(ay1);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									yIter31 = this1;
            								}
            								else {
HXLINE(  59)									int ii_min = ::Math_obj::floor(by2);
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  59)								if ((by2 > cy2)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((ay1 > cy2)) {
HXLINE(  59)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::ceil(ay1);
            									}
HXDLIN(  59)									int ii_min = min;
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									yIter31 = this1;
            								}
            								else {
HXLINE(  59)									int ii_min = ::Math_obj::floor(ay1);
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									yIter31 = this1;
            								}
            							}
HXDLIN(  59)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  59)							if (hasUndo1) {
HXLINE(  59)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  59)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  59)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  59)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  59)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  59)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  59)								undoImage1 = this3;
HXDLIN(  59)								{
HXLINE(  59)									int rectLeft = xIter31->start;
HXDLIN(  59)									int rectTop = yIter31->start;
HXDLIN(  59)									int rectRight = xIter31->max;
HXDLIN(  59)									bool forceClear = false;
HXDLIN(  59)									{
HXLINE(  59)										int _g = rectTop;
HXDLIN(  59)										int _g1 = yIter31->max;
HXDLIN(  59)										while((_g < _g1)){
HXLINE(  59)											_g = (_g + 1);
HXDLIN(  59)											int dy = (_g - 1);
HXDLIN(  59)											{
HXLINE(  59)												int _g1 = rectLeft;
HXDLIN(  59)												int _g2 = rectRight;
HXDLIN(  59)												while((_g1 < _g2)){
HXLINE(  59)													_g1 = (_g1 + 1);
HXDLIN(  59)													int dx = (_g1 - 1);
HXDLIN(  59)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)													int index;
HXDLIN(  59)													if (pixelShape->useVirtualPos) {
HXLINE(  59)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  59)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  59)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)													int col;
HXDLIN(  59)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  59)														col = c;
            													}
HXDLIN(  59)													bool _hx_tmp;
HXDLIN(  59)													if (pixelShape->useMask) {
HXLINE(  59)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  59)														_hx_tmp = false;
            													}
HXDLIN(  59)													if (_hx_tmp) {
HXLINE(  59)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  59)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  59)														int index;
HXDLIN(  59)														if (this1->useVirtualPos) {
HXLINE(  59)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  59)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  59)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  59)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  59)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)														int v;
HXDLIN(  59)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  59)															v = c;
            														}
HXDLIN(  59)														int this3 = v;
HXDLIN(  59)														int maskPixel = this3;
HXDLIN(  59)														int this4 = col;
HXDLIN(  59)														int this5 = this4;
HXDLIN(  59)														if ((maskPixel == 0)) {
HXLINE(  59)															int this1 = this5;
HXDLIN(  59)															col = this1;
            														}
            														else {
HXLINE(  59)															Float m0;
HXDLIN(  59)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  59)															if ((this1 == 0)) {
HXLINE(  59)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m1;
HXDLIN(  59)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  59)															if ((this2 == 0)) {
HXLINE(  59)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m2;
HXDLIN(  59)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  59)															if ((this3 == 0)) {
HXLINE(  59)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m3;
HXDLIN(  59)															int this4 = (maskPixel & 255);
HXDLIN(  59)															if ((this4 == 0)) {
HXLINE(  59)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  59)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  59)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  59)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  59)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  59)													if ((col != 0)) {
HXLINE(  59)														int x = (dx - rectLeft);
HXDLIN(  59)														int y = (dy - rectTop);
HXDLIN(  59)														int this1 = col;
HXDLIN(  59)														int c = this1;
HXDLIN(  59)														bool _hx_tmp;
HXDLIN(  59)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE(  59)															_hx_tmp = false;
            														}
HXDLIN(  59)														if (_hx_tmp) {
HXLINE(  59)															int location;
HXDLIN(  59)															if (undoImage1->useVirtualPos) {
HXLINE(  59)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  59)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  59)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  59)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  59)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)															int this3 = this2;
HXDLIN(  59)															int this4;
HXDLIN(  59)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																this4 = this3;
            															}
HXDLIN(  59)															Float a1;
HXDLIN(  59)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)															if ((this5 == 0)) {
HXLINE(  59)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r1;
HXDLIN(  59)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)															if ((this6 == 0)) {
HXLINE(  59)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g1;
HXDLIN(  59)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)															if ((this7 == 0)) {
HXLINE(  59)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b1;
HXDLIN(  59)															int this8 = (this4 & 255);
HXDLIN(  59)															if ((this8 == 0)) {
HXLINE(  59)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a2;
HXDLIN(  59)															int this9 = ((col >> 24) & 255);
HXDLIN(  59)															if ((this9 == 0)) {
HXLINE(  59)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r2;
HXDLIN(  59)															int this10 = ((col >> 16) & 255);
HXDLIN(  59)															if ((this10 == 0)) {
HXLINE(  59)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g2;
HXDLIN(  59)															int this11 = ((col >> 8) & 255);
HXDLIN(  59)															if ((this11 == 0)) {
HXLINE(  59)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b2;
HXDLIN(  59)															int this12 = (col & 255);
HXDLIN(  59)															if ((this12 == 0)) {
HXLINE(  59)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)															{
HXLINE(  59)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  59)																int value;
HXDLIN(  59)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  59)																	value = blended;
            																}
HXDLIN(  59)																bool _hx_tmp;
HXDLIN(  59)																if ((location >= 0)) {
HXLINE(  59)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  59)																	_hx_tmp = false;
            																}
HXDLIN(  59)																if (_hx_tmp) {
HXLINE(  59)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  59)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  59)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  59)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  59)															int index;
HXDLIN(  59)															if (undoImage1->useVirtualPos) {
HXLINE(  59)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  59)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  59)															int value;
HXDLIN(  59)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  59)																value = c;
            															}
HXDLIN(  59)															bool _hx_tmp;
HXDLIN(  59)															if ((index >= 0)) {
HXLINE(  59)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  59)																_hx_tmp = false;
            															}
HXDLIN(  59)															if (_hx_tmp) {
HXLINE(  59)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  59)														if (forceClear) {
HXLINE(  59)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  59)															int x = (dx - rectLeft);
HXDLIN(  59)															int y = (dy - rectTop);
HXDLIN(  59)															int index;
HXDLIN(  59)															if (undoImage1->useVirtualPos) {
HXLINE(  59)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  59)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  59)															bool _hx_tmp;
HXDLIN(  59)															if ((index >= 0)) {
HXLINE(  59)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  59)																_hx_tmp = false;
            															}
HXDLIN(  59)															if (_hx_tmp) {
HXLINE(  59)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  59)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  59)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  59)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  59)							bool found1 = false;
HXDLIN(  59)							Float s1 = ((Float)0.);
HXDLIN(  59)							Float t1 = ((Float)0.);
HXDLIN(  59)							Float sxx1 = ((Float)0.);
HXDLIN(  59)							Float txx1 = ((Float)0.);
HXDLIN(  59)							{
HXLINE(  59)								int _g_min1 = xIter31->start;
HXDLIN(  59)								int _g_max1 = xIter31->max;
HXDLIN(  59)								while((_g_min1 < _g_max1)){
HXLINE(  59)									_g_min1 = (_g_min1 + 1);
HXDLIN(  59)									int x = (_g_min1 - 1);
HXLINE(  61)									sxx1 = (sx1 * ( (Float)(x) ));
HXLINE(  62)									txx1 = (tx1 * ( (Float)(x) ));
HXLINE(  63)									found1 = false;
HXLINE(  59)									{
HXLINE(  59)										int _g_min = yIter31->start;
HXDLIN(  59)										int _g_max = yIter31->max;
HXDLIN(  59)										while((_g_min < _g_max)){
HXLINE(  59)											_g_min = (_g_min + 1);
HXDLIN(  59)											int y = (_g_min - 1);
HXLINE(  65)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE(  66)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  59)											bool _hx_tmp;
HXDLIN(  59)											if (!((s1 <= 0))) {
HXLINE(  59)												_hx_tmp = (t1 <= 0);
            											}
            											else {
HXLINE(  59)												_hx_tmp = true;
            											}
HXDLIN(  59)											if (_hx_tmp) {
HXLINE(  59)												if (found1) {
HXLINE(  59)													goto _hx_goto_14;
            												}
            											}
            											else {
HXLINE(  59)												if (((s1 + t1) < A1)) {
HXLINE(  59)													{
HXLINE(  59)														int this1 = color1;
HXDLIN(  59)														int c = this1;
HXDLIN(  59)														bool _hx_tmp;
HXDLIN(  59)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)															_hx_tmp = pixelShape->transparent;
            														}
            														else {
HXLINE(  59)															_hx_tmp = false;
            														}
HXDLIN(  59)														if (_hx_tmp) {
HXLINE(  59)															int location;
HXDLIN(  59)															if (pixelShape->useVirtualPos) {
HXLINE(  59)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  59)																location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  59)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  59)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)															int this3 = this2;
HXDLIN(  59)															int this4;
HXDLIN(  59)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																this4 = this3;
            															}
HXDLIN(  59)															Float a1;
HXDLIN(  59)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)															if ((this5 == 0)) {
HXLINE(  59)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r1;
HXDLIN(  59)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)															if ((this6 == 0)) {
HXLINE(  59)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g1;
HXDLIN(  59)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)															if ((this7 == 0)) {
HXLINE(  59)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b1;
HXDLIN(  59)															int this8 = (this4 & 255);
HXDLIN(  59)															if ((this8 == 0)) {
HXLINE(  59)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a2;
HXDLIN(  59)															int this9 = ((color1 >> 24) & 255);
HXDLIN(  59)															if ((this9 == 0)) {
HXLINE(  59)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r2;
HXDLIN(  59)															int this10 = ((color1 >> 16) & 255);
HXDLIN(  59)															if ((this10 == 0)) {
HXLINE(  59)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g2;
HXDLIN(  59)															int this11 = ((color1 >> 8) & 255);
HXDLIN(  59)															if ((this11 == 0)) {
HXLINE(  59)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b2;
HXDLIN(  59)															int this12 = (color1 & 255);
HXDLIN(  59)															if ((this12 == 0)) {
HXLINE(  59)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)															{
HXLINE(  59)																::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  59)																int value;
HXDLIN(  59)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  59)																	value = blended;
            																}
HXDLIN(  59)																bool _hx_tmp;
HXDLIN(  59)																if ((location >= 0)) {
HXLINE(  59)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  59)																	_hx_tmp = false;
            																}
HXDLIN(  59)																if (_hx_tmp) {
HXLINE(  59)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  59)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  59)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  59)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)															int index;
HXDLIN(  59)															if (pixelShape->useVirtualPos) {
HXLINE(  59)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  59)																index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  59)															int value;
HXDLIN(  59)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  59)																value = c;
            															}
HXDLIN(  59)															bool _hx_tmp;
HXDLIN(  59)															if ((index >= 0)) {
HXLINE(  59)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  59)																_hx_tmp = false;
            															}
HXDLIN(  59)															if (_hx_tmp) {
HXLINE(  59)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE(  74)													found1 = true;
            												}
            												else {
HXLINE(  59)													if (found1) {
HXLINE(  59)														goto _hx_goto_14;
            													}
            												}
            											}
            										}
            										_hx_goto_14:;
            									}
            								}
            							}
HXDLIN(  59)							if ((hasHit1 == true)) {
HXLINE(  59)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx2,by2,cx2,cy2,true);
HXDLIN(  59)								if (hasUndo1) {
HXLINE(  59)									v->undoImage = undoImage1;
HXDLIN(  59)									v->undoX = xIter31->start;
HXDLIN(  59)									v->undoY = yIter31->start;
            								}
            							}
            						}
            					}
HXDLIN(  59)					{
HXLINE(  59)						Float bx3 = cx1;
HXDLIN(  59)						Float by3 = cy1;
HXDLIN(  59)						Float cx3 = dx;
HXDLIN(  59)						Float cy3 = dy;
HXDLIN(  59)						bool hasUndo2 = false;
HXDLIN(  59)						bool adjustWinding2 = (((((bx1 * by3) - (bx3 * by1)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by1) - (bx1 * cy3))) > 0);
HXDLIN(  59)						if (!(adjustWinding2)) {
HXLINE(  59)							Float bx_ = bx3;
HXDLIN(  59)							Float by_ = by3;
HXLINE(  26)							bx3 = cx3;
HXLINE(  27)							by3 = cy3;
HXLINE(  28)							cx3 = bx_;
HXLINE(  29)							cy3 = by_;
            						}
HXLINE(  59)						{
HXLINE(  59)							Float s02 = ((by1 * cx3) - (bx1 * cy3));
HXDLIN(  59)							Float sx2 = (cy3 - by1);
HXDLIN(  59)							Float sy2 = (bx1 - cx3);
HXDLIN(  59)							Float t02 = ((bx1 * by3) - (by1 * bx3));
HXDLIN(  59)							Float tx2 = (by1 - by3);
HXDLIN(  59)							Float ty2 = (bx3 - bx1);
HXDLIN(  59)							Float A2 = ((((-(by3) * cx3) + (by1 * (-(bx3) + cx3))) + (bx1 * (by3 - cy3))) + (bx3 * cy3));
HXDLIN(  59)							::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  59)							if ((bx1 > bx3)) {
HXLINE(  59)								if ((bx1 > cx3)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((bx3 > cx3)) {
HXLINE(  59)										min = ::Math_obj::floor(cx3);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::floor(bx3);
            									}
HXDLIN(  59)									int ii_min = min;
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									xIter32 = this1;
            								}
            								else {
HXLINE(  59)									int ii_min = ::Math_obj::floor(bx3);
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									xIter32 = this1;
            								}
            							}
            							else {
HXLINE(  59)								if ((bx3 > cx3)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((bx1 > cx3)) {
HXLINE(  59)										min = ::Math_obj::floor(cx3);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::ceil(bx1);
            									}
HXDLIN(  59)									int ii_min = min;
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(bx3);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									xIter32 = this1;
            								}
            								else {
HXLINE(  59)									int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									xIter32 = this1;
            								}
            							}
HXDLIN(  59)							::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  59)							if ((by1 > by3)) {
HXLINE(  59)								if ((by1 > cy3)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((by3 > cy3)) {
HXLINE(  59)										min = ::Math_obj::floor(cy3);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::floor(by3);
            									}
HXDLIN(  59)									int ii_min = min;
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									yIter32 = this1;
            								}
            								else {
HXLINE(  59)									int ii_min = ::Math_obj::floor(by3);
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									yIter32 = this1;
            								}
            							}
            							else {
HXLINE(  59)								if ((by3 > cy3)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((by1 > cy3)) {
HXLINE(  59)										min = ::Math_obj::floor(cy3);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::ceil(by1);
            									}
HXDLIN(  59)									int ii_min = min;
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(by3);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									yIter32 = this1;
            								}
            								else {
HXLINE(  59)									int ii_min = ::Math_obj::floor(by1);
HXDLIN(  59)									int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  59)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  59)									yIter32 = this1;
            								}
            							}
HXDLIN(  59)							::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  59)							if (hasUndo2) {
HXLINE(  59)								int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  59)								int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  59)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  59)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  59)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  59)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  59)								undoImage2 = this3;
HXDLIN(  59)								{
HXLINE(  59)									int rectLeft = xIter32->start;
HXDLIN(  59)									int rectTop = yIter32->start;
HXDLIN(  59)									int rectRight = xIter32->max;
HXDLIN(  59)									bool forceClear = false;
HXDLIN(  59)									{
HXLINE(  59)										int _g = rectTop;
HXDLIN(  59)										int _g1 = yIter32->max;
HXDLIN(  59)										while((_g < _g1)){
HXLINE(  59)											_g = (_g + 1);
HXDLIN(  59)											int dy = (_g - 1);
HXDLIN(  59)											{
HXLINE(  59)												int _g1 = rectLeft;
HXDLIN(  59)												int _g2 = rectRight;
HXDLIN(  59)												while((_g1 < _g2)){
HXLINE(  59)													_g1 = (_g1 + 1);
HXDLIN(  59)													int dx = (_g1 - 1);
HXDLIN(  59)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)													int index;
HXDLIN(  59)													if (pixelShape->useVirtualPos) {
HXLINE(  59)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  59)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  59)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)													int col;
HXDLIN(  59)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  59)														col = c;
            													}
HXDLIN(  59)													bool _hx_tmp;
HXDLIN(  59)													if (pixelShape->useMask) {
HXLINE(  59)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  59)														_hx_tmp = false;
            													}
HXDLIN(  59)													if (_hx_tmp) {
HXLINE(  59)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  59)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  59)														int index;
HXDLIN(  59)														if (this1->useVirtualPos) {
HXLINE(  59)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  59)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  59)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  59)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  59)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)														int v;
HXDLIN(  59)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  59)															v = c;
            														}
HXDLIN(  59)														int this3 = v;
HXDLIN(  59)														int maskPixel = this3;
HXDLIN(  59)														int this4 = col;
HXDLIN(  59)														int this5 = this4;
HXDLIN(  59)														if ((maskPixel == 0)) {
HXLINE(  59)															int this1 = this5;
HXDLIN(  59)															col = this1;
            														}
            														else {
HXLINE(  59)															Float m0;
HXDLIN(  59)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  59)															if ((this1 == 0)) {
HXLINE(  59)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m1;
HXDLIN(  59)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  59)															if ((this2 == 0)) {
HXLINE(  59)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m2;
HXDLIN(  59)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  59)															if ((this3 == 0)) {
HXLINE(  59)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m3;
HXDLIN(  59)															int this4 = (maskPixel & 255);
HXDLIN(  59)															if ((this4 == 0)) {
HXLINE(  59)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  59)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  59)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  59)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  59)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  59)													if ((col != 0)) {
HXLINE(  59)														int x = (dx - rectLeft);
HXDLIN(  59)														int y = (dy - rectTop);
HXDLIN(  59)														int this1 = col;
HXDLIN(  59)														int c = this1;
HXDLIN(  59)														bool _hx_tmp;
HXDLIN(  59)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)															_hx_tmp = undoImage2->transparent;
            														}
            														else {
HXLINE(  59)															_hx_tmp = false;
            														}
HXDLIN(  59)														if (_hx_tmp) {
HXLINE(  59)															int location;
HXDLIN(  59)															if (undoImage2->useVirtualPos) {
HXLINE(  59)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE(  59)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN(  59)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  59)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  59)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)															int this3 = this2;
HXDLIN(  59)															int this4;
HXDLIN(  59)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																this4 = this3;
            															}
HXDLIN(  59)															Float a1;
HXDLIN(  59)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)															if ((this5 == 0)) {
HXLINE(  59)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r1;
HXDLIN(  59)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)															if ((this6 == 0)) {
HXLINE(  59)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g1;
HXDLIN(  59)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)															if ((this7 == 0)) {
HXLINE(  59)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b1;
HXDLIN(  59)															int this8 = (this4 & 255);
HXDLIN(  59)															if ((this8 == 0)) {
HXLINE(  59)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a2;
HXDLIN(  59)															int this9 = ((col >> 24) & 255);
HXDLIN(  59)															if ((this9 == 0)) {
HXLINE(  59)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r2;
HXDLIN(  59)															int this10 = ((col >> 16) & 255);
HXDLIN(  59)															if ((this10 == 0)) {
HXLINE(  59)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g2;
HXDLIN(  59)															int this11 = ((col >> 8) & 255);
HXDLIN(  59)															if ((this11 == 0)) {
HXLINE(  59)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b2;
HXDLIN(  59)															int this12 = (col & 255);
HXDLIN(  59)															if ((this12 == 0)) {
HXLINE(  59)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)															{
HXLINE(  59)																::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  59)																int value;
HXDLIN(  59)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  59)																	value = blended;
            																}
HXDLIN(  59)																bool _hx_tmp;
HXDLIN(  59)																if ((location >= 0)) {
HXLINE(  59)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  59)																	_hx_tmp = false;
            																}
HXDLIN(  59)																if (_hx_tmp) {
HXLINE(  59)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  59)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  59)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  59)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  59)															int index;
HXDLIN(  59)															if (undoImage2->useVirtualPos) {
HXLINE(  59)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE(  59)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN(  59)															int value;
HXDLIN(  59)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  59)																value = c;
            															}
HXDLIN(  59)															bool _hx_tmp;
HXDLIN(  59)															if ((index >= 0)) {
HXLINE(  59)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  59)																_hx_tmp = false;
            															}
HXDLIN(  59)															if (_hx_tmp) {
HXLINE(  59)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  59)														if (forceClear) {
HXLINE(  59)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  59)															int x = (dx - rectLeft);
HXDLIN(  59)															int y = (dy - rectTop);
HXDLIN(  59)															int index;
HXDLIN(  59)															if (undoImage2->useVirtualPos) {
HXLINE(  59)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE(  59)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN(  59)															bool _hx_tmp;
HXDLIN(  59)															if ((index >= 0)) {
HXLINE(  59)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  59)																_hx_tmp = false;
            															}
HXDLIN(  59)															if (_hx_tmp) {
HXLINE(  59)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  59)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  59)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  59)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  59)							bool found2 = false;
HXDLIN(  59)							Float s2 = ((Float)0.);
HXDLIN(  59)							Float t2 = ((Float)0.);
HXDLIN(  59)							Float sxx2 = ((Float)0.);
HXDLIN(  59)							Float txx2 = ((Float)0.);
HXDLIN(  59)							{
HXLINE(  59)								int _g_min2 = xIter32->start;
HXDLIN(  59)								int _g_max2 = xIter32->max;
HXDLIN(  59)								while((_g_min2 < _g_max2)){
HXLINE(  59)									_g_min2 = (_g_min2 + 1);
HXDLIN(  59)									int x = (_g_min2 - 1);
HXLINE(  61)									sxx2 = (sx2 * ( (Float)(x) ));
HXLINE(  62)									txx2 = (tx2 * ( (Float)(x) ));
HXLINE(  63)									found2 = false;
HXLINE(  59)									{
HXLINE(  59)										int _g_min = yIter32->start;
HXDLIN(  59)										int _g_max = yIter32->max;
HXDLIN(  59)										while((_g_min < _g_max)){
HXLINE(  59)											_g_min = (_g_min + 1);
HXDLIN(  59)											int y = (_g_min - 1);
HXLINE(  65)											s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE(  66)											t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE(  59)											bool _hx_tmp;
HXDLIN(  59)											if (!((s2 <= 0))) {
HXLINE(  59)												_hx_tmp = (t2 <= 0);
            											}
            											else {
HXLINE(  59)												_hx_tmp = true;
            											}
HXDLIN(  59)											if (_hx_tmp) {
HXLINE(  59)												if (found2) {
HXLINE(  59)													goto _hx_goto_18;
            												}
            											}
            											else {
HXLINE(  59)												if (((s2 + t2) < A2)) {
HXLINE(  59)													{
HXLINE(  59)														int this1 = color1;
HXDLIN(  59)														int c = this1;
HXDLIN(  59)														bool _hx_tmp;
HXDLIN(  59)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)															_hx_tmp = pixelShape->transparent;
            														}
            														else {
HXLINE(  59)															_hx_tmp = false;
            														}
HXDLIN(  59)														if (_hx_tmp) {
HXLINE(  59)															int location;
HXDLIN(  59)															if (pixelShape->useVirtualPos) {
HXLINE(  59)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  59)																location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  59)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  59)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  59)															int this3 = this2;
HXDLIN(  59)															int this4;
HXDLIN(  59)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																this4 = this3;
            															}
HXDLIN(  59)															Float a1;
HXDLIN(  59)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)															if ((this5 == 0)) {
HXLINE(  59)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r1;
HXDLIN(  59)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)															if ((this6 == 0)) {
HXLINE(  59)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g1;
HXDLIN(  59)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)															if ((this7 == 0)) {
HXLINE(  59)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b1;
HXDLIN(  59)															int this8 = (this4 & 255);
HXDLIN(  59)															if ((this8 == 0)) {
HXLINE(  59)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a2;
HXDLIN(  59)															int this9 = ((color1 >> 24) & 255);
HXDLIN(  59)															if ((this9 == 0)) {
HXLINE(  59)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r2;
HXDLIN(  59)															int this10 = ((color1 >> 16) & 255);
HXDLIN(  59)															if ((this10 == 0)) {
HXLINE(  59)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g2;
HXDLIN(  59)															int this11 = ((color1 >> 8) & 255);
HXDLIN(  59)															if ((this11 == 0)) {
HXLINE(  59)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b2;
HXDLIN(  59)															int this12 = (color1 & 255);
HXDLIN(  59)															if ((this12 == 0)) {
HXLINE(  59)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)															{
HXLINE(  59)																::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  59)																int value;
HXDLIN(  59)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  59)																	value = blended;
            																}
HXDLIN(  59)																bool _hx_tmp;
HXDLIN(  59)																if ((location >= 0)) {
HXLINE(  59)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  59)																	_hx_tmp = false;
            																}
HXDLIN(  59)																if (_hx_tmp) {
HXLINE(  59)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  59)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  59)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  59)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  59)															int index;
HXDLIN(  59)															if (pixelShape->useVirtualPos) {
HXLINE(  59)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  59)																index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  59)															int value;
HXDLIN(  59)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  59)																value = c;
            															}
HXDLIN(  59)															bool _hx_tmp;
HXDLIN(  59)															if ((index >= 0)) {
HXLINE(  59)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  59)																_hx_tmp = false;
            															}
HXDLIN(  59)															if (_hx_tmp) {
HXLINE(  59)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  59)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  59)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  59)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  59)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  59)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE(  74)													found2 = true;
            												}
            												else {
HXLINE(  59)													if (found2) {
HXLINE(  59)														goto _hx_goto_18;
            													}
            												}
            											}
            										}
            										_hx_goto_18:;
            									}
            								}
            							}
HXDLIN(  59)							if ((hasHit1 == true)) {
HXLINE(  59)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx1,by1,bx3,by3,cx3,cy3,true);
HXDLIN(  59)								if (hasUndo2) {
HXLINE(  59)									v->undoImage = undoImage2;
HXDLIN(  59)									v->undoX = xIter32->start;
HXDLIN(  59)									v->undoY = yIter32->start;
            								}
            							}
            						}
            					}
HXDLIN(  59)					if ((hasHit1 == true)) {
HXLINE(  59)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax1,ay1,bx1,by1,cx1,cy1,dx,dy,true);
            					}
            				}
            			}
            		}
HXLINE(  60)		{
HXLINE(  60)			Float px1 = this->x2;
HXDLIN(  60)			Float py1 = this->y2;
HXDLIN(  60)			int color2 = this->strokeColor;
HXDLIN(  60)			bool hasHit2 = true;
HXDLIN(  60)			Float o1 = (this->y3 - py1);
HXDLIN(  60)			Float a1 = (this->x3 - px1);
HXDLIN(  60)			Float h1 = ::Math_obj::pow(((o1 * o1) + (a1 * a1)),((Float)0.5));
HXDLIN(  60)			Float theta1 = ::Math_obj::atan2(o1,a1);
HXDLIN(  60)			{
HXLINE(  60)				 ::Dynamic debugCorners1 = false;
HXDLIN(  60)				if (::hx::IsNull( debugCorners1 )) {
HXLINE( 878)					debugCorners1 = false;
            				}
HXLINE(  60)				Float sin1 = ::Math_obj::sin(theta1);
HXDLIN(  60)				Float cos1 = ::Math_obj::cos(theta1);
HXDLIN(  60)				Float radius1 = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  60)				Float dx1 = ((Float)0.1);
HXDLIN(  60)				Float dy1 = radius1;
HXDLIN(  60)				Float cx4 = h1;
HXDLIN(  60)				Float cy4 = radius1;
HXDLIN(  60)				Float bx4 = h1;
HXDLIN(  60)				Float by4 = -(radius1);
HXDLIN(  60)				Float ax2 = ((Float)0.1);
HXDLIN(  60)				Float ay2 = -(radius1);
HXDLIN(  60)				Float temp1 = ((Float)0.);
HXLINE(  28)				temp1 = (px1 + ((ax2 * cos1) - (ay2 * sin1)));
HXLINE(  29)				ay2 = (py1 + ((ay2 * cos1) + (ax2 * sin1)));
HXLINE(  30)				ax2 = temp1;
HXLINE(  32)				temp1 = (px1 + ((bx4 * cos1) - (by4 * sin1)));
HXLINE(  33)				by4 = (py1 + ((by4 * cos1) + (bx4 * sin1)));
HXLINE(  34)				bx4 = temp1;
HXLINE(  36)				temp1 = (px1 + ((cx4 * cos1) - (cy4 * sin1)));
HXLINE(  37)				cy4 = (py1 + ((cy4 * cos1) + (cx4 * sin1)));
HXLINE(  38)				cx4 = temp1;
HXLINE(  40)				temp1 = (px1 + ((dx1 * cos1) - (dy1 * sin1)));
HXLINE(  41)				dy1 = (py1 + ((dy1 * cos1) + (dx1 * sin1)));
HXLINE(  42)				dx1 = temp1;
HXLINE(  60)				if (( (bool)(debugCorners1) )) {
HXLINE(  60)					{
HXLINE(  60)						Float x = (ax2 - ((Float)6.));
HXDLIN(  60)						Float y = (ay2 - ((Float)6.));
HXDLIN(  60)						int p = ::Std_obj::_hx_int(x);
HXDLIN(  60)						int xx = p;
HXDLIN(  60)						int q = ::Std_obj::_hx_int(y);
HXDLIN(  60)						int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  60)						int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  60)						while(true){
HXLINE(  60)							{
HXLINE(  60)								p = (p + 1);
HXDLIN(  60)								int x = (p - 1);
HXDLIN(  60)								int this1 = -65536;
HXDLIN(  60)								int c = this1;
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									int location;
HXDLIN(  60)									if (pixelShape->useVirtualPos) {
HXLINE(  60)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  60)										location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  60)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)									int this3 = this2;
HXDLIN(  60)									int this4;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  60)										this4 = this3;
            									}
HXDLIN(  60)									Float a1;
HXDLIN(  60)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)									if ((this5 == 0)) {
HXLINE(  60)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r1;
HXDLIN(  60)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)									if ((this6 == 0)) {
HXLINE(  60)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g1;
HXDLIN(  60)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)									if ((this7 == 0)) {
HXLINE(  60)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b1;
HXDLIN(  60)									int this8 = (this4 & 255);
HXDLIN(  60)									if ((this8 == 0)) {
HXLINE(  60)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a2;
HXDLIN(  60)									int this9 = ((-65536 >> 24) & 255);
HXDLIN(  60)									if ((this9 == 0)) {
HXLINE(  60)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r2;
HXDLIN(  60)									int this10 = ((-65536 >> 16) & 255);
HXDLIN(  60)									if ((this10 == 0)) {
HXLINE(  60)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g2;
HXDLIN(  60)									int this11 = ((-65536 >> 8) & 255);
HXDLIN(  60)									if ((this11 == 0)) {
HXLINE(  60)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b2;
HXDLIN(  60)									int this12 = (-65536 & 255);
HXDLIN(  60)									if ((this12 == 0)) {
HXLINE(  60)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)									{
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  60)										int value;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  60)											value = blended;
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((location >= 0)) {
HXLINE(  60)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  60)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)									int index;
HXDLIN(  60)									if (pixelShape->useVirtualPos) {
HXLINE(  60)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  60)										index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  60)									int value;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  60)										value = c;
            									}
HXDLIN(  60)									bool _hx_tmp;
HXDLIN(  60)									if ((index >= 0)) {
HXLINE(  60)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  60)										_hx_tmp = false;
            									}
HXDLIN(  60)									if (_hx_tmp) {
HXLINE(  60)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  60)							if ((p > maxX)) {
HXLINE( 247)								p = xx;
HXLINE(  60)								q = (q + 1);
            							}
HXDLIN(  60)							if ((q > maxY)) {
HXLINE(  60)								goto _hx_goto_19;
            							}
            						}
            						_hx_goto_19:;
            					}
HXDLIN(  60)					{
HXLINE(  60)						Float x1 = (bx4 - ((Float)6.));
HXDLIN(  60)						Float y1 = (by4 - ((Float)6.));
HXDLIN(  60)						int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  60)						int xx1 = p1;
HXDLIN(  60)						int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  60)						int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  60)						int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  60)						while(true){
HXLINE(  60)							{
HXLINE(  60)								p1 = (p1 + 1);
HXDLIN(  60)								int x = (p1 - 1);
HXDLIN(  60)								int this1 = -16711936;
HXDLIN(  60)								int c = this1;
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									int location;
HXDLIN(  60)									if (pixelShape->useVirtualPos) {
HXLINE(  60)										location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  60)										location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            									}
HXDLIN(  60)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)									int this3 = this2;
HXDLIN(  60)									int this4;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  60)										this4 = this3;
            									}
HXDLIN(  60)									Float a1;
HXDLIN(  60)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)									if ((this5 == 0)) {
HXLINE(  60)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r1;
HXDLIN(  60)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)									if ((this6 == 0)) {
HXLINE(  60)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g1;
HXDLIN(  60)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)									if ((this7 == 0)) {
HXLINE(  60)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b1;
HXDLIN(  60)									int this8 = (this4 & 255);
HXDLIN(  60)									if ((this8 == 0)) {
HXLINE(  60)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a2;
HXDLIN(  60)									int this9 = ((-16711936 >> 24) & 255);
HXDLIN(  60)									if ((this9 == 0)) {
HXLINE(  60)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r2;
HXDLIN(  60)									int this10 = ((-16711936 >> 16) & 255);
HXDLIN(  60)									if ((this10 == 0)) {
HXLINE(  60)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g2;
HXDLIN(  60)									int this11 = ((-16711936 >> 8) & 255);
HXDLIN(  60)									if ((this11 == 0)) {
HXLINE(  60)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b2;
HXDLIN(  60)									int this12 = (-16711936 & 255);
HXDLIN(  60)									if ((this12 == 0)) {
HXLINE(  60)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)									{
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  60)										int value;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  60)											value = blended;
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((location >= 0)) {
HXLINE(  60)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  60)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)									int index;
HXDLIN(  60)									if (pixelShape->useVirtualPos) {
HXLINE(  60)										index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  60)										index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            									}
HXDLIN(  60)									int value;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  60)										value = c;
            									}
HXDLIN(  60)									bool _hx_tmp;
HXDLIN(  60)									if ((index >= 0)) {
HXLINE(  60)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  60)										_hx_tmp = false;
            									}
HXDLIN(  60)									if (_hx_tmp) {
HXLINE(  60)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  60)							if ((p1 > maxX1)) {
HXLINE( 247)								p1 = xx1;
HXLINE(  60)								q1 = (q1 + 1);
            							}
HXDLIN(  60)							if ((q1 > maxY1)) {
HXLINE(  60)								goto _hx_goto_20;
            							}
            						}
            						_hx_goto_20:;
            					}
HXDLIN(  60)					{
HXLINE(  60)						Float x2 = (cx4 - ((Float)6.));
HXDLIN(  60)						Float y2 = (cy4 - ((Float)6.));
HXDLIN(  60)						int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  60)						int xx2 = p2;
HXDLIN(  60)						int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  60)						int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  60)						int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  60)						while(true){
HXLINE(  60)							{
HXLINE(  60)								p2 = (p2 + 1);
HXDLIN(  60)								int x = (p2 - 1);
HXDLIN(  60)								int this1 = -16776961;
HXDLIN(  60)								int c = this1;
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									int location;
HXDLIN(  60)									if (pixelShape->useVirtualPos) {
HXLINE(  60)										location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  60)										location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            									}
HXDLIN(  60)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)									int this3 = this2;
HXDLIN(  60)									int this4;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  60)										this4 = this3;
            									}
HXDLIN(  60)									Float a1;
HXDLIN(  60)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)									if ((this5 == 0)) {
HXLINE(  60)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r1;
HXDLIN(  60)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)									if ((this6 == 0)) {
HXLINE(  60)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g1;
HXDLIN(  60)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)									if ((this7 == 0)) {
HXLINE(  60)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b1;
HXDLIN(  60)									int this8 = (this4 & 255);
HXDLIN(  60)									if ((this8 == 0)) {
HXLINE(  60)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a2;
HXDLIN(  60)									int this9 = ((-16776961 >> 24) & 255);
HXDLIN(  60)									if ((this9 == 0)) {
HXLINE(  60)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r2;
HXDLIN(  60)									int this10 = ((-16776961 >> 16) & 255);
HXDLIN(  60)									if ((this10 == 0)) {
HXLINE(  60)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g2;
HXDLIN(  60)									int this11 = ((-16776961 >> 8) & 255);
HXDLIN(  60)									if ((this11 == 0)) {
HXLINE(  60)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b2;
HXDLIN(  60)									int this12 = (-16776961 & 255);
HXDLIN(  60)									if ((this12 == 0)) {
HXLINE(  60)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)									{
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  60)										int value;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  60)											value = blended;
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((location >= 0)) {
HXLINE(  60)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  60)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)									int index;
HXDLIN(  60)									if (pixelShape->useVirtualPos) {
HXLINE(  60)										index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  60)										index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            									}
HXDLIN(  60)									int value;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  60)										value = c;
            									}
HXDLIN(  60)									bool _hx_tmp;
HXDLIN(  60)									if ((index >= 0)) {
HXLINE(  60)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  60)										_hx_tmp = false;
            									}
HXDLIN(  60)									if (_hx_tmp) {
HXLINE(  60)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  60)							if ((p2 > maxX2)) {
HXLINE( 247)								p2 = xx2;
HXLINE(  60)								q2 = (q2 + 1);
            							}
HXDLIN(  60)							if ((q2 > maxY2)) {
HXLINE(  60)								goto _hx_goto_21;
            							}
            						}
            						_hx_goto_21:;
            					}
HXDLIN(  60)					{
HXLINE(  60)						Float x3 = (dx1 - ((Float)6.));
HXDLIN(  60)						Float y3 = (dy1 - ((Float)6.));
HXDLIN(  60)						int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  60)						int xx3 = p3;
HXDLIN(  60)						int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  60)						int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  60)						int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  60)						while(true){
HXLINE(  60)							{
HXLINE(  60)								p3 = (p3 + 1);
HXDLIN(  60)								int x = (p3 - 1);
HXDLIN(  60)								int this1 = -1048336;
HXDLIN(  60)								int c = this1;
HXDLIN(  60)								bool _hx_tmp;
HXDLIN(  60)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  60)									_hx_tmp = false;
            								}
HXDLIN(  60)								if (_hx_tmp) {
HXLINE(  60)									int location;
HXDLIN(  60)									if (pixelShape->useVirtualPos) {
HXLINE(  60)										location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  60)										location = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            									}
HXDLIN(  60)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)									int this3 = this2;
HXDLIN(  60)									int this4;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  60)										this4 = this3;
            									}
HXDLIN(  60)									Float a1;
HXDLIN(  60)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)									if ((this5 == 0)) {
HXLINE(  60)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r1;
HXDLIN(  60)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)									if ((this6 == 0)) {
HXLINE(  60)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g1;
HXDLIN(  60)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)									if ((this7 == 0)) {
HXLINE(  60)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b1;
HXDLIN(  60)									int this8 = (this4 & 255);
HXDLIN(  60)									if ((this8 == 0)) {
HXLINE(  60)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a2;
HXDLIN(  60)									int this9 = ((-1048336 >> 24) & 255);
HXDLIN(  60)									if ((this9 == 0)) {
HXLINE(  60)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float r2;
HXDLIN(  60)									int this10 = ((-1048336 >> 16) & 255);
HXDLIN(  60)									if ((this10 == 0)) {
HXLINE(  60)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float g2;
HXDLIN(  60)									int this11 = ((-1048336 >> 8) & 255);
HXDLIN(  60)									if ((this11 == 0)) {
HXLINE(  60)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float b2;
HXDLIN(  60)									int this12 = (-1048336 & 255);
HXDLIN(  60)									if ((this12 == 0)) {
HXLINE(  60)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  60)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  60)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)									{
HXLINE(  60)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  60)										int value;
HXDLIN(  60)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  60)											value = blended;
            										}
HXDLIN(  60)										bool _hx_tmp;
HXDLIN(  60)										if ((location >= 0)) {
HXLINE(  60)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  60)											_hx_tmp = false;
            										}
HXDLIN(  60)										if (_hx_tmp) {
HXLINE(  60)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  60)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)									int index;
HXDLIN(  60)									if (pixelShape->useVirtualPos) {
HXLINE(  60)										index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  60)										index = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            									}
HXDLIN(  60)									int value;
HXDLIN(  60)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  60)										value = c;
            									}
HXDLIN(  60)									bool _hx_tmp;
HXDLIN(  60)									if ((index >= 0)) {
HXLINE(  60)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  60)										_hx_tmp = false;
            									}
HXDLIN(  60)									if (_hx_tmp) {
HXLINE(  60)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  60)							if ((p3 > maxX3)) {
HXLINE( 247)								p3 = xx3;
HXLINE(  60)								q3 = (q3 + 1);
            							}
HXDLIN(  60)							if ((q3 > maxY3)) {
HXLINE(  60)								goto _hx_goto_22;
            							}
            						}
            						_hx_goto_22:;
            					}
            				}
HXDLIN(  60)				{
HXLINE(  60)					{
HXLINE(  60)						Float bx5 = bx4;
HXDLIN(  60)						Float by5 = by4;
HXDLIN(  60)						Float cx5 = dx1;
HXDLIN(  60)						Float cy5 = dy1;
HXDLIN(  60)						bool hasUndo3 = false;
HXDLIN(  60)						bool adjustWinding3 = (((((ax2 * by5) - (bx5 * ay2)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay2) - (ax2 * cy5))) > 0);
HXDLIN(  60)						if (!(adjustWinding3)) {
HXLINE(  60)							Float bx_ = bx5;
HXDLIN(  60)							Float by_ = by5;
HXLINE(  26)							bx5 = cx5;
HXLINE(  27)							by5 = cy5;
HXLINE(  28)							cx5 = bx_;
HXLINE(  29)							cy5 = by_;
            						}
HXLINE(  60)						{
HXLINE(  60)							Float s03 = ((ay2 * cx5) - (ax2 * cy5));
HXDLIN(  60)							Float sx3 = (cy5 - ay2);
HXDLIN(  60)							Float sy3 = (ax2 - cx5);
HXDLIN(  60)							Float t03 = ((ax2 * by5) - (ay2 * bx5));
HXDLIN(  60)							Float tx3 = (ay2 - by5);
HXDLIN(  60)							Float ty3 = (bx5 - ax2);
HXDLIN(  60)							Float A3 = ((((-(by5) * cx5) + (ay2 * (-(bx5) + cx5))) + (ax2 * (by5 - cy5))) + (bx5 * cy5));
HXDLIN(  60)							::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  60)							if ((ax2 > bx5)) {
HXLINE(  60)								if ((ax2 > cx5)) {
HXLINE(  60)									int min;
HXDLIN(  60)									if ((bx5 > cx5)) {
HXLINE(  60)										min = ::Math_obj::floor(cx5);
            									}
            									else {
HXLINE(  60)										min = ::Math_obj::floor(bx5);
            									}
HXDLIN(  60)									int ii_min = min;
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(ax2);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									xIter33 = this1;
            								}
            								else {
HXLINE(  60)									int ii_min = ::Math_obj::floor(bx5);
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(cx5);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									xIter33 = this1;
            								}
            							}
            							else {
HXLINE(  60)								if ((bx5 > cx5)) {
HXLINE(  60)									int min;
HXDLIN(  60)									if ((ax2 > cx5)) {
HXLINE(  60)										min = ::Math_obj::floor(cx5);
            									}
            									else {
HXLINE(  60)										min = ::Math_obj::ceil(ax2);
            									}
HXDLIN(  60)									int ii_min = min;
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(bx5);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									xIter33 = this1;
            								}
            								else {
HXLINE(  60)									int ii_min = ::Math_obj::floor(ax2);
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(cx5);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									xIter33 = this1;
            								}
            							}
HXDLIN(  60)							::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  60)							if ((ay2 > by5)) {
HXLINE(  60)								if ((ay2 > cy5)) {
HXLINE(  60)									int min;
HXDLIN(  60)									if ((by5 > cy5)) {
HXLINE(  60)										min = ::Math_obj::floor(cy5);
            									}
            									else {
HXLINE(  60)										min = ::Math_obj::floor(by5);
            									}
HXDLIN(  60)									int ii_min = min;
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(ay2);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									yIter33 = this1;
            								}
            								else {
HXLINE(  60)									int ii_min = ::Math_obj::floor(by5);
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(cy5);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									yIter33 = this1;
            								}
            							}
            							else {
HXLINE(  60)								if ((by5 > cy5)) {
HXLINE(  60)									int min;
HXDLIN(  60)									if ((ay2 > cy5)) {
HXLINE(  60)										min = ::Math_obj::floor(cy5);
            									}
            									else {
HXLINE(  60)										min = ::Math_obj::ceil(ay2);
            									}
HXDLIN(  60)									int ii_min = min;
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(by5);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									yIter33 = this1;
            								}
            								else {
HXLINE(  60)									int ii_min = ::Math_obj::floor(ay2);
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(cy5);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									yIter33 = this1;
            								}
            							}
HXDLIN(  60)							::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  60)							if (hasUndo3) {
HXLINE(  60)								int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  60)								int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  60)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  60)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  60)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  60)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  60)								undoImage3 = this3;
HXDLIN(  60)								{
HXLINE(  60)									int rectLeft = xIter33->start;
HXDLIN(  60)									int rectTop = yIter33->start;
HXDLIN(  60)									int rectRight = xIter33->max;
HXDLIN(  60)									bool forceClear = false;
HXDLIN(  60)									{
HXLINE(  60)										int _g = rectTop;
HXDLIN(  60)										int _g1 = yIter33->max;
HXDLIN(  60)										while((_g < _g1)){
HXLINE(  60)											_g = (_g + 1);
HXDLIN(  60)											int dy = (_g - 1);
HXDLIN(  60)											{
HXLINE(  60)												int _g1 = rectLeft;
HXDLIN(  60)												int _g2 = rectRight;
HXDLIN(  60)												while((_g1 < _g2)){
HXLINE(  60)													_g1 = (_g1 + 1);
HXDLIN(  60)													int dx = (_g1 - 1);
HXDLIN(  60)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)													int index;
HXDLIN(  60)													if (pixelShape->useVirtualPos) {
HXLINE(  60)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  60)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  60)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)													int col;
HXDLIN(  60)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  60)														col = c;
            													}
HXDLIN(  60)													bool _hx_tmp;
HXDLIN(  60)													if (pixelShape->useMask) {
HXLINE(  60)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  60)														_hx_tmp = false;
            													}
HXDLIN(  60)													if (_hx_tmp) {
HXLINE(  60)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  60)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)														int index;
HXDLIN(  60)														if (this1->useVirtualPos) {
HXLINE(  60)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  60)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  60)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)														int v;
HXDLIN(  60)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  60)															v = c;
            														}
HXDLIN(  60)														int this3 = v;
HXDLIN(  60)														int maskPixel = this3;
HXDLIN(  60)														int this4 = col;
HXDLIN(  60)														int this5 = this4;
HXDLIN(  60)														if ((maskPixel == 0)) {
HXLINE(  60)															int this1 = this5;
HXDLIN(  60)															col = this1;
            														}
            														else {
HXLINE(  60)															Float m0;
HXDLIN(  60)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  60)															if ((this1 == 0)) {
HXLINE(  60)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m1;
HXDLIN(  60)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  60)															if ((this2 == 0)) {
HXLINE(  60)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m2;
HXDLIN(  60)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  60)															if ((this3 == 0)) {
HXLINE(  60)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m3;
HXDLIN(  60)															int this4 = (maskPixel & 255);
HXDLIN(  60)															if ((this4 == 0)) {
HXLINE(  60)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  60)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  60)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  60)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  60)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  60)													if ((col != 0)) {
HXLINE(  60)														int x = (dx - rectLeft);
HXDLIN(  60)														int y = (dy - rectTop);
HXDLIN(  60)														int this1 = col;
HXDLIN(  60)														int c = this1;
HXDLIN(  60)														bool _hx_tmp;
HXDLIN(  60)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)															_hx_tmp = undoImage3->transparent;
            														}
            														else {
HXLINE(  60)															_hx_tmp = false;
            														}
HXDLIN(  60)														if (_hx_tmp) {
HXLINE(  60)															int location;
HXDLIN(  60)															if (undoImage3->useVirtualPos) {
HXLINE(  60)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  60)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN(  60)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  60)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)															int this3 = this2;
HXDLIN(  60)															int this4;
HXDLIN(  60)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																this4 = this3;
            															}
HXDLIN(  60)															Float a1;
HXDLIN(  60)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)															if ((this5 == 0)) {
HXLINE(  60)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r1;
HXDLIN(  60)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)															if ((this6 == 0)) {
HXLINE(  60)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g1;
HXDLIN(  60)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)															if ((this7 == 0)) {
HXLINE(  60)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b1;
HXDLIN(  60)															int this8 = (this4 & 255);
HXDLIN(  60)															if ((this8 == 0)) {
HXLINE(  60)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a2;
HXDLIN(  60)															int this9 = ((col >> 24) & 255);
HXDLIN(  60)															if ((this9 == 0)) {
HXLINE(  60)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r2;
HXDLIN(  60)															int this10 = ((col >> 16) & 255);
HXDLIN(  60)															if ((this10 == 0)) {
HXLINE(  60)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g2;
HXDLIN(  60)															int this11 = ((col >> 8) & 255);
HXDLIN(  60)															if ((this11 == 0)) {
HXLINE(  60)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b2;
HXDLIN(  60)															int this12 = (col & 255);
HXDLIN(  60)															if ((this12 == 0)) {
HXLINE(  60)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)															{
HXLINE(  60)																::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  60)																int value;
HXDLIN(  60)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  60)																	value = blended;
            																}
HXDLIN(  60)																bool _hx_tmp;
HXDLIN(  60)																if ((location >= 0)) {
HXLINE(  60)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  60)																	_hx_tmp = false;
            																}
HXDLIN(  60)																if (_hx_tmp) {
HXLINE(  60)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  60)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  60)															int index;
HXDLIN(  60)															if (undoImage3->useVirtualPos) {
HXLINE(  60)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  60)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN(  60)															int value;
HXDLIN(  60)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  60)																value = c;
            															}
HXDLIN(  60)															bool _hx_tmp;
HXDLIN(  60)															if ((index >= 0)) {
HXLINE(  60)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  60)																_hx_tmp = false;
            															}
HXDLIN(  60)															if (_hx_tmp) {
HXLINE(  60)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  60)														if (forceClear) {
HXLINE(  60)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  60)															int x = (dx - rectLeft);
HXDLIN(  60)															int y = (dy - rectTop);
HXDLIN(  60)															int index;
HXDLIN(  60)															if (undoImage3->useVirtualPos) {
HXLINE(  60)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  60)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN(  60)															bool _hx_tmp;
HXDLIN(  60)															if ((index >= 0)) {
HXLINE(  60)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  60)																_hx_tmp = false;
            															}
HXDLIN(  60)															if (_hx_tmp) {
HXLINE(  60)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  60)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  60)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  60)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  60)							bool found3 = false;
HXDLIN(  60)							Float s3 = ((Float)0.);
HXDLIN(  60)							Float t3 = ((Float)0.);
HXDLIN(  60)							Float sxx3 = ((Float)0.);
HXDLIN(  60)							Float txx3 = ((Float)0.);
HXDLIN(  60)							{
HXLINE(  60)								int _g_min3 = xIter33->start;
HXDLIN(  60)								int _g_max3 = xIter33->max;
HXDLIN(  60)								while((_g_min3 < _g_max3)){
HXLINE(  60)									_g_min3 = (_g_min3 + 1);
HXDLIN(  60)									int x = (_g_min3 - 1);
HXLINE(  61)									sxx3 = (sx3 * ( (Float)(x) ));
HXLINE(  62)									txx3 = (tx3 * ( (Float)(x) ));
HXLINE(  63)									found3 = false;
HXLINE(  60)									{
HXLINE(  60)										int _g_min = yIter33->start;
HXDLIN(  60)										int _g_max = yIter33->max;
HXDLIN(  60)										while((_g_min < _g_max)){
HXLINE(  60)											_g_min = (_g_min + 1);
HXDLIN(  60)											int y = (_g_min - 1);
HXLINE(  65)											s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE(  66)											t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE(  60)											bool _hx_tmp;
HXDLIN(  60)											if (!((s3 <= 0))) {
HXLINE(  60)												_hx_tmp = (t3 <= 0);
            											}
            											else {
HXLINE(  60)												_hx_tmp = true;
            											}
HXDLIN(  60)											if (_hx_tmp) {
HXLINE(  60)												if (found3) {
HXLINE(  60)													goto _hx_goto_26;
            												}
            											}
            											else {
HXLINE(  60)												if (((s3 + t3) < A3)) {
HXLINE(  60)													{
HXLINE(  60)														int this1 = color2;
HXDLIN(  60)														int c = this1;
HXDLIN(  60)														bool _hx_tmp;
HXDLIN(  60)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)															_hx_tmp = pixelShape->transparent;
            														}
            														else {
HXLINE(  60)															_hx_tmp = false;
            														}
HXDLIN(  60)														if (_hx_tmp) {
HXLINE(  60)															int location;
HXDLIN(  60)															if (pixelShape->useVirtualPos) {
HXLINE(  60)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  60)																location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  60)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)															int this3 = this2;
HXDLIN(  60)															int this4;
HXDLIN(  60)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																this4 = this3;
            															}
HXDLIN(  60)															Float a1;
HXDLIN(  60)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)															if ((this5 == 0)) {
HXLINE(  60)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r1;
HXDLIN(  60)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)															if ((this6 == 0)) {
HXLINE(  60)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g1;
HXDLIN(  60)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)															if ((this7 == 0)) {
HXLINE(  60)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b1;
HXDLIN(  60)															int this8 = (this4 & 255);
HXDLIN(  60)															if ((this8 == 0)) {
HXLINE(  60)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a2;
HXDLIN(  60)															int this9 = ((color2 >> 24) & 255);
HXDLIN(  60)															if ((this9 == 0)) {
HXLINE(  60)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r2;
HXDLIN(  60)															int this10 = ((color2 >> 16) & 255);
HXDLIN(  60)															if ((this10 == 0)) {
HXLINE(  60)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g2;
HXDLIN(  60)															int this11 = ((color2 >> 8) & 255);
HXDLIN(  60)															if ((this11 == 0)) {
HXLINE(  60)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b2;
HXDLIN(  60)															int this12 = (color2 & 255);
HXDLIN(  60)															if ((this12 == 0)) {
HXLINE(  60)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)															{
HXLINE(  60)																::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  60)																int value;
HXDLIN(  60)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  60)																	value = blended;
            																}
HXDLIN(  60)																bool _hx_tmp;
HXDLIN(  60)																if ((location >= 0)) {
HXLINE(  60)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  60)																	_hx_tmp = false;
            																}
HXDLIN(  60)																if (_hx_tmp) {
HXLINE(  60)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  60)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)															int index;
HXDLIN(  60)															if (pixelShape->useVirtualPos) {
HXLINE(  60)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  60)																index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  60)															int value;
HXDLIN(  60)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  60)																value = c;
            															}
HXDLIN(  60)															bool _hx_tmp;
HXDLIN(  60)															if ((index >= 0)) {
HXLINE(  60)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  60)																_hx_tmp = false;
            															}
HXDLIN(  60)															if (_hx_tmp) {
HXLINE(  60)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE(  74)													found3 = true;
            												}
            												else {
HXLINE(  60)													if (found3) {
HXLINE(  60)														goto _hx_goto_26;
            													}
            												}
            											}
            										}
            										_hx_goto_26:;
            									}
            								}
            							}
HXDLIN(  60)							if ((hasHit2 == true)) {
HXLINE(  60)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax2,ay2,bx5,by5,cx5,cy5,true);
HXDLIN(  60)								if (hasUndo3) {
HXLINE(  60)									v->undoImage = undoImage3;
HXDLIN(  60)									v->undoX = xIter33->start;
HXDLIN(  60)									v->undoY = yIter33->start;
            								}
            							}
            						}
            					}
HXDLIN(  60)					{
HXLINE(  60)						Float bx6 = cx4;
HXDLIN(  60)						Float by6 = cy4;
HXDLIN(  60)						Float cx6 = dx1;
HXDLIN(  60)						Float cy6 = dy1;
HXDLIN(  60)						bool hasUndo4 = false;
HXDLIN(  60)						bool adjustWinding4 = (((((bx4 * by6) - (bx6 * by4)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * by4) - (bx4 * cy6))) > 0);
HXDLIN(  60)						if (!(adjustWinding4)) {
HXLINE(  60)							Float bx_ = bx6;
HXDLIN(  60)							Float by_ = by6;
HXLINE(  26)							bx6 = cx6;
HXLINE(  27)							by6 = cy6;
HXLINE(  28)							cx6 = bx_;
HXLINE(  29)							cy6 = by_;
            						}
HXLINE(  60)						{
HXLINE(  60)							Float s04 = ((by4 * cx6) - (bx4 * cy6));
HXDLIN(  60)							Float sx4 = (cy6 - by4);
HXDLIN(  60)							Float sy4 = (bx4 - cx6);
HXDLIN(  60)							Float t04 = ((bx4 * by6) - (by4 * bx6));
HXDLIN(  60)							Float tx4 = (by4 - by6);
HXDLIN(  60)							Float ty4 = (bx6 - bx4);
HXDLIN(  60)							Float A4 = ((((-(by6) * cx6) + (by4 * (-(bx6) + cx6))) + (bx4 * (by6 - cy6))) + (bx6 * cy6));
HXDLIN(  60)							::pixelimage::iter::IntIterStart xIter34;
HXDLIN(  60)							if ((bx4 > bx6)) {
HXLINE(  60)								if ((bx4 > cx6)) {
HXLINE(  60)									int min;
HXDLIN(  60)									if ((bx6 > cx6)) {
HXLINE(  60)										min = ::Math_obj::floor(cx6);
            									}
            									else {
HXLINE(  60)										min = ::Math_obj::floor(bx6);
            									}
HXDLIN(  60)									int ii_min = min;
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(bx4);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									xIter34 = this1;
            								}
            								else {
HXLINE(  60)									int ii_min = ::Math_obj::floor(bx6);
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(cx6);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									xIter34 = this1;
            								}
            							}
            							else {
HXLINE(  60)								if ((bx6 > cx6)) {
HXLINE(  60)									int min;
HXDLIN(  60)									if ((bx4 > cx6)) {
HXLINE(  60)										min = ::Math_obj::floor(cx6);
            									}
            									else {
HXLINE(  60)										min = ::Math_obj::ceil(bx4);
            									}
HXDLIN(  60)									int ii_min = min;
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(bx6);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									xIter34 = this1;
            								}
            								else {
HXLINE(  60)									int ii_min = ::Math_obj::floor(bx4);
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(cx6);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									xIter34 = this1;
            								}
            							}
HXDLIN(  60)							::pixelimage::iter::IntIterStart yIter34;
HXDLIN(  60)							if ((by4 > by6)) {
HXLINE(  60)								if ((by4 > cy6)) {
HXLINE(  60)									int min;
HXDLIN(  60)									if ((by6 > cy6)) {
HXLINE(  60)										min = ::Math_obj::floor(cy6);
            									}
            									else {
HXLINE(  60)										min = ::Math_obj::floor(by6);
            									}
HXDLIN(  60)									int ii_min = min;
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(by4);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									yIter34 = this1;
            								}
            								else {
HXLINE(  60)									int ii_min = ::Math_obj::floor(by6);
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(cy6);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									yIter34 = this1;
            								}
            							}
            							else {
HXLINE(  60)								if ((by6 > cy6)) {
HXLINE(  60)									int min;
HXDLIN(  60)									if ((by4 > cy6)) {
HXLINE(  60)										min = ::Math_obj::floor(cy6);
            									}
            									else {
HXLINE(  60)										min = ::Math_obj::ceil(by4);
            									}
HXDLIN(  60)									int ii_min = min;
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(by6);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									yIter34 = this1;
            								}
            								else {
HXLINE(  60)									int ii_min = ::Math_obj::floor(by4);
HXDLIN(  60)									int ii_max = ::Math_obj::ceil(cy6);
HXDLIN(  60)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  60)									yIter34 = this1;
            								}
            							}
HXDLIN(  60)							::pixelimage::ImageStruct undoImage4 = null();
HXDLIN(  60)							if (hasUndo4) {
HXLINE(  60)								int w = ((xIter34->max - xIter34->start) + 1);
HXDLIN(  60)								int h = ((yIter34->max - yIter34->start) + 1);
HXDLIN(  60)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  60)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  60)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  60)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  60)								undoImage4 = this3;
HXDLIN(  60)								{
HXLINE(  60)									int rectLeft = xIter34->start;
HXDLIN(  60)									int rectTop = yIter34->start;
HXDLIN(  60)									int rectRight = xIter34->max;
HXDLIN(  60)									bool forceClear = false;
HXDLIN(  60)									{
HXLINE(  60)										int _g = rectTop;
HXDLIN(  60)										int _g1 = yIter34->max;
HXDLIN(  60)										while((_g < _g1)){
HXLINE(  60)											_g = (_g + 1);
HXDLIN(  60)											int dy = (_g - 1);
HXDLIN(  60)											{
HXLINE(  60)												int _g1 = rectLeft;
HXDLIN(  60)												int _g2 = rectRight;
HXDLIN(  60)												while((_g1 < _g2)){
HXLINE(  60)													_g1 = (_g1 + 1);
HXDLIN(  60)													int dx = (_g1 - 1);
HXDLIN(  60)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)													int index;
HXDLIN(  60)													if (pixelShape->useVirtualPos) {
HXLINE(  60)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  60)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  60)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)													int col;
HXDLIN(  60)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  60)														col = c;
            													}
HXDLIN(  60)													bool _hx_tmp;
HXDLIN(  60)													if (pixelShape->useMask) {
HXLINE(  60)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  60)														_hx_tmp = false;
            													}
HXDLIN(  60)													if (_hx_tmp) {
HXLINE(  60)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  60)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  60)														int index;
HXDLIN(  60)														if (this1->useVirtualPos) {
HXLINE(  60)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  60)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  60)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  60)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  60)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)														int v;
HXDLIN(  60)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  60)															v = c;
            														}
HXDLIN(  60)														int this3 = v;
HXDLIN(  60)														int maskPixel = this3;
HXDLIN(  60)														int this4 = col;
HXDLIN(  60)														int this5 = this4;
HXDLIN(  60)														if ((maskPixel == 0)) {
HXLINE(  60)															int this1 = this5;
HXDLIN(  60)															col = this1;
            														}
            														else {
HXLINE(  60)															Float m0;
HXDLIN(  60)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  60)															if ((this1 == 0)) {
HXLINE(  60)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m1;
HXDLIN(  60)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  60)															if ((this2 == 0)) {
HXLINE(  60)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m2;
HXDLIN(  60)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  60)															if ((this3 == 0)) {
HXLINE(  60)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m3;
HXDLIN(  60)															int this4 = (maskPixel & 255);
HXDLIN(  60)															if ((this4 == 0)) {
HXLINE(  60)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  60)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  60)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  60)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  60)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  60)													if ((col != 0)) {
HXLINE(  60)														int x = (dx - rectLeft);
HXDLIN(  60)														int y = (dy - rectTop);
HXDLIN(  60)														int this1 = col;
HXDLIN(  60)														int c = this1;
HXDLIN(  60)														bool _hx_tmp;
HXDLIN(  60)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)															_hx_tmp = undoImage4->transparent;
            														}
            														else {
HXLINE(  60)															_hx_tmp = false;
            														}
HXDLIN(  60)														if (_hx_tmp) {
HXLINE(  60)															int location;
HXDLIN(  60)															if (undoImage4->useVirtualPos) {
HXLINE(  60)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            															}
            															else {
HXLINE(  60)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            															}
HXDLIN(  60)															::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  60)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)															int this3 = this2;
HXDLIN(  60)															int this4;
HXDLIN(  60)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																this4 = this3;
            															}
HXDLIN(  60)															Float a1;
HXDLIN(  60)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)															if ((this5 == 0)) {
HXLINE(  60)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r1;
HXDLIN(  60)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)															if ((this6 == 0)) {
HXLINE(  60)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g1;
HXDLIN(  60)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)															if ((this7 == 0)) {
HXLINE(  60)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b1;
HXDLIN(  60)															int this8 = (this4 & 255);
HXDLIN(  60)															if ((this8 == 0)) {
HXLINE(  60)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a2;
HXDLIN(  60)															int this9 = ((col >> 24) & 255);
HXDLIN(  60)															if ((this9 == 0)) {
HXLINE(  60)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r2;
HXDLIN(  60)															int this10 = ((col >> 16) & 255);
HXDLIN(  60)															if ((this10 == 0)) {
HXLINE(  60)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g2;
HXDLIN(  60)															int this11 = ((col >> 8) & 255);
HXDLIN(  60)															if ((this11 == 0)) {
HXLINE(  60)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b2;
HXDLIN(  60)															int this12 = (col & 255);
HXDLIN(  60)															if ((this12 == 0)) {
HXLINE(  60)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)															{
HXLINE(  60)																::haxe::io::ArrayBufferViewImpl this13 = undoImage4->image;
HXDLIN(  60)																int value;
HXDLIN(  60)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  60)																	value = blended;
            																}
HXDLIN(  60)																bool _hx_tmp;
HXDLIN(  60)																if ((location >= 0)) {
HXLINE(  60)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  60)																	_hx_tmp = false;
            																}
HXDLIN(  60)																if (_hx_tmp) {
HXLINE(  60)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  60)															::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  60)															int index;
HXDLIN(  60)															if (undoImage4->useVirtualPos) {
HXLINE(  60)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            															}
            															else {
HXLINE(  60)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            															}
HXDLIN(  60)															int value;
HXDLIN(  60)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  60)																value = c;
            															}
HXDLIN(  60)															bool _hx_tmp;
HXDLIN(  60)															if ((index >= 0)) {
HXLINE(  60)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  60)																_hx_tmp = false;
            															}
HXDLIN(  60)															if (_hx_tmp) {
HXLINE(  60)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  60)														if (forceClear) {
HXLINE(  60)															::haxe::io::ArrayBufferViewImpl this1 = undoImage4->image;
HXDLIN(  60)															int x = (dx - rectLeft);
HXDLIN(  60)															int y = (dy - rectTop);
HXDLIN(  60)															int index;
HXDLIN(  60)															if (undoImage4->useVirtualPos) {
HXLINE(  60)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x) - undoImage4->virtualX));
            															}
            															else {
HXLINE(  60)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage4->width) + x)) ));
            															}
HXDLIN(  60)															bool _hx_tmp;
HXDLIN(  60)															if ((index >= 0)) {
HXLINE(  60)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  60)																_hx_tmp = false;
            															}
HXDLIN(  60)															if (_hx_tmp) {
HXLINE(  60)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  60)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  60)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  60)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  60)							bool found4 = false;
HXDLIN(  60)							Float s4 = ((Float)0.);
HXDLIN(  60)							Float t4 = ((Float)0.);
HXDLIN(  60)							Float sxx4 = ((Float)0.);
HXDLIN(  60)							Float txx4 = ((Float)0.);
HXDLIN(  60)							{
HXLINE(  60)								int _g_min4 = xIter34->start;
HXDLIN(  60)								int _g_max4 = xIter34->max;
HXDLIN(  60)								while((_g_min4 < _g_max4)){
HXLINE(  60)									_g_min4 = (_g_min4 + 1);
HXDLIN(  60)									int x = (_g_min4 - 1);
HXLINE(  61)									sxx4 = (sx4 * ( (Float)(x) ));
HXLINE(  62)									txx4 = (tx4 * ( (Float)(x) ));
HXLINE(  63)									found4 = false;
HXLINE(  60)									{
HXLINE(  60)										int _g_min = yIter34->start;
HXDLIN(  60)										int _g_max = yIter34->max;
HXDLIN(  60)										while((_g_min < _g_max)){
HXLINE(  60)											_g_min = (_g_min + 1);
HXDLIN(  60)											int y = (_g_min - 1);
HXLINE(  65)											s4 = ((s04 + sxx4) + (sy4 * ( (Float)(y) )));
HXLINE(  66)											t4 = ((t04 + txx4) + (ty4 * ( (Float)(y) )));
HXLINE(  60)											bool _hx_tmp;
HXDLIN(  60)											if (!((s4 <= 0))) {
HXLINE(  60)												_hx_tmp = (t4 <= 0);
            											}
            											else {
HXLINE(  60)												_hx_tmp = true;
            											}
HXDLIN(  60)											if (_hx_tmp) {
HXLINE(  60)												if (found4) {
HXLINE(  60)													goto _hx_goto_30;
            												}
            											}
            											else {
HXLINE(  60)												if (((s4 + t4) < A4)) {
HXLINE(  60)													{
HXLINE(  60)														int this1 = color2;
HXDLIN(  60)														int c = this1;
HXDLIN(  60)														bool _hx_tmp;
HXDLIN(  60)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  60)															_hx_tmp = pixelShape->transparent;
            														}
            														else {
HXLINE(  60)															_hx_tmp = false;
            														}
HXDLIN(  60)														if (_hx_tmp) {
HXLINE(  60)															int location;
HXDLIN(  60)															if (pixelShape->useVirtualPos) {
HXLINE(  60)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  60)																location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  60)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  60)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  60)															int this3 = this2;
HXDLIN(  60)															int this4;
HXDLIN(  60)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																this4 = this3;
            															}
HXDLIN(  60)															Float a1;
HXDLIN(  60)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  60)															if ((this5 == 0)) {
HXLINE(  60)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r1;
HXDLIN(  60)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  60)															if ((this6 == 0)) {
HXLINE(  60)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g1;
HXDLIN(  60)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  60)															if ((this7 == 0)) {
HXLINE(  60)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b1;
HXDLIN(  60)															int this8 = (this4 & 255);
HXDLIN(  60)															if ((this8 == 0)) {
HXLINE(  60)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a2;
HXDLIN(  60)															int this9 = ((color2 >> 24) & 255);
HXDLIN(  60)															if ((this9 == 0)) {
HXLINE(  60)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r2;
HXDLIN(  60)															int this10 = ((color2 >> 16) & 255);
HXDLIN(  60)															if ((this10 == 0)) {
HXLINE(  60)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g2;
HXDLIN(  60)															int this11 = ((color2 >> 8) & 255);
HXDLIN(  60)															if ((this11 == 0)) {
HXLINE(  60)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b2;
HXDLIN(  60)															int this12 = (color2 & 255);
HXDLIN(  60)															if ((this12 == 0)) {
HXLINE(  60)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  60)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  60)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  60)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  60)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  60)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  60)															{
HXLINE(  60)																::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  60)																int value;
HXDLIN(  60)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  60)																	value = blended;
            																}
HXDLIN(  60)																bool _hx_tmp;
HXDLIN(  60)																if ((location >= 0)) {
HXLINE(  60)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  60)																	_hx_tmp = false;
            																}
HXDLIN(  60)																if (_hx_tmp) {
HXLINE(  60)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  60)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  60)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  60)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  60)															int index;
HXDLIN(  60)															if (pixelShape->useVirtualPos) {
HXLINE(  60)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  60)																index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  60)															int value;
HXDLIN(  60)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  60)																value = c;
            															}
HXDLIN(  60)															bool _hx_tmp;
HXDLIN(  60)															if ((index >= 0)) {
HXLINE(  60)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  60)																_hx_tmp = false;
            															}
HXDLIN(  60)															if (_hx_tmp) {
HXLINE(  60)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  60)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  60)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  60)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  60)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  60)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE(  74)													found4 = true;
            												}
            												else {
HXLINE(  60)													if (found4) {
HXLINE(  60)														goto _hx_goto_30;
            													}
            												}
            											}
            										}
            										_hx_goto_30:;
            									}
            								}
            							}
HXDLIN(  60)							if ((hasHit2 == true)) {
HXLINE(  60)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx4,by4,bx6,by6,cx6,cy6,true);
HXDLIN(  60)								if (hasUndo4) {
HXLINE(  60)									v->undoImage = undoImage4;
HXDLIN(  60)									v->undoX = xIter34->start;
HXDLIN(  60)									v->undoY = yIter34->start;
            								}
            							}
            						}
            					}
HXDLIN(  60)					if ((hasHit2 == true)) {
HXLINE(  60)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax2,ay2,bx4,by4,cx4,cy4,dx1,dy1,true);
            					}
            				}
            			}
            		}
HXLINE(  61)		{
HXLINE(  61)			Float px2 = this->x3;
HXDLIN(  61)			Float py2 = this->y3;
HXDLIN(  61)			int color3 = this->strokeColor;
HXDLIN(  61)			bool hasHit3 = true;
HXDLIN(  61)			Float o2 = (this->y1 - py2);
HXDLIN(  61)			Float a2 = (this->x1 - px2);
HXDLIN(  61)			Float h2 = ::Math_obj::pow(((o2 * o2) + (a2 * a2)),((Float)0.5));
HXDLIN(  61)			Float theta2 = ::Math_obj::atan2(o2,a2);
HXDLIN(  61)			{
HXLINE(  61)				 ::Dynamic debugCorners2 = false;
HXDLIN(  61)				if (::hx::IsNull( debugCorners2 )) {
HXLINE( 878)					debugCorners2 = false;
            				}
HXLINE(  61)				Float sin2 = ::Math_obj::sin(theta2);
HXDLIN(  61)				Float cos2 = ::Math_obj::cos(theta2);
HXDLIN(  61)				Float radius2 = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  61)				Float dx2 = ((Float)0.1);
HXDLIN(  61)				Float dy2 = radius2;
HXDLIN(  61)				Float cx7 = h2;
HXDLIN(  61)				Float cy7 = radius2;
HXDLIN(  61)				Float bx7 = h2;
HXDLIN(  61)				Float by7 = -(radius2);
HXDLIN(  61)				Float ax3 = ((Float)0.1);
HXDLIN(  61)				Float ay3 = -(radius2);
HXDLIN(  61)				Float temp2 = ((Float)0.);
HXLINE(  28)				temp2 = (px2 + ((ax3 * cos2) - (ay3 * sin2)));
HXLINE(  29)				ay3 = (py2 + ((ay3 * cos2) + (ax3 * sin2)));
HXLINE(  30)				ax3 = temp2;
HXLINE(  32)				temp2 = (px2 + ((bx7 * cos2) - (by7 * sin2)));
HXLINE(  33)				by7 = (py2 + ((by7 * cos2) + (bx7 * sin2)));
HXLINE(  34)				bx7 = temp2;
HXLINE(  36)				temp2 = (px2 + ((cx7 * cos2) - (cy7 * sin2)));
HXLINE(  37)				cy7 = (py2 + ((cy7 * cos2) + (cx7 * sin2)));
HXLINE(  38)				cx7 = temp2;
HXLINE(  40)				temp2 = (px2 + ((dx2 * cos2) - (dy2 * sin2)));
HXLINE(  41)				dy2 = (py2 + ((dy2 * cos2) + (dx2 * sin2)));
HXLINE(  42)				dx2 = temp2;
HXLINE(  61)				if (( (bool)(debugCorners2) )) {
HXLINE(  61)					{
HXLINE(  61)						Float x = (ax3 - ((Float)6.));
HXDLIN(  61)						Float y = (ay3 - ((Float)6.));
HXDLIN(  61)						int p = ::Std_obj::_hx_int(x);
HXDLIN(  61)						int xx = p;
HXDLIN(  61)						int q = ::Std_obj::_hx_int(y);
HXDLIN(  61)						int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  61)						int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  61)						while(true){
HXLINE(  61)							{
HXLINE(  61)								p = (p + 1);
HXDLIN(  61)								int x = (p - 1);
HXDLIN(  61)								int this1 = -65536;
HXDLIN(  61)								int c = this1;
HXDLIN(  61)								bool _hx_tmp;
HXDLIN(  61)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp = false;
            								}
HXDLIN(  61)								if (_hx_tmp) {
HXLINE(  61)									int location;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)									int this3 = this2;
HXDLIN(  61)									int this4;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this4 = this3;
            									}
HXDLIN(  61)									Float a1;
HXDLIN(  61)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)									if ((this5 == 0)) {
HXLINE(  61)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r1;
HXDLIN(  61)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)									if ((this6 == 0)) {
HXLINE(  61)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g1;
HXDLIN(  61)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)									if ((this7 == 0)) {
HXLINE(  61)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b1;
HXDLIN(  61)									int this8 = (this4 & 255);
HXDLIN(  61)									if ((this8 == 0)) {
HXLINE(  61)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a2;
HXDLIN(  61)									int this9 = ((-65536 >> 24) & 255);
HXDLIN(  61)									if ((this9 == 0)) {
HXLINE(  61)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r2;
HXDLIN(  61)									int this10 = ((-65536 >> 16) & 255);
HXDLIN(  61)									if ((this10 == 0)) {
HXLINE(  61)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g2;
HXDLIN(  61)									int this11 = ((-65536 >> 8) & 255);
HXDLIN(  61)									if ((this11 == 0)) {
HXLINE(  61)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b2;
HXDLIN(  61)									int this12 = (-65536 & 255);
HXDLIN(  61)									if ((this12 == 0)) {
HXLINE(  61)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)									{
HXLINE(  61)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)										int value;
HXDLIN(  61)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  61)											value = blended;
            										}
HXDLIN(  61)										bool _hx_tmp;
HXDLIN(  61)										if ((location >= 0)) {
HXLINE(  61)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  61)											_hx_tmp = false;
            										}
HXDLIN(  61)										if (_hx_tmp) {
HXLINE(  61)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									int index;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									int value;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  61)										value = c;
            									}
HXDLIN(  61)									bool _hx_tmp;
HXDLIN(  61)									if ((index >= 0)) {
HXLINE(  61)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  61)										_hx_tmp = false;
            									}
HXDLIN(  61)									if (_hx_tmp) {
HXLINE(  61)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  61)							if ((p > maxX)) {
HXLINE( 247)								p = xx;
HXLINE(  61)								q = (q + 1);
            							}
HXDLIN(  61)							if ((q > maxY)) {
HXLINE(  61)								goto _hx_goto_31;
            							}
            						}
            						_hx_goto_31:;
            					}
HXDLIN(  61)					{
HXLINE(  61)						Float x1 = (bx7 - ((Float)6.));
HXDLIN(  61)						Float y1 = (by7 - ((Float)6.));
HXDLIN(  61)						int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  61)						int xx1 = p1;
HXDLIN(  61)						int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  61)						int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  61)						int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  61)						while(true){
HXLINE(  61)							{
HXLINE(  61)								p1 = (p1 + 1);
HXDLIN(  61)								int x = (p1 - 1);
HXDLIN(  61)								int this1 = -16711936;
HXDLIN(  61)								int c = this1;
HXDLIN(  61)								bool _hx_tmp;
HXDLIN(  61)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp = false;
            								}
HXDLIN(  61)								if (_hx_tmp) {
HXLINE(  61)									int location;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)									int this3 = this2;
HXDLIN(  61)									int this4;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this4 = this3;
            									}
HXDLIN(  61)									Float a1;
HXDLIN(  61)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)									if ((this5 == 0)) {
HXLINE(  61)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r1;
HXDLIN(  61)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)									if ((this6 == 0)) {
HXLINE(  61)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g1;
HXDLIN(  61)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)									if ((this7 == 0)) {
HXLINE(  61)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b1;
HXDLIN(  61)									int this8 = (this4 & 255);
HXDLIN(  61)									if ((this8 == 0)) {
HXLINE(  61)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a2;
HXDLIN(  61)									int this9 = ((-16711936 >> 24) & 255);
HXDLIN(  61)									if ((this9 == 0)) {
HXLINE(  61)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r2;
HXDLIN(  61)									int this10 = ((-16711936 >> 16) & 255);
HXDLIN(  61)									if ((this10 == 0)) {
HXLINE(  61)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g2;
HXDLIN(  61)									int this11 = ((-16711936 >> 8) & 255);
HXDLIN(  61)									if ((this11 == 0)) {
HXLINE(  61)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b2;
HXDLIN(  61)									int this12 = (-16711936 & 255);
HXDLIN(  61)									if ((this12 == 0)) {
HXLINE(  61)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)									{
HXLINE(  61)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)										int value;
HXDLIN(  61)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  61)											value = blended;
            										}
HXDLIN(  61)										bool _hx_tmp;
HXDLIN(  61)										if ((location >= 0)) {
HXLINE(  61)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  61)											_hx_tmp = false;
            										}
HXDLIN(  61)										if (_hx_tmp) {
HXLINE(  61)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									int index;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									int value;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  61)										value = c;
            									}
HXDLIN(  61)									bool _hx_tmp;
HXDLIN(  61)									if ((index >= 0)) {
HXLINE(  61)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  61)										_hx_tmp = false;
            									}
HXDLIN(  61)									if (_hx_tmp) {
HXLINE(  61)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  61)							if ((p1 > maxX1)) {
HXLINE( 247)								p1 = xx1;
HXLINE(  61)								q1 = (q1 + 1);
            							}
HXDLIN(  61)							if ((q1 > maxY1)) {
HXLINE(  61)								goto _hx_goto_32;
            							}
            						}
            						_hx_goto_32:;
            					}
HXDLIN(  61)					{
HXLINE(  61)						Float x2 = (cx7 - ((Float)6.));
HXDLIN(  61)						Float y2 = (cy7 - ((Float)6.));
HXDLIN(  61)						int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  61)						int xx2 = p2;
HXDLIN(  61)						int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  61)						int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  61)						int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  61)						while(true){
HXLINE(  61)							{
HXLINE(  61)								p2 = (p2 + 1);
HXDLIN(  61)								int x = (p2 - 1);
HXDLIN(  61)								int this1 = -16776961;
HXDLIN(  61)								int c = this1;
HXDLIN(  61)								bool _hx_tmp;
HXDLIN(  61)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp = false;
            								}
HXDLIN(  61)								if (_hx_tmp) {
HXLINE(  61)									int location;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)									int this3 = this2;
HXDLIN(  61)									int this4;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this4 = this3;
            									}
HXDLIN(  61)									Float a1;
HXDLIN(  61)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)									if ((this5 == 0)) {
HXLINE(  61)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r1;
HXDLIN(  61)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)									if ((this6 == 0)) {
HXLINE(  61)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g1;
HXDLIN(  61)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)									if ((this7 == 0)) {
HXLINE(  61)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b1;
HXDLIN(  61)									int this8 = (this4 & 255);
HXDLIN(  61)									if ((this8 == 0)) {
HXLINE(  61)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a2;
HXDLIN(  61)									int this9 = ((-16776961 >> 24) & 255);
HXDLIN(  61)									if ((this9 == 0)) {
HXLINE(  61)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r2;
HXDLIN(  61)									int this10 = ((-16776961 >> 16) & 255);
HXDLIN(  61)									if ((this10 == 0)) {
HXLINE(  61)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g2;
HXDLIN(  61)									int this11 = ((-16776961 >> 8) & 255);
HXDLIN(  61)									if ((this11 == 0)) {
HXLINE(  61)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b2;
HXDLIN(  61)									int this12 = (-16776961 & 255);
HXDLIN(  61)									if ((this12 == 0)) {
HXLINE(  61)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)									{
HXLINE(  61)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)										int value;
HXDLIN(  61)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  61)											value = blended;
            										}
HXDLIN(  61)										bool _hx_tmp;
HXDLIN(  61)										if ((location >= 0)) {
HXLINE(  61)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  61)											_hx_tmp = false;
            										}
HXDLIN(  61)										if (_hx_tmp) {
HXLINE(  61)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									int index;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									int value;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  61)										value = c;
            									}
HXDLIN(  61)									bool _hx_tmp;
HXDLIN(  61)									if ((index >= 0)) {
HXLINE(  61)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  61)										_hx_tmp = false;
            									}
HXDLIN(  61)									if (_hx_tmp) {
HXLINE(  61)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  61)							if ((p2 > maxX2)) {
HXLINE( 247)								p2 = xx2;
HXLINE(  61)								q2 = (q2 + 1);
            							}
HXDLIN(  61)							if ((q2 > maxY2)) {
HXLINE(  61)								goto _hx_goto_33;
            							}
            						}
            						_hx_goto_33:;
            					}
HXDLIN(  61)					{
HXLINE(  61)						Float x3 = (dx2 - ((Float)6.));
HXDLIN(  61)						Float y3 = (dy2 - ((Float)6.));
HXDLIN(  61)						int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  61)						int xx3 = p3;
HXDLIN(  61)						int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  61)						int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  61)						int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  61)						while(true){
HXLINE(  61)							{
HXLINE(  61)								p3 = (p3 + 1);
HXDLIN(  61)								int x = (p3 - 1);
HXDLIN(  61)								int this1 = -1048336;
HXDLIN(  61)								int c = this1;
HXDLIN(  61)								bool _hx_tmp;
HXDLIN(  61)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp = false;
            								}
HXDLIN(  61)								if (_hx_tmp) {
HXLINE(  61)									int location;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										location = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)									int this3 = this2;
HXDLIN(  61)									int this4;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this4 = this3;
            									}
HXDLIN(  61)									Float a1;
HXDLIN(  61)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)									if ((this5 == 0)) {
HXLINE(  61)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r1;
HXDLIN(  61)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)									if ((this6 == 0)) {
HXLINE(  61)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g1;
HXDLIN(  61)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)									if ((this7 == 0)) {
HXLINE(  61)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b1;
HXDLIN(  61)									int this8 = (this4 & 255);
HXDLIN(  61)									if ((this8 == 0)) {
HXLINE(  61)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a2;
HXDLIN(  61)									int this9 = ((-1048336 >> 24) & 255);
HXDLIN(  61)									if ((this9 == 0)) {
HXLINE(  61)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r2;
HXDLIN(  61)									int this10 = ((-1048336 >> 16) & 255);
HXDLIN(  61)									if ((this10 == 0)) {
HXLINE(  61)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g2;
HXDLIN(  61)									int this11 = ((-1048336 >> 8) & 255);
HXDLIN(  61)									if ((this11 == 0)) {
HXLINE(  61)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b2;
HXDLIN(  61)									int this12 = (-1048336 & 255);
HXDLIN(  61)									if ((this12 == 0)) {
HXLINE(  61)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)									{
HXLINE(  61)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)										int value;
HXDLIN(  61)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  61)											value = blended;
            										}
HXDLIN(  61)										bool _hx_tmp;
HXDLIN(  61)										if ((location >= 0)) {
HXLINE(  61)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  61)											_hx_tmp = false;
            										}
HXDLIN(  61)										if (_hx_tmp) {
HXLINE(  61)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									int index;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										index = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									int value;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  61)										value = c;
            									}
HXDLIN(  61)									bool _hx_tmp;
HXDLIN(  61)									if ((index >= 0)) {
HXLINE(  61)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  61)										_hx_tmp = false;
            									}
HXDLIN(  61)									if (_hx_tmp) {
HXLINE(  61)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  61)							if ((p3 > maxX3)) {
HXLINE( 247)								p3 = xx3;
HXLINE(  61)								q3 = (q3 + 1);
            							}
HXDLIN(  61)							if ((q3 > maxY3)) {
HXLINE(  61)								goto _hx_goto_34;
            							}
            						}
            						_hx_goto_34:;
            					}
            				}
HXDLIN(  61)				{
HXLINE(  61)					{
HXLINE(  61)						Float bx8 = bx7;
HXDLIN(  61)						Float by8 = by7;
HXDLIN(  61)						Float cx8 = dx2;
HXDLIN(  61)						Float cy8 = dy2;
HXDLIN(  61)						bool hasUndo5 = false;
HXDLIN(  61)						bool adjustWinding5 = (((((ax3 * by8) - (bx8 * ay3)) + ((bx8 * cy8) - (cx8 * by8))) + ((cx8 * ay3) - (ax3 * cy8))) > 0);
HXDLIN(  61)						if (!(adjustWinding5)) {
HXLINE(  61)							Float bx_ = bx8;
HXDLIN(  61)							Float by_ = by8;
HXLINE(  26)							bx8 = cx8;
HXLINE(  27)							by8 = cy8;
HXLINE(  28)							cx8 = bx_;
HXLINE(  29)							cy8 = by_;
            						}
HXLINE(  61)						{
HXLINE(  61)							Float s05 = ((ay3 * cx8) - (ax3 * cy8));
HXDLIN(  61)							Float sx5 = (cy8 - ay3);
HXDLIN(  61)							Float sy5 = (ax3 - cx8);
HXDLIN(  61)							Float t05 = ((ax3 * by8) - (ay3 * bx8));
HXDLIN(  61)							Float tx5 = (ay3 - by8);
HXDLIN(  61)							Float ty5 = (bx8 - ax3);
HXDLIN(  61)							Float A5 = ((((-(by8) * cx8) + (ay3 * (-(bx8) + cx8))) + (ax3 * (by8 - cy8))) + (bx8 * cy8));
HXDLIN(  61)							::pixelimage::iter::IntIterStart xIter35;
HXDLIN(  61)							if ((ax3 > bx8)) {
HXLINE(  61)								if ((ax3 > cx8)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((bx8 > cx8)) {
HXLINE(  61)										min = ::Math_obj::floor(cx8);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::floor(bx8);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(ax3);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter35 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(bx8);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cx8);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter35 = this1;
            								}
            							}
            							else {
HXLINE(  61)								if ((bx8 > cx8)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((ax3 > cx8)) {
HXLINE(  61)										min = ::Math_obj::floor(cx8);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::ceil(ax3);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(bx8);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter35 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(ax3);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cx8);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter35 = this1;
            								}
            							}
HXDLIN(  61)							::pixelimage::iter::IntIterStart yIter35;
HXDLIN(  61)							if ((ay3 > by8)) {
HXLINE(  61)								if ((ay3 > cy8)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((by8 > cy8)) {
HXLINE(  61)										min = ::Math_obj::floor(cy8);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::floor(by8);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(ay3);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter35 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(by8);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cy8);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter35 = this1;
            								}
            							}
            							else {
HXLINE(  61)								if ((by8 > cy8)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((ay3 > cy8)) {
HXLINE(  61)										min = ::Math_obj::floor(cy8);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::ceil(ay3);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(by8);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter35 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(ay3);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cy8);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter35 = this1;
            								}
            							}
HXDLIN(  61)							::pixelimage::ImageStruct undoImage5 = null();
HXDLIN(  61)							if (hasUndo5) {
HXLINE(  61)								int w = ((xIter35->max - xIter35->start) + 1);
HXDLIN(  61)								int h = ((yIter35->max - yIter35->start) + 1);
HXDLIN(  61)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  61)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  61)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  61)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  61)								undoImage5 = this3;
HXDLIN(  61)								{
HXLINE(  61)									int rectLeft = xIter35->start;
HXDLIN(  61)									int rectTop = yIter35->start;
HXDLIN(  61)									int rectRight = xIter35->max;
HXDLIN(  61)									bool forceClear = false;
HXDLIN(  61)									{
HXLINE(  61)										int _g = rectTop;
HXDLIN(  61)										int _g1 = yIter35->max;
HXDLIN(  61)										while((_g < _g1)){
HXLINE(  61)											_g = (_g + 1);
HXDLIN(  61)											int dy = (_g - 1);
HXDLIN(  61)											{
HXLINE(  61)												int _g1 = rectLeft;
HXDLIN(  61)												int _g2 = rectRight;
HXDLIN(  61)												while((_g1 < _g2)){
HXLINE(  61)													_g1 = (_g1 + 1);
HXDLIN(  61)													int dx = (_g1 - 1);
HXDLIN(  61)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)													int index;
HXDLIN(  61)													if (pixelShape->useVirtualPos) {
HXLINE(  61)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  61)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  61)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)													int col;
HXDLIN(  61)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  61)														col = c;
            													}
HXDLIN(  61)													bool _hx_tmp;
HXDLIN(  61)													if (pixelShape->useMask) {
HXLINE(  61)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  61)														_hx_tmp = false;
            													}
HXDLIN(  61)													if (_hx_tmp) {
HXLINE(  61)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  61)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  61)														int index;
HXDLIN(  61)														if (this1->useVirtualPos) {
HXLINE(  61)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  61)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  61)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  61)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  61)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)														int v;
HXDLIN(  61)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  61)															v = c;
            														}
HXDLIN(  61)														int this3 = v;
HXDLIN(  61)														int maskPixel = this3;
HXDLIN(  61)														int this4 = col;
HXDLIN(  61)														int this5 = this4;
HXDLIN(  61)														if ((maskPixel == 0)) {
HXLINE(  61)															int this1 = this5;
HXDLIN(  61)															col = this1;
            														}
            														else {
HXLINE(  61)															Float m0;
HXDLIN(  61)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  61)															if ((this1 == 0)) {
HXLINE(  61)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m1;
HXDLIN(  61)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  61)															if ((this2 == 0)) {
HXLINE(  61)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m2;
HXDLIN(  61)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  61)															if ((this3 == 0)) {
HXLINE(  61)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m3;
HXDLIN(  61)															int this4 = (maskPixel & 255);
HXDLIN(  61)															if ((this4 == 0)) {
HXLINE(  61)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  61)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  61)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  61)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  61)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  61)													if ((col != 0)) {
HXLINE(  61)														int x = (dx - rectLeft);
HXDLIN(  61)														int y = (dy - rectTop);
HXDLIN(  61)														int this1 = col;
HXDLIN(  61)														int c = this1;
HXDLIN(  61)														bool _hx_tmp;
HXDLIN(  61)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)															_hx_tmp = undoImage5->transparent;
            														}
            														else {
HXLINE(  61)															_hx_tmp = false;
            														}
HXDLIN(  61)														if (_hx_tmp) {
HXLINE(  61)															int location;
HXDLIN(  61)															if (undoImage5->useVirtualPos) {
HXLINE(  61)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            															}
            															else {
HXLINE(  61)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            															}
HXDLIN(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  61)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)															int this3 = this2;
HXDLIN(  61)															int this4;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  61)																this4 = this3;
            															}
HXDLIN(  61)															Float a1;
HXDLIN(  61)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)															if ((this5 == 0)) {
HXLINE(  61)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r1;
HXDLIN(  61)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)															if ((this6 == 0)) {
HXLINE(  61)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g1;
HXDLIN(  61)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)															if ((this7 == 0)) {
HXLINE(  61)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b1;
HXDLIN(  61)															int this8 = (this4 & 255);
HXDLIN(  61)															if ((this8 == 0)) {
HXLINE(  61)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a2;
HXDLIN(  61)															int this9 = ((col >> 24) & 255);
HXDLIN(  61)															if ((this9 == 0)) {
HXLINE(  61)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r2;
HXDLIN(  61)															int this10 = ((col >> 16) & 255);
HXDLIN(  61)															if ((this10 == 0)) {
HXLINE(  61)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g2;
HXDLIN(  61)															int this11 = ((col >> 8) & 255);
HXDLIN(  61)															if ((this11 == 0)) {
HXLINE(  61)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b2;
HXDLIN(  61)															int this12 = (col & 255);
HXDLIN(  61)															if ((this12 == 0)) {
HXLINE(  61)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)															{
HXLINE(  61)																::haxe::io::ArrayBufferViewImpl this13 = undoImage5->image;
HXDLIN(  61)																int value;
HXDLIN(  61)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  61)																	value = blended;
            																}
HXDLIN(  61)																bool _hx_tmp;
HXDLIN(  61)																if ((location >= 0)) {
HXLINE(  61)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  61)																	_hx_tmp = false;
            																}
HXDLIN(  61)																if (_hx_tmp) {
HXLINE(  61)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  61)															int index;
HXDLIN(  61)															if (undoImage5->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            															}
HXDLIN(  61)															int value;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  61)																value = c;
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  61)														if (forceClear) {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage5->image;
HXDLIN(  61)															int x = (dx - rectLeft);
HXDLIN(  61)															int y = (dy - rectTop);
HXDLIN(  61)															int index;
HXDLIN(  61)															if (undoImage5->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage5->virtualY) * ( (Float)(undoImage5->width) )) + x) - undoImage5->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage5->width) + x)) ));
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							bool found5 = false;
HXDLIN(  61)							Float s5 = ((Float)0.);
HXDLIN(  61)							Float t5 = ((Float)0.);
HXDLIN(  61)							Float sxx5 = ((Float)0.);
HXDLIN(  61)							Float txx5 = ((Float)0.);
HXDLIN(  61)							{
HXLINE(  61)								int _g_min5 = xIter35->start;
HXDLIN(  61)								int _g_max5 = xIter35->max;
HXDLIN(  61)								while((_g_min5 < _g_max5)){
HXLINE(  61)									_g_min5 = (_g_min5 + 1);
HXDLIN(  61)									int x = (_g_min5 - 1);
HXDLIN(  61)									sxx5 = (sx5 * ( (Float)(x) ));
HXLINE(  62)									txx5 = (tx5 * ( (Float)(x) ));
HXLINE(  63)									found5 = false;
HXLINE(  61)									{
HXLINE(  61)										int _g_min = yIter35->start;
HXDLIN(  61)										int _g_max = yIter35->max;
HXDLIN(  61)										while((_g_min < _g_max)){
HXLINE(  61)											_g_min = (_g_min + 1);
HXDLIN(  61)											int y = (_g_min - 1);
HXLINE(  65)											s5 = ((s05 + sxx5) + (sy5 * ( (Float)(y) )));
HXLINE(  66)											t5 = ((t05 + txx5) + (ty5 * ( (Float)(y) )));
HXLINE(  61)											bool _hx_tmp;
HXDLIN(  61)											if (!((s5 <= 0))) {
HXLINE(  61)												_hx_tmp = (t5 <= 0);
            											}
            											else {
HXLINE(  61)												_hx_tmp = true;
            											}
HXDLIN(  61)											if (_hx_tmp) {
HXLINE(  61)												if (found5) {
HXLINE(  61)													goto _hx_goto_38;
            												}
            											}
            											else {
HXLINE(  61)												if (((s5 + t5) < A5)) {
HXLINE(  61)													{
HXLINE(  61)														int this1 = color3;
HXDLIN(  61)														int c = this1;
HXDLIN(  61)														bool _hx_tmp;
HXDLIN(  61)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)															_hx_tmp = pixelShape->transparent;
            														}
            														else {
HXLINE(  61)															_hx_tmp = false;
            														}
HXDLIN(  61)														if (_hx_tmp) {
HXLINE(  61)															int location;
HXDLIN(  61)															if (pixelShape->useVirtualPos) {
HXLINE(  61)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  61)																location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  61)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)															int this3 = this2;
HXDLIN(  61)															int this4;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  61)																this4 = this3;
            															}
HXDLIN(  61)															Float a1;
HXDLIN(  61)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)															if ((this5 == 0)) {
HXLINE(  61)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r1;
HXDLIN(  61)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)															if ((this6 == 0)) {
HXLINE(  61)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g1;
HXDLIN(  61)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)															if ((this7 == 0)) {
HXLINE(  61)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b1;
HXDLIN(  61)															int this8 = (this4 & 255);
HXDLIN(  61)															if ((this8 == 0)) {
HXLINE(  61)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a2;
HXDLIN(  61)															int this9 = ((color3 >> 24) & 255);
HXDLIN(  61)															if ((this9 == 0)) {
HXLINE(  61)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r2;
HXDLIN(  61)															int this10 = ((color3 >> 16) & 255);
HXDLIN(  61)															if ((this10 == 0)) {
HXLINE(  61)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g2;
HXDLIN(  61)															int this11 = ((color3 >> 8) & 255);
HXDLIN(  61)															if ((this11 == 0)) {
HXLINE(  61)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b2;
HXDLIN(  61)															int this12 = (color3 & 255);
HXDLIN(  61)															if ((this12 == 0)) {
HXLINE(  61)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)															{
HXLINE(  61)																::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)																int value;
HXDLIN(  61)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  61)																	value = blended;
            																}
HXDLIN(  61)																bool _hx_tmp;
HXDLIN(  61)																if ((location >= 0)) {
HXLINE(  61)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  61)																	_hx_tmp = false;
            																}
HXDLIN(  61)																if (_hx_tmp) {
HXLINE(  61)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)															int index;
HXDLIN(  61)															if (pixelShape->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  61)															int value;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  61)																value = c;
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE(  74)													found5 = true;
            												}
            												else {
HXLINE(  61)													if (found5) {
HXLINE(  61)														goto _hx_goto_38;
            													}
            												}
            											}
            										}
            										_hx_goto_38:;
            									}
            								}
            							}
HXDLIN(  61)							if ((hasHit3 == true)) {
HXLINE(  61)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax3,ay3,bx8,by8,cx8,cy8,true);
HXDLIN(  61)								if (hasUndo5) {
HXLINE(  61)									v->undoImage = undoImage5;
HXDLIN(  61)									v->undoX = xIter35->start;
HXDLIN(  61)									v->undoY = yIter35->start;
            								}
            							}
            						}
            					}
HXDLIN(  61)					{
HXLINE(  61)						Float bx9 = cx7;
HXDLIN(  61)						Float by9 = cy7;
HXDLIN(  61)						Float cx9 = dx2;
HXDLIN(  61)						Float cy9 = dy2;
HXDLIN(  61)						bool hasUndo6 = false;
HXDLIN(  61)						bool adjustWinding6 = (((((bx7 * by9) - (bx9 * by7)) + ((bx9 * cy9) - (cx9 * by9))) + ((cx9 * by7) - (bx7 * cy9))) > 0);
HXDLIN(  61)						if (!(adjustWinding6)) {
HXLINE(  61)							Float bx_ = bx9;
HXDLIN(  61)							Float by_ = by9;
HXLINE(  26)							bx9 = cx9;
HXLINE(  27)							by9 = cy9;
HXLINE(  28)							cx9 = bx_;
HXLINE(  29)							cy9 = by_;
            						}
HXLINE(  61)						{
HXLINE(  61)							Float s06 = ((by7 * cx9) - (bx7 * cy9));
HXDLIN(  61)							Float sx6 = (cy9 - by7);
HXDLIN(  61)							Float sy6 = (bx7 - cx9);
HXDLIN(  61)							Float t06 = ((bx7 * by9) - (by7 * bx9));
HXDLIN(  61)							Float tx6 = (by7 - by9);
HXDLIN(  61)							Float ty6 = (bx9 - bx7);
HXDLIN(  61)							Float A6 = ((((-(by9) * cx9) + (by7 * (-(bx9) + cx9))) + (bx7 * (by9 - cy9))) + (bx9 * cy9));
HXDLIN(  61)							::pixelimage::iter::IntIterStart xIter36;
HXDLIN(  61)							if ((bx7 > bx9)) {
HXLINE(  61)								if ((bx7 > cx9)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((bx9 > cx9)) {
HXLINE(  61)										min = ::Math_obj::floor(cx9);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::floor(bx9);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(bx7);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter36 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(bx9);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cx9);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter36 = this1;
            								}
            							}
            							else {
HXLINE(  61)								if ((bx9 > cx9)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((bx7 > cx9)) {
HXLINE(  61)										min = ::Math_obj::floor(cx9);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::ceil(bx7);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(bx9);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter36 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(bx7);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cx9);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter36 = this1;
            								}
            							}
HXDLIN(  61)							::pixelimage::iter::IntIterStart yIter36;
HXDLIN(  61)							if ((by7 > by9)) {
HXLINE(  61)								if ((by7 > cy9)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((by9 > cy9)) {
HXLINE(  61)										min = ::Math_obj::floor(cy9);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::floor(by9);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(by7);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter36 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(by9);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cy9);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter36 = this1;
            								}
            							}
            							else {
HXLINE(  61)								if ((by9 > cy9)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((by7 > cy9)) {
HXLINE(  61)										min = ::Math_obj::floor(cy9);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::ceil(by7);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(by9);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter36 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(by7);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cy9);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter36 = this1;
            								}
            							}
HXDLIN(  61)							::pixelimage::ImageStruct undoImage6 = null();
HXDLIN(  61)							if (hasUndo6) {
HXLINE(  61)								int w = ((xIter36->max - xIter36->start) + 1);
HXDLIN(  61)								int h = ((yIter36->max - yIter36->start) + 1);
HXDLIN(  61)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  61)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  61)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  61)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  61)								undoImage6 = this3;
HXDLIN(  61)								{
HXLINE(  61)									int rectLeft = xIter36->start;
HXDLIN(  61)									int rectTop = yIter36->start;
HXDLIN(  61)									int rectRight = xIter36->max;
HXDLIN(  61)									bool forceClear = false;
HXDLIN(  61)									{
HXLINE(  61)										int _g = rectTop;
HXDLIN(  61)										int _g1 = yIter36->max;
HXDLIN(  61)										while((_g < _g1)){
HXLINE(  61)											_g = (_g + 1);
HXDLIN(  61)											int dy = (_g - 1);
HXDLIN(  61)											{
HXLINE(  61)												int _g1 = rectLeft;
HXDLIN(  61)												int _g2 = rectRight;
HXDLIN(  61)												while((_g1 < _g2)){
HXLINE(  61)													_g1 = (_g1 + 1);
HXDLIN(  61)													int dx = (_g1 - 1);
HXDLIN(  61)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)													int index;
HXDLIN(  61)													if (pixelShape->useVirtualPos) {
HXLINE(  61)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  61)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  61)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)													int col;
HXDLIN(  61)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  61)														col = c;
            													}
HXDLIN(  61)													bool _hx_tmp;
HXDLIN(  61)													if (pixelShape->useMask) {
HXLINE(  61)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  61)														_hx_tmp = false;
            													}
HXDLIN(  61)													if (_hx_tmp) {
HXLINE(  61)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  61)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  61)														int index;
HXDLIN(  61)														if (this1->useVirtualPos) {
HXLINE(  61)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  61)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  61)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  61)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  61)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)														int v;
HXDLIN(  61)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  61)															v = c;
            														}
HXDLIN(  61)														int this3 = v;
HXDLIN(  61)														int maskPixel = this3;
HXDLIN(  61)														int this4 = col;
HXDLIN(  61)														int this5 = this4;
HXDLIN(  61)														if ((maskPixel == 0)) {
HXLINE(  61)															int this1 = this5;
HXDLIN(  61)															col = this1;
            														}
            														else {
HXLINE(  61)															Float m0;
HXDLIN(  61)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  61)															if ((this1 == 0)) {
HXLINE(  61)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m1;
HXDLIN(  61)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  61)															if ((this2 == 0)) {
HXLINE(  61)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m2;
HXDLIN(  61)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  61)															if ((this3 == 0)) {
HXLINE(  61)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m3;
HXDLIN(  61)															int this4 = (maskPixel & 255);
HXDLIN(  61)															if ((this4 == 0)) {
HXLINE(  61)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  61)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  61)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  61)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  61)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  61)													if ((col != 0)) {
HXLINE(  61)														int x = (dx - rectLeft);
HXDLIN(  61)														int y = (dy - rectTop);
HXDLIN(  61)														int this1 = col;
HXDLIN(  61)														int c = this1;
HXDLIN(  61)														bool _hx_tmp;
HXDLIN(  61)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)															_hx_tmp = undoImage6->transparent;
            														}
            														else {
HXLINE(  61)															_hx_tmp = false;
            														}
HXDLIN(  61)														if (_hx_tmp) {
HXLINE(  61)															int location;
HXDLIN(  61)															if (undoImage6->useVirtualPos) {
HXLINE(  61)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  61)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage6->width) + x)) ));
            															}
HXDLIN(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage6->image;
HXDLIN(  61)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)															int this3 = this2;
HXDLIN(  61)															int this4;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  61)																this4 = this3;
            															}
HXDLIN(  61)															Float a1;
HXDLIN(  61)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)															if ((this5 == 0)) {
HXLINE(  61)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r1;
HXDLIN(  61)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)															if ((this6 == 0)) {
HXLINE(  61)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g1;
HXDLIN(  61)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)															if ((this7 == 0)) {
HXLINE(  61)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b1;
HXDLIN(  61)															int this8 = (this4 & 255);
HXDLIN(  61)															if ((this8 == 0)) {
HXLINE(  61)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a2;
HXDLIN(  61)															int this9 = ((col >> 24) & 255);
HXDLIN(  61)															if ((this9 == 0)) {
HXLINE(  61)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r2;
HXDLIN(  61)															int this10 = ((col >> 16) & 255);
HXDLIN(  61)															if ((this10 == 0)) {
HXLINE(  61)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g2;
HXDLIN(  61)															int this11 = ((col >> 8) & 255);
HXDLIN(  61)															if ((this11 == 0)) {
HXLINE(  61)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b2;
HXDLIN(  61)															int this12 = (col & 255);
HXDLIN(  61)															if ((this12 == 0)) {
HXLINE(  61)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)															{
HXLINE(  61)																::haxe::io::ArrayBufferViewImpl this13 = undoImage6->image;
HXDLIN(  61)																int value;
HXDLIN(  61)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  61)																	value = blended;
            																}
HXDLIN(  61)																bool _hx_tmp;
HXDLIN(  61)																if ((location >= 0)) {
HXLINE(  61)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  61)																	_hx_tmp = false;
            																}
HXDLIN(  61)																if (_hx_tmp) {
HXLINE(  61)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage6->image;
HXDLIN(  61)															int index;
HXDLIN(  61)															if (undoImage6->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage6->width) + x)) ));
            															}
HXDLIN(  61)															int value;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  61)																value = c;
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  61)														if (forceClear) {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage6->image;
HXDLIN(  61)															int x = (dx - rectLeft);
HXDLIN(  61)															int y = (dy - rectTop);
HXDLIN(  61)															int index;
HXDLIN(  61)															if (undoImage6->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage6->width) + x)) ));
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							bool found6 = false;
HXDLIN(  61)							Float s6 = ((Float)0.);
HXDLIN(  61)							Float t6 = ((Float)0.);
HXDLIN(  61)							Float sxx6 = ((Float)0.);
HXDLIN(  61)							Float txx6 = ((Float)0.);
HXDLIN(  61)							{
HXLINE(  61)								int _g_min6 = xIter36->start;
HXDLIN(  61)								int _g_max6 = xIter36->max;
HXDLIN(  61)								while((_g_min6 < _g_max6)){
HXLINE(  61)									_g_min6 = (_g_min6 + 1);
HXDLIN(  61)									int x = (_g_min6 - 1);
HXDLIN(  61)									sxx6 = (sx6 * ( (Float)(x) ));
HXLINE(  62)									txx6 = (tx6 * ( (Float)(x) ));
HXLINE(  63)									found6 = false;
HXLINE(  61)									{
HXLINE(  61)										int _g_min = yIter36->start;
HXDLIN(  61)										int _g_max = yIter36->max;
HXDLIN(  61)										while((_g_min < _g_max)){
HXLINE(  61)											_g_min = (_g_min + 1);
HXDLIN(  61)											int y = (_g_min - 1);
HXLINE(  65)											s6 = ((s06 + sxx6) + (sy6 * ( (Float)(y) )));
HXLINE(  66)											t6 = ((t06 + txx6) + (ty6 * ( (Float)(y) )));
HXLINE(  61)											bool _hx_tmp;
HXDLIN(  61)											if (!((s6 <= 0))) {
HXLINE(  61)												_hx_tmp = (t6 <= 0);
            											}
            											else {
HXLINE(  61)												_hx_tmp = true;
            											}
HXDLIN(  61)											if (_hx_tmp) {
HXLINE(  61)												if (found6) {
HXLINE(  61)													goto _hx_goto_42;
            												}
            											}
            											else {
HXLINE(  61)												if (((s6 + t6) < A6)) {
HXLINE(  61)													{
HXLINE(  61)														int this1 = color3;
HXDLIN(  61)														int c = this1;
HXDLIN(  61)														bool _hx_tmp;
HXDLIN(  61)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)															_hx_tmp = pixelShape->transparent;
            														}
            														else {
HXLINE(  61)															_hx_tmp = false;
            														}
HXDLIN(  61)														if (_hx_tmp) {
HXLINE(  61)															int location;
HXDLIN(  61)															if (pixelShape->useVirtualPos) {
HXLINE(  61)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  61)																location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  61)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)															int this3 = this2;
HXDLIN(  61)															int this4;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  61)																this4 = this3;
            															}
HXDLIN(  61)															Float a1;
HXDLIN(  61)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)															if ((this5 == 0)) {
HXLINE(  61)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r1;
HXDLIN(  61)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)															if ((this6 == 0)) {
HXLINE(  61)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g1;
HXDLIN(  61)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)															if ((this7 == 0)) {
HXLINE(  61)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b1;
HXDLIN(  61)															int this8 = (this4 & 255);
HXDLIN(  61)															if ((this8 == 0)) {
HXLINE(  61)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a2;
HXDLIN(  61)															int this9 = ((color3 >> 24) & 255);
HXDLIN(  61)															if ((this9 == 0)) {
HXLINE(  61)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r2;
HXDLIN(  61)															int this10 = ((color3 >> 16) & 255);
HXDLIN(  61)															if ((this10 == 0)) {
HXLINE(  61)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g2;
HXDLIN(  61)															int this11 = ((color3 >> 8) & 255);
HXDLIN(  61)															if ((this11 == 0)) {
HXLINE(  61)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b2;
HXDLIN(  61)															int this12 = (color3 & 255);
HXDLIN(  61)															if ((this12 == 0)) {
HXLINE(  61)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)															{
HXLINE(  61)																::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)																int value;
HXDLIN(  61)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  61)																	value = blended;
            																}
HXDLIN(  61)																bool _hx_tmp;
HXDLIN(  61)																if ((location >= 0)) {
HXLINE(  61)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  61)																	_hx_tmp = false;
            																}
HXDLIN(  61)																if (_hx_tmp) {
HXLINE(  61)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)															int index;
HXDLIN(  61)															if (pixelShape->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  61)															int value;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  61)																value = c;
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE(  74)													found6 = true;
            												}
            												else {
HXLINE(  61)													if (found6) {
HXLINE(  61)														goto _hx_goto_42;
            													}
            												}
            											}
            										}
            										_hx_goto_42:;
            									}
            								}
            							}
HXDLIN(  61)							if ((hasHit3 == true)) {
HXLINE(  61)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx7,by7,bx9,by9,cx9,cy9,true);
HXDLIN(  61)								if (hasUndo6) {
HXLINE(  61)									v->undoImage = undoImage6;
HXDLIN(  61)									v->undoX = xIter36->start;
HXDLIN(  61)									v->undoY = yIter36->start;
            								}
            							}
            						}
            					}
HXDLIN(  61)					if ((hasHit3 == true)) {
HXLINE(  61)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax3,ay3,bx7,by7,cx7,cy7,dx2,dy2,true);
            					}
            				}
            			}
            		}
HXLINE(  62)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< TriangleShape_obj > TriangleShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3) {
	::hx::ObjectPtr< TriangleShape_obj > __this = new TriangleShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_fill,__o_x1,__o_y1,__o_x2,__o_y2,__o_x3,__o_y3);
	return __this;
}

::hx::ObjectPtr< TriangleShape_obj > TriangleShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_x3,::hx::Null< Float >  __o_y3) {
	TriangleShape_obj *__this = (TriangleShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TriangleShape_obj), true, "pixelimage.triangleGML.shape.TriangleShape"));
	*(void **)__this = TriangleShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_fill,__o_x1,__o_y1,__o_x2,__o_y2,__o_x3,__o_y3);
	return __this;
}

TriangleShape_obj::TriangleShape_obj()
{
}

::hx::Val TriangleShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { return ::hx::Val( x1 ); }
		if (HX_FIELD_EQ(inName,"y1") ) { return ::hx::Val( y1 ); }
		if (HX_FIELD_EQ(inName,"x2") ) { return ::hx::Val( x2 ); }
		if (HX_FIELD_EQ(inName,"y2") ) { return ::hx::Val( y2 ); }
		if (HX_FIELD_EQ(inName,"x3") ) { return ::hx::Val( x3 ); }
		if (HX_FIELD_EQ(inName,"y3") ) { return ::hx::Val( y3 ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val TriangleShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { x1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y1") ) { y1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x2") ) { x2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y2") ) { y2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x3") ) { x3=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y3") ) { y3=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TriangleShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x1",b9,68,00,00));
	outFields->push(HX_("y1",98,69,00,00));
	outFields->push(HX_("x2",ba,68,00,00));
	outFields->push(HX_("y2",99,69,00,00));
	outFields->push(HX_("x3",bb,68,00,00));
	outFields->push(HX_("y3",9a,69,00,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TriangleShape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(TriangleShape_obj,x1),HX_("x1",b9,68,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleShape_obj,y1),HX_("y1",98,69,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleShape_obj,x2),HX_("x2",ba,68,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleShape_obj,y2),HX_("y2",99,69,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleShape_obj,x3),HX_("x3",bb,68,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleShape_obj,y3),HX_("y3",9a,69,00,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *TriangleShape_obj_sStaticStorageInfo = 0;
#endif

static ::String TriangleShape_obj_sMemberFields[] = {
	HX_("x1",b9,68,00,00),
	HX_("y1",98,69,00,00),
	HX_("x2",ba,68,00,00),
	HX_("y2",99,69,00,00),
	HX_("x3",bb,68,00,00),
	HX_("y3",9a,69,00,00),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class TriangleShape_obj::__mClass;

void TriangleShape_obj::__register()
{
	TriangleShape_obj _hx_dummy;
	TriangleShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.shape.TriangleShape",e3,bc,4d,45);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TriangleShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TriangleShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TriangleShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TriangleShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace shape
