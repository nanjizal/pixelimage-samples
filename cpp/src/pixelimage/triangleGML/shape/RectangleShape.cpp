// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_FillShape
#include <pixelimage/triangleGML/coreShape/FillShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_shape_RectangleShape
#include <pixelimage/triangleGML/shape/RectangleShape.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b839ebe2c2620c02_27_new,"pixelimage.triangleGML.shape.RectangleShape","new",0x1dcb307a,"pixelimage.triangleGML.shape.RectangleShape.new","pixelimage/triangleGML/shape/RectangleShape.hx",27,0xde72ddd3)
HX_LOCAL_STACK_FRAME(_hx_pos_b839ebe2c2620c02_36_setParameter,"pixelimage.triangleGML.shape.RectangleShape","setParameter",0xdd2cc24d,"pixelimage.triangleGML.shape.RectangleShape.setParameter","pixelimage/triangleGML/shape/RectangleShape.hx",36,0xde72ddd3)
HX_LOCAL_STACK_FRAME(_hx_pos_b839ebe2c2620c02_51_render,"pixelimage.triangleGML.shape.RectangleShape","render",0xf1bd977c,"pixelimage.triangleGML.shape.RectangleShape.render","pixelimage/triangleGML/shape/RectangleShape.hx",51,0xde72ddd3)
namespace pixelimage{
namespace triangleGML{
namespace shape{

void RectangleShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< bool >  __o_rounded){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		int fill = __o_fill.Default(0);
            		Float left = __o_left.Default(((Float)0.));
            		Float top = __o_top.Default(((Float)0.));
            		Float width = __o_width.Default(((Float)1.));
            		Float height = __o_height.Default(((Float)1.));
            		bool rounded = __o_rounded.Default(false);
            	HX_STACKFRAME(&_hx_pos_b839ebe2c2620c02_27_new)
HXLINE(  28)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
HXLINE(  29)		this->left = left;
HXLINE(  30)		this->top = top;
HXLINE(  31)		this->width = width;
HXLINE(  32)		this->height = height;
HXLINE(  33)		this->rounded = rounded;
            	}

Dynamic RectangleShape_obj::__CreateEmpty() { return new RectangleShape_obj; }

void *RectangleShape_obj::_hx_vtable = 0;

Dynamic RectangleShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< RectangleShape_obj > _hx_result = new RectangleShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10]);
	return _hx_result;
}

bool RectangleShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2091632c) {
		if (inClassId<=(int)0x1f39f2ea) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x1f39f2ea;
		} else {
			return inClassId==(int)0x2091632c;
		}
	} else {
		return inClassId==(int)0x24e92cfb || inClassId==(int)0x389f4e25;
	}
}

void RectangleShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_b839ebe2c2620c02_36_setParameter)
HXDLIN(  36)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("height",e7,07,4c,02)) ){
HXLINE(  44)			this->height = ::Std_obj::parseFloat(value);
HXDLIN(  44)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("left",07,08,b0,47)) ){
HXLINE(  38)			this->left = ::Std_obj::parseFloat(value);
HXDLIN(  38)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("rounded",2d,80,0f,8d)) ){
HXLINE(  46)			bool _hx_tmp;
HXDLIN(  46)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  46)				_hx_tmp = true;
            			}
            			else {
HXLINE(  46)				_hx_tmp = false;
            			}
HXDLIN(  46)			this->rounded = _hx_tmp;
HXDLIN(  46)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("top",95,66,58,00)) ){
HXLINE(  40)			this->top = ::Std_obj::parseFloat(value);
HXDLIN(  40)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("width",06,b6,62,ca)) ){
HXLINE(  42)			this->width = ::Std_obj::parseFloat(value);
HXDLIN(  42)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  48)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct RectangleShape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_b839ebe2c2620c02_51_render)
HXLINE(  52)		if ((this->rounded == false)) {
HXLINE(  54)			int w = ::Math_obj::ceil(this->width);
HXDLIN(  54)			int h = ::Math_obj::ceil(this->height);
HXDLIN(  54)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  54)			::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  54)			::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  54)			::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  54)			::pixelimage::ImageStruct this4 = this3;
HXDLIN(  54)			::pixelimage::ImageStruct temp = this4;
HXLINE(  55)			temp->transparent = false;
HXLINE(  56)			{
HXLINE(  56)				Float h1 = this->height;
HXDLIN(  56)				int color = this->strokeColor;
HXDLIN(  56)				int p = 0;
HXDLIN(  56)				int xx = p;
HXDLIN(  56)				int q = 0;
HXDLIN(  56)				int maxX = ::Std_obj::_hx_int(this->width);
HXDLIN(  56)				int maxY = ::Std_obj::_hx_int(h1);
HXDLIN(  56)				while(true){
HXLINE(  56)					{
HXLINE(  56)						p = (p + 1);
HXDLIN(  56)						int x = (p - 1);
HXDLIN(  56)						int this1 = color;
HXDLIN(  56)						int c = this1;
HXDLIN(  56)						bool _hx_tmp;
HXDLIN(  56)						if ((((c >> 24) & 255) < 254)) {
HXLINE(  56)							_hx_tmp = temp->transparent;
            						}
            						else {
HXLINE(  56)							_hx_tmp = false;
            						}
HXDLIN(  56)						if (_hx_tmp) {
HXLINE(  56)							int location;
HXDLIN(  56)							if (temp->useVirtualPos) {
HXLINE(  56)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            							}
            							else {
HXLINE(  56)								location = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            							}
HXDLIN(  56)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  56)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  56)							int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  56)							int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  56)							int this3 = this2;
HXDLIN(  56)							int this4;
HXDLIN(  56)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)								this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            							}
            							else {
HXLINE(  56)								this4 = this3;
            							}
HXDLIN(  56)							Float a1;
HXDLIN(  56)							int this5 = ((this4 >> 24) & 255);
HXDLIN(  56)							if ((this5 == 0)) {
HXLINE(  56)								a1 = ((Float)0.);
            							}
            							else {
HXLINE(  56)								a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            							}
HXDLIN(  56)							Float r1;
HXDLIN(  56)							int this6 = ((this4 >> 16) & 255);
HXDLIN(  56)							if ((this6 == 0)) {
HXLINE(  56)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  56)								r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN(  56)							Float g1;
HXDLIN(  56)							int this7 = ((this4 >> 8) & 255);
HXDLIN(  56)							if ((this7 == 0)) {
HXLINE(  56)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  56)								g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN(  56)							Float b1;
HXDLIN(  56)							int this8 = (this4 & 255);
HXDLIN(  56)							if ((this8 == 0)) {
HXLINE(  56)								b1 = ((Float)0.);
            							}
            							else {
HXLINE(  56)								b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN(  56)							Float a2;
HXDLIN(  56)							int this9 = ((color >> 24) & 255);
HXDLIN(  56)							if ((this9 == 0)) {
HXLINE(  56)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  56)								a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  56)							Float r2;
HXDLIN(  56)							int this10 = ((color >> 16) & 255);
HXDLIN(  56)							if ((this10 == 0)) {
HXLINE(  56)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  56)								r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  56)							Float g2;
HXDLIN(  56)							int this11 = ((color >> 8) & 255);
HXDLIN(  56)							if ((this11 == 0)) {
HXLINE(  56)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  56)								g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  56)							Float b2;
HXDLIN(  56)							int this12 = (color & 255);
HXDLIN(  56)							if ((this12 == 0)) {
HXLINE(  56)								b2 = ((Float)0.);
            							}
            							else {
HXLINE(  56)								b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  56)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  56)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  56)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  56)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  56)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  56)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  56)							{
HXLINE(  56)								::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  56)								int value;
HXDLIN(  56)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  56)									value = blended;
            								}
HXDLIN(  56)								bool _hx_tmp;
HXDLIN(  56)								if ((location >= 0)) {
HXLINE(  56)									_hx_tmp = (location < (this13->byteLength >> 2));
            								}
            								else {
HXLINE(  56)									_hx_tmp = false;
            								}
HXDLIN(  56)								if (_hx_tmp) {
HXLINE(  56)									::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  56)									int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  56)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  56)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  56)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  56)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE(  56)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  56)							int index;
HXDLIN(  56)							if (temp->useVirtualPos) {
HXLINE(  56)								index = ::Std_obj::_hx_int(((((( (Float)(q) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            							}
            							else {
HXLINE(  56)								index = ::Std_obj::_hx_int(( (Float)(((q * temp->width) + x)) ));
            							}
HXDLIN(  56)							int value;
HXDLIN(  56)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  56)								value = c;
            							}
HXDLIN(  56)							bool _hx_tmp;
HXDLIN(  56)							if ((index >= 0)) {
HXLINE(  56)								_hx_tmp = (index < (this1->byteLength >> 2));
            							}
            							else {
HXLINE(  56)								_hx_tmp = false;
            							}
HXDLIN(  56)							if (_hx_tmp) {
HXLINE(  56)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  56)								int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  56)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  56)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  56)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  56)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN(  56)					if ((p > maxX)) {
HXLINE( 247)						p = xx;
HXLINE(  56)						q = (q + 1);
            					}
HXDLIN(  56)					if ((q > maxY)) {
HXLINE(  56)						goto _hx_goto_3;
            					}
            				}
            				_hx_goto_3:;
            			}
HXLINE(  57)			{
HXLINE(  57)				Float x = this->strokeWidth;
HXDLIN(  57)				Float y = this->strokeWidth;
HXDLIN(  57)				Float w1 = (this->width - (( (Float)(2) ) * this->strokeWidth));
HXDLIN(  57)				Float h2 = (this->height - (( (Float)(2) ) * this->strokeWidth));
HXDLIN(  57)				int color1 = this->fill;
HXDLIN(  57)				int p1 = ::Std_obj::_hx_int(x);
HXDLIN(  57)				int xx1 = p1;
HXDLIN(  57)				int q1 = ::Std_obj::_hx_int(y);
HXDLIN(  57)				int maxX1 = ::Std_obj::_hx_int((x + w1));
HXDLIN(  57)				int maxY1 = ::Std_obj::_hx_int((y + h2));
HXDLIN(  57)				while(true){
HXLINE(  57)					{
HXLINE(  57)						p1 = (p1 + 1);
HXDLIN(  57)						int x = (p1 - 1);
HXDLIN(  57)						int this1 = color1;
HXDLIN(  57)						int c = this1;
HXDLIN(  57)						bool _hx_tmp;
HXDLIN(  57)						if ((((c >> 24) & 255) < 254)) {
HXLINE(  57)							_hx_tmp = temp->transparent;
            						}
            						else {
HXLINE(  57)							_hx_tmp = false;
            						}
HXDLIN(  57)						if (_hx_tmp) {
HXLINE(  57)							int location;
HXDLIN(  57)							if (temp->useVirtualPos) {
HXLINE(  57)								location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            							}
            							else {
HXLINE(  57)								location = ::Std_obj::_hx_int(( (Float)(((q1 * temp->width) + x)) ));
            							}
HXDLIN(  57)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  57)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  57)							int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  57)							int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  57)							int this3 = this2;
HXDLIN(  57)							int this4;
HXDLIN(  57)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)								this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            							}
            							else {
HXLINE(  57)								this4 = this3;
            							}
HXDLIN(  57)							Float a1;
HXDLIN(  57)							int this5 = ((this4 >> 24) & 255);
HXDLIN(  57)							if ((this5 == 0)) {
HXLINE(  57)								a1 = ((Float)0.);
            							}
            							else {
HXLINE(  57)								a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            							}
HXDLIN(  57)							Float r1;
HXDLIN(  57)							int this6 = ((this4 >> 16) & 255);
HXDLIN(  57)							if ((this6 == 0)) {
HXLINE(  57)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  57)								r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN(  57)							Float g1;
HXDLIN(  57)							int this7 = ((this4 >> 8) & 255);
HXDLIN(  57)							if ((this7 == 0)) {
HXLINE(  57)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  57)								g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN(  57)							Float b1;
HXDLIN(  57)							int this8 = (this4 & 255);
HXDLIN(  57)							if ((this8 == 0)) {
HXLINE(  57)								b1 = ((Float)0.);
            							}
            							else {
HXLINE(  57)								b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN(  57)							Float a2;
HXDLIN(  57)							int this9 = ((color1 >> 24) & 255);
HXDLIN(  57)							if ((this9 == 0)) {
HXLINE(  57)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  57)								a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  57)							Float r2;
HXDLIN(  57)							int this10 = ((color1 >> 16) & 255);
HXDLIN(  57)							if ((this10 == 0)) {
HXLINE(  57)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  57)								r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  57)							Float g2;
HXDLIN(  57)							int this11 = ((color1 >> 8) & 255);
HXDLIN(  57)							if ((this11 == 0)) {
HXLINE(  57)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  57)								g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  57)							Float b2;
HXDLIN(  57)							int this12 = (color1 & 255);
HXDLIN(  57)							if ((this12 == 0)) {
HXLINE(  57)								b2 = ((Float)0.);
            							}
            							else {
HXLINE(  57)								b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  57)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  57)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  57)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  57)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  57)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  57)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  57)							{
HXLINE(  57)								::haxe::io::ArrayBufferViewImpl this13 = temp->image;
HXDLIN(  57)								int value;
HXDLIN(  57)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)									value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  57)									value = blended;
            								}
HXDLIN(  57)								bool _hx_tmp;
HXDLIN(  57)								if ((location >= 0)) {
HXLINE(  57)									_hx_tmp = (location < (this13->byteLength >> 2));
            								}
            								else {
HXLINE(  57)									_hx_tmp = false;
            								}
HXDLIN(  57)								if (_hx_tmp) {
HXLINE(  57)									::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  57)									int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  57)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  57)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  57)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  57)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
            						else {
HXLINE(  57)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  57)							int index;
HXDLIN(  57)							if (temp->useVirtualPos) {
HXLINE(  57)								index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - temp->virtualY) * ( (Float)(temp->width) )) + x) - temp->virtualX));
            							}
            							else {
HXLINE(  57)								index = ::Std_obj::_hx_int(( (Float)(((q1 * temp->width) + x)) ));
            							}
HXDLIN(  57)							int value;
HXDLIN(  57)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)								value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  57)								value = c;
            							}
HXDLIN(  57)							bool _hx_tmp;
HXDLIN(  57)							if ((index >= 0)) {
HXLINE(  57)								_hx_tmp = (index < (this1->byteLength >> 2));
            							}
            							else {
HXLINE(  57)								_hx_tmp = false;
            							}
HXDLIN(  57)							if (_hx_tmp) {
HXLINE(  57)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  57)								int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  57)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  57)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  57)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  57)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
HXDLIN(  57)					if ((p1 > maxX1)) {
HXLINE( 247)						p1 = xx1;
HXLINE(  57)						q1 = (q1 + 1);
            					}
HXDLIN(  57)					if ((q1 > maxY1)) {
HXLINE(  57)						goto _hx_goto_4;
            					}
            				}
            				_hx_goto_4:;
            			}
HXLINE(  58)			{
HXLINE(  58)				int x1 = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  58)				int y1 = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  58)				bool forceClear = false;
HXDLIN(  58)				{
HXLINE(  58)					int _g = 0;
HXDLIN(  58)					int _g1 = temp->height;
HXDLIN(  58)					while((_g < _g1)){
HXLINE(  58)						_g = (_g + 1);
HXDLIN(  58)						int dy = (_g - 1);
HXDLIN(  58)						{
HXLINE(  58)							int _g1 = 0;
HXDLIN(  58)							int _g2 = temp->width;
HXDLIN(  58)							while((_g1 < _g2)){
HXLINE(  58)								_g1 = (_g1 + 1);
HXDLIN(  58)								int dx = (_g1 - 1);
HXDLIN(  58)								::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  58)								int index;
HXDLIN(  58)								if (temp->useVirtualPos) {
HXLINE(  58)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            								}
            								else {
HXLINE(  58)									index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            								}
HXDLIN(  58)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  58)								int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  58)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  58)								int col;
HXDLIN(  58)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  58)									col = c;
            								}
HXDLIN(  58)								bool _hx_tmp;
HXDLIN(  58)								if (temp->useMask) {
HXLINE(  58)									_hx_tmp = ::hx::IsNotNull( temp->mask );
            								}
            								else {
HXLINE(  58)									_hx_tmp = false;
            								}
HXDLIN(  58)								if (_hx_tmp) {
HXLINE(  58)									::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  58)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  58)									int index;
HXDLIN(  58)									if (this1->useVirtualPos) {
HXLINE(  58)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            									}
            									else {
HXLINE(  58)										index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            									}
HXDLIN(  58)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  58)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  58)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  58)									int v;
HXDLIN(  58)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)										v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  58)										v = c;
            									}
HXDLIN(  58)									int this3 = v;
HXDLIN(  58)									int maskPixel = this3;
HXDLIN(  58)									int this4 = col;
HXDLIN(  58)									int this5 = this4;
HXDLIN(  58)									if ((maskPixel == 0)) {
HXLINE(  58)										int this1 = this5;
HXDLIN(  58)										col = this1;
            									}
            									else {
HXLINE(  58)										Float m0;
HXDLIN(  58)										int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  58)										if ((this1 == 0)) {
HXLINE(  58)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float m1;
HXDLIN(  58)										int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  58)										if ((this2 == 0)) {
HXLINE(  58)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float m2;
HXDLIN(  58)										int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  58)										if ((this3 == 0)) {
HXLINE(  58)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float m3;
HXDLIN(  58)										int this4 = (maskPixel & 255);
HXDLIN(  58)										if ((this4 == 0)) {
HXLINE(  58)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  58)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  58)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  58)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  58)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  58)								if ((col != 0)) {
HXLINE(  58)									int x = (x1 + dx);
HXDLIN(  58)									int y = (y1 + dy);
HXDLIN(  58)									int this1 = col;
HXDLIN(  58)									int c = this1;
HXDLIN(  58)									bool _hx_tmp;
HXDLIN(  58)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  58)										_hx_tmp = pixelShape->transparent;
            									}
            									else {
HXLINE(  58)										_hx_tmp = false;
            									}
HXDLIN(  58)									if (_hx_tmp) {
HXLINE(  58)										int location;
HXDLIN(  58)										if (pixelShape->useVirtualPos) {
HXLINE(  58)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  58)											location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            										}
HXDLIN(  58)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  58)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  58)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  58)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  58)										int this3 = this2;
HXDLIN(  58)										int this4;
HXDLIN(  58)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  58)											this4 = this3;
            										}
HXDLIN(  58)										Float a1;
HXDLIN(  58)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  58)										if ((this5 == 0)) {
HXLINE(  58)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float r1;
HXDLIN(  58)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  58)										if ((this6 == 0)) {
HXLINE(  58)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float g1;
HXDLIN(  58)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  58)										if ((this7 == 0)) {
HXLINE(  58)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float b1;
HXDLIN(  58)										int this8 = (this4 & 255);
HXDLIN(  58)										if ((this8 == 0)) {
HXLINE(  58)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float a2;
HXDLIN(  58)										int this9 = ((col >> 24) & 255);
HXDLIN(  58)										if ((this9 == 0)) {
HXLINE(  58)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float r2;
HXDLIN(  58)										int this10 = ((col >> 16) & 255);
HXDLIN(  58)										if ((this10 == 0)) {
HXLINE(  58)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float g2;
HXDLIN(  58)										int this11 = ((col >> 8) & 255);
HXDLIN(  58)										if ((this11 == 0)) {
HXLINE(  58)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float b2;
HXDLIN(  58)										int this12 = (col & 255);
HXDLIN(  58)										if ((this12 == 0)) {
HXLINE(  58)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  58)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  58)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  58)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  58)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  58)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  58)										{
HXLINE(  58)											::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  58)											int value;
HXDLIN(  58)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  58)												value = blended;
            											}
HXDLIN(  58)											bool _hx_tmp;
HXDLIN(  58)											if ((location >= 0)) {
HXLINE(  58)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE(  58)												_hx_tmp = false;
            											}
HXDLIN(  58)											if (_hx_tmp) {
HXLINE(  58)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  58)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  58)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  58)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  58)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  58)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  58)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  58)										int index;
HXDLIN(  58)										if (pixelShape->useVirtualPos) {
HXLINE(  58)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  58)											index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            										}
HXDLIN(  58)										int value;
HXDLIN(  58)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  58)											value = c;
            										}
HXDLIN(  58)										bool _hx_tmp;
HXDLIN(  58)										if ((index >= 0)) {
HXLINE(  58)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  58)											_hx_tmp = false;
            										}
HXDLIN(  58)										if (_hx_tmp) {
HXLINE(  58)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  58)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  58)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  58)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  58)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  58)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  58)									if (forceClear) {
HXLINE(  58)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  58)										int x = (x1 + dx);
HXDLIN(  58)										int y = (y1 + dy);
HXDLIN(  58)										int index;
HXDLIN(  58)										if (pixelShape->useVirtualPos) {
HXLINE(  58)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  58)											index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            										}
HXDLIN(  58)										bool _hx_tmp;
HXDLIN(  58)										if ((index >= 0)) {
HXLINE(  58)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  58)											_hx_tmp = false;
            										}
HXDLIN(  58)										if (_hx_tmp) {
HXLINE(  58)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  58)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  58)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  58)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  58)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  58)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXLINE(  59)			temp = null();
            		}
            		else {
HXLINE(  61)			int w = ::Math_obj::ceil(this->width);
HXDLIN(  61)			int h = ::Math_obj::ceil(this->height);
HXDLIN(  61)			int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  61)			::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  61)			::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  61)			::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  61)			::pixelimage::ImageStruct this4 = this3;
HXDLIN(  61)			::pixelimage::ImageStruct temp = this4;
HXLINE(  62)			temp->transparent = false;
HXLINE(  63)			{
HXLINE(  63)				::pixelimage::ImageStruct pixelshape = temp;
HXDLIN(  63)				Float wid = this->width;
HXDLIN(  63)				Float hi = this->height;
HXDLIN(  63)				int color = this->strokeColor;
HXDLIN(  63)				 ::Dynamic dx = ((Float)-1.);
HXDLIN(  63)				 ::Dynamic dy = ((Float)-1.);
HXDLIN(  63)				 ::Dynamic fat = ((Float)-1.);
HXDLIN(  63)				 ::Dynamic tall = ((Float)-1.);
HXDLIN(  63)				if (::hx::IsLess( dx,((Float)0.) )) {
HXLINE(  63)					Float smallest;
HXDLIN(  63)					if ((hi < wid)) {
HXLINE(  63)						smallest = hi;
            					}
            					else {
HXLINE(  63)						smallest = wid;
            					}
HXDLIN(  63)					Float goldenRatio = ((Float)1.61803398875);
HXLINE(  27)					dx = (smallest / (goldenRatio + 2));
            				}
HXLINE(  63)				if (::hx::IsLess( dy,((Float)0.) )) {
HXLINE(  29)					dy = dx;
            				}
HXLINE(  63)				if (::hx::IsLess( fat,((Float)0.) )) {
HXLINE(  30)					fat = (wid - (( (Float)(2) ) * ( (Float)(dx) )));
            				}
HXLINE(  63)				if (::hx::IsLess( tall,((Float)0.) )) {
HXLINE(  31)					tall = (hi - (( (Float)(2) ) * ( (Float)(dy) )));
            				}
HXLINE(  63)				Float rightRadius = ((wid - ( (Float)(fat) )) - ( (Float)(dx) ));
HXDLIN(  63)				Float bottomRadius = ((hi - ( (Float)(tall) )) - ( (Float)(dy) ));
HXDLIN(  63)				Float farX = (dx + fat);
HXDLIN(  63)				Float lowerY = (dy + tall);
HXDLIN(  63)				{
HXLINE(  63)					Float cx = ( (Float)(dx) );
HXDLIN(  63)					Float cy = ( (Float)(dy) );
HXDLIN(  63)					Float rx = ( (Float)(dx) );
HXDLIN(  63)					Float ry = ( (Float)(dy) );
HXDLIN(  63)					{
HXLINE(  63)						 ::Dynamic targetError = ((Float)1.05);
HXDLIN(  63)						if (::hx::IsNull( targetError )) {
HXLINE( 840)							targetError = ((Float)1.05);
            						}
HXLINE(  63)						Float rSmall;
HXDLIN(  63)						if ((rx > ry)) {
HXLINE(  63)							rSmall = ry;
            						}
            						else {
HXLINE(  63)							rSmall = rx;
            						}
HXDLIN(  63)						 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN(  63)						if (::hx::IsNull( targetE )) {
HXLINE(  20)							targetE = ((Float)1.05);
            						}
HXLINE(  63)						int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  63)						int noSides;
HXDLIN(  63)						if ((result < 12)) {
HXLINE(  63)							noSides = 12;
            						}
            						else {
HXLINE(  63)							if ((result > 500)) {
HXLINE(  63)								noSides = 500;
            							}
            							else {
HXLINE(  63)								noSides = result;
            							}
            						}
HXDLIN(  63)						int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN(  63)						Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN(  63)						Float omega = ::Math_obj::PI;
HXDLIN(  63)						int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN(  63)						Float lastX = ((Float)0.);
HXDLIN(  63)						Float lastY = ((Float)0.);
HXDLIN(  63)						{
HXLINE(  26)							lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)							lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            						}
HXLINE(  63)						{
HXLINE(  63)							int _g = 0;
HXDLIN(  63)							int _g1 = (quarter + 1);
HXDLIN(  63)							while((_g < _g1)){
HXLINE(  63)								_g = (_g + 1);
HXDLIN(  63)								int i = (_g - 1);
HXDLIN(  63)								Float nextX = (cx + (rx * ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  63)								Float nextY = (cy + (ry * ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  63)								{
HXLINE(  63)									bool hasHit = false;
HXDLIN(  63)									bool hasUndo = false;
HXDLIN(  63)									{
HXLINE(  63)										Float bx = lastX;
HXDLIN(  63)										Float by = lastY;
HXDLIN(  63)										Float cx1 = nextX;
HXDLIN(  63)										Float cy1 = nextY;
HXDLIN(  63)										bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  63)										if (!(adjustWinding)) {
HXLINE(  63)											Float bx_ = bx;
HXDLIN(  63)											Float by_ = by;
HXLINE(  26)											bx = cx1;
HXLINE(  27)											by = cy1;
HXLINE(  28)											cx1 = bx_;
HXLINE(  29)											cy1 = by_;
            										}
HXLINE(  63)										{
HXLINE(  63)											Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  63)											Float sx = (cy1 - cy);
HXDLIN(  63)											Float sy = (cx - cx1);
HXDLIN(  63)											Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  63)											Float tx = (cy - by);
HXDLIN(  63)											Float ty = (bx - cx);
HXDLIN(  63)											Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  63)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  63)											if ((cx > bx)) {
HXLINE(  63)												if ((cx > cx1)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((bx > cx1)) {
HXLINE(  63)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  63)												if ((bx > cx1)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((cx > cx1)) {
HXLINE(  63)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::ceil(cx);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(cx);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            											}
HXDLIN(  63)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  63)											if ((cy > by)) {
HXLINE(  63)												if ((cy > cy1)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((by > cy1)) {
HXLINE(  63)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  63)												if ((by > cy1)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((cy > cy1)) {
HXLINE(  63)														min = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::ceil(cy);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(cy);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            											}
HXDLIN(  63)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  63)											if (hasUndo) {
HXLINE(  63)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  63)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  63)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  63)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  63)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  63)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  63)												undoImage = this3;
HXDLIN(  63)												{
HXLINE(  63)													int rectLeft = xIter3->start;
HXDLIN(  63)													int rectTop = yIter3->start;
HXDLIN(  63)													int rectRight = xIter3->max;
HXDLIN(  63)													bool forceClear = false;
HXDLIN(  63)													{
HXLINE(  63)														int _g = rectTop;
HXDLIN(  63)														int _g1 = yIter3->max;
HXDLIN(  63)														while((_g < _g1)){
HXLINE(  63)															_g = (_g + 1);
HXDLIN(  63)															int dy = (_g - 1);
HXDLIN(  63)															{
HXLINE(  63)																int _g1 = rectLeft;
HXDLIN(  63)																int _g2 = rectRight;
HXDLIN(  63)																while((_g1 < _g2)){
HXLINE(  63)																	_g1 = (_g1 + 1);
HXDLIN(  63)																	int dx = (_g1 - 1);
HXDLIN(  63)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																	int index;
HXDLIN(  63)																	if (pixelshape->useVirtualPos) {
HXLINE(  63)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  63)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  63)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																	int col;
HXDLIN(  63)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  63)																		col = c;
            																	}
HXDLIN(  63)																	bool _hx_tmp;
HXDLIN(  63)																	if (pixelshape->useMask) {
HXLINE(  63)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  63)																		_hx_tmp = false;
            																	}
HXDLIN(  63)																	if (_hx_tmp) {
HXLINE(  63)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  63)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  63)																		int index;
HXDLIN(  63)																		if (this1->useVirtualPos) {
HXLINE(  63)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  63)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  63)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  63)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  63)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																		int v;
HXDLIN(  63)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  63)																			v = c;
            																		}
HXDLIN(  63)																		int this3 = v;
HXDLIN(  63)																		int maskPixel = this3;
HXDLIN(  63)																		int this4 = col;
HXDLIN(  63)																		int this5 = this4;
HXDLIN(  63)																		if ((maskPixel == 0)) {
HXLINE(  63)																			int this1 = this5;
HXDLIN(  63)																			col = this1;
            																		}
            																		else {
HXLINE(  63)																			Float m0;
HXDLIN(  63)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  63)																			if ((this1 == 0)) {
HXLINE(  63)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m1;
HXDLIN(  63)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  63)																			if ((this2 == 0)) {
HXLINE(  63)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m2;
HXDLIN(  63)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  63)																			if ((this3 == 0)) {
HXLINE(  63)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m3;
HXDLIN(  63)																			int this4 = (maskPixel & 255);
HXDLIN(  63)																			if ((this4 == 0)) {
HXLINE(  63)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  63)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  63)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  63)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  63)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  63)																	if ((col != 0)) {
HXLINE(  63)																		int x = (dx - rectLeft);
HXDLIN(  63)																		int y = (dy - rectTop);
HXDLIN(  63)																		int this1 = col;
HXDLIN(  63)																		int c = this1;
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			int location;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																			int this3 = this2;
HXDLIN(  63)																			int this4;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				this4 = this3;
            																			}
HXDLIN(  63)																			Float a1;
HXDLIN(  63)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)																			if ((this5 == 0)) {
HXLINE(  63)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r1;
HXDLIN(  63)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)																			if ((this6 == 0)) {
HXLINE(  63)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g1;
HXDLIN(  63)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)																			if ((this7 == 0)) {
HXLINE(  63)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b1;
HXDLIN(  63)																			int this8 = (this4 & 255);
HXDLIN(  63)																			if ((this8 == 0)) {
HXLINE(  63)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a2;
HXDLIN(  63)																			int this9 = ((col >> 24) & 255);
HXDLIN(  63)																			if ((this9 == 0)) {
HXLINE(  63)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r2;
HXDLIN(  63)																			int this10 = ((col >> 16) & 255);
HXDLIN(  63)																			if ((this10 == 0)) {
HXLINE(  63)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g2;
HXDLIN(  63)																			int this11 = ((col >> 8) & 255);
HXDLIN(  63)																			if ((this11 == 0)) {
HXLINE(  63)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b2;
HXDLIN(  63)																			int this12 = (col & 255);
HXDLIN(  63)																			if ((this12 == 0)) {
HXLINE(  63)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)																			{
HXLINE(  63)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  63)																				int value;
HXDLIN(  63)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  63)																					value = blended;
            																				}
HXDLIN(  63)																				bool _hx_tmp;
HXDLIN(  63)																				if ((location >= 0)) {
HXLINE(  63)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  63)																					_hx_tmp = false;
            																				}
HXDLIN(  63)																				if (_hx_tmp) {
HXLINE(  63)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			int value;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				value = c;
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  63)																		if (forceClear) {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			int x = (dx - rectLeft);
HXDLIN(  63)																			int y = (dy - rectTop);
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  63)											bool found = false;
HXDLIN(  63)											Float s = ((Float)0.);
HXDLIN(  63)											Float t = ((Float)0.);
HXDLIN(  63)											Float sxx = ((Float)0.);
HXDLIN(  63)											Float txx = ((Float)0.);
HXDLIN(  63)											{
HXLINE(  63)												int _g_min = xIter3->start;
HXDLIN(  63)												int _g_max = xIter3->max;
HXDLIN(  63)												while((_g_min < _g_max)){
HXLINE(  63)													_g_min = (_g_min + 1);
HXDLIN(  63)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXDLIN(  63)													{
HXLINE(  63)														int _g_min1 = yIter3->start;
HXDLIN(  63)														int _g_max = yIter3->max;
HXDLIN(  63)														while((_g_min1 < _g_max)){
HXLINE(  63)															_g_min1 = (_g_min1 + 1);
HXDLIN(  63)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  63)															bool _hx_tmp;
HXDLIN(  63)															if (!((s <= 0))) {
HXLINE(  63)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  63)																_hx_tmp = true;
            															}
HXDLIN(  63)															if (_hx_tmp) {
HXLINE(  63)																if (found) {
HXLINE(  63)																	goto _hx_goto_11;
            																}
            															}
            															else {
HXLINE(  63)																if (((s + t) < A)) {
HXLINE(  63)																	{
HXLINE(  63)																		int this1 = color;
HXDLIN(  63)																		int c = this1;
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			int location;
HXDLIN(  63)																			if (pixelshape->useVirtualPos) {
HXLINE(  63)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  63)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  63)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																			int this3 = this2;
HXDLIN(  63)																			int this4;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				this4 = this3;
            																			}
HXDLIN(  63)																			Float a1;
HXDLIN(  63)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)																			if ((this5 == 0)) {
HXLINE(  63)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r1;
HXDLIN(  63)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)																			if ((this6 == 0)) {
HXLINE(  63)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g1;
HXDLIN(  63)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)																			if ((this7 == 0)) {
HXLINE(  63)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b1;
HXDLIN(  63)																			int this8 = (this4 & 255);
HXDLIN(  63)																			if ((this8 == 0)) {
HXLINE(  63)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a2;
HXDLIN(  63)																			int this9 = ((color >> 24) & 255);
HXDLIN(  63)																			if ((this9 == 0)) {
HXLINE(  63)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r2;
HXDLIN(  63)																			int this10 = ((color >> 16) & 255);
HXDLIN(  63)																			if ((this10 == 0)) {
HXLINE(  63)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g2;
HXDLIN(  63)																			int this11 = ((color >> 8) & 255);
HXDLIN(  63)																			if ((this11 == 0)) {
HXLINE(  63)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b2;
HXDLIN(  63)																			int this12 = (color & 255);
HXDLIN(  63)																			if ((this12 == 0)) {
HXLINE(  63)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)																			{
HXLINE(  63)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  63)																				int value;
HXDLIN(  63)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  63)																					value = blended;
            																				}
HXDLIN(  63)																				bool _hx_tmp;
HXDLIN(  63)																				if ((location >= 0)) {
HXLINE(  63)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  63)																					_hx_tmp = false;
            																				}
HXDLIN(  63)																				if (_hx_tmp) {
HXLINE(  63)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (pixelshape->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  63)																			int value;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				value = c;
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  63)																	if (found) {
HXLINE(  63)																		goto _hx_goto_11;
            																	}
            																}
            															}
            														}
            														_hx_goto_11:;
            													}
            												}
            											}
HXDLIN(  63)											if ((hasHit == true)) {
HXLINE(  63)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  63)												if (hasUndo) {
HXLINE(  63)													v->undoImage = undoImage;
HXDLIN(  63)													v->undoX = xIter3->start;
HXDLIN(  63)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX = nextX;
HXLINE(  47)								lastY = nextY;
            							}
            						}
            					}
            				}
HXLINE(  63)				{
HXLINE(  63)					Float x = ( (Float)(dx) );
HXDLIN(  63)					int p = ::Std_obj::_hx_int(x);
HXDLIN(  63)					int xx = p;
HXDLIN(  63)					int q = 0;
HXDLIN(  63)					int maxX = ::Std_obj::_hx_int((x + ( (Float)(fat) )));
HXDLIN(  63)					int maxY = ::Std_obj::_hx_int(( (Float)(dy) ));
HXDLIN(  63)					while(true){
HXLINE(  63)						{
HXLINE(  63)							p = (p + 1);
HXDLIN(  63)							int x = (p - 1);
HXDLIN(  63)							int this1 = color;
HXDLIN(  63)							int c = this1;
HXDLIN(  63)							bool _hx_tmp;
HXDLIN(  63)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)								_hx_tmp = pixelshape->transparent;
            							}
            							else {
HXLINE(  63)								_hx_tmp = false;
            							}
HXDLIN(  63)							if (_hx_tmp) {
HXLINE(  63)								int location;
HXDLIN(  63)								if (pixelshape->useVirtualPos) {
HXLINE(  63)									location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  63)									location = ::Std_obj::_hx_int(( (Float)(((q * pixelshape->width) + x)) ));
            								}
HXDLIN(  63)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)								int this3 = this2;
HXDLIN(  63)								int this4;
HXDLIN(  63)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  63)									this4 = this3;
            								}
HXDLIN(  63)								Float a1;
HXDLIN(  63)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)								if ((this5 == 0)) {
HXLINE(  63)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float r1;
HXDLIN(  63)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)								if ((this6 == 0)) {
HXLINE(  63)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float g1;
HXDLIN(  63)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)								if ((this7 == 0)) {
HXLINE(  63)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float b1;
HXDLIN(  63)								int this8 = (this4 & 255);
HXDLIN(  63)								if ((this8 == 0)) {
HXLINE(  63)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float a2;
HXDLIN(  63)								int this9 = ((color >> 24) & 255);
HXDLIN(  63)								if ((this9 == 0)) {
HXLINE(  63)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float r2;
HXDLIN(  63)								int this10 = ((color >> 16) & 255);
HXDLIN(  63)								if ((this10 == 0)) {
HXLINE(  63)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float g2;
HXDLIN(  63)								int this11 = ((color >> 8) & 255);
HXDLIN(  63)								if ((this11 == 0)) {
HXLINE(  63)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float b2;
HXDLIN(  63)								int this12 = (color & 255);
HXDLIN(  63)								if ((this12 == 0)) {
HXLINE(  63)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)								{
HXLINE(  63)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  63)									int value;
HXDLIN(  63)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  63)										value = blended;
            									}
HXDLIN(  63)									bool _hx_tmp;
HXDLIN(  63)									if ((location >= 0)) {
HXLINE(  63)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  63)										_hx_tmp = false;
            									}
HXDLIN(  63)									if (_hx_tmp) {
HXLINE(  63)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  63)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)								int index;
HXDLIN(  63)								if (pixelshape->useVirtualPos) {
HXLINE(  63)									index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  63)									index = ::Std_obj::_hx_int(( (Float)(((q * pixelshape->width) + x)) ));
            								}
HXDLIN(  63)								int value;
HXDLIN(  63)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  63)									value = c;
            								}
HXDLIN(  63)								bool _hx_tmp;
HXDLIN(  63)								if ((index >= 0)) {
HXLINE(  63)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  63)									_hx_tmp = false;
            								}
HXDLIN(  63)								if (_hx_tmp) {
HXLINE(  63)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  63)						if ((p > maxX)) {
HXLINE( 247)							p = xx;
HXLINE(  63)							q = (q + 1);
            						}
HXDLIN(  63)						if ((q > maxY)) {
HXLINE(  63)							goto _hx_goto_12;
            						}
            					}
            					_hx_goto_12:;
            				}
HXDLIN(  63)				{
HXLINE(  63)					Float cy1 = ( (Float)(dy) );
HXDLIN(  63)					Float ry1 = ( (Float)(dy) );
HXDLIN(  63)					{
HXLINE(  63)						 ::Dynamic targetError1 = ((Float)1.05);
HXDLIN(  63)						if (::hx::IsNull( targetError1 )) {
HXLINE( 840)							targetError1 = ((Float)1.05);
            						}
HXLINE(  63)						Float rSmall1;
HXDLIN(  63)						if ((rightRadius > ry1)) {
HXLINE(  63)							rSmall1 = ry1;
            						}
            						else {
HXLINE(  63)							rSmall1 = rightRadius;
            						}
HXDLIN(  63)						 ::Dynamic targetE1 = ( (Float)(targetError1) );
HXDLIN(  63)						if (::hx::IsNull( targetE1 )) {
HXLINE(  20)							targetE1 = ((Float)1.05);
            						}
HXLINE(  63)						int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN(  63)						int noSides1;
HXDLIN(  63)						if ((result1 < 12)) {
HXLINE(  63)							noSides1 = 12;
            						}
            						else {
HXLINE(  63)							if ((result1 > 500)) {
HXLINE(  63)								noSides1 = 500;
            							}
            							else {
HXLINE(  63)								noSides1 = result1;
            							}
            						}
HXDLIN(  63)						int sides1 = (::Math_obj::ceil((( (Float)(noSides1) ) / ( (Float)(4) ))) * 4);
HXDLIN(  63)						Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  63)						Float omega1 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN(  63)						int quarter1 = ::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(4) )));
HXDLIN(  63)						Float lastX1 = ((Float)0.);
HXDLIN(  63)						Float lastY1 = ((Float)0.);
HXDLIN(  63)						{
HXLINE(  26)							lastX1 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides1) ) * theta1) + omega1))));
HXLINE(  27)							lastY1 = (cy1 + (ry1 * ::Math_obj::sin(((( (Float)(sides1) ) * theta1) + omega1))));
            						}
HXLINE(  63)						{
HXLINE(  63)							int _g2 = 0;
HXDLIN(  63)							int _g3 = (quarter1 + 1);
HXDLIN(  63)							while((_g2 < _g3)){
HXLINE(  63)								_g2 = (_g2 + 1);
HXDLIN(  63)								int i = (_g2 - 1);
HXDLIN(  63)								Float nextX = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  63)								Float nextY = (cy1 + (ry1 * ::Math_obj::sin((((( (Float)(i) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  63)								{
HXLINE(  63)									bool hasHit = false;
HXDLIN(  63)									bool hasUndo = false;
HXDLIN(  63)									{
HXLINE(  63)										Float bx = lastX1;
HXDLIN(  63)										Float by = lastY1;
HXDLIN(  63)										Float cx = nextX;
HXDLIN(  63)										Float cy = nextY;
HXDLIN(  63)										bool adjustWinding = (((((farX * by) - (bx * cy1)) + ((bx * cy) - (cx * by))) + ((cx * cy1) - (farX * cy))) > 0);
HXDLIN(  63)										if (!(adjustWinding)) {
HXLINE(  63)											Float bx_ = bx;
HXDLIN(  63)											Float by_ = by;
HXLINE(  26)											bx = cx;
HXLINE(  27)											by = cy;
HXLINE(  28)											cx = bx_;
HXLINE(  29)											cy = by_;
            										}
HXLINE(  63)										{
HXLINE(  63)											Float s0 = ((cy1 * cx) - (farX * cy));
HXDLIN(  63)											Float sx = (cy - cy1);
HXDLIN(  63)											Float sy = (farX - cx);
HXDLIN(  63)											Float t0 = ((farX * by) - (cy1 * bx));
HXDLIN(  63)											Float tx = (cy1 - by);
HXDLIN(  63)											Float ty = (bx - farX);
HXDLIN(  63)											Float A = ((((-(by) * cx) + (cy1 * (-(bx) + cx))) + (farX * (by - cy))) + (bx * cy));
HXDLIN(  63)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  63)											if ((farX > bx)) {
HXLINE(  63)												if ((farX > cx)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((bx > cx)) {
HXLINE(  63)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(farX);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  63)												if ((bx > cx)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((farX > cx)) {
HXLINE(  63)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::ceil(farX);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(farX);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            											}
HXDLIN(  63)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  63)											if ((cy1 > by)) {
HXLINE(  63)												if ((cy1 > cy)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((by > cy)) {
HXLINE(  63)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  63)												if ((by > cy)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((cy1 > cy)) {
HXLINE(  63)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::ceil(cy1);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(cy1);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            											}
HXDLIN(  63)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  63)											if (hasUndo) {
HXLINE(  63)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  63)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  63)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  63)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  63)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  63)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  63)												undoImage = this3;
HXDLIN(  63)												{
HXLINE(  63)													int rectLeft = xIter3->start;
HXDLIN(  63)													int rectTop = yIter3->start;
HXDLIN(  63)													int rectRight = xIter3->max;
HXDLIN(  63)													bool forceClear = false;
HXDLIN(  63)													{
HXLINE(  63)														int _g = rectTop;
HXDLIN(  63)														int _g1 = yIter3->max;
HXDLIN(  63)														while((_g < _g1)){
HXLINE(  63)															_g = (_g + 1);
HXDLIN(  63)															int dy = (_g - 1);
HXDLIN(  63)															{
HXLINE(  63)																int _g1 = rectLeft;
HXDLIN(  63)																int _g2 = rectRight;
HXDLIN(  63)																while((_g1 < _g2)){
HXLINE(  63)																	_g1 = (_g1 + 1);
HXDLIN(  63)																	int dx = (_g1 - 1);
HXDLIN(  63)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																	int index;
HXDLIN(  63)																	if (pixelshape->useVirtualPos) {
HXLINE(  63)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  63)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  63)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																	int col;
HXDLIN(  63)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  63)																		col = c;
            																	}
HXDLIN(  63)																	bool _hx_tmp;
HXDLIN(  63)																	if (pixelshape->useMask) {
HXLINE(  63)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  63)																		_hx_tmp = false;
            																	}
HXDLIN(  63)																	if (_hx_tmp) {
HXLINE(  63)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  63)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  63)																		int index;
HXDLIN(  63)																		if (this1->useVirtualPos) {
HXLINE(  63)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  63)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  63)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  63)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  63)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																		int v;
HXDLIN(  63)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  63)																			v = c;
            																		}
HXDLIN(  63)																		int this3 = v;
HXDLIN(  63)																		int maskPixel = this3;
HXDLIN(  63)																		int this4 = col;
HXDLIN(  63)																		int this5 = this4;
HXDLIN(  63)																		if ((maskPixel == 0)) {
HXLINE(  63)																			int this1 = this5;
HXDLIN(  63)																			col = this1;
            																		}
            																		else {
HXLINE(  63)																			Float m0;
HXDLIN(  63)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  63)																			if ((this1 == 0)) {
HXLINE(  63)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m1;
HXDLIN(  63)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  63)																			if ((this2 == 0)) {
HXLINE(  63)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m2;
HXDLIN(  63)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  63)																			if ((this3 == 0)) {
HXLINE(  63)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m3;
HXDLIN(  63)																			int this4 = (maskPixel & 255);
HXDLIN(  63)																			if ((this4 == 0)) {
HXLINE(  63)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  63)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  63)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  63)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  63)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  63)																	if ((col != 0)) {
HXLINE(  63)																		int x = (dx - rectLeft);
HXDLIN(  63)																		int y = (dy - rectTop);
HXDLIN(  63)																		int this1 = col;
HXDLIN(  63)																		int c = this1;
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			int location;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																			int this3 = this2;
HXDLIN(  63)																			int this4;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				this4 = this3;
            																			}
HXDLIN(  63)																			Float a1;
HXDLIN(  63)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)																			if ((this5 == 0)) {
HXLINE(  63)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r1;
HXDLIN(  63)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)																			if ((this6 == 0)) {
HXLINE(  63)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g1;
HXDLIN(  63)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)																			if ((this7 == 0)) {
HXLINE(  63)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b1;
HXDLIN(  63)																			int this8 = (this4 & 255);
HXDLIN(  63)																			if ((this8 == 0)) {
HXLINE(  63)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a2;
HXDLIN(  63)																			int this9 = ((col >> 24) & 255);
HXDLIN(  63)																			if ((this9 == 0)) {
HXLINE(  63)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r2;
HXDLIN(  63)																			int this10 = ((col >> 16) & 255);
HXDLIN(  63)																			if ((this10 == 0)) {
HXLINE(  63)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g2;
HXDLIN(  63)																			int this11 = ((col >> 8) & 255);
HXDLIN(  63)																			if ((this11 == 0)) {
HXLINE(  63)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b2;
HXDLIN(  63)																			int this12 = (col & 255);
HXDLIN(  63)																			if ((this12 == 0)) {
HXLINE(  63)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)																			{
HXLINE(  63)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  63)																				int value;
HXDLIN(  63)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  63)																					value = blended;
            																				}
HXDLIN(  63)																				bool _hx_tmp;
HXDLIN(  63)																				if ((location >= 0)) {
HXLINE(  63)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  63)																					_hx_tmp = false;
            																				}
HXDLIN(  63)																				if (_hx_tmp) {
HXLINE(  63)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			int value;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				value = c;
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  63)																		if (forceClear) {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			int x = (dx - rectLeft);
HXDLIN(  63)																			int y = (dy - rectTop);
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  63)											bool found = false;
HXDLIN(  63)											Float s = ((Float)0.);
HXDLIN(  63)											Float t = ((Float)0.);
HXDLIN(  63)											Float sxx = ((Float)0.);
HXDLIN(  63)											Float txx = ((Float)0.);
HXDLIN(  63)											{
HXLINE(  63)												int _g_min = xIter3->start;
HXDLIN(  63)												int _g_max = xIter3->max;
HXDLIN(  63)												while((_g_min < _g_max)){
HXLINE(  63)													_g_min = (_g_min + 1);
HXDLIN(  63)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXDLIN(  63)													{
HXLINE(  63)														int _g_min1 = yIter3->start;
HXDLIN(  63)														int _g_max = yIter3->max;
HXDLIN(  63)														while((_g_min1 < _g_max)){
HXLINE(  63)															_g_min1 = (_g_min1 + 1);
HXDLIN(  63)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  63)															bool _hx_tmp;
HXDLIN(  63)															if (!((s <= 0))) {
HXLINE(  63)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  63)																_hx_tmp = true;
            															}
HXDLIN(  63)															if (_hx_tmp) {
HXLINE(  63)																if (found) {
HXLINE(  63)																	goto _hx_goto_17;
            																}
            															}
            															else {
HXLINE(  63)																if (((s + t) < A)) {
HXLINE(  63)																	{
HXLINE(  63)																		int this1 = color;
HXDLIN(  63)																		int c = this1;
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			int location;
HXDLIN(  63)																			if (pixelshape->useVirtualPos) {
HXLINE(  63)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  63)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  63)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																			int this3 = this2;
HXDLIN(  63)																			int this4;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				this4 = this3;
            																			}
HXDLIN(  63)																			Float a1;
HXDLIN(  63)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)																			if ((this5 == 0)) {
HXLINE(  63)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r1;
HXDLIN(  63)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)																			if ((this6 == 0)) {
HXLINE(  63)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g1;
HXDLIN(  63)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)																			if ((this7 == 0)) {
HXLINE(  63)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b1;
HXDLIN(  63)																			int this8 = (this4 & 255);
HXDLIN(  63)																			if ((this8 == 0)) {
HXLINE(  63)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a2;
HXDLIN(  63)																			int this9 = ((color >> 24) & 255);
HXDLIN(  63)																			if ((this9 == 0)) {
HXLINE(  63)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r2;
HXDLIN(  63)																			int this10 = ((color >> 16) & 255);
HXDLIN(  63)																			if ((this10 == 0)) {
HXLINE(  63)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g2;
HXDLIN(  63)																			int this11 = ((color >> 8) & 255);
HXDLIN(  63)																			if ((this11 == 0)) {
HXLINE(  63)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b2;
HXDLIN(  63)																			int this12 = (color & 255);
HXDLIN(  63)																			if ((this12 == 0)) {
HXLINE(  63)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)																			{
HXLINE(  63)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  63)																				int value;
HXDLIN(  63)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  63)																					value = blended;
            																				}
HXDLIN(  63)																				bool _hx_tmp;
HXDLIN(  63)																				if ((location >= 0)) {
HXLINE(  63)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  63)																					_hx_tmp = false;
            																				}
HXDLIN(  63)																				if (_hx_tmp) {
HXLINE(  63)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (pixelshape->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  63)																			int value;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				value = c;
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  63)																	if (found) {
HXLINE(  63)																		goto _hx_goto_17;
            																	}
            																}
            															}
            														}
            														_hx_goto_17:;
            													}
            												}
            											}
HXDLIN(  63)											if ((hasHit == true)) {
HXLINE(  63)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX,cy1,bx,by,cx,cy,true);
HXDLIN(  63)												if (hasUndo) {
HXLINE(  63)													v->undoImage = undoImage;
HXDLIN(  63)													v->undoX = xIter3->start;
HXDLIN(  63)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX1 = nextX;
HXLINE(  47)								lastY1 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  63)				{
HXLINE(  63)					Float y = ( (Float)(dy) );
HXDLIN(  63)					int p1 = 0;
HXDLIN(  63)					int xx1 = p1;
HXDLIN(  63)					int q1 = ::Std_obj::_hx_int(y);
HXDLIN(  63)					int maxX1 = ::Std_obj::_hx_int(wid);
HXDLIN(  63)					int maxY1 = ::Std_obj::_hx_int((y + ( (Float)(tall) )));
HXDLIN(  63)					while(true){
HXLINE(  63)						{
HXLINE(  63)							p1 = (p1 + 1);
HXDLIN(  63)							int x = (p1 - 1);
HXDLIN(  63)							int this1 = color;
HXDLIN(  63)							int c = this1;
HXDLIN(  63)							bool _hx_tmp;
HXDLIN(  63)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)								_hx_tmp = pixelshape->transparent;
            							}
            							else {
HXLINE(  63)								_hx_tmp = false;
            							}
HXDLIN(  63)							if (_hx_tmp) {
HXLINE(  63)								int location;
HXDLIN(  63)								if (pixelshape->useVirtualPos) {
HXLINE(  63)									location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  63)									location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelshape->width) + x)) ));
            								}
HXDLIN(  63)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)								int this3 = this2;
HXDLIN(  63)								int this4;
HXDLIN(  63)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  63)									this4 = this3;
            								}
HXDLIN(  63)								Float a1;
HXDLIN(  63)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)								if ((this5 == 0)) {
HXLINE(  63)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float r1;
HXDLIN(  63)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)								if ((this6 == 0)) {
HXLINE(  63)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float g1;
HXDLIN(  63)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)								if ((this7 == 0)) {
HXLINE(  63)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float b1;
HXDLIN(  63)								int this8 = (this4 & 255);
HXDLIN(  63)								if ((this8 == 0)) {
HXLINE(  63)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float a2;
HXDLIN(  63)								int this9 = ((color >> 24) & 255);
HXDLIN(  63)								if ((this9 == 0)) {
HXLINE(  63)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float r2;
HXDLIN(  63)								int this10 = ((color >> 16) & 255);
HXDLIN(  63)								if ((this10 == 0)) {
HXLINE(  63)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float g2;
HXDLIN(  63)								int this11 = ((color >> 8) & 255);
HXDLIN(  63)								if ((this11 == 0)) {
HXLINE(  63)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float b2;
HXDLIN(  63)								int this12 = (color & 255);
HXDLIN(  63)								if ((this12 == 0)) {
HXLINE(  63)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)								{
HXLINE(  63)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  63)									int value;
HXDLIN(  63)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  63)										value = blended;
            									}
HXDLIN(  63)									bool _hx_tmp;
HXDLIN(  63)									if ((location >= 0)) {
HXLINE(  63)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  63)										_hx_tmp = false;
            									}
HXDLIN(  63)									if (_hx_tmp) {
HXLINE(  63)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  63)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)								int index;
HXDLIN(  63)								if (pixelshape->useVirtualPos) {
HXLINE(  63)									index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  63)									index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelshape->width) + x)) ));
            								}
HXDLIN(  63)								int value;
HXDLIN(  63)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  63)									value = c;
            								}
HXDLIN(  63)								bool _hx_tmp;
HXDLIN(  63)								if ((index >= 0)) {
HXLINE(  63)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  63)									_hx_tmp = false;
            								}
HXDLIN(  63)								if (_hx_tmp) {
HXLINE(  63)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  63)						if ((p1 > maxX1)) {
HXLINE( 247)							p1 = xx1;
HXLINE(  63)							q1 = (q1 + 1);
            						}
HXDLIN(  63)						if ((q1 > maxY1)) {
HXLINE(  63)							goto _hx_goto_18;
            						}
            					}
            					_hx_goto_18:;
            				}
HXDLIN(  63)				{
HXLINE(  63)					Float cx1 = ( (Float)(dx) );
HXDLIN(  63)					Float rx1 = ( (Float)(dx) );
HXDLIN(  63)					{
HXLINE(  63)						 ::Dynamic targetError2 = ((Float)1.05);
HXDLIN(  63)						if (::hx::IsNull( targetError2 )) {
HXLINE( 840)							targetError2 = ((Float)1.05);
            						}
HXLINE(  63)						Float rSmall2;
HXDLIN(  63)						if ((rx1 > bottomRadius)) {
HXLINE(  63)							rSmall2 = bottomRadius;
            						}
            						else {
HXLINE(  63)							rSmall2 = rx1;
            						}
HXDLIN(  63)						 ::Dynamic targetE2 = ( (Float)(targetError2) );
HXDLIN(  63)						if (::hx::IsNull( targetE2 )) {
HXLINE(  20)							targetE2 = ((Float)1.05);
            						}
HXLINE(  63)						int result2 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE2) ) / rSmall2)))));
HXDLIN(  63)						int noSides2;
HXDLIN(  63)						if ((result2 < 12)) {
HXLINE(  63)							noSides2 = 12;
            						}
            						else {
HXLINE(  63)							if ((result2 > 500)) {
HXLINE(  63)								noSides2 = 500;
            							}
            							else {
HXLINE(  63)								noSides2 = result2;
            							}
            						}
HXDLIN(  63)						int sides2 = (::Math_obj::ceil((( (Float)(noSides2) ) / ( (Float)(4) ))) * 4);
HXDLIN(  63)						Float theta2 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides2) ));
HXDLIN(  63)						Float omega2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  63)						int quarter2 = ::Std_obj::_hx_int((( (Float)(sides2) ) / ( (Float)(4) )));
HXDLIN(  63)						Float lastX2 = ((Float)0.);
HXDLIN(  63)						Float lastY2 = ((Float)0.);
HXDLIN(  63)						{
HXLINE(  26)							lastX2 = (cx1 + (rx1 * ::Math_obj::cos(((( (Float)(sides2) ) * theta2) + omega2))));
HXLINE(  27)							lastY2 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides2) ) * theta2) + omega2))));
            						}
HXLINE(  63)						{
HXLINE(  63)							int _g4 = 0;
HXDLIN(  63)							int _g5 = (quarter2 + 1);
HXDLIN(  63)							while((_g4 < _g5)){
HXLINE(  63)								_g4 = (_g4 + 1);
HXDLIN(  63)								int i = (_g4 - 1);
HXDLIN(  63)								Float nextX = (cx1 + (rx1 * ::Math_obj::cos((((( (Float)(i) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  63)								Float nextY = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  63)								{
HXLINE(  63)									bool hasHit = false;
HXDLIN(  63)									bool hasUndo = false;
HXDLIN(  63)									{
HXLINE(  63)										Float bx = lastX2;
HXDLIN(  63)										Float by = lastY2;
HXDLIN(  63)										Float cx = nextX;
HXDLIN(  63)										Float cy = nextY;
HXDLIN(  63)										bool adjustWinding = (((((cx1 * by) - (bx * lowerY)) + ((bx * cy) - (cx * by))) + ((cx * lowerY) - (cx1 * cy))) > 0);
HXDLIN(  63)										if (!(adjustWinding)) {
HXLINE(  63)											Float bx_ = bx;
HXDLIN(  63)											Float by_ = by;
HXLINE(  26)											bx = cx;
HXLINE(  27)											by = cy;
HXLINE(  28)											cx = bx_;
HXLINE(  29)											cy = by_;
            										}
HXLINE(  63)										{
HXLINE(  63)											Float s0 = ((lowerY * cx) - (cx1 * cy));
HXDLIN(  63)											Float sx = (cy - lowerY);
HXDLIN(  63)											Float sy = (cx1 - cx);
HXDLIN(  63)											Float t0 = ((cx1 * by) - (lowerY * bx));
HXDLIN(  63)											Float tx = (lowerY - by);
HXDLIN(  63)											Float ty = (bx - cx1);
HXDLIN(  63)											Float A = ((((-(by) * cx) + (lowerY * (-(bx) + cx))) + (cx1 * (by - cy))) + (bx * cy));
HXDLIN(  63)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  63)											if ((cx1 > bx)) {
HXLINE(  63)												if ((cx1 > cx)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((bx > cx)) {
HXLINE(  63)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  63)												if ((bx > cx)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((cx1 > cx)) {
HXLINE(  63)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::ceil(cx1);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(cx1);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													xIter3 = this1;
            												}
            											}
HXDLIN(  63)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  63)											if ((lowerY > by)) {
HXLINE(  63)												if ((lowerY > cy)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((by > cy)) {
HXLINE(  63)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  63)												if ((by > cy)) {
HXLINE(  63)													int min;
HXDLIN(  63)													if ((lowerY > cy)) {
HXLINE(  63)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  63)														min = ::Math_obj::ceil(lowerY);
            													}
HXDLIN(  63)													int ii_min = min;
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            												else {
HXLINE(  63)													int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  63)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  63)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)													yIter3 = this1;
            												}
            											}
HXDLIN(  63)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  63)											if (hasUndo) {
HXLINE(  63)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  63)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  63)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  63)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  63)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  63)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  63)												undoImage = this3;
HXDLIN(  63)												{
HXLINE(  63)													int rectLeft = xIter3->start;
HXDLIN(  63)													int rectTop = yIter3->start;
HXDLIN(  63)													int rectRight = xIter3->max;
HXDLIN(  63)													bool forceClear = false;
HXDLIN(  63)													{
HXLINE(  63)														int _g = rectTop;
HXDLIN(  63)														int _g1 = yIter3->max;
HXDLIN(  63)														while((_g < _g1)){
HXLINE(  63)															_g = (_g + 1);
HXDLIN(  63)															int dy = (_g - 1);
HXDLIN(  63)															{
HXLINE(  63)																int _g1 = rectLeft;
HXDLIN(  63)																int _g2 = rectRight;
HXDLIN(  63)																while((_g1 < _g2)){
HXLINE(  63)																	_g1 = (_g1 + 1);
HXDLIN(  63)																	int dx = (_g1 - 1);
HXDLIN(  63)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																	int index;
HXDLIN(  63)																	if (pixelshape->useVirtualPos) {
HXLINE(  63)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																	}
            																	else {
HXLINE(  63)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																	}
HXDLIN(  63)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																	int col;
HXDLIN(  63)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  63)																		col = c;
            																	}
HXDLIN(  63)																	bool _hx_tmp;
HXDLIN(  63)																	if (pixelshape->useMask) {
HXLINE(  63)																		_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																	}
            																	else {
HXLINE(  63)																		_hx_tmp = false;
            																	}
HXDLIN(  63)																	if (_hx_tmp) {
HXLINE(  63)																		::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  63)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  63)																		int index;
HXDLIN(  63)																		if (this1->useVirtualPos) {
HXLINE(  63)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  63)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  63)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  63)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  63)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																		int v;
HXDLIN(  63)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  63)																			v = c;
            																		}
HXDLIN(  63)																		int this3 = v;
HXDLIN(  63)																		int maskPixel = this3;
HXDLIN(  63)																		int this4 = col;
HXDLIN(  63)																		int this5 = this4;
HXDLIN(  63)																		if ((maskPixel == 0)) {
HXLINE(  63)																			int this1 = this5;
HXDLIN(  63)																			col = this1;
            																		}
            																		else {
HXLINE(  63)																			Float m0;
HXDLIN(  63)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  63)																			if ((this1 == 0)) {
HXLINE(  63)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m1;
HXDLIN(  63)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  63)																			if ((this2 == 0)) {
HXLINE(  63)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m2;
HXDLIN(  63)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  63)																			if ((this3 == 0)) {
HXLINE(  63)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float m3;
HXDLIN(  63)																			int this4 = (maskPixel & 255);
HXDLIN(  63)																			if ((this4 == 0)) {
HXLINE(  63)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  63)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  63)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  63)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  63)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  63)																	if ((col != 0)) {
HXLINE(  63)																		int x = (dx - rectLeft);
HXDLIN(  63)																		int y = (dy - rectTop);
HXDLIN(  63)																		int this1 = col;
HXDLIN(  63)																		int c = this1;
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			int location;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																			int this3 = this2;
HXDLIN(  63)																			int this4;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				this4 = this3;
            																			}
HXDLIN(  63)																			Float a1;
HXDLIN(  63)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)																			if ((this5 == 0)) {
HXLINE(  63)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r1;
HXDLIN(  63)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)																			if ((this6 == 0)) {
HXLINE(  63)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g1;
HXDLIN(  63)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)																			if ((this7 == 0)) {
HXLINE(  63)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b1;
HXDLIN(  63)																			int this8 = (this4 & 255);
HXDLIN(  63)																			if ((this8 == 0)) {
HXLINE(  63)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a2;
HXDLIN(  63)																			int this9 = ((col >> 24) & 255);
HXDLIN(  63)																			if ((this9 == 0)) {
HXLINE(  63)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r2;
HXDLIN(  63)																			int this10 = ((col >> 16) & 255);
HXDLIN(  63)																			if ((this10 == 0)) {
HXLINE(  63)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g2;
HXDLIN(  63)																			int this11 = ((col >> 8) & 255);
HXDLIN(  63)																			if ((this11 == 0)) {
HXLINE(  63)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b2;
HXDLIN(  63)																			int this12 = (col & 255);
HXDLIN(  63)																			if ((this12 == 0)) {
HXLINE(  63)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)																			{
HXLINE(  63)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  63)																				int value;
HXDLIN(  63)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  63)																					value = blended;
            																				}
HXDLIN(  63)																				bool _hx_tmp;
HXDLIN(  63)																				if ((location >= 0)) {
HXLINE(  63)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  63)																					_hx_tmp = false;
            																				}
HXDLIN(  63)																				if (_hx_tmp) {
HXLINE(  63)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			int value;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				value = c;
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  63)																		if (forceClear) {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																			int x = (dx - rectLeft);
HXDLIN(  63)																			int y = (dy - rectTop);
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (undoImage->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  63)											bool found = false;
HXDLIN(  63)											Float s = ((Float)0.);
HXDLIN(  63)											Float t = ((Float)0.);
HXDLIN(  63)											Float sxx = ((Float)0.);
HXDLIN(  63)											Float txx = ((Float)0.);
HXDLIN(  63)											{
HXLINE(  63)												int _g_min = xIter3->start;
HXDLIN(  63)												int _g_max = xIter3->max;
HXDLIN(  63)												while((_g_min < _g_max)){
HXLINE(  63)													_g_min = (_g_min + 1);
HXDLIN(  63)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXDLIN(  63)													{
HXLINE(  63)														int _g_min1 = yIter3->start;
HXDLIN(  63)														int _g_max = yIter3->max;
HXDLIN(  63)														while((_g_min1 < _g_max)){
HXLINE(  63)															_g_min1 = (_g_min1 + 1);
HXDLIN(  63)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  63)															bool _hx_tmp;
HXDLIN(  63)															if (!((s <= 0))) {
HXLINE(  63)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  63)																_hx_tmp = true;
            															}
HXDLIN(  63)															if (_hx_tmp) {
HXLINE(  63)																if (found) {
HXLINE(  63)																	goto _hx_goto_23;
            																}
            															}
            															else {
HXLINE(  63)																if (((s + t) < A)) {
HXLINE(  63)																	{
HXLINE(  63)																		int this1 = color;
HXDLIN(  63)																		int c = this1;
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)																			_hx_tmp = pixelshape->transparent;
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			int location;
HXDLIN(  63)																			if (pixelshape->useVirtualPos) {
HXLINE(  63)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  63)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  63)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																			int this3 = this2;
HXDLIN(  63)																			int this4;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				this4 = this3;
            																			}
HXDLIN(  63)																			Float a1;
HXDLIN(  63)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)																			if ((this5 == 0)) {
HXLINE(  63)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r1;
HXDLIN(  63)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)																			if ((this6 == 0)) {
HXLINE(  63)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g1;
HXDLIN(  63)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)																			if ((this7 == 0)) {
HXLINE(  63)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b1;
HXDLIN(  63)																			int this8 = (this4 & 255);
HXDLIN(  63)																			if ((this8 == 0)) {
HXLINE(  63)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a2;
HXDLIN(  63)																			int this9 = ((color >> 24) & 255);
HXDLIN(  63)																			if ((this9 == 0)) {
HXLINE(  63)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float r2;
HXDLIN(  63)																			int this10 = ((color >> 16) & 255);
HXDLIN(  63)																			if ((this10 == 0)) {
HXLINE(  63)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float g2;
HXDLIN(  63)																			int this11 = ((color >> 8) & 255);
HXDLIN(  63)																			if ((this11 == 0)) {
HXLINE(  63)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float b2;
HXDLIN(  63)																			int this12 = (color & 255);
HXDLIN(  63)																			if ((this12 == 0)) {
HXLINE(  63)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  63)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  63)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)																			{
HXLINE(  63)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  63)																				int value;
HXDLIN(  63)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  63)																					value = blended;
            																				}
HXDLIN(  63)																				bool _hx_tmp;
HXDLIN(  63)																				if ((location >= 0)) {
HXLINE(  63)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  63)																					_hx_tmp = false;
            																				}
HXDLIN(  63)																				if (_hx_tmp) {
HXLINE(  63)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																			int index;
HXDLIN(  63)																			if (pixelshape->useVirtualPos) {
HXLINE(  63)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																			}
            																			else {
HXLINE(  63)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																			}
HXDLIN(  63)																			int value;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				value = c;
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((index >= 0)) {
HXLINE(  63)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  63)																	if (found) {
HXLINE(  63)																		goto _hx_goto_23;
            																	}
            																}
            															}
            														}
            														_hx_goto_23:;
            													}
            												}
            											}
HXDLIN(  63)											if ((hasHit == true)) {
HXLINE(  63)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx1,lowerY,bx,by,cx,cy,true);
HXDLIN(  63)												if (hasUndo) {
HXLINE(  63)													v->undoImage = undoImage;
HXDLIN(  63)													v->undoX = xIter3->start;
HXDLIN(  63)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX2 = nextX;
HXLINE(  47)								lastY2 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  63)				{
HXLINE(  63)					Float x1 = ( (Float)(dx) );
HXDLIN(  63)					int p2 = ::Std_obj::_hx_int(x1);
HXDLIN(  63)					int xx2 = p2;
HXDLIN(  63)					int q2 = ::Std_obj::_hx_int(lowerY);
HXDLIN(  63)					int maxX2 = ::Std_obj::_hx_int((x1 + ( (Float)(fat) )));
HXDLIN(  63)					int maxY2 = ::Std_obj::_hx_int((lowerY + bottomRadius));
HXDLIN(  63)					while(true){
HXLINE(  63)						{
HXLINE(  63)							p2 = (p2 + 1);
HXDLIN(  63)							int x = (p2 - 1);
HXDLIN(  63)							int this1 = color;
HXDLIN(  63)							int c = this1;
HXDLIN(  63)							bool _hx_tmp;
HXDLIN(  63)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)								_hx_tmp = pixelshape->transparent;
            							}
            							else {
HXLINE(  63)								_hx_tmp = false;
            							}
HXDLIN(  63)							if (_hx_tmp) {
HXLINE(  63)								int location;
HXDLIN(  63)								if (pixelshape->useVirtualPos) {
HXLINE(  63)									location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  63)									location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelshape->width) + x)) ));
            								}
HXDLIN(  63)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)								int this3 = this2;
HXDLIN(  63)								int this4;
HXDLIN(  63)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  63)									this4 = this3;
            								}
HXDLIN(  63)								Float a1;
HXDLIN(  63)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)								if ((this5 == 0)) {
HXLINE(  63)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float r1;
HXDLIN(  63)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)								if ((this6 == 0)) {
HXLINE(  63)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float g1;
HXDLIN(  63)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)								if ((this7 == 0)) {
HXLINE(  63)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float b1;
HXDLIN(  63)								int this8 = (this4 & 255);
HXDLIN(  63)								if ((this8 == 0)) {
HXLINE(  63)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float a2;
HXDLIN(  63)								int this9 = ((color >> 24) & 255);
HXDLIN(  63)								if ((this9 == 0)) {
HXLINE(  63)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float r2;
HXDLIN(  63)								int this10 = ((color >> 16) & 255);
HXDLIN(  63)								if ((this10 == 0)) {
HXLINE(  63)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float g2;
HXDLIN(  63)								int this11 = ((color >> 8) & 255);
HXDLIN(  63)								if ((this11 == 0)) {
HXLINE(  63)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float b2;
HXDLIN(  63)								int this12 = (color & 255);
HXDLIN(  63)								if ((this12 == 0)) {
HXLINE(  63)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  63)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  63)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)								{
HXLINE(  63)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  63)									int value;
HXDLIN(  63)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  63)										value = blended;
            									}
HXDLIN(  63)									bool _hx_tmp;
HXDLIN(  63)									if ((location >= 0)) {
HXLINE(  63)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  63)										_hx_tmp = false;
            									}
HXDLIN(  63)									if (_hx_tmp) {
HXLINE(  63)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  63)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)								int index;
HXDLIN(  63)								if (pixelshape->useVirtualPos) {
HXLINE(  63)									index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            								}
            								else {
HXLINE(  63)									index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelshape->width) + x)) ));
            								}
HXDLIN(  63)								int value;
HXDLIN(  63)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  63)									value = c;
            								}
HXDLIN(  63)								bool _hx_tmp;
HXDLIN(  63)								if ((index >= 0)) {
HXLINE(  63)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  63)									_hx_tmp = false;
            								}
HXDLIN(  63)								if (_hx_tmp) {
HXLINE(  63)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  63)						if ((p2 > maxX2)) {
HXLINE( 247)							p2 = xx2;
HXLINE(  63)							q2 = (q2 + 1);
            						}
HXDLIN(  63)						if ((q2 > maxY2)) {
HXLINE(  63)							goto _hx_goto_24;
            						}
            					}
            					_hx_goto_24:;
            				}
HXDLIN(  63)				{
HXLINE(  63)					 ::Dynamic targetError3 = ((Float)1.05);
HXDLIN(  63)					if (::hx::IsNull( targetError3 )) {
HXLINE( 840)						targetError3 = ((Float)1.05);
            					}
HXLINE(  63)					Float rSmall3;
HXDLIN(  63)					if ((rightRadius > bottomRadius)) {
HXLINE(  63)						rSmall3 = bottomRadius;
            					}
            					else {
HXLINE(  63)						rSmall3 = rightRadius;
            					}
HXDLIN(  63)					 ::Dynamic targetE3 = ( (Float)(targetError3) );
HXDLIN(  63)					if (::hx::IsNull( targetE3 )) {
HXLINE(  20)						targetE3 = ((Float)1.05);
            					}
HXLINE(  63)					int result3 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE3) ) / rSmall3)))));
HXDLIN(  63)					int noSides3;
HXDLIN(  63)					if ((result3 < 12)) {
HXLINE(  63)						noSides3 = 12;
            					}
            					else {
HXLINE(  63)						if ((result3 > 500)) {
HXLINE(  63)							noSides3 = 500;
            						}
            						else {
HXLINE(  63)							noSides3 = result3;
            						}
            					}
HXDLIN(  63)					int sides3 = (::Math_obj::ceil((( (Float)(noSides3) ) / ( (Float)(4) ))) * 4);
HXDLIN(  63)					Float theta3 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN(  63)					Float omega3 = ( (Float)(0) );
HXDLIN(  63)					int quarter3 = ::Std_obj::_hx_int((( (Float)(sides3) ) / ( (Float)(4) )));
HXDLIN(  63)					Float lastX3 = ((Float)0.);
HXDLIN(  63)					Float lastY3 = ((Float)0.);
HXDLIN(  63)					{
HXLINE(  26)						lastX3 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides3) ) * theta3) + omega3))));
HXLINE(  27)						lastY3 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides3) ) * theta3) + omega3))));
            					}
HXLINE(  63)					{
HXLINE(  63)						int _g6 = 0;
HXDLIN(  63)						int _g7 = (quarter3 + 1);
HXDLIN(  63)						while((_g6 < _g7)){
HXLINE(  63)							_g6 = (_g6 + 1);
HXDLIN(  63)							int i = (_g6 - 1);
HXDLIN(  63)							Float nextX = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  63)							Float nextY = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  63)							{
HXLINE(  63)								bool hasHit = false;
HXDLIN(  63)								bool hasUndo = false;
HXDLIN(  63)								{
HXLINE(  63)									Float bx = lastX3;
HXDLIN(  63)									Float by = lastY3;
HXDLIN(  63)									Float cx = nextX;
HXDLIN(  63)									Float cy = nextY;
HXDLIN(  63)									bool adjustWinding = (((((farX * by) - (bx * lowerY)) + ((bx * cy) - (cx * by))) + ((cx * lowerY) - (farX * cy))) > 0);
HXDLIN(  63)									if (!(adjustWinding)) {
HXLINE(  63)										Float bx_ = bx;
HXDLIN(  63)										Float by_ = by;
HXLINE(  26)										bx = cx;
HXLINE(  27)										by = cy;
HXLINE(  28)										cx = bx_;
HXLINE(  29)										cy = by_;
            									}
HXLINE(  63)									{
HXLINE(  63)										Float s0 = ((lowerY * cx) - (farX * cy));
HXDLIN(  63)										Float sx = (cy - lowerY);
HXDLIN(  63)										Float sy = (farX - cx);
HXDLIN(  63)										Float t0 = ((farX * by) - (lowerY * bx));
HXDLIN(  63)										Float tx = (lowerY - by);
HXDLIN(  63)										Float ty = (bx - farX);
HXDLIN(  63)										Float A = ((((-(by) * cx) + (lowerY * (-(bx) + cx))) + (farX * (by - cy))) + (bx * cy));
HXDLIN(  63)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  63)										if ((farX > bx)) {
HXLINE(  63)											if ((farX > cx)) {
HXLINE(  63)												int min;
HXDLIN(  63)												if ((bx > cx)) {
HXLINE(  63)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  63)													min = ::Math_obj::floor(bx);
            												}
HXDLIN(  63)												int ii_min = min;
HXDLIN(  63)												int ii_max = ::Math_obj::ceil(farX);
HXDLIN(  63)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)												xIter3 = this1;
            											}
            											else {
HXLINE(  63)												int ii_min = ::Math_obj::floor(bx);
HXDLIN(  63)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  63)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  63)											if ((bx > cx)) {
HXLINE(  63)												int min;
HXDLIN(  63)												if ((farX > cx)) {
HXLINE(  63)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  63)													min = ::Math_obj::ceil(farX);
            												}
HXDLIN(  63)												int ii_min = min;
HXDLIN(  63)												int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  63)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)												xIter3 = this1;
            											}
            											else {
HXLINE(  63)												int ii_min = ::Math_obj::floor(farX);
HXDLIN(  63)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  63)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)												xIter3 = this1;
            											}
            										}
HXDLIN(  63)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  63)										if ((lowerY > by)) {
HXLINE(  63)											if ((lowerY > cy)) {
HXLINE(  63)												int min;
HXDLIN(  63)												if ((by > cy)) {
HXLINE(  63)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  63)													min = ::Math_obj::floor(by);
            												}
HXDLIN(  63)												int ii_min = min;
HXDLIN(  63)												int ii_max = ::Math_obj::ceil(lowerY);
HXDLIN(  63)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)												yIter3 = this1;
            											}
            											else {
HXLINE(  63)												int ii_min = ::Math_obj::floor(by);
HXDLIN(  63)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  63)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  63)											if ((by > cy)) {
HXLINE(  63)												int min;
HXDLIN(  63)												if ((lowerY > cy)) {
HXLINE(  63)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  63)													min = ::Math_obj::ceil(lowerY);
            												}
HXDLIN(  63)												int ii_min = min;
HXDLIN(  63)												int ii_max = ::Math_obj::ceil(by);
HXDLIN(  63)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)												yIter3 = this1;
            											}
            											else {
HXLINE(  63)												int ii_min = ::Math_obj::floor(lowerY);
HXDLIN(  63)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  63)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  63)												yIter3 = this1;
            											}
            										}
HXDLIN(  63)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  63)										if (hasUndo) {
HXLINE(  63)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  63)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  63)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  63)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  63)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  63)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  63)											undoImage = this3;
HXDLIN(  63)											{
HXLINE(  63)												int rectLeft = xIter3->start;
HXDLIN(  63)												int rectTop = yIter3->start;
HXDLIN(  63)												int rectRight = xIter3->max;
HXDLIN(  63)												bool forceClear = false;
HXDLIN(  63)												{
HXLINE(  63)													int _g = rectTop;
HXDLIN(  63)													int _g1 = yIter3->max;
HXDLIN(  63)													while((_g < _g1)){
HXLINE(  63)														_g = (_g + 1);
HXDLIN(  63)														int dy = (_g - 1);
HXDLIN(  63)														{
HXLINE(  63)															int _g1 = rectLeft;
HXDLIN(  63)															int _g2 = rectRight;
HXDLIN(  63)															while((_g1 < _g2)){
HXLINE(  63)																_g1 = (_g1 + 1);
HXDLIN(  63)																int dx = (_g1 - 1);
HXDLIN(  63)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																int index;
HXDLIN(  63)																if (pixelshape->useVirtualPos) {
HXLINE(  63)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + dx) - pixelshape->virtualX));
            																}
            																else {
HXLINE(  63)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape->width) + dx)) ));
            																}
HXDLIN(  63)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																int col;
HXDLIN(  63)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  63)																	col = c;
            																}
HXDLIN(  63)																bool _hx_tmp;
HXDLIN(  63)																if (pixelshape->useMask) {
HXLINE(  63)																	_hx_tmp = ::hx::IsNotNull( pixelshape->mask );
            																}
            																else {
HXLINE(  63)																	_hx_tmp = false;
            																}
HXDLIN(  63)																if (_hx_tmp) {
HXLINE(  63)																	::pixelimage::ImageStruct this1 = pixelshape->mask;
HXDLIN(  63)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  63)																	int index;
HXDLIN(  63)																	if (this1->useVirtualPos) {
HXLINE(  63)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  63)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  63)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  63)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  63)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																	int v;
HXDLIN(  63)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  63)																		v = c;
            																	}
HXDLIN(  63)																	int this3 = v;
HXDLIN(  63)																	int maskPixel = this3;
HXDLIN(  63)																	int this4 = col;
HXDLIN(  63)																	int this5 = this4;
HXDLIN(  63)																	if ((maskPixel == 0)) {
HXLINE(  63)																		int this1 = this5;
HXDLIN(  63)																		col = this1;
            																	}
            																	else {
HXLINE(  63)																		Float m0;
HXDLIN(  63)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  63)																		if ((this1 == 0)) {
HXLINE(  63)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float m1;
HXDLIN(  63)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  63)																		if ((this2 == 0)) {
HXLINE(  63)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float m2;
HXDLIN(  63)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  63)																		if ((this3 == 0)) {
HXLINE(  63)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float m3;
HXDLIN(  63)																		int this4 = (maskPixel & 255);
HXDLIN(  63)																		if ((this4 == 0)) {
HXLINE(  63)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  63)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  63)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  63)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  63)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  63)																if ((col != 0)) {
HXLINE(  63)																	int x = (dx - rectLeft);
HXDLIN(  63)																	int y = (dy - rectTop);
HXDLIN(  63)																	int this1 = col;
HXDLIN(  63)																	int c = this1;
HXDLIN(  63)																	bool _hx_tmp;
HXDLIN(  63)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)																		_hx_tmp = undoImage->transparent;
            																	}
            																	else {
HXLINE(  63)																		_hx_tmp = false;
            																	}
HXDLIN(  63)																	if (_hx_tmp) {
HXLINE(  63)																		int location;
HXDLIN(  63)																		if (undoImage->useVirtualPos) {
HXLINE(  63)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  63)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  63)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																		int this3 = this2;
HXDLIN(  63)																		int this4;
HXDLIN(  63)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  63)																			this4 = this3;
            																		}
HXDLIN(  63)																		Float a1;
HXDLIN(  63)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)																		if ((this5 == 0)) {
HXLINE(  63)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float r1;
HXDLIN(  63)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)																		if ((this6 == 0)) {
HXLINE(  63)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float g1;
HXDLIN(  63)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)																		if ((this7 == 0)) {
HXLINE(  63)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float b1;
HXDLIN(  63)																		int this8 = (this4 & 255);
HXDLIN(  63)																		if ((this8 == 0)) {
HXLINE(  63)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float a2;
HXDLIN(  63)																		int this9 = ((col >> 24) & 255);
HXDLIN(  63)																		if ((this9 == 0)) {
HXLINE(  63)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float r2;
HXDLIN(  63)																		int this10 = ((col >> 16) & 255);
HXDLIN(  63)																		if ((this10 == 0)) {
HXLINE(  63)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float g2;
HXDLIN(  63)																		int this11 = ((col >> 8) & 255);
HXDLIN(  63)																		if ((this11 == 0)) {
HXLINE(  63)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float b2;
HXDLIN(  63)																		int this12 = (col & 255);
HXDLIN(  63)																		if ((this12 == 0)) {
HXLINE(  63)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)																		{
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  63)																			int value;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				value = blended;
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((location >= 0)) {
HXLINE(  63)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  63)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																		int index;
HXDLIN(  63)																		if (undoImage->useVirtualPos) {
HXLINE(  63)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  63)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  63)																		int value;
HXDLIN(  63)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  63)																			value = c;
            																		}
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((index >= 0)) {
HXLINE(  63)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  63)																	if (forceClear) {
HXLINE(  63)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  63)																		int x = (dx - rectLeft);
HXDLIN(  63)																		int y = (dy - rectTop);
HXDLIN(  63)																		int index;
HXDLIN(  63)																		if (undoImage->useVirtualPos) {
HXLINE(  63)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  63)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((index >= 0)) {
HXLINE(  63)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  63)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  63)										bool found = false;
HXDLIN(  63)										Float s = ((Float)0.);
HXDLIN(  63)										Float t = ((Float)0.);
HXDLIN(  63)										Float sxx = ((Float)0.);
HXDLIN(  63)										Float txx = ((Float)0.);
HXDLIN(  63)										{
HXLINE(  63)											int _g_min = xIter3->start;
HXDLIN(  63)											int _g_max = xIter3->max;
HXDLIN(  63)											while((_g_min < _g_max)){
HXLINE(  63)												_g_min = (_g_min + 1);
HXDLIN(  63)												int x = (_g_min - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found = false;
HXDLIN(  63)												{
HXLINE(  63)													int _g_min1 = yIter3->start;
HXDLIN(  63)													int _g_max = yIter3->max;
HXDLIN(  63)													while((_g_min1 < _g_max)){
HXLINE(  63)														_g_min1 = (_g_min1 + 1);
HXDLIN(  63)														int y = (_g_min1 - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  63)														bool _hx_tmp;
HXDLIN(  63)														if (!((s <= 0))) {
HXLINE(  63)															_hx_tmp = (t <= 0);
            														}
            														else {
HXLINE(  63)															_hx_tmp = true;
            														}
HXDLIN(  63)														if (_hx_tmp) {
HXLINE(  63)															if (found) {
HXLINE(  63)																goto _hx_goto_29;
            															}
            														}
            														else {
HXLINE(  63)															if (((s + t) < A)) {
HXLINE(  63)																{
HXLINE(  63)																	int this1 = color;
HXDLIN(  63)																	int c = this1;
HXDLIN(  63)																	bool _hx_tmp;
HXDLIN(  63)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  63)																		_hx_tmp = pixelshape->transparent;
            																	}
            																	else {
HXLINE(  63)																		_hx_tmp = false;
            																	}
HXDLIN(  63)																	if (_hx_tmp) {
HXLINE(  63)																		int location;
HXDLIN(  63)																		if (pixelshape->useVirtualPos) {
HXLINE(  63)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																		}
            																		else {
HXLINE(  63)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																		}
HXDLIN(  63)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  63)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  63)																		int this3 = this2;
HXDLIN(  63)																		int this4;
HXDLIN(  63)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  63)																			this4 = this3;
            																		}
HXDLIN(  63)																		Float a1;
HXDLIN(  63)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  63)																		if ((this5 == 0)) {
HXLINE(  63)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float r1;
HXDLIN(  63)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  63)																		if ((this6 == 0)) {
HXLINE(  63)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float g1;
HXDLIN(  63)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  63)																		if ((this7 == 0)) {
HXLINE(  63)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float b1;
HXDLIN(  63)																		int this8 = (this4 & 255);
HXDLIN(  63)																		if ((this8 == 0)) {
HXLINE(  63)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float a2;
HXDLIN(  63)																		int this9 = ((color >> 24) & 255);
HXDLIN(  63)																		if ((this9 == 0)) {
HXLINE(  63)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float r2;
HXDLIN(  63)																		int this10 = ((color >> 16) & 255);
HXDLIN(  63)																		if ((this10 == 0)) {
HXLINE(  63)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float g2;
HXDLIN(  63)																		int this11 = ((color >> 8) & 255);
HXDLIN(  63)																		if ((this11 == 0)) {
HXLINE(  63)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float b2;
HXDLIN(  63)																		int this12 = (color & 255);
HXDLIN(  63)																		if ((this12 == 0)) {
HXLINE(  63)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  63)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  63)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  63)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  63)																		{
HXLINE(  63)																			::haxe::io::ArrayBufferViewImpl this13 = pixelshape->image;
HXDLIN(  63)																			int value;
HXDLIN(  63)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  63)																				value = blended;
            																			}
HXDLIN(  63)																			bool _hx_tmp;
HXDLIN(  63)																			if ((location >= 0)) {
HXLINE(  63)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  63)																				_hx_tmp = false;
            																			}
HXDLIN(  63)																			if (_hx_tmp) {
HXLINE(  63)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  63)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  63)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  63)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape->image;
HXDLIN(  63)																		int index;
HXDLIN(  63)																		if (pixelshape->useVirtualPos) {
HXLINE(  63)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape->virtualY) * ( (Float)(pixelshape->width) )) + x) - pixelshape->virtualX));
            																		}
            																		else {
HXLINE(  63)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape->width) + x)) ));
            																		}
HXDLIN(  63)																		int value;
HXDLIN(  63)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  63)																			value = c;
            																		}
HXDLIN(  63)																		bool _hx_tmp;
HXDLIN(  63)																		if ((index >= 0)) {
HXLINE(  63)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  63)																			_hx_tmp = false;
            																		}
HXDLIN(  63)																		if (_hx_tmp) {
HXLINE(  63)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  63)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  63)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  63)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  63)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  63)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found = true;
            															}
            															else {
HXLINE(  63)																if (found) {
HXLINE(  63)																	goto _hx_goto_29;
            																}
            															}
            														}
            													}
            													_hx_goto_29:;
            												}
            											}
            										}
HXDLIN(  63)										if ((hasHit == true)) {
HXLINE(  63)											::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX,lowerY,bx,by,cx,cy,true);
HXDLIN(  63)											if (hasUndo) {
HXLINE(  63)												v->undoImage = undoImage;
HXDLIN(  63)												v->undoX = xIter3->start;
HXDLIN(  63)												v->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX3 = nextX;
HXLINE(  47)							lastY3 = nextY;
            						}
            					}
            				}
            			}
HXLINE(  64)			{
HXLINE(  64)				::pixelimage::ImageStruct pixelshape1 = temp;
HXDLIN(  64)				Float x2 = this->strokeWidth;
HXDLIN(  64)				Float y1 = this->strokeWidth;
HXDLIN(  64)				Float wid1 = (this->width - (( (Float)(2) ) * this->strokeWidth));
HXDLIN(  64)				Float hi1 = (this->height - (( (Float)(2) ) * this->strokeWidth));
HXDLIN(  64)				int color1 = this->fill;
HXDLIN(  64)				 ::Dynamic dx1 = ((Float)-1.);
HXDLIN(  64)				 ::Dynamic dy1 = ((Float)-1.);
HXDLIN(  64)				 ::Dynamic fat1 = ((Float)-1.);
HXDLIN(  64)				 ::Dynamic tall1 = ((Float)-1.);
HXDLIN(  64)				if (::hx::IsLess( dx1,((Float)0.) )) {
HXLINE(  64)					Float smallest;
HXDLIN(  64)					if ((hi1 < wid1)) {
HXLINE(  64)						smallest = hi1;
            					}
            					else {
HXLINE(  64)						smallest = wid1;
            					}
HXDLIN(  64)					Float goldenRatio = ((Float)1.61803398875);
HXLINE(  27)					dx1 = (smallest / (goldenRatio + 2));
            				}
HXLINE(  64)				if (::hx::IsLess( dy1,((Float)0.) )) {
HXLINE(  29)					dy1 = dx1;
            				}
HXLINE(  64)				if (::hx::IsLess( fat1,((Float)0.) )) {
HXLINE(  30)					fat1 = (wid1 - (( (Float)(2) ) * ( (Float)(dx1) )));
            				}
HXLINE(  64)				if (::hx::IsLess( tall1,((Float)0.) )) {
HXLINE(  31)					tall1 = (hi1 - (( (Float)(2) ) * ( (Float)(dy1) )));
            				}
HXLINE(  64)				Float rightRadius1 = ((wid1 - ( (Float)(fat1) )) - ( (Float)(dx1) ));
HXDLIN(  64)				Float bottomRadius1 = ((hi1 - ( (Float)(tall1) )) - ( (Float)(dy1) ));
HXDLIN(  64)				Float farX1 = ((x2 + dx1) + fat1);
HXDLIN(  64)				Float lowerY1 = ((y1 + dy1) + tall1);
HXDLIN(  64)				{
HXLINE(  64)					Float cx2 = (x2 + dx1);
HXDLIN(  64)					Float cy2 = (y1 + dy1);
HXDLIN(  64)					Float rx2 = ( (Float)(dx1) );
HXDLIN(  64)					Float ry2 = ( (Float)(dy1) );
HXDLIN(  64)					{
HXLINE(  64)						 ::Dynamic targetError4 = ((Float)1.05);
HXDLIN(  64)						if (::hx::IsNull( targetError4 )) {
HXLINE( 840)							targetError4 = ((Float)1.05);
            						}
HXLINE(  64)						Float rSmall4;
HXDLIN(  64)						if ((rx2 > ry2)) {
HXLINE(  64)							rSmall4 = ry2;
            						}
            						else {
HXLINE(  64)							rSmall4 = rx2;
            						}
HXDLIN(  64)						 ::Dynamic targetE4 = ( (Float)(targetError4) );
HXDLIN(  64)						if (::hx::IsNull( targetE4 )) {
HXLINE(  20)							targetE4 = ((Float)1.05);
            						}
HXLINE(  64)						int result4 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE4) ) / rSmall4)))));
HXDLIN(  64)						int noSides4;
HXDLIN(  64)						if ((result4 < 12)) {
HXLINE(  64)							noSides4 = 12;
            						}
            						else {
HXLINE(  64)							if ((result4 > 500)) {
HXLINE(  64)								noSides4 = 500;
            							}
            							else {
HXLINE(  64)								noSides4 = result4;
            							}
            						}
HXDLIN(  64)						int sides4 = (::Math_obj::ceil((( (Float)(noSides4) ) / ( (Float)(4) ))) * 4);
HXDLIN(  64)						Float theta4 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides4) ));
HXDLIN(  64)						Float omega4 = ::Math_obj::PI;
HXDLIN(  64)						int quarter4 = ::Std_obj::_hx_int((( (Float)(sides4) ) / ( (Float)(4) )));
HXDLIN(  64)						Float lastX4 = ((Float)0.);
HXDLIN(  64)						Float lastY4 = ((Float)0.);
HXDLIN(  64)						{
HXLINE(  26)							lastX4 = (cx2 + (rx2 * ::Math_obj::cos(((( (Float)(sides4) ) * theta4) + omega4))));
HXLINE(  27)							lastY4 = (cy2 + (ry2 * ::Math_obj::sin(((( (Float)(sides4) ) * theta4) + omega4))));
            						}
HXLINE(  64)						{
HXLINE(  64)							int _g8 = 0;
HXDLIN(  64)							int _g9 = (quarter4 + 1);
HXDLIN(  64)							while((_g8 < _g9)){
HXLINE(  64)								_g8 = (_g8 + 1);
HXDLIN(  64)								int i = (_g8 - 1);
HXDLIN(  64)								Float nextX = (cx2 + (rx2 * ::Math_obj::cos((((( (Float)(i) ) * theta4) + ((Float)0.0001)) + omega4))));
HXDLIN(  64)								Float nextY = (cy2 + (ry2 * ::Math_obj::sin((((( (Float)(i) ) * theta4) + ((Float)0.0001)) + omega4))));
HXDLIN(  64)								{
HXLINE(  64)									bool hasHit = false;
HXDLIN(  64)									bool hasUndo = false;
HXDLIN(  64)									{
HXLINE(  64)										Float bx = lastX4;
HXDLIN(  64)										Float by = lastY4;
HXDLIN(  64)										Float cx = nextX;
HXDLIN(  64)										Float cy = nextY;
HXDLIN(  64)										bool adjustWinding = (((((cx2 * by) - (bx * cy2)) + ((bx * cy) - (cx * by))) + ((cx * cy2) - (cx2 * cy))) > 0);
HXDLIN(  64)										if (!(adjustWinding)) {
HXLINE(  64)											Float bx_ = bx;
HXDLIN(  64)											Float by_ = by;
HXLINE(  26)											bx = cx;
HXLINE(  27)											by = cy;
HXLINE(  28)											cx = bx_;
HXLINE(  29)											cy = by_;
            										}
HXLINE(  64)										{
HXLINE(  64)											Float s0 = ((cy2 * cx) - (cx2 * cy));
HXDLIN(  64)											Float sx = (cy - cy2);
HXDLIN(  64)											Float sy = (cx2 - cx);
HXDLIN(  64)											Float t0 = ((cx2 * by) - (cy2 * bx));
HXDLIN(  64)											Float tx = (cy2 - by);
HXDLIN(  64)											Float ty = (bx - cx2);
HXDLIN(  64)											Float A = ((((-(by) * cx) + (cy2 * (-(bx) + cx))) + (cx2 * (by - cy))) + (bx * cy));
HXDLIN(  64)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  64)											if ((cx2 > bx)) {
HXLINE(  64)												if ((cx2 > cx)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((bx > cx)) {
HXLINE(  64)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  64)												if ((bx > cx)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((cx2 > cx)) {
HXLINE(  64)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::ceil(cx2);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(cx2);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            											}
HXDLIN(  64)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  64)											if ((cy2 > by)) {
HXLINE(  64)												if ((cy2 > cy)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((by > cy)) {
HXLINE(  64)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  64)												if ((by > cy)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((cy2 > cy)) {
HXLINE(  64)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::ceil(cy2);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(cy2);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            											}
HXDLIN(  64)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  64)											if (hasUndo) {
HXLINE(  64)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  64)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  64)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  64)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  64)												undoImage = this3;
HXDLIN(  64)												{
HXLINE(  64)													int rectLeft = xIter3->start;
HXDLIN(  64)													int rectTop = yIter3->start;
HXDLIN(  64)													int rectRight = xIter3->max;
HXDLIN(  64)													bool forceClear = false;
HXDLIN(  64)													{
HXLINE(  64)														int _g = rectTop;
HXDLIN(  64)														int _g1 = yIter3->max;
HXDLIN(  64)														while((_g < _g1)){
HXLINE(  64)															_g = (_g + 1);
HXDLIN(  64)															int dy = (_g - 1);
HXDLIN(  64)															{
HXLINE(  64)																int _g1 = rectLeft;
HXDLIN(  64)																int _g2 = rectRight;
HXDLIN(  64)																while((_g1 < _g2)){
HXLINE(  64)																	_g1 = (_g1 + 1);
HXDLIN(  64)																	int dx = (_g1 - 1);
HXDLIN(  64)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																	int index;
HXDLIN(  64)																	if (pixelshape1->useVirtualPos) {
HXLINE(  64)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + dx) - pixelshape1->virtualX));
            																	}
            																	else {
HXLINE(  64)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape1->width) + dx)) ));
            																	}
HXDLIN(  64)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																	int col;
HXDLIN(  64)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  64)																		col = c;
            																	}
HXDLIN(  64)																	bool _hx_tmp;
HXDLIN(  64)																	if (pixelshape1->useMask) {
HXLINE(  64)																		_hx_tmp = ::hx::IsNotNull( pixelshape1->mask );
            																	}
            																	else {
HXLINE(  64)																		_hx_tmp = false;
            																	}
HXDLIN(  64)																	if (_hx_tmp) {
HXLINE(  64)																		::pixelimage::ImageStruct this1 = pixelshape1->mask;
HXDLIN(  64)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)																		int index;
HXDLIN(  64)																		if (this1->useVirtualPos) {
HXLINE(  64)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  64)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  64)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																		int v;
HXDLIN(  64)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  64)																			v = c;
            																		}
HXDLIN(  64)																		int this3 = v;
HXDLIN(  64)																		int maskPixel = this3;
HXDLIN(  64)																		int this4 = col;
HXDLIN(  64)																		int this5 = this4;
HXDLIN(  64)																		if ((maskPixel == 0)) {
HXLINE(  64)																			int this1 = this5;
HXDLIN(  64)																			col = this1;
            																		}
            																		else {
HXLINE(  64)																			Float m0;
HXDLIN(  64)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  64)																			if ((this1 == 0)) {
HXLINE(  64)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m1;
HXDLIN(  64)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  64)																			if ((this2 == 0)) {
HXLINE(  64)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m2;
HXDLIN(  64)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  64)																			if ((this3 == 0)) {
HXLINE(  64)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m3;
HXDLIN(  64)																			int this4 = (maskPixel & 255);
HXDLIN(  64)																			if ((this4 == 0)) {
HXLINE(  64)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  64)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  64)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  64)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  64)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  64)																	if ((col != 0)) {
HXLINE(  64)																		int x = (dx - rectLeft);
HXDLIN(  64)																		int y = (dy - rectTop);
HXDLIN(  64)																		int this1 = col;
HXDLIN(  64)																		int c = this1;
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			int location;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																			int this3 = this2;
HXDLIN(  64)																			int this4;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				this4 = this3;
            																			}
HXDLIN(  64)																			Float a1;
HXDLIN(  64)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)																			if ((this5 == 0)) {
HXLINE(  64)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r1;
HXDLIN(  64)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)																			if ((this6 == 0)) {
HXLINE(  64)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g1;
HXDLIN(  64)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)																			if ((this7 == 0)) {
HXLINE(  64)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b1;
HXDLIN(  64)																			int this8 = (this4 & 255);
HXDLIN(  64)																			if ((this8 == 0)) {
HXLINE(  64)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a2;
HXDLIN(  64)																			int this9 = ((col >> 24) & 255);
HXDLIN(  64)																			if ((this9 == 0)) {
HXLINE(  64)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r2;
HXDLIN(  64)																			int this10 = ((col >> 16) & 255);
HXDLIN(  64)																			if ((this10 == 0)) {
HXLINE(  64)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g2;
HXDLIN(  64)																			int this11 = ((col >> 8) & 255);
HXDLIN(  64)																			if ((this11 == 0)) {
HXLINE(  64)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b2;
HXDLIN(  64)																			int this12 = (col & 255);
HXDLIN(  64)																			if ((this12 == 0)) {
HXLINE(  64)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)																			{
HXLINE(  64)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  64)																				int value;
HXDLIN(  64)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  64)																					value = blended;
            																				}
HXDLIN(  64)																				bool _hx_tmp;
HXDLIN(  64)																				if ((location >= 0)) {
HXLINE(  64)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  64)																					_hx_tmp = false;
            																				}
HXDLIN(  64)																				if (_hx_tmp) {
HXLINE(  64)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			int value;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				value = c;
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  64)																		if (forceClear) {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			int x = (dx - rectLeft);
HXDLIN(  64)																			int y = (dy - rectTop);
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  64)											bool found = false;
HXDLIN(  64)											Float s = ((Float)0.);
HXDLIN(  64)											Float t = ((Float)0.);
HXDLIN(  64)											Float sxx = ((Float)0.);
HXDLIN(  64)											Float txx = ((Float)0.);
HXDLIN(  64)											{
HXLINE(  64)												int _g_min = xIter3->start;
HXDLIN(  64)												int _g_max = xIter3->max;
HXDLIN(  64)												while((_g_min < _g_max)){
HXLINE(  64)													_g_min = (_g_min + 1);
HXDLIN(  64)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXLINE(  64)													{
HXLINE(  64)														int _g_min1 = yIter3->start;
HXDLIN(  64)														int _g_max = yIter3->max;
HXDLIN(  64)														while((_g_min1 < _g_max)){
HXLINE(  64)															_g_min1 = (_g_min1 + 1);
HXDLIN(  64)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  64)															bool _hx_tmp;
HXDLIN(  64)															if (!((s <= 0))) {
HXLINE(  64)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  64)																_hx_tmp = true;
            															}
HXDLIN(  64)															if (_hx_tmp) {
HXLINE(  64)																if (found) {
HXLINE(  64)																	goto _hx_goto_34;
            																}
            															}
            															else {
HXLINE(  64)																if (((s + t) < A)) {
HXLINE(  64)																	{
HXLINE(  64)																		int this1 = color1;
HXDLIN(  64)																		int c = this1;
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)																			_hx_tmp = pixelshape1->transparent;
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			int location;
HXDLIN(  64)																			if (pixelshape1->useVirtualPos) {
HXLINE(  64)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            																			}
            																			else {
HXLINE(  64)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape1->width) + x)) ));
            																			}
HXDLIN(  64)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																			int this3 = this2;
HXDLIN(  64)																			int this4;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				this4 = this3;
            																			}
HXDLIN(  64)																			Float a1;
HXDLIN(  64)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)																			if ((this5 == 0)) {
HXLINE(  64)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r1;
HXDLIN(  64)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)																			if ((this6 == 0)) {
HXLINE(  64)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g1;
HXDLIN(  64)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)																			if ((this7 == 0)) {
HXLINE(  64)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b1;
HXDLIN(  64)																			int this8 = (this4 & 255);
HXDLIN(  64)																			if ((this8 == 0)) {
HXLINE(  64)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a2;
HXDLIN(  64)																			int this9 = ((color1 >> 24) & 255);
HXDLIN(  64)																			if ((this9 == 0)) {
HXLINE(  64)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r2;
HXDLIN(  64)																			int this10 = ((color1 >> 16) & 255);
HXDLIN(  64)																			if ((this10 == 0)) {
HXLINE(  64)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g2;
HXDLIN(  64)																			int this11 = ((color1 >> 8) & 255);
HXDLIN(  64)																			if ((this11 == 0)) {
HXLINE(  64)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b2;
HXDLIN(  64)																			int this12 = (color1 & 255);
HXDLIN(  64)																			if ((this12 == 0)) {
HXLINE(  64)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)																			{
HXLINE(  64)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape1->image;
HXDLIN(  64)																				int value;
HXDLIN(  64)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  64)																					value = blended;
            																				}
HXDLIN(  64)																				bool _hx_tmp;
HXDLIN(  64)																				if ((location >= 0)) {
HXLINE(  64)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  64)																					_hx_tmp = false;
            																				}
HXDLIN(  64)																				if (_hx_tmp) {
HXLINE(  64)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (pixelshape1->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape1->width) + x)) ));
            																			}
HXDLIN(  64)																			int value;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				value = c;
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  64)																	if (found) {
HXLINE(  64)																		goto _hx_goto_34;
            																	}
            																}
            															}
            														}
            														_hx_goto_34:;
            													}
            												}
            											}
HXDLIN(  64)											if ((hasHit == true)) {
HXLINE(  64)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx2,cy2,bx,by,cx,cy,true);
HXDLIN(  64)												if (hasUndo) {
HXLINE(  64)													v->undoImage = undoImage;
HXDLIN(  64)													v->undoX = xIter3->start;
HXDLIN(  64)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX4 = nextX;
HXLINE(  47)								lastY4 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  64)				{
HXLINE(  64)					Float x3 = (x2 + dx1);
HXDLIN(  64)					int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  64)					int xx3 = p3;
HXDLIN(  64)					int q3 = ::Std_obj::_hx_int(y1);
HXDLIN(  64)					int maxX3 = ::Std_obj::_hx_int((x3 + ( (Float)(fat1) )));
HXDLIN(  64)					int maxY3 = ::Std_obj::_hx_int((y1 + ( (Float)(dy1) )));
HXDLIN(  64)					while(true){
HXLINE(  64)						{
HXLINE(  64)							p3 = (p3 + 1);
HXDLIN(  64)							int x = (p3 - 1);
HXDLIN(  64)							int this1 = color1;
HXDLIN(  64)							int c = this1;
HXDLIN(  64)							bool _hx_tmp;
HXDLIN(  64)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)								_hx_tmp = pixelshape1->transparent;
            							}
            							else {
HXLINE(  64)								_hx_tmp = false;
            							}
HXDLIN(  64)							if (_hx_tmp) {
HXLINE(  64)								int location;
HXDLIN(  64)								if (pixelshape1->useVirtualPos) {
HXLINE(  64)									location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            								}
            								else {
HXLINE(  64)									location = ::Std_obj::_hx_int(( (Float)(((q3 * pixelshape1->width) + x)) ));
            								}
HXDLIN(  64)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)								int this3 = this2;
HXDLIN(  64)								int this4;
HXDLIN(  64)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  64)									this4 = this3;
            								}
HXDLIN(  64)								Float a1;
HXDLIN(  64)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)								if ((this5 == 0)) {
HXLINE(  64)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float r1;
HXDLIN(  64)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)								if ((this6 == 0)) {
HXLINE(  64)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float g1;
HXDLIN(  64)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)								if ((this7 == 0)) {
HXLINE(  64)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float b1;
HXDLIN(  64)								int this8 = (this4 & 255);
HXDLIN(  64)								if ((this8 == 0)) {
HXLINE(  64)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float a2;
HXDLIN(  64)								int this9 = ((color1 >> 24) & 255);
HXDLIN(  64)								if ((this9 == 0)) {
HXLINE(  64)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float r2;
HXDLIN(  64)								int this10 = ((color1 >> 16) & 255);
HXDLIN(  64)								if ((this10 == 0)) {
HXLINE(  64)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float g2;
HXDLIN(  64)								int this11 = ((color1 >> 8) & 255);
HXDLIN(  64)								if ((this11 == 0)) {
HXLINE(  64)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float b2;
HXDLIN(  64)								int this12 = (color1 & 255);
HXDLIN(  64)								if ((this12 == 0)) {
HXLINE(  64)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)								{
HXLINE(  64)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape1->image;
HXDLIN(  64)									int value;
HXDLIN(  64)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  64)										value = blended;
            									}
HXDLIN(  64)									bool _hx_tmp;
HXDLIN(  64)									if ((location >= 0)) {
HXLINE(  64)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  64)										_hx_tmp = false;
            									}
HXDLIN(  64)									if (_hx_tmp) {
HXLINE(  64)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  64)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)								int index;
HXDLIN(  64)								if (pixelshape1->useVirtualPos) {
HXLINE(  64)									index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            								}
            								else {
HXLINE(  64)									index = ::Std_obj::_hx_int(( (Float)(((q3 * pixelshape1->width) + x)) ));
            								}
HXDLIN(  64)								int value;
HXDLIN(  64)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  64)									value = c;
            								}
HXDLIN(  64)								bool _hx_tmp;
HXDLIN(  64)								if ((index >= 0)) {
HXLINE(  64)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  64)									_hx_tmp = false;
            								}
HXDLIN(  64)								if (_hx_tmp) {
HXLINE(  64)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  64)						if ((p3 > maxX3)) {
HXLINE( 247)							p3 = xx3;
HXLINE(  64)							q3 = (q3 + 1);
            						}
HXDLIN(  64)						if ((q3 > maxY3)) {
HXLINE(  64)							goto _hx_goto_35;
            						}
            					}
            					_hx_goto_35:;
            				}
HXDLIN(  64)				{
HXLINE(  64)					Float cy3 = (y1 + dy1);
HXDLIN(  64)					Float ry3 = ( (Float)(dy1) );
HXDLIN(  64)					{
HXLINE(  64)						 ::Dynamic targetError5 = ((Float)1.05);
HXDLIN(  64)						if (::hx::IsNull( targetError5 )) {
HXLINE( 840)							targetError5 = ((Float)1.05);
            						}
HXLINE(  64)						Float rSmall5;
HXDLIN(  64)						if ((rightRadius1 > ry3)) {
HXLINE(  64)							rSmall5 = ry3;
            						}
            						else {
HXLINE(  64)							rSmall5 = rightRadius1;
            						}
HXDLIN(  64)						 ::Dynamic targetE5 = ( (Float)(targetError5) );
HXDLIN(  64)						if (::hx::IsNull( targetE5 )) {
HXLINE(  20)							targetE5 = ((Float)1.05);
            						}
HXLINE(  64)						int result5 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE5) ) / rSmall5)))));
HXDLIN(  64)						int noSides5;
HXDLIN(  64)						if ((result5 < 12)) {
HXLINE(  64)							noSides5 = 12;
            						}
            						else {
HXLINE(  64)							if ((result5 > 500)) {
HXLINE(  64)								noSides5 = 500;
            							}
            							else {
HXLINE(  64)								noSides5 = result5;
            							}
            						}
HXDLIN(  64)						int sides5 = (::Math_obj::ceil((( (Float)(noSides5) ) / ( (Float)(4) ))) * 4);
HXDLIN(  64)						Float theta5 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides5) ));
HXDLIN(  64)						Float omega5 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN(  64)						int quarter5 = ::Std_obj::_hx_int((( (Float)(sides5) ) / ( (Float)(4) )));
HXDLIN(  64)						Float lastX5 = ((Float)0.);
HXDLIN(  64)						Float lastY5 = ((Float)0.);
HXDLIN(  64)						{
HXLINE(  26)							lastX5 = (farX1 + (rightRadius1 * ::Math_obj::cos(((( (Float)(sides5) ) * theta5) + omega5))));
HXLINE(  27)							lastY5 = (cy3 + (ry3 * ::Math_obj::sin(((( (Float)(sides5) ) * theta5) + omega5))));
            						}
HXLINE(  64)						{
HXLINE(  64)							int _g10 = 0;
HXDLIN(  64)							int _g11 = (quarter5 + 1);
HXDLIN(  64)							while((_g10 < _g11)){
HXLINE(  64)								_g10 = (_g10 + 1);
HXDLIN(  64)								int i = (_g10 - 1);
HXDLIN(  64)								Float nextX = (farX1 + (rightRadius1 * ::Math_obj::cos((((( (Float)(i) ) * theta5) + ((Float)0.0001)) + omega5))));
HXDLIN(  64)								Float nextY = (cy3 + (ry3 * ::Math_obj::sin((((( (Float)(i) ) * theta5) + ((Float)0.0001)) + omega5))));
HXDLIN(  64)								{
HXLINE(  64)									bool hasHit = false;
HXDLIN(  64)									bool hasUndo = false;
HXDLIN(  64)									{
HXLINE(  64)										Float bx = lastX5;
HXDLIN(  64)										Float by = lastY5;
HXDLIN(  64)										Float cx = nextX;
HXDLIN(  64)										Float cy = nextY;
HXDLIN(  64)										bool adjustWinding = (((((farX1 * by) - (bx * cy3)) + ((bx * cy) - (cx * by))) + ((cx * cy3) - (farX1 * cy))) > 0);
HXDLIN(  64)										if (!(adjustWinding)) {
HXLINE(  64)											Float bx_ = bx;
HXDLIN(  64)											Float by_ = by;
HXLINE(  26)											bx = cx;
HXLINE(  27)											by = cy;
HXLINE(  28)											cx = bx_;
HXLINE(  29)											cy = by_;
            										}
HXLINE(  64)										{
HXLINE(  64)											Float s0 = ((cy3 * cx) - (farX1 * cy));
HXDLIN(  64)											Float sx = (cy - cy3);
HXDLIN(  64)											Float sy = (farX1 - cx);
HXDLIN(  64)											Float t0 = ((farX1 * by) - (cy3 * bx));
HXDLIN(  64)											Float tx = (cy3 - by);
HXDLIN(  64)											Float ty = (bx - farX1);
HXDLIN(  64)											Float A = ((((-(by) * cx) + (cy3 * (-(bx) + cx))) + (farX1 * (by - cy))) + (bx * cy));
HXDLIN(  64)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  64)											if ((farX1 > bx)) {
HXLINE(  64)												if ((farX1 > cx)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((bx > cx)) {
HXLINE(  64)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(farX1);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  64)												if ((bx > cx)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((farX1 > cx)) {
HXLINE(  64)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::ceil(farX1);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(farX1);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            											}
HXDLIN(  64)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  64)											if ((cy3 > by)) {
HXLINE(  64)												if ((cy3 > cy)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((by > cy)) {
HXLINE(  64)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  64)												if ((by > cy)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((cy3 > cy)) {
HXLINE(  64)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::ceil(cy3);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(cy3);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            											}
HXDLIN(  64)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  64)											if (hasUndo) {
HXLINE(  64)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  64)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  64)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  64)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  64)												undoImage = this3;
HXDLIN(  64)												{
HXLINE(  64)													int rectLeft = xIter3->start;
HXDLIN(  64)													int rectTop = yIter3->start;
HXDLIN(  64)													int rectRight = xIter3->max;
HXDLIN(  64)													bool forceClear = false;
HXDLIN(  64)													{
HXLINE(  64)														int _g = rectTop;
HXDLIN(  64)														int _g1 = yIter3->max;
HXDLIN(  64)														while((_g < _g1)){
HXLINE(  64)															_g = (_g + 1);
HXDLIN(  64)															int dy = (_g - 1);
HXDLIN(  64)															{
HXLINE(  64)																int _g1 = rectLeft;
HXDLIN(  64)																int _g2 = rectRight;
HXDLIN(  64)																while((_g1 < _g2)){
HXLINE(  64)																	_g1 = (_g1 + 1);
HXDLIN(  64)																	int dx = (_g1 - 1);
HXDLIN(  64)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																	int index;
HXDLIN(  64)																	if (pixelshape1->useVirtualPos) {
HXLINE(  64)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + dx) - pixelshape1->virtualX));
            																	}
            																	else {
HXLINE(  64)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape1->width) + dx)) ));
            																	}
HXDLIN(  64)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																	int col;
HXDLIN(  64)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  64)																		col = c;
            																	}
HXDLIN(  64)																	bool _hx_tmp;
HXDLIN(  64)																	if (pixelshape1->useMask) {
HXLINE(  64)																		_hx_tmp = ::hx::IsNotNull( pixelshape1->mask );
            																	}
            																	else {
HXLINE(  64)																		_hx_tmp = false;
            																	}
HXDLIN(  64)																	if (_hx_tmp) {
HXLINE(  64)																		::pixelimage::ImageStruct this1 = pixelshape1->mask;
HXDLIN(  64)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)																		int index;
HXDLIN(  64)																		if (this1->useVirtualPos) {
HXLINE(  64)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  64)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  64)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																		int v;
HXDLIN(  64)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  64)																			v = c;
            																		}
HXDLIN(  64)																		int this3 = v;
HXDLIN(  64)																		int maskPixel = this3;
HXDLIN(  64)																		int this4 = col;
HXDLIN(  64)																		int this5 = this4;
HXDLIN(  64)																		if ((maskPixel == 0)) {
HXLINE(  64)																			int this1 = this5;
HXDLIN(  64)																			col = this1;
            																		}
            																		else {
HXLINE(  64)																			Float m0;
HXDLIN(  64)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  64)																			if ((this1 == 0)) {
HXLINE(  64)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m1;
HXDLIN(  64)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  64)																			if ((this2 == 0)) {
HXLINE(  64)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m2;
HXDLIN(  64)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  64)																			if ((this3 == 0)) {
HXLINE(  64)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m3;
HXDLIN(  64)																			int this4 = (maskPixel & 255);
HXDLIN(  64)																			if ((this4 == 0)) {
HXLINE(  64)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  64)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  64)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  64)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  64)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  64)																	if ((col != 0)) {
HXLINE(  64)																		int x = (dx - rectLeft);
HXDLIN(  64)																		int y = (dy - rectTop);
HXDLIN(  64)																		int this1 = col;
HXDLIN(  64)																		int c = this1;
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			int location;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																			int this3 = this2;
HXDLIN(  64)																			int this4;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				this4 = this3;
            																			}
HXDLIN(  64)																			Float a1;
HXDLIN(  64)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)																			if ((this5 == 0)) {
HXLINE(  64)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r1;
HXDLIN(  64)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)																			if ((this6 == 0)) {
HXLINE(  64)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g1;
HXDLIN(  64)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)																			if ((this7 == 0)) {
HXLINE(  64)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b1;
HXDLIN(  64)																			int this8 = (this4 & 255);
HXDLIN(  64)																			if ((this8 == 0)) {
HXLINE(  64)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a2;
HXDLIN(  64)																			int this9 = ((col >> 24) & 255);
HXDLIN(  64)																			if ((this9 == 0)) {
HXLINE(  64)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r2;
HXDLIN(  64)																			int this10 = ((col >> 16) & 255);
HXDLIN(  64)																			if ((this10 == 0)) {
HXLINE(  64)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g2;
HXDLIN(  64)																			int this11 = ((col >> 8) & 255);
HXDLIN(  64)																			if ((this11 == 0)) {
HXLINE(  64)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b2;
HXDLIN(  64)																			int this12 = (col & 255);
HXDLIN(  64)																			if ((this12 == 0)) {
HXLINE(  64)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)																			{
HXLINE(  64)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  64)																				int value;
HXDLIN(  64)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  64)																					value = blended;
            																				}
HXDLIN(  64)																				bool _hx_tmp;
HXDLIN(  64)																				if ((location >= 0)) {
HXLINE(  64)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  64)																					_hx_tmp = false;
            																				}
HXDLIN(  64)																				if (_hx_tmp) {
HXLINE(  64)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			int value;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				value = c;
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  64)																		if (forceClear) {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			int x = (dx - rectLeft);
HXDLIN(  64)																			int y = (dy - rectTop);
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  64)											bool found = false;
HXDLIN(  64)											Float s = ((Float)0.);
HXDLIN(  64)											Float t = ((Float)0.);
HXDLIN(  64)											Float sxx = ((Float)0.);
HXDLIN(  64)											Float txx = ((Float)0.);
HXDLIN(  64)											{
HXLINE(  64)												int _g_min = xIter3->start;
HXDLIN(  64)												int _g_max = xIter3->max;
HXDLIN(  64)												while((_g_min < _g_max)){
HXLINE(  64)													_g_min = (_g_min + 1);
HXDLIN(  64)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXLINE(  64)													{
HXLINE(  64)														int _g_min1 = yIter3->start;
HXDLIN(  64)														int _g_max = yIter3->max;
HXDLIN(  64)														while((_g_min1 < _g_max)){
HXLINE(  64)															_g_min1 = (_g_min1 + 1);
HXDLIN(  64)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  64)															bool _hx_tmp;
HXDLIN(  64)															if (!((s <= 0))) {
HXLINE(  64)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  64)																_hx_tmp = true;
            															}
HXDLIN(  64)															if (_hx_tmp) {
HXLINE(  64)																if (found) {
HXLINE(  64)																	goto _hx_goto_40;
            																}
            															}
            															else {
HXLINE(  64)																if (((s + t) < A)) {
HXLINE(  64)																	{
HXLINE(  64)																		int this1 = color1;
HXDLIN(  64)																		int c = this1;
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)																			_hx_tmp = pixelshape1->transparent;
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			int location;
HXDLIN(  64)																			if (pixelshape1->useVirtualPos) {
HXLINE(  64)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            																			}
            																			else {
HXLINE(  64)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape1->width) + x)) ));
            																			}
HXDLIN(  64)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																			int this3 = this2;
HXDLIN(  64)																			int this4;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				this4 = this3;
            																			}
HXDLIN(  64)																			Float a1;
HXDLIN(  64)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)																			if ((this5 == 0)) {
HXLINE(  64)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r1;
HXDLIN(  64)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)																			if ((this6 == 0)) {
HXLINE(  64)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g1;
HXDLIN(  64)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)																			if ((this7 == 0)) {
HXLINE(  64)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b1;
HXDLIN(  64)																			int this8 = (this4 & 255);
HXDLIN(  64)																			if ((this8 == 0)) {
HXLINE(  64)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a2;
HXDLIN(  64)																			int this9 = ((color1 >> 24) & 255);
HXDLIN(  64)																			if ((this9 == 0)) {
HXLINE(  64)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r2;
HXDLIN(  64)																			int this10 = ((color1 >> 16) & 255);
HXDLIN(  64)																			if ((this10 == 0)) {
HXLINE(  64)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g2;
HXDLIN(  64)																			int this11 = ((color1 >> 8) & 255);
HXDLIN(  64)																			if ((this11 == 0)) {
HXLINE(  64)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b2;
HXDLIN(  64)																			int this12 = (color1 & 255);
HXDLIN(  64)																			if ((this12 == 0)) {
HXLINE(  64)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)																			{
HXLINE(  64)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape1->image;
HXDLIN(  64)																				int value;
HXDLIN(  64)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  64)																					value = blended;
            																				}
HXDLIN(  64)																				bool _hx_tmp;
HXDLIN(  64)																				if ((location >= 0)) {
HXLINE(  64)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  64)																					_hx_tmp = false;
            																				}
HXDLIN(  64)																				if (_hx_tmp) {
HXLINE(  64)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (pixelshape1->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape1->width) + x)) ));
            																			}
HXDLIN(  64)																			int value;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				value = c;
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  64)																	if (found) {
HXLINE(  64)																		goto _hx_goto_40;
            																	}
            																}
            															}
            														}
            														_hx_goto_40:;
            													}
            												}
            											}
HXDLIN(  64)											if ((hasHit == true)) {
HXLINE(  64)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX1,cy3,bx,by,cx,cy,true);
HXDLIN(  64)												if (hasUndo) {
HXLINE(  64)													v->undoImage = undoImage;
HXDLIN(  64)													v->undoX = xIter3->start;
HXDLIN(  64)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX5 = nextX;
HXLINE(  47)								lastY5 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  64)				{
HXLINE(  64)					Float y2 = (y1 + dy1);
HXDLIN(  64)					int p4 = ::Std_obj::_hx_int(x2);
HXDLIN(  64)					int xx4 = p4;
HXDLIN(  64)					int q4 = ::Std_obj::_hx_int(y2);
HXDLIN(  64)					int maxX4 = ::Std_obj::_hx_int((x2 + wid1));
HXDLIN(  64)					int maxY4 = ::Std_obj::_hx_int((y2 + ( (Float)(tall1) )));
HXDLIN(  64)					while(true){
HXLINE(  64)						{
HXLINE(  64)							p4 = (p4 + 1);
HXDLIN(  64)							int x = (p4 - 1);
HXDLIN(  64)							int this1 = color1;
HXDLIN(  64)							int c = this1;
HXDLIN(  64)							bool _hx_tmp;
HXDLIN(  64)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)								_hx_tmp = pixelshape1->transparent;
            							}
            							else {
HXLINE(  64)								_hx_tmp = false;
            							}
HXDLIN(  64)							if (_hx_tmp) {
HXLINE(  64)								int location;
HXDLIN(  64)								if (pixelshape1->useVirtualPos) {
HXLINE(  64)									location = ::Std_obj::_hx_int(((((( (Float)(q4) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            								}
            								else {
HXLINE(  64)									location = ::Std_obj::_hx_int(( (Float)(((q4 * pixelshape1->width) + x)) ));
            								}
HXDLIN(  64)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)								int this3 = this2;
HXDLIN(  64)								int this4;
HXDLIN(  64)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  64)									this4 = this3;
            								}
HXDLIN(  64)								Float a1;
HXDLIN(  64)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)								if ((this5 == 0)) {
HXLINE(  64)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float r1;
HXDLIN(  64)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)								if ((this6 == 0)) {
HXLINE(  64)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float g1;
HXDLIN(  64)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)								if ((this7 == 0)) {
HXLINE(  64)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float b1;
HXDLIN(  64)								int this8 = (this4 & 255);
HXDLIN(  64)								if ((this8 == 0)) {
HXLINE(  64)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float a2;
HXDLIN(  64)								int this9 = ((color1 >> 24) & 255);
HXDLIN(  64)								if ((this9 == 0)) {
HXLINE(  64)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float r2;
HXDLIN(  64)								int this10 = ((color1 >> 16) & 255);
HXDLIN(  64)								if ((this10 == 0)) {
HXLINE(  64)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float g2;
HXDLIN(  64)								int this11 = ((color1 >> 8) & 255);
HXDLIN(  64)								if ((this11 == 0)) {
HXLINE(  64)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float b2;
HXDLIN(  64)								int this12 = (color1 & 255);
HXDLIN(  64)								if ((this12 == 0)) {
HXLINE(  64)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)								{
HXLINE(  64)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape1->image;
HXDLIN(  64)									int value;
HXDLIN(  64)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  64)										value = blended;
            									}
HXDLIN(  64)									bool _hx_tmp;
HXDLIN(  64)									if ((location >= 0)) {
HXLINE(  64)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  64)										_hx_tmp = false;
            									}
HXDLIN(  64)									if (_hx_tmp) {
HXLINE(  64)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  64)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)								int index;
HXDLIN(  64)								if (pixelshape1->useVirtualPos) {
HXLINE(  64)									index = ::Std_obj::_hx_int(((((( (Float)(q4) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            								}
            								else {
HXLINE(  64)									index = ::Std_obj::_hx_int(( (Float)(((q4 * pixelshape1->width) + x)) ));
            								}
HXDLIN(  64)								int value;
HXDLIN(  64)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  64)									value = c;
            								}
HXDLIN(  64)								bool _hx_tmp;
HXDLIN(  64)								if ((index >= 0)) {
HXLINE(  64)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  64)									_hx_tmp = false;
            								}
HXDLIN(  64)								if (_hx_tmp) {
HXLINE(  64)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  64)						if ((p4 > maxX4)) {
HXLINE( 247)							p4 = xx4;
HXLINE(  64)							q4 = (q4 + 1);
            						}
HXDLIN(  64)						if ((q4 > maxY4)) {
HXLINE(  64)							goto _hx_goto_41;
            						}
            					}
            					_hx_goto_41:;
            				}
HXDLIN(  64)				{
HXLINE(  64)					Float cx3 = (x2 + dx1);
HXDLIN(  64)					Float rx3 = ( (Float)(dx1) );
HXDLIN(  64)					{
HXLINE(  64)						 ::Dynamic targetError6 = ((Float)1.05);
HXDLIN(  64)						if (::hx::IsNull( targetError6 )) {
HXLINE( 840)							targetError6 = ((Float)1.05);
            						}
HXLINE(  64)						Float rSmall6;
HXDLIN(  64)						if ((rx3 > bottomRadius1)) {
HXLINE(  64)							rSmall6 = bottomRadius1;
            						}
            						else {
HXLINE(  64)							rSmall6 = rx3;
            						}
HXDLIN(  64)						 ::Dynamic targetE6 = ( (Float)(targetError6) );
HXDLIN(  64)						if (::hx::IsNull( targetE6 )) {
HXLINE(  20)							targetE6 = ((Float)1.05);
            						}
HXLINE(  64)						int result6 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE6) ) / rSmall6)))));
HXDLIN(  64)						int noSides6;
HXDLIN(  64)						if ((result6 < 12)) {
HXLINE(  64)							noSides6 = 12;
            						}
            						else {
HXLINE(  64)							if ((result6 > 500)) {
HXLINE(  64)								noSides6 = 500;
            							}
            							else {
HXLINE(  64)								noSides6 = result6;
            							}
            						}
HXDLIN(  64)						int sides6 = (::Math_obj::ceil((( (Float)(noSides6) ) / ( (Float)(4) ))) * 4);
HXDLIN(  64)						Float theta6 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides6) ));
HXDLIN(  64)						Float omega6 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  64)						int quarter6 = ::Std_obj::_hx_int((( (Float)(sides6) ) / ( (Float)(4) )));
HXDLIN(  64)						Float lastX6 = ((Float)0.);
HXDLIN(  64)						Float lastY6 = ((Float)0.);
HXDLIN(  64)						{
HXLINE(  26)							lastX6 = (cx3 + (rx3 * ::Math_obj::cos(((( (Float)(sides6) ) * theta6) + omega6))));
HXLINE(  27)							lastY6 = (lowerY1 + (bottomRadius1 * ::Math_obj::sin(((( (Float)(sides6) ) * theta6) + omega6))));
            						}
HXLINE(  64)						{
HXLINE(  64)							int _g12 = 0;
HXDLIN(  64)							int _g13 = (quarter6 + 1);
HXDLIN(  64)							while((_g12 < _g13)){
HXLINE(  64)								_g12 = (_g12 + 1);
HXDLIN(  64)								int i = (_g12 - 1);
HXDLIN(  64)								Float nextX = (cx3 + (rx3 * ::Math_obj::cos((((( (Float)(i) ) * theta6) + ((Float)0.0001)) + omega6))));
HXDLIN(  64)								Float nextY = (lowerY1 + (bottomRadius1 * ::Math_obj::sin((((( (Float)(i) ) * theta6) + ((Float)0.0001)) + omega6))));
HXDLIN(  64)								{
HXLINE(  64)									bool hasHit = false;
HXDLIN(  64)									bool hasUndo = false;
HXDLIN(  64)									{
HXLINE(  64)										Float bx = lastX6;
HXDLIN(  64)										Float by = lastY6;
HXDLIN(  64)										Float cx = nextX;
HXDLIN(  64)										Float cy = nextY;
HXDLIN(  64)										bool adjustWinding = (((((cx3 * by) - (bx * lowerY1)) + ((bx * cy) - (cx * by))) + ((cx * lowerY1) - (cx3 * cy))) > 0);
HXDLIN(  64)										if (!(adjustWinding)) {
HXLINE(  64)											Float bx_ = bx;
HXDLIN(  64)											Float by_ = by;
HXLINE(  26)											bx = cx;
HXLINE(  27)											by = cy;
HXLINE(  28)											cx = bx_;
HXLINE(  29)											cy = by_;
            										}
HXLINE(  64)										{
HXLINE(  64)											Float s0 = ((lowerY1 * cx) - (cx3 * cy));
HXDLIN(  64)											Float sx = (cy - lowerY1);
HXDLIN(  64)											Float sy = (cx3 - cx);
HXDLIN(  64)											Float t0 = ((cx3 * by) - (lowerY1 * bx));
HXDLIN(  64)											Float tx = (lowerY1 - by);
HXDLIN(  64)											Float ty = (bx - cx3);
HXDLIN(  64)											Float A = ((((-(by) * cx) + (lowerY1 * (-(bx) + cx))) + (cx3 * (by - cy))) + (bx * cy));
HXDLIN(  64)											::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  64)											if ((cx3 > bx)) {
HXLINE(  64)												if ((cx3 > cx)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((bx > cx)) {
HXLINE(  64)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(bx);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            											}
            											else {
HXLINE(  64)												if ((bx > cx)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((cx3 > cx)) {
HXLINE(  64)														min = ::Math_obj::floor(cx);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::ceil(cx3);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(cx3);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													xIter3 = this1;
            												}
            											}
HXDLIN(  64)											::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  64)											if ((lowerY1 > by)) {
HXLINE(  64)												if ((lowerY1 > cy)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((by > cy)) {
HXLINE(  64)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::floor(by);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(lowerY1);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(by);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            											}
            											else {
HXLINE(  64)												if ((by > cy)) {
HXLINE(  64)													int min;
HXDLIN(  64)													if ((lowerY1 > cy)) {
HXLINE(  64)														min = ::Math_obj::floor(cy);
            													}
            													else {
HXLINE(  64)														min = ::Math_obj::ceil(lowerY1);
            													}
HXDLIN(  64)													int ii_min = min;
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(by);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            												else {
HXLINE(  64)													int ii_min = ::Math_obj::floor(lowerY1);
HXDLIN(  64)													int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  64)													::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)													yIter3 = this1;
            												}
            											}
HXDLIN(  64)											::pixelimage::ImageStruct undoImage = null();
HXDLIN(  64)											if (hasUndo) {
HXLINE(  64)												int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  64)												int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  64)												int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  64)												::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  64)												::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  64)												undoImage = this3;
HXDLIN(  64)												{
HXLINE(  64)													int rectLeft = xIter3->start;
HXDLIN(  64)													int rectTop = yIter3->start;
HXDLIN(  64)													int rectRight = xIter3->max;
HXDLIN(  64)													bool forceClear = false;
HXDLIN(  64)													{
HXLINE(  64)														int _g = rectTop;
HXDLIN(  64)														int _g1 = yIter3->max;
HXDLIN(  64)														while((_g < _g1)){
HXLINE(  64)															_g = (_g + 1);
HXDLIN(  64)															int dy = (_g - 1);
HXDLIN(  64)															{
HXLINE(  64)																int _g1 = rectLeft;
HXDLIN(  64)																int _g2 = rectRight;
HXDLIN(  64)																while((_g1 < _g2)){
HXLINE(  64)																	_g1 = (_g1 + 1);
HXDLIN(  64)																	int dx = (_g1 - 1);
HXDLIN(  64)																	::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																	int index;
HXDLIN(  64)																	if (pixelshape1->useVirtualPos) {
HXLINE(  64)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + dx) - pixelshape1->virtualX));
            																	}
            																	else {
HXLINE(  64)																		index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape1->width) + dx)) ));
            																	}
HXDLIN(  64)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																	int col;
HXDLIN(  64)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  64)																		col = c;
            																	}
HXDLIN(  64)																	bool _hx_tmp;
HXDLIN(  64)																	if (pixelshape1->useMask) {
HXLINE(  64)																		_hx_tmp = ::hx::IsNotNull( pixelshape1->mask );
            																	}
            																	else {
HXLINE(  64)																		_hx_tmp = false;
            																	}
HXDLIN(  64)																	if (_hx_tmp) {
HXLINE(  64)																		::pixelimage::ImageStruct this1 = pixelshape1->mask;
HXDLIN(  64)																		::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)																		int index;
HXDLIN(  64)																		if (this1->useVirtualPos) {
HXLINE(  64)																			index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																		}
            																		else {
HXLINE(  64)																			index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																		}
HXDLIN(  64)																		::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)																		int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)																		int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																		int v;
HXDLIN(  64)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  64)																			v = c;
            																		}
HXDLIN(  64)																		int this3 = v;
HXDLIN(  64)																		int maskPixel = this3;
HXDLIN(  64)																		int this4 = col;
HXDLIN(  64)																		int this5 = this4;
HXDLIN(  64)																		if ((maskPixel == 0)) {
HXLINE(  64)																			int this1 = this5;
HXDLIN(  64)																			col = this1;
            																		}
            																		else {
HXLINE(  64)																			Float m0;
HXDLIN(  64)																			int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  64)																			if ((this1 == 0)) {
HXLINE(  64)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m1;
HXDLIN(  64)																			int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  64)																			if ((this2 == 0)) {
HXLINE(  64)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m2;
HXDLIN(  64)																			int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  64)																			if ((this3 == 0)) {
HXLINE(  64)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float m3;
HXDLIN(  64)																			int this4 = (maskPixel & 255);
HXDLIN(  64)																			if ((this4 == 0)) {
HXLINE(  64)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  64)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  64)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  64)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  64)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  64)																	if ((col != 0)) {
HXLINE(  64)																		int x = (dx - rectLeft);
HXDLIN(  64)																		int y = (dy - rectTop);
HXDLIN(  64)																		int this1 = col;
HXDLIN(  64)																		int c = this1;
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)																			_hx_tmp = undoImage->transparent;
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			int location;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																			int this3 = this2;
HXDLIN(  64)																			int this4;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				this4 = this3;
            																			}
HXDLIN(  64)																			Float a1;
HXDLIN(  64)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)																			if ((this5 == 0)) {
HXLINE(  64)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r1;
HXDLIN(  64)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)																			if ((this6 == 0)) {
HXLINE(  64)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g1;
HXDLIN(  64)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)																			if ((this7 == 0)) {
HXLINE(  64)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b1;
HXDLIN(  64)																			int this8 = (this4 & 255);
HXDLIN(  64)																			if ((this8 == 0)) {
HXLINE(  64)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a2;
HXDLIN(  64)																			int this9 = ((col >> 24) & 255);
HXDLIN(  64)																			if ((this9 == 0)) {
HXLINE(  64)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r2;
HXDLIN(  64)																			int this10 = ((col >> 16) & 255);
HXDLIN(  64)																			if ((this10 == 0)) {
HXLINE(  64)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g2;
HXDLIN(  64)																			int this11 = ((col >> 8) & 255);
HXDLIN(  64)																			if ((this11 == 0)) {
HXLINE(  64)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b2;
HXDLIN(  64)																			int this12 = (col & 255);
HXDLIN(  64)																			if ((this12 == 0)) {
HXLINE(  64)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)																			{
HXLINE(  64)																				::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  64)																				int value;
HXDLIN(  64)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  64)																					value = blended;
            																				}
HXDLIN(  64)																				bool _hx_tmp;
HXDLIN(  64)																				if ((location >= 0)) {
HXLINE(  64)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  64)																					_hx_tmp = false;
            																				}
HXDLIN(  64)																				if (_hx_tmp) {
HXLINE(  64)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			int value;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				value = c;
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  64)																		if (forceClear) {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																			int x = (dx - rectLeft);
HXDLIN(  64)																			int y = (dy - rectTop);
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (undoImage->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  64)											bool found = false;
HXDLIN(  64)											Float s = ((Float)0.);
HXDLIN(  64)											Float t = ((Float)0.);
HXDLIN(  64)											Float sxx = ((Float)0.);
HXDLIN(  64)											Float txx = ((Float)0.);
HXDLIN(  64)											{
HXLINE(  64)												int _g_min = xIter3->start;
HXDLIN(  64)												int _g_max = xIter3->max;
HXDLIN(  64)												while((_g_min < _g_max)){
HXLINE(  64)													_g_min = (_g_min + 1);
HXDLIN(  64)													int x = (_g_min - 1);
HXLINE(  61)													sxx = (sx * ( (Float)(x) ));
HXLINE(  62)													txx = (tx * ( (Float)(x) ));
HXLINE(  63)													found = false;
HXLINE(  64)													{
HXLINE(  64)														int _g_min1 = yIter3->start;
HXDLIN(  64)														int _g_max = yIter3->max;
HXDLIN(  64)														while((_g_min1 < _g_max)){
HXLINE(  64)															_g_min1 = (_g_min1 + 1);
HXDLIN(  64)															int y = (_g_min1 - 1);
HXLINE(  65)															s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)															t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  64)															bool _hx_tmp;
HXDLIN(  64)															if (!((s <= 0))) {
HXLINE(  64)																_hx_tmp = (t <= 0);
            															}
            															else {
HXLINE(  64)																_hx_tmp = true;
            															}
HXDLIN(  64)															if (_hx_tmp) {
HXLINE(  64)																if (found) {
HXLINE(  64)																	goto _hx_goto_46;
            																}
            															}
            															else {
HXLINE(  64)																if (((s + t) < A)) {
HXLINE(  64)																	{
HXLINE(  64)																		int this1 = color1;
HXDLIN(  64)																		int c = this1;
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)																			_hx_tmp = pixelshape1->transparent;
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			int location;
HXDLIN(  64)																			if (pixelshape1->useVirtualPos) {
HXLINE(  64)																				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            																			}
            																			else {
HXLINE(  64)																				location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape1->width) + x)) ));
            																			}
HXDLIN(  64)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)																			int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																			int this3 = this2;
HXDLIN(  64)																			int this4;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				this4 = this3;
            																			}
HXDLIN(  64)																			Float a1;
HXDLIN(  64)																			int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)																			if ((this5 == 0)) {
HXLINE(  64)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r1;
HXDLIN(  64)																			int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)																			if ((this6 == 0)) {
HXLINE(  64)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g1;
HXDLIN(  64)																			int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)																			if ((this7 == 0)) {
HXLINE(  64)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b1;
HXDLIN(  64)																			int this8 = (this4 & 255);
HXDLIN(  64)																			if ((this8 == 0)) {
HXLINE(  64)																				b1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a2;
HXDLIN(  64)																			int this9 = ((color1 >> 24) & 255);
HXDLIN(  64)																			if ((this9 == 0)) {
HXLINE(  64)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float r2;
HXDLIN(  64)																			int this10 = ((color1 >> 16) & 255);
HXDLIN(  64)																			if ((this10 == 0)) {
HXLINE(  64)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float g2;
HXDLIN(  64)																			int this11 = ((color1 >> 8) & 255);
HXDLIN(  64)																			if ((this11 == 0)) {
HXLINE(  64)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float b2;
HXDLIN(  64)																			int this12 = (color1 & 255);
HXDLIN(  64)																			if ((this12 == 0)) {
HXLINE(  64)																				b2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  64)																				b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  64)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)																			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)																			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)																			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)																			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)																			{
HXLINE(  64)																				::haxe::io::ArrayBufferViewImpl this13 = pixelshape1->image;
HXDLIN(  64)																				int value;
HXDLIN(  64)																				if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																					value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  64)																					value = blended;
            																				}
HXDLIN(  64)																				bool _hx_tmp;
HXDLIN(  64)																				if ((location >= 0)) {
HXLINE(  64)																					_hx_tmp = (location < (this13->byteLength >> 2));
            																				}
            																				else {
HXLINE(  64)																					_hx_tmp = false;
            																				}
HXDLIN(  64)																				if (_hx_tmp) {
HXLINE(  64)																					::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																					int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																					_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																					_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																					_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																					_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																				}
            																			}
            																		}
            																		else {
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																			int index;
HXDLIN(  64)																			if (pixelshape1->useVirtualPos) {
HXLINE(  64)																				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            																			}
            																			else {
HXLINE(  64)																				index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape1->width) + x)) ));
            																			}
HXDLIN(  64)																			int value;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				value = c;
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((index >= 0)) {
HXLINE(  64)																				_hx_tmp = (index < (this1->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																				int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
HXLINE(  74)																	found = true;
            																}
            																else {
HXLINE(  64)																	if (found) {
HXLINE(  64)																		goto _hx_goto_46;
            																	}
            																}
            															}
            														}
            														_hx_goto_46:;
            													}
            												}
            											}
HXDLIN(  64)											if ((hasHit == true)) {
HXLINE(  64)												::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx3,lowerY1,bx,by,cx,cy,true);
HXDLIN(  64)												if (hasUndo) {
HXLINE(  64)													v->undoImage = undoImage;
HXDLIN(  64)													v->undoX = xIter3->start;
HXDLIN(  64)													v->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  46)								lastX6 = nextX;
HXLINE(  47)								lastY6 = nextY;
            							}
            						}
            					}
            				}
HXLINE(  64)				{
HXLINE(  64)					Float x4 = (x2 + dx1);
HXDLIN(  64)					int p5 = ::Std_obj::_hx_int(x4);
HXDLIN(  64)					int xx5 = p5;
HXDLIN(  64)					int q5 = ::Std_obj::_hx_int(lowerY1);
HXDLIN(  64)					int maxX5 = ::Std_obj::_hx_int((x4 + ( (Float)(fat1) )));
HXDLIN(  64)					int maxY5 = ::Std_obj::_hx_int((lowerY1 + bottomRadius1));
HXDLIN(  64)					while(true){
HXLINE(  64)						{
HXLINE(  64)							p5 = (p5 + 1);
HXDLIN(  64)							int x = (p5 - 1);
HXDLIN(  64)							int this1 = color1;
HXDLIN(  64)							int c = this1;
HXDLIN(  64)							bool _hx_tmp;
HXDLIN(  64)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)								_hx_tmp = pixelshape1->transparent;
            							}
            							else {
HXLINE(  64)								_hx_tmp = false;
            							}
HXDLIN(  64)							if (_hx_tmp) {
HXLINE(  64)								int location;
HXDLIN(  64)								if (pixelshape1->useVirtualPos) {
HXLINE(  64)									location = ::Std_obj::_hx_int(((((( (Float)(q5) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            								}
            								else {
HXLINE(  64)									location = ::Std_obj::_hx_int(( (Float)(((q5 * pixelshape1->width) + x)) ));
            								}
HXDLIN(  64)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)								int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)								int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)								int this3 = this2;
HXDLIN(  64)								int this4;
HXDLIN(  64)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  64)									this4 = this3;
            								}
HXDLIN(  64)								Float a1;
HXDLIN(  64)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)								if ((this5 == 0)) {
HXLINE(  64)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float r1;
HXDLIN(  64)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)								if ((this6 == 0)) {
HXLINE(  64)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float g1;
HXDLIN(  64)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)								if ((this7 == 0)) {
HXLINE(  64)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float b1;
HXDLIN(  64)								int this8 = (this4 & 255);
HXDLIN(  64)								if ((this8 == 0)) {
HXLINE(  64)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float a2;
HXDLIN(  64)								int this9 = ((color1 >> 24) & 255);
HXDLIN(  64)								if ((this9 == 0)) {
HXLINE(  64)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float r2;
HXDLIN(  64)								int this10 = ((color1 >> 16) & 255);
HXDLIN(  64)								if ((this10 == 0)) {
HXLINE(  64)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float g2;
HXDLIN(  64)								int this11 = ((color1 >> 8) & 255);
HXDLIN(  64)								if ((this11 == 0)) {
HXLINE(  64)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float b2;
HXDLIN(  64)								int this12 = (color1 & 255);
HXDLIN(  64)								if ((this12 == 0)) {
HXLINE(  64)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  64)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  64)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)								{
HXLINE(  64)									::haxe::io::ArrayBufferViewImpl this13 = pixelshape1->image;
HXDLIN(  64)									int value;
HXDLIN(  64)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)										value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  64)										value = blended;
            									}
HXDLIN(  64)									bool _hx_tmp;
HXDLIN(  64)									if ((location >= 0)) {
HXLINE(  64)										_hx_tmp = (location < (this13->byteLength >> 2));
            									}
            									else {
HXLINE(  64)										_hx_tmp = false;
            									}
HXDLIN(  64)									if (_hx_tmp) {
HXLINE(  64)										::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)										int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  64)								::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)								int index;
HXDLIN(  64)								if (pixelshape1->useVirtualPos) {
HXLINE(  64)									index = ::Std_obj::_hx_int(((((( (Float)(q5) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            								}
            								else {
HXLINE(  64)									index = ::Std_obj::_hx_int(( (Float)(((q5 * pixelshape1->width) + x)) ));
            								}
HXDLIN(  64)								int value;
HXDLIN(  64)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)									value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  64)									value = c;
            								}
HXDLIN(  64)								bool _hx_tmp;
HXDLIN(  64)								if ((index >= 0)) {
HXLINE(  64)									_hx_tmp = (index < (this1->byteLength >> 2));
            								}
            								else {
HXLINE(  64)									_hx_tmp = false;
            								}
HXDLIN(  64)								if (_hx_tmp) {
HXLINE(  64)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)									_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)									_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)									_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)									_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            								}
            							}
            						}
HXDLIN(  64)						if ((p5 > maxX5)) {
HXLINE( 247)							p5 = xx5;
HXLINE(  64)							q5 = (q5 + 1);
            						}
HXDLIN(  64)						if ((q5 > maxY5)) {
HXLINE(  64)							goto _hx_goto_47;
            						}
            					}
            					_hx_goto_47:;
            				}
HXDLIN(  64)				{
HXLINE(  64)					 ::Dynamic targetError7 = ((Float)1.05);
HXDLIN(  64)					if (::hx::IsNull( targetError7 )) {
HXLINE( 840)						targetError7 = ((Float)1.05);
            					}
HXLINE(  64)					Float rSmall7;
HXDLIN(  64)					if ((rightRadius1 > bottomRadius1)) {
HXLINE(  64)						rSmall7 = bottomRadius1;
            					}
            					else {
HXLINE(  64)						rSmall7 = rightRadius1;
            					}
HXDLIN(  64)					 ::Dynamic targetE7 = ( (Float)(targetError7) );
HXDLIN(  64)					if (::hx::IsNull( targetE7 )) {
HXLINE(  20)						targetE7 = ((Float)1.05);
            					}
HXLINE(  64)					int result7 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE7) ) / rSmall7)))));
HXDLIN(  64)					int noSides7;
HXDLIN(  64)					if ((result7 < 12)) {
HXLINE(  64)						noSides7 = 12;
            					}
            					else {
HXLINE(  64)						if ((result7 > 500)) {
HXLINE(  64)							noSides7 = 500;
            						}
            						else {
HXLINE(  64)							noSides7 = result7;
            						}
            					}
HXDLIN(  64)					int sides7 = (::Math_obj::ceil((( (Float)(noSides7) ) / ( (Float)(4) ))) * 4);
HXDLIN(  64)					Float theta7 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides7) ));
HXDLIN(  64)					Float omega7 = ( (Float)(0) );
HXDLIN(  64)					int quarter7 = ::Std_obj::_hx_int((( (Float)(sides7) ) / ( (Float)(4) )));
HXDLIN(  64)					Float lastX7 = ((Float)0.);
HXDLIN(  64)					Float lastY7 = ((Float)0.);
HXDLIN(  64)					{
HXLINE(  26)						lastX7 = (farX1 + (rightRadius1 * ::Math_obj::cos(((( (Float)(sides7) ) * theta7) + omega7))));
HXLINE(  27)						lastY7 = (lowerY1 + (bottomRadius1 * ::Math_obj::sin(((( (Float)(sides7) ) * theta7) + omega7))));
            					}
HXLINE(  64)					{
HXLINE(  64)						int _g14 = 0;
HXDLIN(  64)						int _g15 = (quarter7 + 1);
HXDLIN(  64)						while((_g14 < _g15)){
HXLINE(  64)							_g14 = (_g14 + 1);
HXDLIN(  64)							int i = (_g14 - 1);
HXDLIN(  64)							Float nextX = (farX1 + (rightRadius1 * ::Math_obj::cos((((( (Float)(i) ) * theta7) + ((Float)0.0001)) + omega7))));
HXDLIN(  64)							Float nextY = (lowerY1 + (bottomRadius1 * ::Math_obj::sin((((( (Float)(i) ) * theta7) + ((Float)0.0001)) + omega7))));
HXDLIN(  64)							{
HXLINE(  64)								bool hasHit = false;
HXDLIN(  64)								bool hasUndo = false;
HXDLIN(  64)								{
HXLINE(  64)									Float bx = lastX7;
HXDLIN(  64)									Float by = lastY7;
HXDLIN(  64)									Float cx = nextX;
HXDLIN(  64)									Float cy = nextY;
HXDLIN(  64)									bool adjustWinding = (((((farX1 * by) - (bx * lowerY1)) + ((bx * cy) - (cx * by))) + ((cx * lowerY1) - (farX1 * cy))) > 0);
HXDLIN(  64)									if (!(adjustWinding)) {
HXLINE(  64)										Float bx_ = bx;
HXDLIN(  64)										Float by_ = by;
HXLINE(  26)										bx = cx;
HXLINE(  27)										by = cy;
HXLINE(  28)										cx = bx_;
HXLINE(  29)										cy = by_;
            									}
HXLINE(  64)									{
HXLINE(  64)										Float s0 = ((lowerY1 * cx) - (farX1 * cy));
HXDLIN(  64)										Float sx = (cy - lowerY1);
HXDLIN(  64)										Float sy = (farX1 - cx);
HXDLIN(  64)										Float t0 = ((farX1 * by) - (lowerY1 * bx));
HXDLIN(  64)										Float tx = (lowerY1 - by);
HXDLIN(  64)										Float ty = (bx - farX1);
HXDLIN(  64)										Float A = ((((-(by) * cx) + (lowerY1 * (-(bx) + cx))) + (farX1 * (by - cy))) + (bx * cy));
HXDLIN(  64)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  64)										if ((farX1 > bx)) {
HXLINE(  64)											if ((farX1 > cx)) {
HXLINE(  64)												int min;
HXDLIN(  64)												if ((bx > cx)) {
HXLINE(  64)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  64)													min = ::Math_obj::floor(bx);
            												}
HXDLIN(  64)												int ii_min = min;
HXDLIN(  64)												int ii_max = ::Math_obj::ceil(farX1);
HXDLIN(  64)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)												xIter3 = this1;
            											}
            											else {
HXLINE(  64)												int ii_min = ::Math_obj::floor(bx);
HXDLIN(  64)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  64)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  64)											if ((bx > cx)) {
HXLINE(  64)												int min;
HXDLIN(  64)												if ((farX1 > cx)) {
HXLINE(  64)													min = ::Math_obj::floor(cx);
            												}
            												else {
HXLINE(  64)													min = ::Math_obj::ceil(farX1);
            												}
HXDLIN(  64)												int ii_min = min;
HXDLIN(  64)												int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  64)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)												xIter3 = this1;
            											}
            											else {
HXLINE(  64)												int ii_min = ::Math_obj::floor(farX1);
HXDLIN(  64)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  64)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)												xIter3 = this1;
            											}
            										}
HXDLIN(  64)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  64)										if ((lowerY1 > by)) {
HXLINE(  64)											if ((lowerY1 > cy)) {
HXLINE(  64)												int min;
HXDLIN(  64)												if ((by > cy)) {
HXLINE(  64)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  64)													min = ::Math_obj::floor(by);
            												}
HXDLIN(  64)												int ii_min = min;
HXDLIN(  64)												int ii_max = ::Math_obj::ceil(lowerY1);
HXDLIN(  64)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)												yIter3 = this1;
            											}
            											else {
HXLINE(  64)												int ii_min = ::Math_obj::floor(by);
HXDLIN(  64)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  64)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  64)											if ((by > cy)) {
HXLINE(  64)												int min;
HXDLIN(  64)												if ((lowerY1 > cy)) {
HXLINE(  64)													min = ::Math_obj::floor(cy);
            												}
            												else {
HXLINE(  64)													min = ::Math_obj::ceil(lowerY1);
            												}
HXDLIN(  64)												int ii_min = min;
HXDLIN(  64)												int ii_max = ::Math_obj::ceil(by);
HXDLIN(  64)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)												yIter3 = this1;
            											}
            											else {
HXLINE(  64)												int ii_min = ::Math_obj::floor(lowerY1);
HXDLIN(  64)												int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  64)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  64)												yIter3 = this1;
            											}
            										}
HXDLIN(  64)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  64)										if (hasUndo) {
HXLINE(  64)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  64)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  64)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  64)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  64)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  64)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  64)											undoImage = this3;
HXDLIN(  64)											{
HXLINE(  64)												int rectLeft = xIter3->start;
HXDLIN(  64)												int rectTop = yIter3->start;
HXDLIN(  64)												int rectRight = xIter3->max;
HXDLIN(  64)												bool forceClear = false;
HXDLIN(  64)												{
HXLINE(  64)													int _g = rectTop;
HXDLIN(  64)													int _g1 = yIter3->max;
HXDLIN(  64)													while((_g < _g1)){
HXLINE(  64)														_g = (_g + 1);
HXDLIN(  64)														int dy = (_g - 1);
HXDLIN(  64)														{
HXLINE(  64)															int _g1 = rectLeft;
HXDLIN(  64)															int _g2 = rectRight;
HXDLIN(  64)															while((_g1 < _g2)){
HXLINE(  64)																_g1 = (_g1 + 1);
HXDLIN(  64)																int dx = (_g1 - 1);
HXDLIN(  64)																::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																int index;
HXDLIN(  64)																if (pixelshape1->useVirtualPos) {
HXLINE(  64)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + dx) - pixelshape1->virtualX));
            																}
            																else {
HXLINE(  64)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelshape1->width) + dx)) ));
            																}
HXDLIN(  64)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																int col;
HXDLIN(  64)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  64)																	col = c;
            																}
HXDLIN(  64)																bool _hx_tmp;
HXDLIN(  64)																if (pixelshape1->useMask) {
HXLINE(  64)																	_hx_tmp = ::hx::IsNotNull( pixelshape1->mask );
            																}
            																else {
HXLINE(  64)																	_hx_tmp = false;
            																}
HXDLIN(  64)																if (_hx_tmp) {
HXLINE(  64)																	::pixelimage::ImageStruct this1 = pixelshape1->mask;
HXDLIN(  64)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  64)																	int index;
HXDLIN(  64)																	if (this1->useVirtualPos) {
HXLINE(  64)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  64)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  64)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  64)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  64)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																	int v;
HXDLIN(  64)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  64)																		v = c;
            																	}
HXDLIN(  64)																	int this3 = v;
HXDLIN(  64)																	int maskPixel = this3;
HXDLIN(  64)																	int this4 = col;
HXDLIN(  64)																	int this5 = this4;
HXDLIN(  64)																	if ((maskPixel == 0)) {
HXLINE(  64)																		int this1 = this5;
HXDLIN(  64)																		col = this1;
            																	}
            																	else {
HXLINE(  64)																		Float m0;
HXDLIN(  64)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  64)																		if ((this1 == 0)) {
HXLINE(  64)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float m1;
HXDLIN(  64)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  64)																		if ((this2 == 0)) {
HXLINE(  64)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float m2;
HXDLIN(  64)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  64)																		if ((this3 == 0)) {
HXLINE(  64)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float m3;
HXDLIN(  64)																		int this4 = (maskPixel & 255);
HXDLIN(  64)																		if ((this4 == 0)) {
HXLINE(  64)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  64)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  64)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  64)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  64)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  64)																if ((col != 0)) {
HXLINE(  64)																	int x = (dx - rectLeft);
HXDLIN(  64)																	int y = (dy - rectTop);
HXDLIN(  64)																	int this1 = col;
HXDLIN(  64)																	int c = this1;
HXDLIN(  64)																	bool _hx_tmp;
HXDLIN(  64)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)																		_hx_tmp = undoImage->transparent;
            																	}
            																	else {
HXLINE(  64)																		_hx_tmp = false;
            																	}
HXDLIN(  64)																	if (_hx_tmp) {
HXLINE(  64)																		int location;
HXDLIN(  64)																		if (undoImage->useVirtualPos) {
HXLINE(  64)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  64)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  64)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																		int this3 = this2;
HXDLIN(  64)																		int this4;
HXDLIN(  64)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  64)																			this4 = this3;
            																		}
HXDLIN(  64)																		Float a1;
HXDLIN(  64)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)																		if ((this5 == 0)) {
HXLINE(  64)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float r1;
HXDLIN(  64)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)																		if ((this6 == 0)) {
HXLINE(  64)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float g1;
HXDLIN(  64)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)																		if ((this7 == 0)) {
HXLINE(  64)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float b1;
HXDLIN(  64)																		int this8 = (this4 & 255);
HXDLIN(  64)																		if ((this8 == 0)) {
HXLINE(  64)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float a2;
HXDLIN(  64)																		int this9 = ((col >> 24) & 255);
HXDLIN(  64)																		if ((this9 == 0)) {
HXLINE(  64)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float r2;
HXDLIN(  64)																		int this10 = ((col >> 16) & 255);
HXDLIN(  64)																		if ((this10 == 0)) {
HXLINE(  64)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float g2;
HXDLIN(  64)																		int this11 = ((col >> 8) & 255);
HXDLIN(  64)																		if ((this11 == 0)) {
HXLINE(  64)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float b2;
HXDLIN(  64)																		int this12 = (col & 255);
HXDLIN(  64)																		if ((this12 == 0)) {
HXLINE(  64)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)																		{
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  64)																			int value;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				value = blended;
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((location >= 0)) {
HXLINE(  64)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  64)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																		int index;
HXDLIN(  64)																		if (undoImage->useVirtualPos) {
HXLINE(  64)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  64)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  64)																		int value;
HXDLIN(  64)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  64)																			value = c;
            																		}
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((index >= 0)) {
HXLINE(  64)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  64)																	if (forceClear) {
HXLINE(  64)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  64)																		int x = (dx - rectLeft);
HXDLIN(  64)																		int y = (dy - rectTop);
HXDLIN(  64)																		int index;
HXDLIN(  64)																		if (undoImage->useVirtualPos) {
HXLINE(  64)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  64)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((index >= 0)) {
HXLINE(  64)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  64)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  64)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  64)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  64)										bool found = false;
HXDLIN(  64)										Float s = ((Float)0.);
HXDLIN(  64)										Float t = ((Float)0.);
HXDLIN(  64)										Float sxx = ((Float)0.);
HXDLIN(  64)										Float txx = ((Float)0.);
HXDLIN(  64)										{
HXLINE(  64)											int _g_min = xIter3->start;
HXDLIN(  64)											int _g_max = xIter3->max;
HXDLIN(  64)											while((_g_min < _g_max)){
HXLINE(  64)												_g_min = (_g_min + 1);
HXDLIN(  64)												int x = (_g_min - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found = false;
HXLINE(  64)												{
HXLINE(  64)													int _g_min1 = yIter3->start;
HXDLIN(  64)													int _g_max = yIter3->max;
HXDLIN(  64)													while((_g_min1 < _g_max)){
HXLINE(  64)														_g_min1 = (_g_min1 + 1);
HXDLIN(  64)														int y = (_g_min1 - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  64)														bool _hx_tmp;
HXDLIN(  64)														if (!((s <= 0))) {
HXLINE(  64)															_hx_tmp = (t <= 0);
            														}
            														else {
HXLINE(  64)															_hx_tmp = true;
            														}
HXDLIN(  64)														if (_hx_tmp) {
HXLINE(  64)															if (found) {
HXLINE(  64)																goto _hx_goto_52;
            															}
            														}
            														else {
HXLINE(  64)															if (((s + t) < A)) {
HXLINE(  64)																{
HXLINE(  64)																	int this1 = color1;
HXDLIN(  64)																	int c = this1;
HXDLIN(  64)																	bool _hx_tmp;
HXDLIN(  64)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  64)																		_hx_tmp = pixelshape1->transparent;
            																	}
            																	else {
HXLINE(  64)																		_hx_tmp = false;
            																	}
HXDLIN(  64)																	if (_hx_tmp) {
HXLINE(  64)																		int location;
HXDLIN(  64)																		if (pixelshape1->useVirtualPos) {
HXLINE(  64)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            																		}
            																		else {
HXLINE(  64)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelshape1->width) + x)) ));
            																		}
HXDLIN(  64)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  64)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  64)																		int this3 = this2;
HXDLIN(  64)																		int this4;
HXDLIN(  64)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  64)																			this4 = this3;
            																		}
HXDLIN(  64)																		Float a1;
HXDLIN(  64)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  64)																		if ((this5 == 0)) {
HXLINE(  64)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float r1;
HXDLIN(  64)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  64)																		if ((this6 == 0)) {
HXLINE(  64)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float g1;
HXDLIN(  64)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  64)																		if ((this7 == 0)) {
HXLINE(  64)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float b1;
HXDLIN(  64)																		int this8 = (this4 & 255);
HXDLIN(  64)																		if ((this8 == 0)) {
HXLINE(  64)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float a2;
HXDLIN(  64)																		int this9 = ((color1 >> 24) & 255);
HXDLIN(  64)																		if ((this9 == 0)) {
HXLINE(  64)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float r2;
HXDLIN(  64)																		int this10 = ((color1 >> 16) & 255);
HXDLIN(  64)																		if ((this10 == 0)) {
HXLINE(  64)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float g2;
HXDLIN(  64)																		int this11 = ((color1 >> 8) & 255);
HXDLIN(  64)																		if ((this11 == 0)) {
HXLINE(  64)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float b2;
HXDLIN(  64)																		int this12 = (color1 & 255);
HXDLIN(  64)																		if ((this12 == 0)) {
HXLINE(  64)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  64)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  64)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  64)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  64)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  64)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  64)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  64)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  64)																		{
HXLINE(  64)																			::haxe::io::ArrayBufferViewImpl this13 = pixelshape1->image;
HXDLIN(  64)																			int value;
HXDLIN(  64)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  64)																				value = blended;
            																			}
HXDLIN(  64)																			bool _hx_tmp;
HXDLIN(  64)																			if ((location >= 0)) {
HXLINE(  64)																				_hx_tmp = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  64)																				_hx_tmp = false;
            																			}
HXDLIN(  64)																			if (_hx_tmp) {
HXLINE(  64)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  64)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  64)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  64)																		::haxe::io::ArrayBufferViewImpl this1 = pixelshape1->image;
HXDLIN(  64)																		int index;
HXDLIN(  64)																		if (pixelshape1->useVirtualPos) {
HXLINE(  64)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelshape1->virtualY) * ( (Float)(pixelshape1->width) )) + x) - pixelshape1->virtualX));
            																		}
            																		else {
HXLINE(  64)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelshape1->width) + x)) ));
            																		}
HXDLIN(  64)																		int value;
HXDLIN(  64)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  64)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  64)																			value = c;
            																		}
HXDLIN(  64)																		bool _hx_tmp;
HXDLIN(  64)																		if ((index >= 0)) {
HXLINE(  64)																			_hx_tmp = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  64)																			_hx_tmp = false;
            																		}
HXDLIN(  64)																		if (_hx_tmp) {
HXLINE(  64)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  64)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  64)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  64)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  64)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  64)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found = true;
            															}
            															else {
HXLINE(  64)																if (found) {
HXLINE(  64)																	goto _hx_goto_52;
            																}
            															}
            														}
            													}
            													_hx_goto_52:;
            												}
            											}
            										}
HXDLIN(  64)										if ((hasHit == true)) {
HXLINE(  64)											::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,farX1,lowerY1,bx,by,cx,cy,true);
HXDLIN(  64)											if (hasUndo) {
HXLINE(  64)												v->undoImage = undoImage;
HXDLIN(  64)												v->undoX = xIter3->start;
HXDLIN(  64)												v->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX7 = nextX;
HXLINE(  47)							lastY7 = nextY;
            						}
            					}
            				}
            			}
HXLINE(  65)			{
HXLINE(  65)				int x5 = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  65)				int y3 = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  65)				bool forceClear = false;
HXDLIN(  65)				{
HXLINE(  65)					int _g16 = 0;
HXDLIN(  65)					int _g17 = temp->height;
HXDLIN(  65)					while((_g16 < _g17)){
HXLINE(  65)						_g16 = (_g16 + 1);
HXDLIN(  65)						int dy = (_g16 - 1);
HXDLIN(  65)						{
HXLINE(  65)							int _g = 0;
HXDLIN(  65)							int _g1 = temp->width;
HXDLIN(  65)							while((_g < _g1)){
HXLINE(  65)								_g = (_g + 1);
HXDLIN(  65)								int dx = (_g - 1);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  65)								int index;
HXDLIN(  65)								if (temp->useVirtualPos) {
HXLINE(  65)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            								}
            								else {
HXLINE(  65)									index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            								}
HXDLIN(  65)								::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)								int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)								int col;
HXDLIN(  65)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  65)									col = c;
            								}
HXDLIN(  65)								bool _hx_tmp;
HXDLIN(  65)								if (temp->useMask) {
HXLINE(  65)									_hx_tmp = ::hx::IsNotNull( temp->mask );
            								}
            								else {
HXLINE(  65)									_hx_tmp = false;
            								}
HXDLIN(  65)								if (_hx_tmp) {
HXLINE(  65)									::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  65)									::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  65)									int index;
HXDLIN(  65)									if (this1->useVirtualPos) {
HXLINE(  65)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            									}
            									else {
HXLINE(  65)										index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            									}
HXDLIN(  65)									::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  65)									int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  65)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)									int v;
HXDLIN(  65)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)										v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  65)										v = c;
            									}
HXDLIN(  65)									int this3 = v;
HXDLIN(  65)									int maskPixel = this3;
HXDLIN(  65)									int this4 = col;
HXDLIN(  65)									int this5 = this4;
HXDLIN(  65)									if ((maskPixel == 0)) {
HXLINE(  65)										int this1 = this5;
HXDLIN(  65)										col = this1;
            									}
            									else {
HXLINE(  65)										Float m0;
HXDLIN(  65)										int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  65)										if ((this1 == 0)) {
HXLINE(  65)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float m1;
HXDLIN(  65)										int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  65)										if ((this2 == 0)) {
HXLINE(  65)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float m2;
HXDLIN(  65)										int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  65)										if ((this3 == 0)) {
HXLINE(  65)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float m3;
HXDLIN(  65)										int this4 = (maskPixel & 255);
HXDLIN(  65)										if ((this4 == 0)) {
HXLINE(  65)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  65)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  65)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  65)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  65)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  65)								if ((col != 0)) {
HXLINE(  65)									int x = (x5 + dx);
HXDLIN(  65)									int y = (y3 + dy);
HXDLIN(  65)									int this1 = col;
HXDLIN(  65)									int c = this1;
HXDLIN(  65)									bool _hx_tmp;
HXDLIN(  65)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)										_hx_tmp = pixelShape->transparent;
            									}
            									else {
HXLINE(  65)										_hx_tmp = false;
            									}
HXDLIN(  65)									if (_hx_tmp) {
HXLINE(  65)										int location;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)										int this3 = this2;
HXDLIN(  65)										int this4;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  65)											this4 = this3;
            										}
HXDLIN(  65)										Float a1;
HXDLIN(  65)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)										if ((this5 == 0)) {
HXLINE(  65)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r1;
HXDLIN(  65)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)										if ((this6 == 0)) {
HXLINE(  65)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g1;
HXDLIN(  65)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)										if ((this7 == 0)) {
HXLINE(  65)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b1;
HXDLIN(  65)										int this8 = (this4 & 255);
HXDLIN(  65)										if ((this8 == 0)) {
HXLINE(  65)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a2;
HXDLIN(  65)										int this9 = ((col >> 24) & 255);
HXDLIN(  65)										if ((this9 == 0)) {
HXLINE(  65)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r2;
HXDLIN(  65)										int this10 = ((col >> 16) & 255);
HXDLIN(  65)										if ((this10 == 0)) {
HXLINE(  65)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g2;
HXDLIN(  65)										int this11 = ((col >> 8) & 255);
HXDLIN(  65)										if ((this11 == 0)) {
HXLINE(  65)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b2;
HXDLIN(  65)										int this12 = (col & 255);
HXDLIN(  65)										if ((this12 == 0)) {
HXLINE(  65)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)										{
HXLINE(  65)											::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  65)											int value;
HXDLIN(  65)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  65)												value = blended;
            											}
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											if ((location >= 0)) {
HXLINE(  65)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										int index;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										int value;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  65)											value = c;
            										}
HXDLIN(  65)										bool _hx_tmp;
HXDLIN(  65)										if ((index >= 0)) {
HXLINE(  65)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  65)											_hx_tmp = false;
            										}
HXDLIN(  65)										if (_hx_tmp) {
HXLINE(  65)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  65)									if (forceClear) {
HXLINE(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										int x = (x5 + dx);
HXDLIN(  65)										int y = (y3 + dy);
HXDLIN(  65)										int index;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										bool _hx_tmp;
HXDLIN(  65)										if ((index >= 0)) {
HXLINE(  65)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  65)											_hx_tmp = false;
            										}
HXDLIN(  65)										if (_hx_tmp) {
HXLINE(  65)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  65)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  65)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  65)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXLINE(  66)			temp = null();
            		}
HXLINE(  68)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< RectangleShape_obj > RectangleShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< bool >  __o_rounded) {
	::hx::ObjectPtr< RectangleShape_obj > __this = new RectangleShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_fill,__o_left,__o_top,__o_width,__o_height,__o_rounded);
	return __this;
}

::hx::ObjectPtr< RectangleShape_obj > RectangleShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< int >  __o_fill,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< bool >  __o_rounded) {
	RectangleShape_obj *__this = (RectangleShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(RectangleShape_obj), true, "pixelimage.triangleGML.shape.RectangleShape"));
	*(void **)__this = RectangleShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_fill,__o_left,__o_top,__o_width,__o_height,__o_rounded);
	return __this;
}

RectangleShape_obj::RectangleShape_obj()
{
}

::hx::Val RectangleShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { return ::hx::Val( top ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { return ::hx::Val( left ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"rounded") ) { return ::hx::Val( rounded ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val RectangleShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { top=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { left=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"rounded") ) { rounded=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void RectangleShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("left",07,08,b0,47));
	outFields->push(HX_("top",95,66,58,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("rounded",2d,80,0f,8d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo RectangleShape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(RectangleShape_obj,left),HX_("left",07,08,b0,47)},
	{::hx::fsFloat,(int)offsetof(RectangleShape_obj,top),HX_("top",95,66,58,00)},
	{::hx::fsFloat,(int)offsetof(RectangleShape_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsFloat,(int)offsetof(RectangleShape_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsBool,(int)offsetof(RectangleShape_obj,rounded),HX_("rounded",2d,80,0f,8d)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *RectangleShape_obj_sStaticStorageInfo = 0;
#endif

static ::String RectangleShape_obj_sMemberFields[] = {
	HX_("left",07,08,b0,47),
	HX_("top",95,66,58,00),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("rounded",2d,80,0f,8d),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class RectangleShape_obj::__mClass;

void RectangleShape_obj::__register()
{
	RectangleShape_obj _hx_dummy;
	RectangleShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.shape.RectangleShape",88,2b,1f,7a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(RectangleShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< RectangleShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RectangleShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RectangleShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace shape
