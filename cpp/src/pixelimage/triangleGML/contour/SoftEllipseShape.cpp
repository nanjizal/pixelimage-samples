// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_contour_SoftEllipseShape
#include <pixelimage/triangleGML/contour/SoftEllipseShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c2121910712d245a_21_new,"pixelimage.triangleGML.contour.SoftEllipseShape","new",0x3f79215c,"pixelimage.triangleGML.contour.SoftEllipseShape.new","pixelimage/triangleGML/contour/SoftEllipseShape.hx",21,0x41220bf1)
HX_LOCAL_STACK_FRAME(_hx_pos_c2121910712d245a_29_setParameter,"pixelimage.triangleGML.contour.SoftEllipseShape","setParameter",0x2ffea52b,"pixelimage.triangleGML.contour.SoftEllipseShape.setParameter","pixelimage/triangleGML/contour/SoftEllipseShape.hx",29,0x41220bf1)
HX_LOCAL_STACK_FRAME(_hx_pos_c2121910712d245a_44_render,"pixelimage.triangleGML.contour.SoftEllipseShape","render",0x92c7dfda,"pixelimage.triangleGML.contour.SoftEllipseShape.render","pixelimage/triangleGML/contour/SoftEllipseShape.hx",44,0x41220bf1)
namespace pixelimage{
namespace triangleGML{
namespace contour{

void SoftEllipseShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_softC){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(0);
            		Float left = __o_left.Default(((Float)0.));
            		Float top = __o_top.Default(((Float)0.));
            		Float width = __o_width.Default(((Float)1.));
            		Float height = __o_height.Default(((Float)1.));
            		Float softC = __o_softC.Default(((Float)10.));
            	HX_STACKFRAME(&_hx_pos_c2121910712d245a_21_new)
HXLINE(  22)		super::__construct(opacity,visibility,strokeColor,((Float)0.),null());
HXLINE(  23)		this->left = left;
HXLINE(  24)		this->top = top;
HXLINE(  25)		this->width = width;
HXLINE(  26)		this->height = height;
            	}

Dynamic SoftEllipseShape_obj::__CreateEmpty() { return new SoftEllipseShape_obj; }

void *SoftEllipseShape_obj::_hx_vtable = 0;

Dynamic SoftEllipseShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< SoftEllipseShape_obj > _hx_result = new SoftEllipseShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7]);
	return _hx_result;
}

bool SoftEllipseShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x31079902;
	}
}

void SoftEllipseShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_c2121910712d245a_29_setParameter)
HXDLIN(  29)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("height",e7,07,4c,02)) ){
HXLINE(  37)			this->height = ::Std_obj::parseFloat(value);
HXDLIN(  37)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("left",07,08,b0,47)) ){
HXLINE(  31)			this->left = ::Std_obj::parseFloat(value);
HXDLIN(  31)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("softC",19,30,c1,80)) ){
HXLINE(  39)			this->softC = ::Std_obj::parseFloat(value);
HXDLIN(  39)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("top",95,66,58,00)) ){
HXLINE(  33)			this->top = ::Std_obj::parseFloat(value);
HXDLIN(  33)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("width",06,b6,62,ca)) ){
HXLINE(  35)			this->width = ::Std_obj::parseFloat(value);
HXDLIN(  35)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  41)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct SoftEllipseShape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_c2121910712d245a_44_render)
HXLINE(  45)		int w = ::Math_obj::ceil(this->width);
HXDLIN(  45)		int h = ::Math_obj::ceil(this->height);
HXDLIN(  45)		int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  45)		::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  45)		::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  45)		::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  45)		::pixelimage::ImageStruct this4 = this3;
HXDLIN(  45)		::pixelimage::ImageStruct temp = this4;
HXLINE(  46)		temp->transparent = false;
HXLINE(  47)		Float rW = (this->width / ( (Float)(2) ));
HXLINE(  48)		Float rH = (this->height / ( (Float)(2) ));
HXLINE(  49)		Float cx = rW;
HXLINE(  50)		Float cy = rH;
HXLINE(  51)		int phi = 0;
HXLINE(  52)		{
HXLINE(  52)			int color = this->strokeColor;
HXDLIN(  52)			Float softC = this->softC;
HXDLIN(  52)			Float rSmall;
HXDLIN(  52)			if ((rW > rH)) {
HXLINE(  52)				rSmall = rH;
            			}
            			else {
HXLINE(  52)				rSmall = rW;
            			}
HXDLIN(  52)			 ::Dynamic targetE = ((Float)1.05);
HXDLIN(  52)			if (::hx::IsNull( targetE )) {
HXLINE( 701)				targetE = ((Float)1.05);
            			}
HXLINE(  52)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  52)			int noSides;
HXDLIN(  52)			if ((result < 12)) {
HXLINE(  52)				noSides = 12;
            			}
            			else {
HXLINE(  52)				if ((result > 500)) {
HXLINE(  52)					noSides = 500;
            				}
            				else {
HXLINE(  52)					noSides = result;
            				}
            			}
HXDLIN(  52)			{
HXLINE(  52)				 ::Dynamic phi1 = phi;
HXDLIN(  52)				 ::Dynamic sides = noSides;
HXDLIN(  52)				if (::hx::IsNull( sides )) {
HXLINE( 703)					sides = 36;
            				}
HXLINE(  52)				if (::hx::IsNull( phi1 )) {
HXLINE( 703)					phi1 = ((Float)0.);
            				}
HXLINE(  52)				{
HXLINE(  52)					 ::Dynamic phi2 = phi1;
HXDLIN(  52)					 ::Dynamic sides1 = sides;
HXDLIN(  52)					if (::hx::IsNull( sides1 )) {
HXLINE( 872)						sides1 = 36;
            					}
HXLINE(  52)					if (::hx::IsNull( phi2 )) {
HXLINE( 872)						phi2 = ((Float)0.);
            					}
HXLINE(  52)					Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  52)					Float omega;
HXDLIN(  52)					omega = ((Float)0.);
HXDLIN(  52)					Float lastX = ((Float)0.);
HXDLIN(  52)					Float lastY = ((Float)0.);
HXDLIN(  52)					if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  95)						lastX = ((((rW * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((rH * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  96)						lastY = ((((rW * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((rH * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            					}
            					else {
HXLINE(  98)						lastX = (cx + (rW * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  99)						lastY = (cy + (rH * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            					}
HXLINE(  52)					if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  52)						Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN(  52)						Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN(  52)						{
HXLINE(  52)							int _g = 0;
HXDLIN(  52)							int _g1 = (sides1 + 1);
HXDLIN(  52)							while((_g < _g1)){
HXLINE(  52)								_g = (_g + 1);
HXDLIN(  52)								int i = (_g - 1);
HXDLIN(  52)								Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  52)								Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  52)								Float nextX = ((((rW * ctheta) * cphi) - ((rH * stheta) * sphi)) + cx);
HXDLIN(  52)								Float nextY = ((((rW * ctheta) * sphi) + ((rH * stheta) * cphi)) + cy);
HXDLIN(  52)								{
HXLINE(  52)									bool hasHit = false;
HXDLIN(  52)									bool hasUndo = false;
HXDLIN(  52)									int aA = ((color >> 24) & 255);
HXDLIN(  52)									int rA = ((color >> 16) & 255);
HXDLIN(  52)									int gA = ((color >> 8) & 255);
HXDLIN(  52)									int bA = (color & 255);
HXDLIN(  52)									Float bcx = (lastX - nextX);
HXDLIN(  52)									Float bcy = (lastY - nextY);
HXDLIN(  52)									Float acx = (cx - nextX);
HXDLIN(  52)									Float acy = (cy - nextY);
HXDLIN(  52)									Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  52)									Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  52)									Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  52)									Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  52)									::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  52)									if ((cx > lastX)) {
HXLINE(  52)										if ((cx > nextX)) {
HXLINE(  52)											int min;
HXDLIN(  52)											if ((lastX > nextX)) {
HXLINE(  52)												min = ::Math_obj::floor(nextX);
            											}
            											else {
HXLINE(  52)												min = ::Math_obj::floor(lastX);
            											}
HXDLIN(  52)											int ii_min = min;
HXDLIN(  52)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  52)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)											xIter3 = this1;
            										}
            										else {
HXLINE(  52)											int ii_min = ::Math_obj::floor(lastX);
HXDLIN(  52)											int ii_max = ::Math_obj::ceil(nextX);
HXDLIN(  52)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)											xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  52)										if ((lastX > nextX)) {
HXLINE(  52)											int min;
HXDLIN(  52)											if ((cx > nextX)) {
HXLINE(  52)												min = ::Math_obj::floor(nextX);
            											}
            											else {
HXLINE(  52)												min = ::Math_obj::ceil(cx);
            											}
HXDLIN(  52)											int ii_min = min;
HXDLIN(  52)											int ii_max = ::Math_obj::ceil(lastX);
HXDLIN(  52)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)											xIter3 = this1;
            										}
            										else {
HXLINE(  52)											int ii_min = ::Math_obj::floor(cx);
HXDLIN(  52)											int ii_max = ::Math_obj::ceil(nextX);
HXDLIN(  52)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)											xIter3 = this1;
            										}
            									}
HXDLIN(  52)									::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  52)									if ((cy > lastY)) {
HXLINE(  52)										if ((cy > nextY)) {
HXLINE(  52)											int min;
HXDLIN(  52)											if ((lastY > nextY)) {
HXLINE(  52)												min = ::Math_obj::floor(nextY);
            											}
            											else {
HXLINE(  52)												min = ::Math_obj::floor(lastY);
            											}
HXDLIN(  52)											int ii_min = min;
HXDLIN(  52)											int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  52)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)											yIter3 = this1;
            										}
            										else {
HXLINE(  52)											int ii_min = ::Math_obj::floor(lastY);
HXDLIN(  52)											int ii_max = ::Math_obj::ceil(nextY);
HXDLIN(  52)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)											yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  52)										if ((lastY > nextY)) {
HXLINE(  52)											int min;
HXDLIN(  52)											if ((cy > nextY)) {
HXLINE(  52)												min = ::Math_obj::floor(nextY);
            											}
            											else {
HXLINE(  52)												min = ::Math_obj::ceil(cy);
            											}
HXDLIN(  52)											int ii_min = min;
HXDLIN(  52)											int ii_max = ::Math_obj::ceil(lastY);
HXDLIN(  52)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)											yIter3 = this1;
            										}
            										else {
HXLINE(  52)											int ii_min = ::Math_obj::floor(cy);
HXDLIN(  52)											int ii_max = ::Math_obj::ceil(nextY);
HXDLIN(  52)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)											yIter3 = this1;
            										}
            									}
HXDLIN(  52)									::pixelimage::ImageStruct undoImage = null();
HXDLIN(  52)									if (hasUndo) {
HXLINE(  52)										int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  52)										int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  52)										int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  52)										::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  52)										::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  52)										::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  52)										undoImage = this3;
HXDLIN(  52)										{
HXLINE(  52)											int rectLeft = xIter3->start;
HXDLIN(  52)											int rectTop = yIter3->start;
HXDLIN(  52)											int rectRight = xIter3->max;
HXDLIN(  52)											bool forceClear = false;
HXDLIN(  52)											{
HXLINE(  52)												int _g = rectTop;
HXDLIN(  52)												int _g1 = yIter3->max;
HXDLIN(  52)												while((_g < _g1)){
HXLINE(  52)													_g = (_g + 1);
HXDLIN(  52)													int dy = (_g - 1);
HXDLIN(  52)													{
HXLINE(  52)														int _g1 = rectLeft;
HXDLIN(  52)														int _g2 = rectRight;
HXDLIN(  52)														while((_g1 < _g2)){
HXLINE(  52)															_g1 = (_g1 + 1);
HXDLIN(  52)															int dx = (_g1 - 1);
HXDLIN(  52)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  52)															int index;
HXDLIN(  52)															if (temp->useVirtualPos) {
HXLINE(  52)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            															}
            															else {
HXLINE(  52)																index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            															}
HXDLIN(  52)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  52)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  52)															int col;
HXDLIN(  52)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  52)																col = c;
            															}
HXDLIN(  52)															bool _hx_tmp;
HXDLIN(  52)															if (temp->useMask) {
HXLINE(  52)																_hx_tmp = ::hx::IsNotNull( temp->mask );
            															}
            															else {
HXLINE(  52)																_hx_tmp = false;
            															}
HXDLIN(  52)															if (_hx_tmp) {
HXLINE(  52)																::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  52)																::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  52)																int index;
HXDLIN(  52)																if (this1->useVirtualPos) {
HXLINE(  52)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																}
            																else {
HXLINE(  52)																	index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																}
HXDLIN(  52)																::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  52)																int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  52)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  52)																int v;
HXDLIN(  52)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																	v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  52)																	v = c;
            																}
HXDLIN(  52)																int this3 = v;
HXDLIN(  52)																int maskPixel = this3;
HXDLIN(  52)																int this4 = col;
HXDLIN(  52)																int this5 = this4;
HXDLIN(  52)																if ((maskPixel == 0)) {
HXLINE(  52)																	int this1 = this5;
HXDLIN(  52)																	col = this1;
            																}
            																else {
HXLINE(  52)																	Float m0;
HXDLIN(  52)																	int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  52)																	if ((this1 == 0)) {
HXLINE(  52)																		m0 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float m1;
HXDLIN(  52)																	int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  52)																	if ((this2 == 0)) {
HXLINE(  52)																		m1 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float m2;
HXDLIN(  52)																	int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  52)																	if ((this3 == 0)) {
HXLINE(  52)																		m2 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float m3;
HXDLIN(  52)																	int this4 = (maskPixel & 255);
HXDLIN(  52)																	if ((this4 == 0)) {
HXLINE(  52)																		m3 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  52)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  52)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  52)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  52)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN(  52)															if ((col != 0)) {
HXLINE(  52)																int x = (dx - rectLeft);
HXDLIN(  52)																int y = (dy - rectTop);
HXDLIN(  52)																int this1 = col;
HXDLIN(  52)																int c = this1;
HXDLIN(  52)																bool _hx_tmp;
HXDLIN(  52)																if ((((c >> 24) & 255) < 254)) {
HXLINE(  52)																	_hx_tmp = undoImage->transparent;
            																}
            																else {
HXLINE(  52)																	_hx_tmp = false;
            																}
HXDLIN(  52)																if (_hx_tmp) {
HXLINE(  52)																	int location;
HXDLIN(  52)																	if (undoImage->useVirtualPos) {
HXLINE(  52)																		location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																	}
            																	else {
HXLINE(  52)																		location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																	}
HXDLIN(  52)																	::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  52)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																	int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  52)																	int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  52)																	int this3 = this2;
HXDLIN(  52)																	int this4;
HXDLIN(  52)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																		this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																	}
            																	else {
HXLINE(  52)																		this4 = this3;
            																	}
HXDLIN(  52)																	Float a1;
HXDLIN(  52)																	int this5 = ((this4 >> 24) & 255);
HXDLIN(  52)																	if ((this5 == 0)) {
HXLINE(  52)																		a1 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float r1;
HXDLIN(  52)																	int this6 = ((this4 >> 16) & 255);
HXDLIN(  52)																	if ((this6 == 0)) {
HXLINE(  52)																		r1 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float g1;
HXDLIN(  52)																	int this7 = ((this4 >> 8) & 255);
HXDLIN(  52)																	if ((this7 == 0)) {
HXLINE(  52)																		g1 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float b1;
HXDLIN(  52)																	int this8 = (this4 & 255);
HXDLIN(  52)																	if ((this8 == 0)) {
HXLINE(  52)																		b1 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float a2;
HXDLIN(  52)																	int this9 = ((col >> 24) & 255);
HXDLIN(  52)																	if ((this9 == 0)) {
HXLINE(  52)																		a2 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float r2;
HXDLIN(  52)																	int this10 = ((col >> 16) & 255);
HXDLIN(  52)																	if ((this10 == 0)) {
HXLINE(  52)																		r2 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float g2;
HXDLIN(  52)																	int this11 = ((col >> 8) & 255);
HXDLIN(  52)																	if ((this11 == 0)) {
HXLINE(  52)																		g2 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float b2;
HXDLIN(  52)																	int this12 = (col & 255);
HXDLIN(  52)																	if ((this12 == 0)) {
HXLINE(  52)																		b2 = ((Float)0.);
            																	}
            																	else {
HXLINE(  52)																		b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN(  52)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  52)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  52)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  52)																	int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  52)																	int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  52)																	int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  52)																	{
HXLINE(  52)																		::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  52)																		int value;
HXDLIN(  52)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																			value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXLINE(  52)																			value = blended;
            																		}
HXDLIN(  52)																		bool _hx_tmp;
HXDLIN(  52)																		if ((location >= 0)) {
HXLINE(  52)																			_hx_tmp = (location < (this13->byteLength >> 2));
            																		}
            																		else {
HXLINE(  52)																			_hx_tmp = false;
            																		}
HXDLIN(  52)																		if (_hx_tmp) {
HXLINE(  52)																			::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  52)																			int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  52)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  52)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  52)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  52)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  52)																	::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  52)																	int index;
HXDLIN(  52)																	if (undoImage->useVirtualPos) {
HXLINE(  52)																		index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																	}
            																	else {
HXLINE(  52)																		index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																	}
HXDLIN(  52)																	int value;
HXDLIN(  52)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																		value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  52)																		value = c;
            																	}
HXDLIN(  52)																	bool _hx_tmp;
HXDLIN(  52)																	if ((index >= 0)) {
HXLINE(  52)																		_hx_tmp = (index < (this1->byteLength >> 2));
            																	}
            																	else {
HXLINE(  52)																		_hx_tmp = false;
            																	}
HXDLIN(  52)																	if (_hx_tmp) {
HXLINE(  52)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																		int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  52)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  52)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  52)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  52)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  52)																if (forceClear) {
HXLINE(  52)																	::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  52)																	int x = (dx - rectLeft);
HXDLIN(  52)																	int y = (dy - rectTop);
HXDLIN(  52)																	int index;
HXDLIN(  52)																	if (undoImage->useVirtualPos) {
HXLINE(  52)																		index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																	}
            																	else {
HXLINE(  52)																		index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																	}
HXDLIN(  52)																	bool _hx_tmp;
HXDLIN(  52)																	if ((index >= 0)) {
HXLINE(  52)																		_hx_tmp = (index < (this1->byteLength >> 2));
            																	}
            																	else {
HXLINE(  52)																		_hx_tmp = false;
            																	}
HXDLIN(  52)																	if (_hx_tmp) {
HXLINE(  52)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																		int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  52)																		_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  52)																		_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  52)																		_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  52)																		_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  52)									bool found = false;
HXDLIN(  52)									{
HXLINE(  52)										int _g_min = xIter3->start;
HXDLIN(  52)										int _g_max = xIter3->max;
HXDLIN(  52)										while((_g_min < _g_max)){
HXLINE(  52)											_g_min = (_g_min + 1);
HXDLIN(  52)											int px = (_g_min - 1);
HXDLIN(  52)											Float pcx = (( (Float)(px) ) - nextX);
HXLINE( 620)											found = false;
HXLINE(  52)											{
HXLINE(  52)												int _g_min1 = yIter3->start;
HXDLIN(  52)												int _g_max = yIter3->max;
HXDLIN(  52)												while((_g_min1 < _g_max)){
HXLINE(  52)													_g_min1 = (_g_min1 + 1);
HXDLIN(  52)													int py = (_g_min1 - 1);
HXDLIN(  52)													Float pcy = (( (Float)(py) ) - nextY);
HXDLIN(  52)													Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  52)													Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  52)													Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  52)													Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  52)													Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  52)													bool _hx_tmp;
HXDLIN(  52)													bool _hx_tmp1;
HXDLIN(  52)													if ((ratioA >= 0)) {
HXLINE(  52)														_hx_tmp1 = (ratioB >= 0);
            													}
            													else {
HXLINE(  52)														_hx_tmp1 = false;
            													}
HXDLIN(  52)													if (_hx_tmp1) {
HXLINE(  52)														_hx_tmp = (ratioC >= 0);
            													}
            													else {
HXLINE(  52)														_hx_tmp = false;
            													}
HXDLIN(  52)													if (_hx_tmp) {
HXLINE(  52)														int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (softC * ratioB)));
HXDLIN(  52)														if ((i > 255)) {
HXLINE(  24)															i = 255;
            														}
HXLINE(  52)														if ((i < 0)) {
HXLINE(  25)															i = 0;
            														}
HXLINE(  52)														int this1 = i;
HXDLIN(  52)														int a = this1;
HXDLIN(  52)														int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  52)														if ((i1 > 255)) {
HXLINE(  24)															i1 = 255;
            														}
HXLINE(  52)														if ((i1 < 0)) {
HXLINE(  25)															i1 = 0;
            														}
HXLINE(  52)														int this2 = i1;
HXDLIN(  52)														int r = this2;
HXDLIN(  52)														int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  52)														if ((i2 > 255)) {
HXLINE(  24)															i2 = 255;
            														}
HXLINE(  52)														if ((i2 < 0)) {
HXLINE(  25)															i2 = 0;
            														}
HXLINE(  52)														int this3 = i2;
HXDLIN(  52)														int g = this3;
HXDLIN(  52)														int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  52)														if ((i3 > 255)) {
HXLINE(  24)															i3 = 255;
            														}
HXLINE(  52)														if ((i3 < 0)) {
HXLINE(  25)															i3 = 0;
            														}
HXLINE(  52)														int this4 = i3;
HXDLIN(  52)														int b = this4;
HXDLIN(  52)														{
HXLINE(  52)															int location;
HXDLIN(  52)															if (temp->useVirtualPos) {
HXLINE(  52)																location = ::Std_obj::_hx_int(((((( (Float)(py) ) - temp->virtualY) * ( (Float)(temp->width) )) + px) - temp->virtualX));
            															}
            															else {
HXLINE(  52)																location = ::Std_obj::_hx_int(( (Float)(((py * temp->width) + px)) ));
            															}
HXDLIN(  52)															bool _hx_tmp;
HXDLIN(  52)															if (temp->transparent) {
HXLINE(  52)																_hx_tmp = (a < 254);
            															}
            															else {
HXLINE(  52)																_hx_tmp = false;
            															}
HXDLIN(  52)															if (_hx_tmp) {
HXLINE(  52)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  52)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  52)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  52)																int this3 = this2;
HXDLIN(  52)																int old;
HXDLIN(  52)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																	old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  52)																	old = this3;
            																}
HXDLIN(  52)																int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  52)																Float a1;
HXDLIN(  52)																int this4 = ((old >> 24) & 255);
HXDLIN(  52)																if ((this4 == 0)) {
HXLINE(  52)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float r1;
HXDLIN(  52)																int this5 = ((old >> 16) & 255);
HXDLIN(  52)																if ((this5 == 0)) {
HXLINE(  52)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float g1;
HXDLIN(  52)																int this6 = ((old >> 8) & 255);
HXDLIN(  52)																if ((this6 == 0)) {
HXLINE(  52)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float b1;
HXDLIN(  52)																int this7 = (old & 255);
HXDLIN(  52)																if ((this7 == 0)) {
HXLINE(  52)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float a2;
HXDLIN(  52)																int this8 = ((rhs >> 24) & 255);
HXDLIN(  52)																if ((this8 == 0)) {
HXLINE(  52)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float r2;
HXDLIN(  52)																int this9 = ((rhs >> 16) & 255);
HXDLIN(  52)																if ((this9 == 0)) {
HXLINE(  52)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float g2;
HXDLIN(  52)																int this10 = ((rhs >> 8) & 255);
HXDLIN(  52)																if ((this10 == 0)) {
HXLINE(  52)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float b2;
HXDLIN(  52)																int this11 = (rhs & 255);
HXDLIN(  52)																if ((this11 == 0)) {
HXLINE(  52)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  52)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  52)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  52)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  52)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  52)																int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  52)																{
HXLINE(  52)																	::haxe::io::ArrayBufferViewImpl this12 = temp->image;
HXDLIN(  52)																	int value;
HXDLIN(  52)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  52)																		value = blended;
            																	}
HXDLIN(  52)																	bool _hx_tmp;
HXDLIN(  52)																	if ((location >= 0)) {
HXLINE(  52)																		_hx_tmp = (location < (this12->byteLength >> 2));
            																	}
            																	else {
HXLINE(  52)																		_hx_tmp = false;
            																	}
HXDLIN(  52)																	if (_hx_tmp) {
HXLINE(  52)																		::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  52)																		int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  52)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  52)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  52)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  52)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  52)																::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  52)																int value;
HXDLIN(  52)																if (temp->isLittle) {
HXLINE(  52)																	value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            																}
            																else {
HXLINE(  52)																	value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            																}
HXDLIN(  52)																bool _hx_tmp;
HXDLIN(  52)																if ((location >= 0)) {
HXLINE(  52)																	_hx_tmp = (location < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  52)																	_hx_tmp = false;
            																}
HXDLIN(  52)																if (_hx_tmp) {
HXLINE(  52)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																	int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  52)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  52)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  52)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  52)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
HXLINE( 634)														found = true;
            													}
            													else {
HXLINE(  52)														if (found) {
HXLINE(  52)															goto _hx_goto_7;
            														}
            													}
            												}
            												_hx_goto_7:;
            											}
            										}
            									}
HXDLIN(  52)									if ((hasHit == false)) {
HXLINE(  52)										::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,lastX,lastY,nextX,nextY,true);
HXDLIN(  52)										if (hasUndo) {
HXLINE(  52)											v->undoImage = undoImage;
HXDLIN(  52)											v->undoX = xIter3->start;
HXDLIN(  52)											v->undoY = yIter3->start;
            										}
            									}
            								}
HXLINE( 110)								lastX = nextX;
HXLINE( 111)								lastY = nextY;
            							}
            						}
            					}
            					else {
HXLINE(  52)						int _g = 0;
HXDLIN(  52)						int _g1 = (sides1 + 1);
HXDLIN(  52)						while((_g < _g1)){
HXLINE(  52)							_g = (_g + 1);
HXDLIN(  52)							int i = (_g - 1);
HXDLIN(  52)							Float nextX = (cx + (rW * ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  52)							Float nextY = (cy + (rH * ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  52)							{
HXLINE(  52)								bool hasHit = false;
HXDLIN(  52)								bool hasUndo = false;
HXDLIN(  52)								int aA = ((color >> 24) & 255);
HXDLIN(  52)								int rA = ((color >> 16) & 255);
HXDLIN(  52)								int gA = ((color >> 8) & 255);
HXDLIN(  52)								int bA = (color & 255);
HXDLIN(  52)								Float bcx = (lastX - nextX);
HXDLIN(  52)								Float bcy = (lastY - nextY);
HXDLIN(  52)								Float acx = (cx - nextX);
HXDLIN(  52)								Float acy = (cy - nextY);
HXDLIN(  52)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  52)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  52)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  52)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  52)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  52)								if ((cx > lastX)) {
HXLINE(  52)									if ((cx > nextX)) {
HXLINE(  52)										int min;
HXDLIN(  52)										if ((lastX > nextX)) {
HXLINE(  52)											min = ::Math_obj::floor(nextX);
            										}
            										else {
HXLINE(  52)											min = ::Math_obj::floor(lastX);
            										}
HXDLIN(  52)										int ii_min = min;
HXDLIN(  52)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  52)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)										xIter3 = this1;
            									}
            									else {
HXLINE(  52)										int ii_min = ::Math_obj::floor(lastX);
HXDLIN(  52)										int ii_max = ::Math_obj::ceil(nextX);
HXDLIN(  52)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  52)									if ((lastX > nextX)) {
HXLINE(  52)										int min;
HXDLIN(  52)										if ((cx > nextX)) {
HXLINE(  52)											min = ::Math_obj::floor(nextX);
            										}
            										else {
HXLINE(  52)											min = ::Math_obj::ceil(cx);
            										}
HXDLIN(  52)										int ii_min = min;
HXDLIN(  52)										int ii_max = ::Math_obj::ceil(lastX);
HXDLIN(  52)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)										xIter3 = this1;
            									}
            									else {
HXLINE(  52)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  52)										int ii_max = ::Math_obj::ceil(nextX);
HXDLIN(  52)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)										xIter3 = this1;
            									}
            								}
HXDLIN(  52)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  52)								if ((cy > lastY)) {
HXLINE(  52)									if ((cy > nextY)) {
HXLINE(  52)										int min;
HXDLIN(  52)										if ((lastY > nextY)) {
HXLINE(  52)											min = ::Math_obj::floor(nextY);
            										}
            										else {
HXLINE(  52)											min = ::Math_obj::floor(lastY);
            										}
HXDLIN(  52)										int ii_min = min;
HXDLIN(  52)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  52)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)										yIter3 = this1;
            									}
            									else {
HXLINE(  52)										int ii_min = ::Math_obj::floor(lastY);
HXDLIN(  52)										int ii_max = ::Math_obj::ceil(nextY);
HXDLIN(  52)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  52)									if ((lastY > nextY)) {
HXLINE(  52)										int min;
HXDLIN(  52)										if ((cy > nextY)) {
HXLINE(  52)											min = ::Math_obj::floor(nextY);
            										}
            										else {
HXLINE(  52)											min = ::Math_obj::ceil(cy);
            										}
HXDLIN(  52)										int ii_min = min;
HXDLIN(  52)										int ii_max = ::Math_obj::ceil(lastY);
HXDLIN(  52)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)										yIter3 = this1;
            									}
            									else {
HXLINE(  52)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  52)										int ii_max = ::Math_obj::ceil(nextY);
HXDLIN(  52)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  52)										yIter3 = this1;
            									}
            								}
HXDLIN(  52)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  52)								if (hasUndo) {
HXLINE(  52)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  52)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  52)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  52)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  52)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  52)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  52)									undoImage = this3;
HXDLIN(  52)									{
HXLINE(  52)										int rectLeft = xIter3->start;
HXDLIN(  52)										int rectTop = yIter3->start;
HXDLIN(  52)										int rectRight = xIter3->max;
HXDLIN(  52)										bool forceClear = false;
HXDLIN(  52)										{
HXLINE(  52)											int _g = rectTop;
HXDLIN(  52)											int _g1 = yIter3->max;
HXDLIN(  52)											while((_g < _g1)){
HXLINE(  52)												_g = (_g + 1);
HXDLIN(  52)												int dy = (_g - 1);
HXDLIN(  52)												{
HXLINE(  52)													int _g1 = rectLeft;
HXDLIN(  52)													int _g2 = rectRight;
HXDLIN(  52)													while((_g1 < _g2)){
HXLINE(  52)														_g1 = (_g1 + 1);
HXDLIN(  52)														int dx = (_g1 - 1);
HXDLIN(  52)														::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  52)														int index;
HXDLIN(  52)														if (temp->useVirtualPos) {
HXLINE(  52)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            														}
            														else {
HXLINE(  52)															index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            														}
HXDLIN(  52)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  52)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  52)														int col;
HXDLIN(  52)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  52)															col = c;
            														}
HXDLIN(  52)														bool _hx_tmp;
HXDLIN(  52)														if (temp->useMask) {
HXLINE(  52)															_hx_tmp = ::hx::IsNotNull( temp->mask );
            														}
            														else {
HXLINE(  52)															_hx_tmp = false;
            														}
HXDLIN(  52)														if (_hx_tmp) {
HXLINE(  52)															::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  52)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  52)															int index;
HXDLIN(  52)															if (this1->useVirtualPos) {
HXLINE(  52)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  52)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  52)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  52)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  52)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  52)															int v;
HXDLIN(  52)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  52)																v = c;
            															}
HXDLIN(  52)															int this3 = v;
HXDLIN(  52)															int maskPixel = this3;
HXDLIN(  52)															int this4 = col;
HXDLIN(  52)															int this5 = this4;
HXDLIN(  52)															if ((maskPixel == 0)) {
HXLINE(  52)																int this1 = this5;
HXDLIN(  52)																col = this1;
            															}
            															else {
HXLINE(  52)																Float m0;
HXDLIN(  52)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  52)																if ((this1 == 0)) {
HXLINE(  52)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float m1;
HXDLIN(  52)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  52)																if ((this2 == 0)) {
HXLINE(  52)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float m2;
HXDLIN(  52)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  52)																if ((this3 == 0)) {
HXLINE(  52)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float m3;
HXDLIN(  52)																int this4 = (maskPixel & 255);
HXDLIN(  52)																if ((this4 == 0)) {
HXLINE(  52)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  52)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  52)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  52)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  52)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  52)														if ((col != 0)) {
HXLINE(  52)															int x = (dx - rectLeft);
HXDLIN(  52)															int y = (dy - rectTop);
HXDLIN(  52)															int this1 = col;
HXDLIN(  52)															int c = this1;
HXDLIN(  52)															bool _hx_tmp;
HXDLIN(  52)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  52)																_hx_tmp = undoImage->transparent;
            															}
            															else {
HXLINE(  52)																_hx_tmp = false;
            															}
HXDLIN(  52)															if (_hx_tmp) {
HXLINE(  52)																int location;
HXDLIN(  52)																if (undoImage->useVirtualPos) {
HXLINE(  52)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  52)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  52)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  52)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  52)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  52)																int this3 = this2;
HXDLIN(  52)																int this4;
HXDLIN(  52)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  52)																	this4 = this3;
            																}
HXDLIN(  52)																Float a1;
HXDLIN(  52)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  52)																if ((this5 == 0)) {
HXLINE(  52)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float r1;
HXDLIN(  52)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  52)																if ((this6 == 0)) {
HXLINE(  52)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float g1;
HXDLIN(  52)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  52)																if ((this7 == 0)) {
HXLINE(  52)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float b1;
HXDLIN(  52)																int this8 = (this4 & 255);
HXDLIN(  52)																if ((this8 == 0)) {
HXLINE(  52)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float a2;
HXDLIN(  52)																int this9 = ((col >> 24) & 255);
HXDLIN(  52)																if ((this9 == 0)) {
HXLINE(  52)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float r2;
HXDLIN(  52)																int this10 = ((col >> 16) & 255);
HXDLIN(  52)																if ((this10 == 0)) {
HXLINE(  52)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float g2;
HXDLIN(  52)																int this11 = ((col >> 8) & 255);
HXDLIN(  52)																if ((this11 == 0)) {
HXLINE(  52)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float b2;
HXDLIN(  52)																int this12 = (col & 255);
HXDLIN(  52)																if ((this12 == 0)) {
HXLINE(  52)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  52)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  52)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  52)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  52)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  52)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  52)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  52)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  52)																{
HXLINE(  52)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  52)																	int value;
HXDLIN(  52)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  52)																		value = blended;
            																	}
HXDLIN(  52)																	bool _hx_tmp;
HXDLIN(  52)																	if ((location >= 0)) {
HXLINE(  52)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  52)																		_hx_tmp = false;
            																	}
HXDLIN(  52)																	if (_hx_tmp) {
HXLINE(  52)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  52)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  52)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  52)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  52)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  52)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  52)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  52)																int index;
HXDLIN(  52)																if (undoImage->useVirtualPos) {
HXLINE(  52)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  52)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  52)																int value;
HXDLIN(  52)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  52)																	value = c;
            																}
HXDLIN(  52)																bool _hx_tmp;
HXDLIN(  52)																if ((index >= 0)) {
HXLINE(  52)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  52)																	_hx_tmp = false;
            																}
HXDLIN(  52)																if (_hx_tmp) {
HXLINE(  52)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  52)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  52)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  52)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  52)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  52)															if (forceClear) {
HXLINE(  52)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  52)																int x = (dx - rectLeft);
HXDLIN(  52)																int y = (dy - rectTop);
HXDLIN(  52)																int index;
HXDLIN(  52)																if (undoImage->useVirtualPos) {
HXLINE(  52)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  52)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  52)																bool _hx_tmp;
HXDLIN(  52)																if ((index >= 0)) {
HXLINE(  52)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  52)																	_hx_tmp = false;
            																}
HXDLIN(  52)																if (_hx_tmp) {
HXLINE(  52)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  52)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  52)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  52)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  52)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  52)								bool found = false;
HXDLIN(  52)								{
HXLINE(  52)									int _g_min = xIter3->start;
HXDLIN(  52)									int _g_max = xIter3->max;
HXDLIN(  52)									while((_g_min < _g_max)){
HXLINE(  52)										_g_min = (_g_min + 1);
HXDLIN(  52)										int px = (_g_min - 1);
HXDLIN(  52)										Float pcx = (( (Float)(px) ) - nextX);
HXLINE( 620)										found = false;
HXLINE(  52)										{
HXLINE(  52)											int _g_min1 = yIter3->start;
HXDLIN(  52)											int _g_max = yIter3->max;
HXDLIN(  52)											while((_g_min1 < _g_max)){
HXLINE(  52)												_g_min1 = (_g_min1 + 1);
HXDLIN(  52)												int py = (_g_min1 - 1);
HXDLIN(  52)												Float pcy = (( (Float)(py) ) - nextY);
HXDLIN(  52)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  52)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  52)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  52)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  52)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  52)												bool _hx_tmp;
HXDLIN(  52)												bool _hx_tmp1;
HXDLIN(  52)												if ((ratioA >= 0)) {
HXLINE(  52)													_hx_tmp1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  52)													_hx_tmp1 = false;
            												}
HXDLIN(  52)												if (_hx_tmp1) {
HXLINE(  52)													_hx_tmp = (ratioC >= 0);
            												}
            												else {
HXLINE(  52)													_hx_tmp = false;
            												}
HXDLIN(  52)												if (_hx_tmp) {
HXLINE(  52)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (softC * ratioB)));
HXDLIN(  52)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  52)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  52)													int this1 = i;
HXDLIN(  52)													int a = this1;
HXDLIN(  52)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  52)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  52)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  52)													int this2 = i1;
HXDLIN(  52)													int r = this2;
HXDLIN(  52)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  52)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  52)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  52)													int this3 = i2;
HXDLIN(  52)													int g = this3;
HXDLIN(  52)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  52)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  52)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  52)													int this4 = i3;
HXDLIN(  52)													int b = this4;
HXDLIN(  52)													{
HXLINE(  52)														int location;
HXDLIN(  52)														if (temp->useVirtualPos) {
HXLINE(  52)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - temp->virtualY) * ( (Float)(temp->width) )) + px) - temp->virtualX));
            														}
            														else {
HXLINE(  52)															location = ::Std_obj::_hx_int(( (Float)(((py * temp->width) + px)) ));
            														}
HXDLIN(  52)														bool _hx_tmp;
HXDLIN(  52)														if (temp->transparent) {
HXLINE(  52)															_hx_tmp = (a < 254);
            														}
            														else {
HXLINE(  52)															_hx_tmp = false;
            														}
HXDLIN(  52)														if (_hx_tmp) {
HXLINE(  52)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  52)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  52)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  52)															int this3 = this2;
HXDLIN(  52)															int old;
HXDLIN(  52)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  52)																old = this3;
            															}
HXDLIN(  52)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  52)															Float a1;
HXDLIN(  52)															int this4 = ((old >> 24) & 255);
HXDLIN(  52)															if ((this4 == 0)) {
HXLINE(  52)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  52)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  52)															Float r1;
HXDLIN(  52)															int this5 = ((old >> 16) & 255);
HXDLIN(  52)															if ((this5 == 0)) {
HXLINE(  52)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  52)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  52)															Float g1;
HXDLIN(  52)															int this6 = ((old >> 8) & 255);
HXDLIN(  52)															if ((this6 == 0)) {
HXLINE(  52)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  52)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  52)															Float b1;
HXDLIN(  52)															int this7 = (old & 255);
HXDLIN(  52)															if ((this7 == 0)) {
HXLINE(  52)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  52)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  52)															Float a2;
HXDLIN(  52)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  52)															if ((this8 == 0)) {
HXLINE(  52)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  52)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  52)															Float r2;
HXDLIN(  52)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  52)															if ((this9 == 0)) {
HXLINE(  52)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  52)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  52)															Float g2;
HXDLIN(  52)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  52)															if ((this10 == 0)) {
HXLINE(  52)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  52)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  52)															Float b2;
HXDLIN(  52)															int this11 = (rhs & 255);
HXDLIN(  52)															if ((this11 == 0)) {
HXLINE(  52)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  52)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  52)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  52)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  52)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  52)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  52)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  52)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  52)															{
HXLINE(  52)																::haxe::io::ArrayBufferViewImpl this12 = temp->image;
HXDLIN(  52)																int value;
HXDLIN(  52)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  52)																	value = blended;
            																}
HXDLIN(  52)																bool _hx_tmp;
HXDLIN(  52)																if ((location >= 0)) {
HXLINE(  52)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  52)																	_hx_tmp = false;
            																}
HXDLIN(  52)																if (_hx_tmp) {
HXLINE(  52)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  52)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  52)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  52)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  52)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  52)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  52)															::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  52)															int value;
HXDLIN(  52)															if (temp->isLittle) {
HXLINE(  52)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  52)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  52)															bool _hx_tmp;
HXDLIN(  52)															if ((location >= 0)) {
HXLINE(  52)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  52)																_hx_tmp = false;
            															}
HXDLIN(  52)															if (_hx_tmp) {
HXLINE(  52)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  52)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  52)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  52)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  52)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  52)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found = true;
            												}
            												else {
HXLINE(  52)													if (found) {
HXLINE(  52)														goto _hx_goto_12;
            													}
            												}
            											}
            											_hx_goto_12:;
            										}
            									}
            								}
HXDLIN(  52)								if ((hasHit == false)) {
HXLINE(  52)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,lastX,lastY,nextX,nextY,true);
HXDLIN(  52)									if (hasUndo) {
HXLINE(  52)										v->undoImage = undoImage;
HXDLIN(  52)										v->undoX = xIter3->start;
HXDLIN(  52)										v->undoY = yIter3->start;
            									}
            								}
            							}
HXLINE( 119)							lastX = nextX;
HXLINE( 120)							lastY = nextY;
            						}
            					}
            				}
            			}
            		}
HXLINE(  53)		{
HXLINE(  53)			int x = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  53)			int y = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  53)			bool forceClear = false;
HXDLIN(  53)			{
HXLINE(  53)				int _g = 0;
HXDLIN(  53)				int _g1 = temp->height;
HXDLIN(  53)				while((_g < _g1)){
HXLINE(  53)					_g = (_g + 1);
HXDLIN(  53)					int dy = (_g - 1);
HXDLIN(  53)					{
HXLINE(  53)						int _g1 = 0;
HXDLIN(  53)						int _g2 = temp->width;
HXDLIN(  53)						while((_g1 < _g2)){
HXLINE(  53)							_g1 = (_g1 + 1);
HXDLIN(  53)							int dx = (_g1 - 1);
HXDLIN(  53)							::haxe::io::ArrayBufferViewImpl this1 = temp->image;
HXDLIN(  53)							int index;
HXDLIN(  53)							if (temp->useVirtualPos) {
HXLINE(  53)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  53)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  53)							::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  53)							int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  53)							int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  53)							int col;
HXDLIN(  53)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  53)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  53)								col = c;
            							}
HXDLIN(  53)							bool _hx_tmp;
HXDLIN(  53)							if (temp->useMask) {
HXLINE(  53)								_hx_tmp = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  53)								_hx_tmp = false;
            							}
HXDLIN(  53)							if (_hx_tmp) {
HXLINE(  53)								::pixelimage::ImageStruct this1 = temp->mask;
HXDLIN(  53)								::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  53)								int index;
HXDLIN(  53)								if (this1->useVirtualPos) {
HXLINE(  53)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE(  53)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  53)								::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  53)								int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  53)								int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  53)								int v;
HXDLIN(  53)								if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  53)									v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  53)									v = c;
            								}
HXDLIN(  53)								int this3 = v;
HXDLIN(  53)								int maskPixel = this3;
HXDLIN(  53)								int this4 = col;
HXDLIN(  53)								int this5 = this4;
HXDLIN(  53)								if ((maskPixel == 0)) {
HXLINE(  53)									int this1 = this5;
HXDLIN(  53)									col = this1;
            								}
            								else {
HXLINE(  53)									Float m0;
HXDLIN(  53)									int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  53)									if ((this1 == 0)) {
HXLINE(  53)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float m1;
HXDLIN(  53)									int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  53)									if ((this2 == 0)) {
HXLINE(  53)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float m2;
HXDLIN(  53)									int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  53)									if ((this3 == 0)) {
HXLINE(  53)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float m3;
HXDLIN(  53)									int this4 = (maskPixel & 255);
HXDLIN(  53)									if ((this4 == 0)) {
HXLINE(  53)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  53)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  53)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  53)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  53)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  53)							if ((col != 0)) {
HXLINE(  53)								int x1 = (x + dx);
HXDLIN(  53)								int y1 = (y + dy);
HXDLIN(  53)								int this1 = col;
HXDLIN(  53)								int c = this1;
HXDLIN(  53)								bool _hx_tmp;
HXDLIN(  53)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  53)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  53)									_hx_tmp = false;
            								}
HXDLIN(  53)								if (_hx_tmp) {
HXLINE(  53)									int location;
HXDLIN(  53)									if (pixelShape->useVirtualPos) {
HXLINE(  53)										location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  53)										location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  53)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  53)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  53)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  53)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  53)									int this3 = this2;
HXDLIN(  53)									int this4;
HXDLIN(  53)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  53)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  53)										this4 = this3;
            									}
HXDLIN(  53)									Float a1;
HXDLIN(  53)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  53)									if ((this5 == 0)) {
HXLINE(  53)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float r1;
HXDLIN(  53)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  53)									if ((this6 == 0)) {
HXLINE(  53)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float g1;
HXDLIN(  53)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  53)									if ((this7 == 0)) {
HXLINE(  53)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float b1;
HXDLIN(  53)									int this8 = (this4 & 255);
HXDLIN(  53)									if ((this8 == 0)) {
HXLINE(  53)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float a2;
HXDLIN(  53)									int this9 = ((col >> 24) & 255);
HXDLIN(  53)									if ((this9 == 0)) {
HXLINE(  53)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float r2;
HXDLIN(  53)									int this10 = ((col >> 16) & 255);
HXDLIN(  53)									if ((this10 == 0)) {
HXLINE(  53)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float g2;
HXDLIN(  53)									int this11 = ((col >> 8) & 255);
HXDLIN(  53)									if ((this11 == 0)) {
HXLINE(  53)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float b2;
HXDLIN(  53)									int this12 = (col & 255);
HXDLIN(  53)									if ((this12 == 0)) {
HXLINE(  53)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  53)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  53)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  53)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  53)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  53)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  53)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  53)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  53)									{
HXLINE(  53)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  53)										int value;
HXDLIN(  53)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  53)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  53)											value = blended;
            										}
HXDLIN(  53)										bool _hx_tmp;
HXDLIN(  53)										if ((location >= 0)) {
HXLINE(  53)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  53)											_hx_tmp = false;
            										}
HXDLIN(  53)										if (_hx_tmp) {
HXLINE(  53)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  53)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  53)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  53)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  53)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  53)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  53)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  53)									int index;
HXDLIN(  53)									if (pixelShape->useVirtualPos) {
HXLINE(  53)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  53)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  53)									int value;
HXDLIN(  53)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  53)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  53)										value = c;
            									}
HXDLIN(  53)									bool _hx_tmp;
HXDLIN(  53)									if ((index >= 0)) {
HXLINE(  53)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  53)										_hx_tmp = false;
            									}
HXDLIN(  53)									if (_hx_tmp) {
HXLINE(  53)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  53)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  53)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  53)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  53)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  53)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
            							else {
HXLINE(  53)								if (forceClear) {
HXLINE(  53)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  53)									int x1 = (x + dx);
HXDLIN(  53)									int y1 = (y + dy);
HXDLIN(  53)									int index;
HXDLIN(  53)									if (pixelShape->useVirtualPos) {
HXLINE(  53)										index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x1) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  53)										index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelShape->width) + x1)) ));
            									}
HXDLIN(  53)									bool _hx_tmp;
HXDLIN(  53)									if ((index >= 0)) {
HXLINE(  53)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  53)										_hx_tmp = false;
            									}
HXDLIN(  53)									if (_hx_tmp) {
HXLINE(  53)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  53)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  53)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  53)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  53)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  53)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  54)		temp = null();
HXLINE(  55)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< SoftEllipseShape_obj > SoftEllipseShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_softC) {
	::hx::ObjectPtr< SoftEllipseShape_obj > __this = new SoftEllipseShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_left,__o_top,__o_width,__o_height,__o_softC);
	return __this;
}

::hx::ObjectPtr< SoftEllipseShape_obj > SoftEllipseShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_softC) {
	SoftEllipseShape_obj *__this = (SoftEllipseShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(SoftEllipseShape_obj), true, "pixelimage.triangleGML.contour.SoftEllipseShape"));
	*(void **)__this = SoftEllipseShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_left,__o_top,__o_width,__o_height,__o_softC);
	return __this;
}

SoftEllipseShape_obj::SoftEllipseShape_obj()
{
}

::hx::Val SoftEllipseShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { return ::hx::Val( top ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { return ::hx::Val( left ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"softC") ) { return ::hx::Val( softC ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val SoftEllipseShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { top=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { left=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"softC") ) { softC=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void SoftEllipseShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("left",07,08,b0,47));
	outFields->push(HX_("top",95,66,58,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("softC",19,30,c1,80));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo SoftEllipseShape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(SoftEllipseShape_obj,left),HX_("left",07,08,b0,47)},
	{::hx::fsFloat,(int)offsetof(SoftEllipseShape_obj,top),HX_("top",95,66,58,00)},
	{::hx::fsFloat,(int)offsetof(SoftEllipseShape_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsFloat,(int)offsetof(SoftEllipseShape_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsFloat,(int)offsetof(SoftEllipseShape_obj,softC),HX_("softC",19,30,c1,80)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *SoftEllipseShape_obj_sStaticStorageInfo = 0;
#endif

static ::String SoftEllipseShape_obj_sMemberFields[] = {
	HX_("left",07,08,b0,47),
	HX_("top",95,66,58,00),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("softC",19,30,c1,80),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class SoftEllipseShape_obj::__mClass;

void SoftEllipseShape_obj::__register()
{
	SoftEllipseShape_obj _hx_dummy;
	SoftEllipseShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.contour.SoftEllipseShape",6a,83,46,7f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(SoftEllipseShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< SoftEllipseShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SoftEllipseShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SoftEllipseShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace contour
