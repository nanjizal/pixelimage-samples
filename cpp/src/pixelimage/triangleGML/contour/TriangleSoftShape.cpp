// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_contour_TriangleSoftShape
#include <pixelimage/triangleGML/contour/TriangleSoftShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d2648086770999bb_32_new,"pixelimage.triangleGML.contour.TriangleSoftShape","new",0x81ade744,"pixelimage.triangleGML.contour.TriangleSoftShape.new","pixelimage/triangleGML/contour/TriangleSoftShape.hx",32,0xff816faf)
HX_LOCAL_STACK_FRAME(_hx_pos_d2648086770999bb_47_setParameter,"pixelimage.triangleGML.contour.TriangleSoftShape","setParameter",0x9905e243,"pixelimage.triangleGML.contour.TriangleSoftShape.setParameter","pixelimage/triangleGML/contour/TriangleSoftShape.hx",47,0xff816faf)
HX_LOCAL_STACK_FRAME(_hx_pos_d2648086770999bb_72_render,"pixelimage.triangleGML.contour.TriangleSoftShape","render",0x7975baf2,"pixelimage.triangleGML.contour.TriangleSoftShape.render","pixelimage/triangleGML/contour/TriangleSoftShape.hx",72,0xff816faf)
namespace pixelimage{
namespace triangleGML{
namespace contour{

void TriangleSoftShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_aX,::hx::Null< Float >  __o_aY,::hx::Null< Float >  __o_bX,::hx::Null< Float >  __o_bY,::hx::Null< Float >  __o_cX,::hx::Null< Float >  __o_cY,::hx::Null< Float >  __o_soft3,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCA){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(-1048576);
            		Float aX = __o_aX.Default(((Float)0.));
            		Float aY = __o_aY.Default(((Float)0.));
            		Float bX = __o_bX.Default(((Float)1.));
            		Float bY = __o_bY.Default(((Float)0.));
            		Float cX = __o_cX.Default(((Float)1.));
            		Float cY = __o_cY.Default(((Float)1.));
            		Float soft3 = __o_soft3.Default(((Float)10.));
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCA = __o_softCA.Default(true);
            	HX_STACKFRAME(&_hx_pos_d2648086770999bb_32_new)
HXLINE(  33)		super::__construct(opacity,visibility,strokeColor,((Float)0.),null());
HXLINE(  34)		this->aX = aX;
HXLINE(  35)		this->aY = aY;
HXLINE(  36)		this->bX = bX;
HXLINE(  37)		this->bY = bY;
HXLINE(  38)		this->cX = cX;
HXLINE(  39)		this->cY = cY;
HXLINE(  40)		this->soft3 = soft3;
HXLINE(  41)		this->softAB = softAB;
HXLINE(  42)		this->softBC = softBC;
HXLINE(  43)		this->softCA = softCA;
            	}

Dynamic TriangleSoftShape_obj::__CreateEmpty() { return new TriangleSoftShape_obj; }

void *TriangleSoftShape_obj::_hx_vtable = 0;

Dynamic TriangleSoftShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TriangleSoftShape_obj > _hx_result = new TriangleSoftShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12]);
	return _hx_result;
}

bool TriangleSoftShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x3a8a04ba;
	}
}

void TriangleSoftShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_d2648086770999bb_47_setParameter)
HXDLIN(  47)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("aX",d7,54,00,00)) ){
HXLINE(  49)			this->aX = ::Std_obj::parseFloat(value);
HXDLIN(  49)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("aY",d8,54,00,00)) ){
HXLINE(  51)			this->aY = ::Std_obj::parseFloat(value);
HXDLIN(  51)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("bX",b6,55,00,00)) ){
HXLINE(  53)			this->bX = ::Std_obj::parseFloat(value);
HXDLIN(  53)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("bY",b7,55,00,00)) ){
HXLINE(  55)			this->bY = ::Std_obj::parseFloat(value);
HXDLIN(  55)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("cX",95,56,00,00)) ){
HXLINE(  57)			this->cX = ::Std_obj::parseFloat(value);
HXDLIN(  57)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("cY",96,56,00,00)) ){
HXLINE(  59)			this->cY = ::Std_obj::parseFloat(value);
HXDLIN(  59)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("soft3",09,30,c1,80)) ){
HXLINE(  61)			this->soft3 = ::Std_obj::parseFloat(value);
HXDLIN(  61)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("softAB",4b,e4,48,28)) ){
HXLINE(  63)			bool _hx_tmp;
HXDLIN(  63)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  63)				_hx_tmp = true;
            			}
            			else {
HXLINE(  63)				_hx_tmp = false;
            			}
HXDLIN(  63)			this->softAB = _hx_tmp;
HXDLIN(  63)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("softBC",2b,e5,48,28)) ){
HXLINE(  65)			bool _hx_tmp;
HXDLIN(  65)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  65)				_hx_tmp = true;
            			}
            			else {
HXLINE(  65)				_hx_tmp = false;
            			}
HXDLIN(  65)			this->softBC = _hx_tmp;
HXDLIN(  65)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("softCA",08,e6,48,28)) ){
HXLINE(  67)			bool _hx_tmp;
HXDLIN(  67)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  67)				_hx_tmp = true;
            			}
            			else {
HXLINE(  67)				_hx_tmp = false;
            			}
HXDLIN(  67)			this->softCA = _hx_tmp;
HXDLIN(  67)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  69)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct TriangleSoftShape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_d2648086770999bb_72_render)
HXLINE(  73)		{
HXLINE(  73)			Float ax = this->aX;
HXDLIN(  73)			Float ay = this->aY;
HXDLIN(  73)			Float bx = this->bX;
HXDLIN(  73)			Float by = this->bY;
HXDLIN(  73)			Float cx = this->cX;
HXDLIN(  73)			Float cy = this->cY;
HXDLIN(  73)			int color = this->strokeColor;
HXDLIN(  73)			Float soft3 = this->soft3;
HXDLIN(  73)			bool softAB = this->softAB;
HXDLIN(  73)			bool softBC = this->softBC;
HXDLIN(  73)			bool softCA = this->softCA;
HXDLIN(  73)			bool hasHit = false;
HXDLIN(  73)			{
HXLINE(  73)				bool hasUndo = true;
HXDLIN(  73)				int aA = ((color >> 24) & 255);
HXDLIN(  73)				int rA = ((color >> 16) & 255);
HXDLIN(  73)				int gA = ((color >> 8) & 255);
HXDLIN(  73)				int bA = (color & 255);
HXDLIN(  73)				Float bcx = (bx - cx);
HXDLIN(  73)				Float bcy = (by - cy);
HXDLIN(  73)				Float acx = (ax - cx);
HXDLIN(  73)				Float acy = (ay - cy);
HXDLIN(  73)				Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  73)				Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  73)				Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  73)				Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  73)				::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  73)				if ((ax > bx)) {
HXLINE(  73)					if ((ax > cx)) {
HXLINE(  73)						int min;
HXDLIN(  73)						if ((bx > cx)) {
HXLINE(  73)							min = ::Math_obj::floor(cx);
            						}
            						else {
HXLINE(  73)							min = ::Math_obj::floor(bx);
            						}
HXDLIN(  73)						int ii_min = min;
HXDLIN(  73)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  73)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)						xIter3 = this1;
            					}
            					else {
HXLINE(  73)						int ii_min = ::Math_obj::floor(bx);
HXDLIN(  73)						int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  73)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)						xIter3 = this1;
            					}
            				}
            				else {
HXLINE(  73)					if ((bx > cx)) {
HXLINE(  73)						int min;
HXDLIN(  73)						if ((ax > cx)) {
HXLINE(  73)							min = ::Math_obj::floor(cx);
            						}
            						else {
HXLINE(  73)							min = ::Math_obj::ceil(ax);
            						}
HXDLIN(  73)						int ii_min = min;
HXDLIN(  73)						int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  73)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)						xIter3 = this1;
            					}
            					else {
HXLINE(  73)						int ii_min = ::Math_obj::floor(ax);
HXDLIN(  73)						int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  73)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)						xIter3 = this1;
            					}
            				}
HXDLIN(  73)				::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  73)				if ((ay > by)) {
HXLINE(  73)					if ((ay > cy)) {
HXLINE(  73)						int min;
HXDLIN(  73)						if ((by > cy)) {
HXLINE(  73)							min = ::Math_obj::floor(cy);
            						}
            						else {
HXLINE(  73)							min = ::Math_obj::floor(by);
            						}
HXDLIN(  73)						int ii_min = min;
HXDLIN(  73)						int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  73)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)						yIter3 = this1;
            					}
            					else {
HXLINE(  73)						int ii_min = ::Math_obj::floor(by);
HXDLIN(  73)						int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  73)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)						yIter3 = this1;
            					}
            				}
            				else {
HXLINE(  73)					if ((by > cy)) {
HXLINE(  73)						int min;
HXDLIN(  73)						if ((ay > cy)) {
HXLINE(  73)							min = ::Math_obj::floor(cy);
            						}
            						else {
HXLINE(  73)							min = ::Math_obj::ceil(ay);
            						}
HXDLIN(  73)						int ii_min = min;
HXDLIN(  73)						int ii_max = ::Math_obj::ceil(by);
HXDLIN(  73)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)						yIter3 = this1;
            					}
            					else {
HXLINE(  73)						int ii_min = ::Math_obj::floor(ay);
HXDLIN(  73)						int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  73)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  73)						yIter3 = this1;
            					}
            				}
HXDLIN(  73)				::pixelimage::ImageStruct undoImage = null();
HXDLIN(  73)				if (hasUndo) {
HXLINE(  73)					int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  73)					int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  73)					int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  73)					::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  73)					::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  73)					::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  73)					undoImage = this3;
HXDLIN(  73)					{
HXLINE(  73)						int rectLeft = xIter3->start;
HXDLIN(  73)						int rectTop = yIter3->start;
HXDLIN(  73)						int rectRight = xIter3->max;
HXDLIN(  73)						bool forceClear = false;
HXDLIN(  73)						{
HXLINE(  73)							int _g = rectTop;
HXDLIN(  73)							int _g1 = yIter3->max;
HXDLIN(  73)							while((_g < _g1)){
HXLINE(  73)								_g = (_g + 1);
HXDLIN(  73)								int dy = (_g - 1);
HXDLIN(  73)								{
HXLINE(  73)									int _g1 = rectLeft;
HXDLIN(  73)									int _g2 = rectRight;
HXDLIN(  73)									while((_g1 < _g2)){
HXLINE(  73)										_g1 = (_g1 + 1);
HXDLIN(  73)										int dx = (_g1 - 1);
HXDLIN(  73)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  73)										int index;
HXDLIN(  73)										if (pixelShape->useVirtualPos) {
HXLINE(  73)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  73)											index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            										}
HXDLIN(  73)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)										int col;
HXDLIN(  73)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  73)											col = c;
            										}
HXDLIN(  73)										bool _hx_tmp;
HXDLIN(  73)										if (pixelShape->useMask) {
HXLINE(  73)											_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            										}
            										else {
HXLINE(  73)											_hx_tmp = false;
            										}
HXDLIN(  73)										if (_hx_tmp) {
HXLINE(  73)											::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  73)											::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  73)											int index;
HXDLIN(  73)											if (this1->useVirtualPos) {
HXLINE(  73)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            											}
            											else {
HXLINE(  73)												index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            											}
HXDLIN(  73)											::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  73)											int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  73)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)											int v;
HXDLIN(  73)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)												v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  73)												v = c;
            											}
HXDLIN(  73)											int this3 = v;
HXDLIN(  73)											int maskPixel = this3;
HXDLIN(  73)											int this4 = col;
HXDLIN(  73)											int this5 = this4;
HXDLIN(  73)											if ((maskPixel == 0)) {
HXLINE(  73)												int this1 = this5;
HXDLIN(  73)												col = this1;
            											}
            											else {
HXLINE(  73)												Float m0;
HXDLIN(  73)												int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  73)												if ((this1 == 0)) {
HXLINE(  73)													m0 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m1;
HXDLIN(  73)												int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  73)												if ((this2 == 0)) {
HXLINE(  73)													m1 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m2;
HXDLIN(  73)												int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  73)												if ((this3 == 0)) {
HXLINE(  73)													m2 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m3;
HXDLIN(  73)												int this4 = (maskPixel & 255);
HXDLIN(  73)												if ((this4 == 0)) {
HXLINE(  73)													m3 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  73)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  73)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  73)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  73)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  73)										if ((col != 0)) {
HXLINE(  73)											int x = (dx - rectLeft);
HXDLIN(  73)											int y = (dy - rectTop);
HXDLIN(  73)											int this1 = col;
HXDLIN(  73)											int c = this1;
HXDLIN(  73)											bool _hx_tmp;
HXDLIN(  73)											if ((((c >> 24) & 255) < 254)) {
HXLINE(  73)												_hx_tmp = undoImage->transparent;
            											}
            											else {
HXLINE(  73)												_hx_tmp = false;
            											}
HXDLIN(  73)											if (_hx_tmp) {
HXLINE(  73)												int location;
HXDLIN(  73)												if (undoImage->useVirtualPos) {
HXLINE(  73)													location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            												}
            												else {
HXLINE(  73)													location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            												}
HXDLIN(  73)												::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)												int this3 = this2;
HXDLIN(  73)												int this4;
HXDLIN(  73)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													this4 = this3;
            												}
HXDLIN(  73)												Float a1;
HXDLIN(  73)												int this5 = ((this4 >> 24) & 255);
HXDLIN(  73)												if ((this5 == 0)) {
HXLINE(  73)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r1;
HXDLIN(  73)												int this6 = ((this4 >> 16) & 255);
HXDLIN(  73)												if ((this6 == 0)) {
HXLINE(  73)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g1;
HXDLIN(  73)												int this7 = ((this4 >> 8) & 255);
HXDLIN(  73)												if ((this7 == 0)) {
HXLINE(  73)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b1;
HXDLIN(  73)												int this8 = (this4 & 255);
HXDLIN(  73)												if ((this8 == 0)) {
HXLINE(  73)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a2;
HXDLIN(  73)												int this9 = ((col >> 24) & 255);
HXDLIN(  73)												if ((this9 == 0)) {
HXLINE(  73)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r2;
HXDLIN(  73)												int this10 = ((col >> 16) & 255);
HXDLIN(  73)												if ((this10 == 0)) {
HXLINE(  73)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g2;
HXDLIN(  73)												int this11 = ((col >> 8) & 255);
HXDLIN(  73)												if ((this11 == 0)) {
HXLINE(  73)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b2;
HXDLIN(  73)												int this12 = (col & 255);
HXDLIN(  73)												if ((this12 == 0)) {
HXLINE(  73)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  73)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  73)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  73)												int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  73)												int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  73)												int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  73)												{
HXLINE(  73)													::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  73)													int value;
HXDLIN(  73)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  73)														value = blended;
            													}
HXDLIN(  73)													bool _hx_tmp;
HXDLIN(  73)													if ((location >= 0)) {
HXLINE(  73)														_hx_tmp = (location < (this13->byteLength >> 2));
            													}
            													else {
HXLINE(  73)														_hx_tmp = false;
            													}
HXDLIN(  73)													if (_hx_tmp) {
HXLINE(  73)														::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  73)														int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  73)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  73)												::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)												int index;
HXDLIN(  73)												if (undoImage->useVirtualPos) {
HXLINE(  73)													index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            												}
            												else {
HXLINE(  73)													index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            												}
HXDLIN(  73)												int value;
HXDLIN(  73)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  73)													value = c;
            												}
HXDLIN(  73)												bool _hx_tmp;
HXDLIN(  73)												if ((index >= 0)) {
HXLINE(  73)													_hx_tmp = (index < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  73)													_hx_tmp = false;
            												}
HXDLIN(  73)												if (_hx_tmp) {
HXLINE(  73)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  73)											if (forceClear) {
HXLINE(  73)												::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  73)												int x = (dx - rectLeft);
HXDLIN(  73)												int y = (dy - rectTop);
HXDLIN(  73)												int index;
HXDLIN(  73)												if (undoImage->useVirtualPos) {
HXLINE(  73)													index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            												}
            												else {
HXLINE(  73)													index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            												}
HXDLIN(  73)												bool _hx_tmp;
HXDLIN(  73)												if ((index >= 0)) {
HXLINE(  73)													_hx_tmp = (index < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  73)													_hx_tmp = false;
            												}
HXDLIN(  73)												if (_hx_tmp) {
HXLINE(  73)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  73)													_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  73)													_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  73)													_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  73)													_this->b[(pos + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  73)				bool found = false;
HXDLIN(  73)				Float min = ( (Float)(0) );
HXDLIN(  73)				Float max = ( (Float)(0) );
HXDLIN(  73)				int a = 0;
HXDLIN(  73)				int r = 0;
HXDLIN(  73)				int g = 0;
HXDLIN(  73)				int b = 0;
HXDLIN(  73)				{
HXLINE(  73)					int _g_min = xIter3->start;
HXDLIN(  73)					int _g_max = xIter3->max;
HXDLIN(  73)					while((_g_min < _g_max)){
HXLINE(  73)						_g_min = (_g_min + 1);
HXDLIN(  73)						int px = (_g_min - 1);
HXDLIN(  73)						Float pcx = (( (Float)(px) ) - cx);
HXLINE( 696)						found = false;
HXLINE(  73)						{
HXLINE(  73)							int _g_min1 = yIter3->start;
HXDLIN(  73)							int _g_max = yIter3->max;
HXDLIN(  73)							while((_g_min1 < _g_max)){
HXLINE(  73)								_g_min1 = (_g_min1 + 1);
HXDLIN(  73)								int py = (_g_min1 - 1);
HXDLIN(  73)								Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  73)								Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  73)								Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  73)								Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  73)								Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  73)								Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  73)								bool _hx_tmp;
HXDLIN(  73)								bool _hx_tmp1;
HXDLIN(  73)								if ((ratioA >= 0)) {
HXLINE(  73)									_hx_tmp1 = (ratioB >= 0);
            								}
            								else {
HXLINE(  73)									_hx_tmp1 = false;
            								}
HXDLIN(  73)								if (_hx_tmp1) {
HXLINE(  73)									_hx_tmp = (ratioC >= 0);
            								}
            								else {
HXLINE(  73)									_hx_tmp = false;
            								}
HXDLIN(  73)								if (_hx_tmp) {
HXLINE(  73)									if (softAB) {
HXLINE(  73)										if (softBC) {
HXLINE(  73)											if (softCA) {
HXLINE(  73)												Float min;
HXDLIN(  73)												if ((ratioA < ratioB)) {
HXLINE(  73)													min = ratioA;
            												}
            												else {
HXLINE(  73)													min = ratioB;
            												}
HXDLIN(  73)												if (!((min < ratioC))) {
HXLINE(  73)													min = ratioC;
            												}
HXDLIN(  73)												Float max;
HXDLIN(  73)												if ((ratioA > ratioB)) {
HXLINE(  73)													max = ratioA;
            												}
            												else {
HXLINE(  73)													max = ratioB;
            												}
HXDLIN(  73)												if (!((max > ratioC))) {
HXLINE(  73)													max = ratioC;
            												}
HXLINE( 744)												max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  73)												Float min1;
HXDLIN(  73)												if ((min < max)) {
HXLINE(  73)													min1 = min;
            												}
            												else {
HXLINE(  73)													min1 = ((max + min) / ( (Float)(2) ));
            												}
HXDLIN(  73)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min1));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												a = this1;
            											}
            											else {
HXLINE(  73)												if ((ratioB < ratioC)) {
HXLINE(  73)													min = ratioB;
            												}
            												else {
HXLINE(  73)													min = ratioC;
            												}
HXDLIN(  73)												if ((ratioA > ratioB)) {
HXLINE(  73)													max = ratioA;
            												}
            												else {
HXLINE(  73)													max = ratioB;
            												}
HXDLIN(  73)												if (!((max > ratioC))) {
HXLINE(  73)													max = ratioC;
            												}
HXLINE( 736)												max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  73)												if (!((min < max))) {
HXLINE(  73)													min = ((max + min) / ( (Float)(2) ));
            												}
HXDLIN(  73)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												a = this1;
            											}
            										}
            										else {
HXLINE(  73)											if (softCA) {
HXLINE(  73)												if ((ratioA < ratioC)) {
HXLINE(  73)													min = ratioA;
            												}
            												else {
HXLINE(  73)													min = ratioC;
            												}
HXDLIN(  73)												if ((ratioA > ratioB)) {
HXLINE(  73)													max = ratioA;
            												}
            												else {
HXLINE(  73)													max = ratioB;
            												}
HXDLIN(  73)												if (!((max > ratioC))) {
HXLINE(  73)													max = ratioC;
            												}
HXLINE( 729)												max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  73)												if (!((min < max))) {
HXLINE(  73)													min = ((max + min) / ( (Float)(2) ));
            												}
HXDLIN(  73)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												a = this1;
            											}
            											else {
HXLINE( 723)												min = ratioC;
HXLINE(  73)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												a = this1;
            											}
            										}
            									}
            									else {
HXLINE(  73)										if (softBC) {
HXLINE(  73)											if (softCA) {
HXLINE(  73)												if ((ratioA < ratioB)) {
HXLINE(  73)													min = ratioA;
            												}
            												else {
HXLINE(  73)													min = ratioB;
            												}
HXDLIN(  73)												if ((ratioA > ratioB)) {
HXLINE(  73)													max = ratioA;
            												}
            												else {
HXLINE(  73)													max = ratioB;
            												}
HXDLIN(  73)												if (!((max > ratioC))) {
HXLINE(  73)													max = ratioC;
            												}
HXLINE( 719)												max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  73)												if (!((min < max))) {
HXLINE(  73)													min = ((max + min) / ( (Float)(2) ));
            												}
HXDLIN(  73)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												a = this1;
            											}
            											else {
HXLINE( 713)												min = ratioB;
HXLINE(  73)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												a = this1;
            											}
            										}
            										else {
HXLINE(  73)											if (softCA) {
HXLINE( 710)												min = ratioA;
HXLINE(  73)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft3) * min));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												a = this1;
            											}
            											else {
HXLINE(  73)												int i = ::Std_obj::_hx_int(( (Float)(aA) ));
HXDLIN(  73)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  73)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  73)												int this1 = i;
HXDLIN(  73)												a = this1;
            											}
            										}
            									}
HXDLIN(  73)									int i = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  73)									if ((i > 255)) {
HXLINE(  24)										i = 255;
            									}
HXLINE(  73)									if ((i < 0)) {
HXLINE(  25)										i = 0;
            									}
HXLINE(  73)									int this1 = i;
HXLINE( 748)									r = this1;
HXLINE(  73)									int i1 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  73)									if ((i1 > 255)) {
HXLINE(  24)										i1 = 255;
            									}
HXLINE(  73)									if ((i1 < 0)) {
HXLINE(  25)										i1 = 0;
            									}
HXLINE(  73)									int this2 = i1;
HXLINE( 749)									g = this2;
HXLINE(  73)									int i2 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  73)									if ((i2 > 255)) {
HXLINE(  24)										i2 = 255;
            									}
HXLINE(  73)									if ((i2 < 0)) {
HXLINE(  25)										i2 = 0;
            									}
HXLINE(  73)									int this3 = i2;
HXLINE( 750)									b = this3;
HXLINE(  73)									{
HXLINE(  73)										int location;
HXDLIN(  73)										if (pixelShape->useVirtualPos) {
HXLINE(  73)											location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  73)											location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            										}
HXDLIN(  73)										bool _hx_tmp;
HXDLIN(  73)										if (pixelShape->transparent) {
HXLINE(  73)											_hx_tmp = (a < 254);
            										}
            										else {
HXLINE(  73)											_hx_tmp = false;
            										}
HXDLIN(  73)										if (_hx_tmp) {
HXLINE(  73)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  73)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  73)											int this3 = this2;
HXDLIN(  73)											int old;
HXDLIN(  73)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)												old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  73)												old = this3;
            											}
HXDLIN(  73)											int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  73)											Float a1;
HXDLIN(  73)											int this4 = ((old >> 24) & 255);
HXDLIN(  73)											if ((this4 == 0)) {
HXLINE(  73)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  73)												a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN(  73)											Float r1;
HXDLIN(  73)											int this5 = ((old >> 16) & 255);
HXDLIN(  73)											if ((this5 == 0)) {
HXLINE(  73)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  73)												r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  73)											Float g1;
HXDLIN(  73)											int this6 = ((old >> 8) & 255);
HXDLIN(  73)											if ((this6 == 0)) {
HXLINE(  73)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  73)												g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  73)											Float b1;
HXDLIN(  73)											int this7 = (old & 255);
HXDLIN(  73)											if ((this7 == 0)) {
HXLINE(  73)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  73)												b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  73)											Float a2;
HXDLIN(  73)											int this8 = ((rhs >> 24) & 255);
HXDLIN(  73)											if ((this8 == 0)) {
HXLINE(  73)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  73)												a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  73)											Float r2;
HXDLIN(  73)											int this9 = ((rhs >> 16) & 255);
HXDLIN(  73)											if ((this9 == 0)) {
HXLINE(  73)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  73)												r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  73)											Float g2;
HXDLIN(  73)											int this10 = ((rhs >> 8) & 255);
HXDLIN(  73)											if ((this10 == 0)) {
HXLINE(  73)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  73)												g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  73)											Float b2;
HXDLIN(  73)											int this11 = (rhs & 255);
HXDLIN(  73)											if ((this11 == 0)) {
HXLINE(  73)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  73)												b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  73)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  73)											int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  73)											int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  73)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  73)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  73)											int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  73)											{
HXLINE(  73)												::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  73)												int value;
HXDLIN(  73)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  73)													value = blended;
            												}
HXDLIN(  73)												bool _hx_tmp;
HXDLIN(  73)												if ((location >= 0)) {
HXLINE(  73)													_hx_tmp = (location < (this12->byteLength >> 2));
            												}
            												else {
HXLINE(  73)													_hx_tmp = false;
            												}
HXDLIN(  73)												if (_hx_tmp) {
HXLINE(  73)													::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  73)													int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  73)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  73)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  73)											int value;
HXDLIN(  73)											if (pixelShape->isLittle) {
HXLINE(  73)												value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            											}
            											else {
HXLINE(  73)												value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            											}
HXDLIN(  73)											bool _hx_tmp;
HXDLIN(  73)											if ((location >= 0)) {
HXLINE(  73)												_hx_tmp = (location < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  73)												_hx_tmp = false;
            											}
HXDLIN(  73)											if (_hx_tmp) {
HXLINE(  73)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  73)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  73)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  73)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  73)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  73)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXLINE( 752)									found = true;
            								}
            								else {
HXLINE(  73)									if (found) {
HXLINE(  73)										goto _hx_goto_6;
            									}
            								}
            							}
            							_hx_goto_6:;
            						}
            					}
            				}
HXDLIN(  73)				if ((hasHit == false)) {
HXLINE(  73)					::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN(  73)					if (hasUndo) {
HXLINE(  73)						v->undoImage = undoImage;
HXDLIN(  73)						v->undoX = xIter3->start;
HXDLIN(  73)						v->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXLINE(  74)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< TriangleSoftShape_obj > TriangleSoftShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_aX,::hx::Null< Float >  __o_aY,::hx::Null< Float >  __o_bX,::hx::Null< Float >  __o_bY,::hx::Null< Float >  __o_cX,::hx::Null< Float >  __o_cY,::hx::Null< Float >  __o_soft3,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCA) {
	::hx::ObjectPtr< TriangleSoftShape_obj > __this = new TriangleSoftShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_aX,__o_aY,__o_bX,__o_bY,__o_cX,__o_cY,__o_soft3,__o_softAB,__o_softBC,__o_softCA);
	return __this;
}

::hx::ObjectPtr< TriangleSoftShape_obj > TriangleSoftShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_aX,::hx::Null< Float >  __o_aY,::hx::Null< Float >  __o_bX,::hx::Null< Float >  __o_bY,::hx::Null< Float >  __o_cX,::hx::Null< Float >  __o_cY,::hx::Null< Float >  __o_soft3,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCA) {
	TriangleSoftShape_obj *__this = (TriangleSoftShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TriangleSoftShape_obj), true, "pixelimage.triangleGML.contour.TriangleSoftShape"));
	*(void **)__this = TriangleSoftShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_aX,__o_aY,__o_bX,__o_bY,__o_cX,__o_cY,__o_soft3,__o_softAB,__o_softBC,__o_softCA);
	return __this;
}

TriangleSoftShape_obj::TriangleSoftShape_obj()
{
}

::hx::Val TriangleSoftShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"aX") ) { return ::hx::Val( aX ); }
		if (HX_FIELD_EQ(inName,"aY") ) { return ::hx::Val( aY ); }
		if (HX_FIELD_EQ(inName,"bX") ) { return ::hx::Val( bX ); }
		if (HX_FIELD_EQ(inName,"bY") ) { return ::hx::Val( bY ); }
		if (HX_FIELD_EQ(inName,"cX") ) { return ::hx::Val( cX ); }
		if (HX_FIELD_EQ(inName,"cY") ) { return ::hx::Val( cY ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"soft3") ) { return ::hx::Val( soft3 ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"softAB") ) { return ::hx::Val( softAB ); }
		if (HX_FIELD_EQ(inName,"softBC") ) { return ::hx::Val( softBC ); }
		if (HX_FIELD_EQ(inName,"softCA") ) { return ::hx::Val( softCA ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val TriangleSoftShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"aX") ) { aX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"aY") ) { aY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bX") ) { bX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bY") ) { bY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cX") ) { cX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cY") ) { cY=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"soft3") ) { soft3=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"softAB") ) { softAB=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"softBC") ) { softBC=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"softCA") ) { softCA=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TriangleSoftShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("aX",d7,54,00,00));
	outFields->push(HX_("aY",d8,54,00,00));
	outFields->push(HX_("bX",b6,55,00,00));
	outFields->push(HX_("bY",b7,55,00,00));
	outFields->push(HX_("cX",95,56,00,00));
	outFields->push(HX_("cY",96,56,00,00));
	outFields->push(HX_("soft3",09,30,c1,80));
	outFields->push(HX_("softAB",4b,e4,48,28));
	outFields->push(HX_("softBC",2b,e5,48,28));
	outFields->push(HX_("softCA",08,e6,48,28));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TriangleSoftShape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(TriangleSoftShape_obj,aX),HX_("aX",d7,54,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleSoftShape_obj,aY),HX_("aY",d8,54,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleSoftShape_obj,bX),HX_("bX",b6,55,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleSoftShape_obj,bY),HX_("bY",b7,55,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleSoftShape_obj,cX),HX_("cX",95,56,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleSoftShape_obj,cY),HX_("cY",96,56,00,00)},
	{::hx::fsFloat,(int)offsetof(TriangleSoftShape_obj,soft3),HX_("soft3",09,30,c1,80)},
	{::hx::fsBool,(int)offsetof(TriangleSoftShape_obj,softAB),HX_("softAB",4b,e4,48,28)},
	{::hx::fsBool,(int)offsetof(TriangleSoftShape_obj,softBC),HX_("softBC",2b,e5,48,28)},
	{::hx::fsBool,(int)offsetof(TriangleSoftShape_obj,softCA),HX_("softCA",08,e6,48,28)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *TriangleSoftShape_obj_sStaticStorageInfo = 0;
#endif

static ::String TriangleSoftShape_obj_sMemberFields[] = {
	HX_("aX",d7,54,00,00),
	HX_("aY",d8,54,00,00),
	HX_("bX",b6,55,00,00),
	HX_("bY",b7,55,00,00),
	HX_("cX",95,56,00,00),
	HX_("cY",96,56,00,00),
	HX_("soft3",09,30,c1,80),
	HX_("softAB",4b,e4,48,28),
	HX_("softBC",2b,e5,48,28),
	HX_("softCA",08,e6,48,28),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class TriangleSoftShape_obj::__mClass;

void TriangleSoftShape_obj::__register()
{
	TriangleSoftShape_obj _hx_dummy;
	TriangleSoftShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.contour.TriangleSoftShape",52,35,58,63);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TriangleSoftShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TriangleSoftShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TriangleSoftShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TriangleSoftShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace contour
