// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_contour_LineShape
#include <pixelimage/triangleGML/contour/LineShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_cf12637b25404790_27_new,"pixelimage.triangleGML.contour.LineShape","new",0x2e1e2be2,"pixelimage.triangleGML.contour.LineShape.new","pixelimage/triangleGML/contour/LineShape.hx",27,0x5af6edd1)
HX_LOCAL_STACK_FRAME(_hx_pos_cf12637b25404790_37_setParameter,"pixelimage.triangleGML.contour.LineShape","setParameter",0x546319e5,"pixelimage.triangleGML.contour.LineShape.setParameter","pixelimage/triangleGML/contour/LineShape.hx",37,0x5af6edd1)
HX_LOCAL_STACK_FRAME(_hx_pos_cf12637b25404790_55_render,"pixelimage.triangleGML.contour.LineShape","render",0x8df7ad14,"pixelimage.triangleGML.contour.LineShape.render","pixelimage/triangleGML/contour/LineShape.hx",55,0x5af6edd1)
namespace pixelimage{
namespace triangleGML{
namespace contour{

void LineShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_luxury){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(-1048576);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		Float x1 = __o_x1.Default(((Float)0.));
            		Float y1 = __o_y1.Default(((Float)0.));
            		Float x2 = __o_x2.Default(((Float)0.));
            		Float y2 = __o_y2.Default(((Float)0.));
            		Float soft = __o_soft.Default(((Float)0.));
            		bool luxury = __o_luxury.Default(false);
            	HX_STACKFRAME(&_hx_pos_cf12637b25404790_27_new)
HXLINE(  28)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
HXLINE(  29)		this->x1 = x1;
HXLINE(  30)		this->y1 = y1;
HXLINE(  31)		this->x2 = x2;
HXLINE(  32)		this->y2 = y2;
HXLINE(  33)		this->soft = soft;
HXLINE(  34)		this->luxury = luxury;
            	}

Dynamic LineShape_obj::__CreateEmpty() { return new LineShape_obj; }

void *LineShape_obj::_hx_vtable = 0;

Dynamic LineShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LineShape_obj > _hx_result = new LineShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10]);
	return _hx_result;
}

bool LineShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x5724fb74;
	}
}

void LineShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_cf12637b25404790_37_setParameter)
HXDLIN(  37)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("luxury",0d,9d,17,dc)) ){
HXLINE(  49)			bool _hx_tmp;
HXDLIN(  49)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  49)				_hx_tmp = true;
            			}
            			else {
HXLINE(  49)				_hx_tmp = false;
            			}
HXDLIN(  49)			this->luxury = _hx_tmp;
HXLINE(  50)			::haxe::Log_obj::trace((HX_("setting luxury ",e3,03,9c,5a) + value),::hx::SourceInfo(HX_("pixelimage/triangleGML/contour/LineShape.hx",d1,ed,f6,5a),50,HX_("pixelimage.triangleGML.contour.LineShape",f0,52,a6,b8),HX_("setParameter",a7,f5,ff,6c)));
HXLINE(  48)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("soft",ea,1c,58,4c)) ){
HXLINE(  47)			this->soft = ::Std_obj::parseFloat(value);
HXDLIN(  47)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x1",b9,68,00,00)) ){
HXLINE(  39)			this->x1 = ::Std_obj::parseFloat(value);
HXDLIN(  39)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x2",ba,68,00,00)) ){
HXLINE(  43)			this->x2 = ::Std_obj::parseFloat(value);
HXDLIN(  43)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y1",98,69,00,00)) ){
HXLINE(  41)			this->y1 = ::Std_obj::parseFloat(value);
HXDLIN(  41)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y2",99,69,00,00)) ){
HXLINE(  45)			this->y2 = ::Std_obj::parseFloat(value);
HXDLIN(  45)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  52)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct LineShape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_cf12637b25404790_55_render)
HXLINE(  56)		Float px = (this->x1 + this->offX);
HXLINE(  57)		Float qx = (this->x2 + this->offX);
HXLINE(  58)		Float py = (this->y1 + this->offY);
HXLINE(  59)		Float qy = (this->y2 + this->offY);
HXLINE(  60)		if ((this->soft == ((Float)0.))) {
HXLINE(  61)			int color = this->strokeColor;
HXDLIN(  61)			bool hasHit = true;
HXDLIN(  61)			Float o = (qy - py);
HXDLIN(  61)			Float a = (qx - px);
HXDLIN(  61)			Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  61)			Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  61)			{
HXLINE(  61)				 ::Dynamic debugCorners = false;
HXDLIN(  61)				if (::hx::IsNull( debugCorners )) {
HXLINE( 878)					debugCorners = false;
            				}
HXLINE(  61)				Float sin = ::Math_obj::sin(theta);
HXDLIN(  61)				Float cos = ::Math_obj::cos(theta);
HXDLIN(  61)				Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  61)				Float dx = ((Float)0.1);
HXDLIN(  61)				Float dy = radius;
HXDLIN(  61)				Float cx = h;
HXDLIN(  61)				Float cy = radius;
HXDLIN(  61)				Float bx = h;
HXDLIN(  61)				Float by = -(radius);
HXDLIN(  61)				Float ax = ((Float)0.1);
HXDLIN(  61)				Float ay = -(radius);
HXDLIN(  61)				Float temp = ((Float)0.);
HXLINE(  28)				temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  29)				ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  30)				ax = temp;
HXLINE(  32)				temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  33)				by = (py + ((by * cos) + (bx * sin)));
HXLINE(  34)				bx = temp;
HXLINE(  36)				temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  37)				cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  38)				cx = temp;
HXLINE(  40)				temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  41)				dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  42)				dx = temp;
HXLINE(  61)				if (( (bool)(debugCorners) )) {
HXLINE(  61)					{
HXLINE(  61)						Float x = (ax - ((Float)6.));
HXDLIN(  61)						Float y = (ay - ((Float)6.));
HXDLIN(  61)						int p = ::Std_obj::_hx_int(x);
HXDLIN(  61)						int xx = p;
HXDLIN(  61)						int q = ::Std_obj::_hx_int(y);
HXDLIN(  61)						int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  61)						int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  61)						while(true){
HXLINE(  61)							{
HXLINE(  61)								p = (p + 1);
HXDLIN(  61)								int x = (p - 1);
HXDLIN(  61)								int this1 = -65536;
HXDLIN(  61)								int c = this1;
HXDLIN(  61)								bool _hx_tmp;
HXDLIN(  61)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp = false;
            								}
HXDLIN(  61)								if (_hx_tmp) {
HXLINE(  61)									int location;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)									int this3 = this2;
HXDLIN(  61)									int this4;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this4 = this3;
            									}
HXDLIN(  61)									Float a1;
HXDLIN(  61)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)									if ((this5 == 0)) {
HXLINE(  61)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r1;
HXDLIN(  61)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)									if ((this6 == 0)) {
HXLINE(  61)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g1;
HXDLIN(  61)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)									if ((this7 == 0)) {
HXLINE(  61)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b1;
HXDLIN(  61)									int this8 = (this4 & 255);
HXDLIN(  61)									if ((this8 == 0)) {
HXLINE(  61)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a2;
HXDLIN(  61)									int this9 = ((-65536 >> 24) & 255);
HXDLIN(  61)									if ((this9 == 0)) {
HXLINE(  61)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r2;
HXDLIN(  61)									int this10 = ((-65536 >> 16) & 255);
HXDLIN(  61)									if ((this10 == 0)) {
HXLINE(  61)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g2;
HXDLIN(  61)									int this11 = ((-65536 >> 8) & 255);
HXDLIN(  61)									if ((this11 == 0)) {
HXLINE(  61)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b2;
HXDLIN(  61)									int this12 = (-65536 & 255);
HXDLIN(  61)									if ((this12 == 0)) {
HXLINE(  61)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)									{
HXLINE(  61)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)										int value;
HXDLIN(  61)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  61)											value = blended;
            										}
HXDLIN(  61)										bool _hx_tmp;
HXDLIN(  61)										if ((location >= 0)) {
HXLINE(  61)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  61)											_hx_tmp = false;
            										}
HXDLIN(  61)										if (_hx_tmp) {
HXLINE(  61)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									int index;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									int value;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  61)										value = c;
            									}
HXDLIN(  61)									bool _hx_tmp;
HXDLIN(  61)									if ((index >= 0)) {
HXLINE(  61)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  61)										_hx_tmp = false;
            									}
HXDLIN(  61)									if (_hx_tmp) {
HXLINE(  61)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  61)							if ((p > maxX)) {
HXLINE( 247)								p = xx;
HXLINE(  61)								q = (q + 1);
            							}
HXDLIN(  61)							if ((q > maxY)) {
HXLINE(  61)								goto _hx_goto_3;
            							}
            						}
            						_hx_goto_3:;
            					}
HXDLIN(  61)					{
HXLINE(  61)						Float x1 = (bx - ((Float)6.));
HXDLIN(  61)						Float y1 = (by - ((Float)6.));
HXDLIN(  61)						int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  61)						int xx1 = p1;
HXDLIN(  61)						int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  61)						int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  61)						int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  61)						while(true){
HXLINE(  61)							{
HXLINE(  61)								p1 = (p1 + 1);
HXDLIN(  61)								int x = (p1 - 1);
HXDLIN(  61)								int this1 = -16711936;
HXDLIN(  61)								int c = this1;
HXDLIN(  61)								bool _hx_tmp;
HXDLIN(  61)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp = false;
            								}
HXDLIN(  61)								if (_hx_tmp) {
HXLINE(  61)									int location;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)									int this3 = this2;
HXDLIN(  61)									int this4;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this4 = this3;
            									}
HXDLIN(  61)									Float a1;
HXDLIN(  61)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)									if ((this5 == 0)) {
HXLINE(  61)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r1;
HXDLIN(  61)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)									if ((this6 == 0)) {
HXLINE(  61)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g1;
HXDLIN(  61)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)									if ((this7 == 0)) {
HXLINE(  61)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b1;
HXDLIN(  61)									int this8 = (this4 & 255);
HXDLIN(  61)									if ((this8 == 0)) {
HXLINE(  61)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a2;
HXDLIN(  61)									int this9 = ((-16711936 >> 24) & 255);
HXDLIN(  61)									if ((this9 == 0)) {
HXLINE(  61)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r2;
HXDLIN(  61)									int this10 = ((-16711936 >> 16) & 255);
HXDLIN(  61)									if ((this10 == 0)) {
HXLINE(  61)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g2;
HXDLIN(  61)									int this11 = ((-16711936 >> 8) & 255);
HXDLIN(  61)									if ((this11 == 0)) {
HXLINE(  61)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b2;
HXDLIN(  61)									int this12 = (-16711936 & 255);
HXDLIN(  61)									if ((this12 == 0)) {
HXLINE(  61)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)									{
HXLINE(  61)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)										int value;
HXDLIN(  61)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  61)											value = blended;
            										}
HXDLIN(  61)										bool _hx_tmp;
HXDLIN(  61)										if ((location >= 0)) {
HXLINE(  61)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  61)											_hx_tmp = false;
            										}
HXDLIN(  61)										if (_hx_tmp) {
HXLINE(  61)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									int index;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									int value;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  61)										value = c;
            									}
HXDLIN(  61)									bool _hx_tmp;
HXDLIN(  61)									if ((index >= 0)) {
HXLINE(  61)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  61)										_hx_tmp = false;
            									}
HXDLIN(  61)									if (_hx_tmp) {
HXLINE(  61)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  61)							if ((p1 > maxX1)) {
HXLINE( 247)								p1 = xx1;
HXLINE(  61)								q1 = (q1 + 1);
            							}
HXDLIN(  61)							if ((q1 > maxY1)) {
HXLINE(  61)								goto _hx_goto_4;
            							}
            						}
            						_hx_goto_4:;
            					}
HXDLIN(  61)					{
HXLINE(  61)						Float x2 = (cx - ((Float)6.));
HXDLIN(  61)						Float y2 = (cy - ((Float)6.));
HXDLIN(  61)						int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  61)						int xx2 = p2;
HXDLIN(  61)						int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  61)						int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  61)						int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  61)						while(true){
HXLINE(  61)							{
HXLINE(  61)								p2 = (p2 + 1);
HXDLIN(  61)								int x = (p2 - 1);
HXDLIN(  61)								int this1 = -16776961;
HXDLIN(  61)								int c = this1;
HXDLIN(  61)								bool _hx_tmp;
HXDLIN(  61)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp = false;
            								}
HXDLIN(  61)								if (_hx_tmp) {
HXLINE(  61)									int location;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)									int this3 = this2;
HXDLIN(  61)									int this4;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this4 = this3;
            									}
HXDLIN(  61)									Float a1;
HXDLIN(  61)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)									if ((this5 == 0)) {
HXLINE(  61)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r1;
HXDLIN(  61)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)									if ((this6 == 0)) {
HXLINE(  61)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g1;
HXDLIN(  61)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)									if ((this7 == 0)) {
HXLINE(  61)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b1;
HXDLIN(  61)									int this8 = (this4 & 255);
HXDLIN(  61)									if ((this8 == 0)) {
HXLINE(  61)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a2;
HXDLIN(  61)									int this9 = ((-16776961 >> 24) & 255);
HXDLIN(  61)									if ((this9 == 0)) {
HXLINE(  61)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r2;
HXDLIN(  61)									int this10 = ((-16776961 >> 16) & 255);
HXDLIN(  61)									if ((this10 == 0)) {
HXLINE(  61)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g2;
HXDLIN(  61)									int this11 = ((-16776961 >> 8) & 255);
HXDLIN(  61)									if ((this11 == 0)) {
HXLINE(  61)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b2;
HXDLIN(  61)									int this12 = (-16776961 & 255);
HXDLIN(  61)									if ((this12 == 0)) {
HXLINE(  61)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)									{
HXLINE(  61)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)										int value;
HXDLIN(  61)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  61)											value = blended;
            										}
HXDLIN(  61)										bool _hx_tmp;
HXDLIN(  61)										if ((location >= 0)) {
HXLINE(  61)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  61)											_hx_tmp = false;
            										}
HXDLIN(  61)										if (_hx_tmp) {
HXLINE(  61)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									int index;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									int value;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  61)										value = c;
            									}
HXDLIN(  61)									bool _hx_tmp;
HXDLIN(  61)									if ((index >= 0)) {
HXLINE(  61)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  61)										_hx_tmp = false;
            									}
HXDLIN(  61)									if (_hx_tmp) {
HXLINE(  61)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  61)							if ((p2 > maxX2)) {
HXLINE( 247)								p2 = xx2;
HXLINE(  61)								q2 = (q2 + 1);
            							}
HXDLIN(  61)							if ((q2 > maxY2)) {
HXLINE(  61)								goto _hx_goto_5;
            							}
            						}
            						_hx_goto_5:;
            					}
HXDLIN(  61)					{
HXLINE(  61)						Float x3 = (dx - ((Float)6.));
HXDLIN(  61)						Float y3 = (dy - ((Float)6.));
HXDLIN(  61)						int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  61)						int xx3 = p3;
HXDLIN(  61)						int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  61)						int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  61)						int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  61)						while(true){
HXLINE(  61)							{
HXLINE(  61)								p3 = (p3 + 1);
HXDLIN(  61)								int x = (p3 - 1);
HXDLIN(  61)								int this1 = -1048336;
HXDLIN(  61)								int c = this1;
HXDLIN(  61)								bool _hx_tmp;
HXDLIN(  61)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  61)									_hx_tmp = false;
            								}
HXDLIN(  61)								if (_hx_tmp) {
HXLINE(  61)									int location;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										location = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)									int this3 = this2;
HXDLIN(  61)									int this4;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										this4 = this3;
            									}
HXDLIN(  61)									Float a1;
HXDLIN(  61)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)									if ((this5 == 0)) {
HXLINE(  61)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r1;
HXDLIN(  61)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)									if ((this6 == 0)) {
HXLINE(  61)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g1;
HXDLIN(  61)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)									if ((this7 == 0)) {
HXLINE(  61)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b1;
HXDLIN(  61)									int this8 = (this4 & 255);
HXDLIN(  61)									if ((this8 == 0)) {
HXLINE(  61)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a2;
HXDLIN(  61)									int this9 = ((-1048336 >> 24) & 255);
HXDLIN(  61)									if ((this9 == 0)) {
HXLINE(  61)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float r2;
HXDLIN(  61)									int this10 = ((-1048336 >> 16) & 255);
HXDLIN(  61)									if ((this10 == 0)) {
HXLINE(  61)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float g2;
HXDLIN(  61)									int this11 = ((-1048336 >> 8) & 255);
HXDLIN(  61)									if ((this11 == 0)) {
HXLINE(  61)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float b2;
HXDLIN(  61)									int this12 = (-1048336 & 255);
HXDLIN(  61)									if ((this12 == 0)) {
HXLINE(  61)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  61)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  61)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)									{
HXLINE(  61)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)										int value;
HXDLIN(  61)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  61)											value = blended;
            										}
HXDLIN(  61)										bool _hx_tmp;
HXDLIN(  61)										if ((location >= 0)) {
HXLINE(  61)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  61)											_hx_tmp = false;
            										}
HXDLIN(  61)										if (_hx_tmp) {
HXLINE(  61)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  61)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)									int index;
HXDLIN(  61)									if (pixelShape->useVirtualPos) {
HXLINE(  61)										index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  61)										index = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            									}
HXDLIN(  61)									int value;
HXDLIN(  61)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  61)										value = c;
            									}
HXDLIN(  61)									bool _hx_tmp;
HXDLIN(  61)									if ((index >= 0)) {
HXLINE(  61)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  61)										_hx_tmp = false;
            									}
HXDLIN(  61)									if (_hx_tmp) {
HXLINE(  61)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  61)							if ((p3 > maxX3)) {
HXLINE( 247)								p3 = xx3;
HXLINE(  61)								q3 = (q3 + 1);
            							}
HXDLIN(  61)							if ((q3 > maxY3)) {
HXLINE(  61)								goto _hx_goto_6;
            							}
            						}
            						_hx_goto_6:;
            					}
            				}
HXDLIN(  61)				{
HXLINE(  61)					{
HXLINE(  61)						Float bx1 = bx;
HXDLIN(  61)						Float by1 = by;
HXDLIN(  61)						Float cx1 = dx;
HXDLIN(  61)						Float cy1 = dy;
HXDLIN(  61)						bool hasUndo = false;
HXDLIN(  61)						bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  61)						if (!(adjustWinding)) {
HXLINE(  61)							Float bx_ = bx1;
HXDLIN(  61)							Float by_ = by1;
HXLINE(  26)							bx1 = cx1;
HXLINE(  27)							by1 = cy1;
HXLINE(  28)							cx1 = bx_;
HXLINE(  29)							cy1 = by_;
            						}
HXLINE(  61)						{
HXLINE(  61)							Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  61)							Float sx = (cy1 - ay);
HXDLIN(  61)							Float sy = (ax - cx1);
HXDLIN(  61)							Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  61)							Float tx = (ay - by1);
HXDLIN(  61)							Float ty = (bx1 - ax);
HXDLIN(  61)							Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  61)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  61)							if ((ax > bx1)) {
HXLINE(  61)								if ((ax > cx1)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((bx1 > cx1)) {
HXLINE(  61)										min = ::Math_obj::floor(cx1);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::floor(bx1);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter3 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  61)								if ((bx1 > cx1)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((ax > cx1)) {
HXLINE(  61)										min = ::Math_obj::floor(cx1);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::ceil(ax);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter3 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(ax);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter3 = this1;
            								}
            							}
HXDLIN(  61)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  61)							if ((ay > by1)) {
HXLINE(  61)								if ((ay > cy1)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((by1 > cy1)) {
HXLINE(  61)										min = ::Math_obj::floor(cy1);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::floor(by1);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter3 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(by1);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  61)								if ((by1 > cy1)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((ay > cy1)) {
HXLINE(  61)										min = ::Math_obj::floor(cy1);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::ceil(ay);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter3 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(ay);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter3 = this1;
            								}
            							}
HXDLIN(  61)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  61)							if (hasUndo) {
HXLINE(  61)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  61)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  61)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  61)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  61)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  61)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  61)								undoImage = this3;
HXDLIN(  61)								{
HXLINE(  61)									int rectLeft = xIter3->start;
HXDLIN(  61)									int rectTop = yIter3->start;
HXDLIN(  61)									int rectRight = xIter3->max;
HXDLIN(  61)									bool forceClear = false;
HXDLIN(  61)									{
HXLINE(  61)										int _g = rectTop;
HXDLIN(  61)										int _g1 = yIter3->max;
HXDLIN(  61)										while((_g < _g1)){
HXLINE(  61)											_g = (_g + 1);
HXDLIN(  61)											int dy = (_g - 1);
HXDLIN(  61)											{
HXLINE(  61)												int _g1 = rectLeft;
HXDLIN(  61)												int _g2 = rectRight;
HXDLIN(  61)												while((_g1 < _g2)){
HXLINE(  61)													_g1 = (_g1 + 1);
HXDLIN(  61)													int dx = (_g1 - 1);
HXDLIN(  61)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)													int index;
HXDLIN(  61)													if (pixelShape->useVirtualPos) {
HXLINE(  61)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  61)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  61)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)													int col;
HXDLIN(  61)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  61)														col = c;
            													}
HXDLIN(  61)													bool _hx_tmp;
HXDLIN(  61)													if (pixelShape->useMask) {
HXLINE(  61)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  61)														_hx_tmp = false;
            													}
HXDLIN(  61)													if (_hx_tmp) {
HXLINE(  61)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  61)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  61)														int index;
HXDLIN(  61)														if (this1->useVirtualPos) {
HXLINE(  61)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  61)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  61)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  61)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  61)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)														int v;
HXDLIN(  61)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  61)															v = c;
            														}
HXDLIN(  61)														int this3 = v;
HXDLIN(  61)														int maskPixel = this3;
HXDLIN(  61)														int this4 = col;
HXDLIN(  61)														int this5 = this4;
HXDLIN(  61)														if ((maskPixel == 0)) {
HXLINE(  61)															int this1 = this5;
HXDLIN(  61)															col = this1;
            														}
            														else {
HXLINE(  61)															Float m0;
HXDLIN(  61)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  61)															if ((this1 == 0)) {
HXLINE(  61)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m1;
HXDLIN(  61)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  61)															if ((this2 == 0)) {
HXLINE(  61)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m2;
HXDLIN(  61)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  61)															if ((this3 == 0)) {
HXLINE(  61)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m3;
HXDLIN(  61)															int this4 = (maskPixel & 255);
HXDLIN(  61)															if ((this4 == 0)) {
HXLINE(  61)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  61)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  61)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  61)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  61)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  61)													if ((col != 0)) {
HXLINE(  61)														int x = (dx - rectLeft);
HXDLIN(  61)														int y = (dy - rectTop);
HXDLIN(  61)														int this1 = col;
HXDLIN(  61)														int c = this1;
HXDLIN(  61)														bool _hx_tmp;
HXDLIN(  61)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE(  61)															_hx_tmp = false;
            														}
HXDLIN(  61)														if (_hx_tmp) {
HXLINE(  61)															int location;
HXDLIN(  61)															if (undoImage->useVirtualPos) {
HXLINE(  61)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  61)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  61)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)															int this3 = this2;
HXDLIN(  61)															int this4;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  61)																this4 = this3;
            															}
HXDLIN(  61)															Float a1;
HXDLIN(  61)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)															if ((this5 == 0)) {
HXLINE(  61)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r1;
HXDLIN(  61)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)															if ((this6 == 0)) {
HXLINE(  61)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g1;
HXDLIN(  61)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)															if ((this7 == 0)) {
HXLINE(  61)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b1;
HXDLIN(  61)															int this8 = (this4 & 255);
HXDLIN(  61)															if ((this8 == 0)) {
HXLINE(  61)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a2;
HXDLIN(  61)															int this9 = ((col >> 24) & 255);
HXDLIN(  61)															if ((this9 == 0)) {
HXLINE(  61)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r2;
HXDLIN(  61)															int this10 = ((col >> 16) & 255);
HXDLIN(  61)															if ((this10 == 0)) {
HXLINE(  61)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g2;
HXDLIN(  61)															int this11 = ((col >> 8) & 255);
HXDLIN(  61)															if ((this11 == 0)) {
HXLINE(  61)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b2;
HXDLIN(  61)															int this12 = (col & 255);
HXDLIN(  61)															if ((this12 == 0)) {
HXLINE(  61)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)															{
HXLINE(  61)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  61)																int value;
HXDLIN(  61)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  61)																	value = blended;
            																}
HXDLIN(  61)																bool _hx_tmp;
HXDLIN(  61)																if ((location >= 0)) {
HXLINE(  61)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  61)																	_hx_tmp = false;
            																}
HXDLIN(  61)																if (_hx_tmp) {
HXLINE(  61)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  61)															int index;
HXDLIN(  61)															if (undoImage->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  61)															int value;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  61)																value = c;
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  61)														if (forceClear) {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  61)															int x = (dx - rectLeft);
HXDLIN(  61)															int y = (dy - rectTop);
HXDLIN(  61)															int index;
HXDLIN(  61)															if (undoImage->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							bool found = false;
HXDLIN(  61)							Float s = ((Float)0.);
HXDLIN(  61)							Float t = ((Float)0.);
HXDLIN(  61)							Float sxx = ((Float)0.);
HXDLIN(  61)							Float txx = ((Float)0.);
HXDLIN(  61)							{
HXLINE(  61)								int _g_min = xIter3->start;
HXDLIN(  61)								int _g_max = xIter3->max;
HXDLIN(  61)								while((_g_min < _g_max)){
HXLINE(  61)									_g_min = (_g_min + 1);
HXDLIN(  61)									int x = (_g_min - 1);
HXDLIN(  61)									sxx = (sx * ( (Float)(x) ));
HXLINE(  62)									txx = (tx * ( (Float)(x) ));
HXLINE(  63)									found = false;
HXLINE(  61)									{
HXLINE(  61)										int _g_min1 = yIter3->start;
HXDLIN(  61)										int _g_max = yIter3->max;
HXDLIN(  61)										while((_g_min1 < _g_max)){
HXLINE(  61)											_g_min1 = (_g_min1 + 1);
HXDLIN(  61)											int y = (_g_min1 - 1);
HXLINE(  65)											s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)											t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  61)											bool _hx_tmp;
HXDLIN(  61)											if (!((s <= 0))) {
HXLINE(  61)												_hx_tmp = (t <= 0);
            											}
            											else {
HXLINE(  61)												_hx_tmp = true;
            											}
HXDLIN(  61)											if (_hx_tmp) {
HXLINE(  61)												if (found) {
HXLINE(  61)													goto _hx_goto_10;
            												}
            											}
            											else {
HXLINE(  61)												if (((s + t) < A)) {
HXLINE(  61)													{
HXLINE(  61)														int this1 = color;
HXDLIN(  61)														int c = this1;
HXDLIN(  61)														bool _hx_tmp;
HXDLIN(  61)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)															_hx_tmp = pixelShape->transparent;
            														}
            														else {
HXLINE(  61)															_hx_tmp = false;
            														}
HXDLIN(  61)														if (_hx_tmp) {
HXLINE(  61)															int location;
HXDLIN(  61)															if (pixelShape->useVirtualPos) {
HXLINE(  61)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  61)																location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  61)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)															int this3 = this2;
HXDLIN(  61)															int this4;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  61)																this4 = this3;
            															}
HXDLIN(  61)															Float a1;
HXDLIN(  61)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)															if ((this5 == 0)) {
HXLINE(  61)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r1;
HXDLIN(  61)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)															if ((this6 == 0)) {
HXLINE(  61)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g1;
HXDLIN(  61)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)															if ((this7 == 0)) {
HXLINE(  61)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b1;
HXDLIN(  61)															int this8 = (this4 & 255);
HXDLIN(  61)															if ((this8 == 0)) {
HXLINE(  61)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a2;
HXDLIN(  61)															int this9 = ((color >> 24) & 255);
HXDLIN(  61)															if ((this9 == 0)) {
HXLINE(  61)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r2;
HXDLIN(  61)															int this10 = ((color >> 16) & 255);
HXDLIN(  61)															if ((this10 == 0)) {
HXLINE(  61)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g2;
HXDLIN(  61)															int this11 = ((color >> 8) & 255);
HXDLIN(  61)															if ((this11 == 0)) {
HXLINE(  61)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b2;
HXDLIN(  61)															int this12 = (color & 255);
HXDLIN(  61)															if ((this12 == 0)) {
HXLINE(  61)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)															{
HXLINE(  61)																::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)																int value;
HXDLIN(  61)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  61)																	value = blended;
            																}
HXDLIN(  61)																bool _hx_tmp;
HXDLIN(  61)																if ((location >= 0)) {
HXLINE(  61)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  61)																	_hx_tmp = false;
            																}
HXDLIN(  61)																if (_hx_tmp) {
HXLINE(  61)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)															int index;
HXDLIN(  61)															if (pixelShape->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  61)															int value;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  61)																value = c;
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE(  74)													found = true;
            												}
            												else {
HXLINE(  61)													if (found) {
HXLINE(  61)														goto _hx_goto_10;
            													}
            												}
            											}
            										}
            										_hx_goto_10:;
            									}
            								}
            							}
HXDLIN(  61)							if ((hasHit == true)) {
HXLINE(  61)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  61)								if (hasUndo) {
HXLINE(  61)									v->undoImage = undoImage;
HXDLIN(  61)									v->undoX = xIter3->start;
HXDLIN(  61)									v->undoY = yIter3->start;
            								}
            							}
            						}
            					}
HXDLIN(  61)					{
HXLINE(  61)						Float bx2 = cx;
HXDLIN(  61)						Float by2 = cy;
HXDLIN(  61)						Float cx2 = dx;
HXDLIN(  61)						Float cy2 = dy;
HXDLIN(  61)						bool hasUndo1 = false;
HXDLIN(  61)						bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  61)						if (!(adjustWinding1)) {
HXLINE(  61)							Float bx_ = bx2;
HXDLIN(  61)							Float by_ = by2;
HXLINE(  26)							bx2 = cx2;
HXLINE(  27)							by2 = cy2;
HXLINE(  28)							cx2 = bx_;
HXLINE(  29)							cy2 = by_;
            						}
HXLINE(  61)						{
HXLINE(  61)							Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  61)							Float sx1 = (cy2 - by);
HXDLIN(  61)							Float sy1 = (bx - cx2);
HXDLIN(  61)							Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  61)							Float tx1 = (by - by2);
HXDLIN(  61)							Float ty1 = (bx2 - bx);
HXDLIN(  61)							Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  61)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  61)							if ((bx > bx2)) {
HXLINE(  61)								if ((bx > cx2)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((bx2 > cx2)) {
HXLINE(  61)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::floor(bx2);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter31 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  61)								if ((bx2 > cx2)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((bx > cx2)) {
HXLINE(  61)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter31 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									xIter31 = this1;
            								}
            							}
HXDLIN(  61)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  61)							if ((by > by2)) {
HXLINE(  61)								if ((by > cy2)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((by2 > cy2)) {
HXLINE(  61)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::floor(by2);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter31 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(by2);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  61)								if ((by2 > cy2)) {
HXLINE(  61)									int min;
HXDLIN(  61)									if ((by > cy2)) {
HXLINE(  61)										min = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  61)										min = ::Math_obj::ceil(by);
            									}
HXDLIN(  61)									int ii_min = min;
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter31 = this1;
            								}
            								else {
HXLINE(  61)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  61)									int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  61)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  61)									yIter31 = this1;
            								}
            							}
HXDLIN(  61)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  61)							if (hasUndo1) {
HXLINE(  61)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  61)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  61)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  61)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  61)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  61)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  61)								undoImage1 = this3;
HXDLIN(  61)								{
HXLINE(  61)									int rectLeft = xIter31->start;
HXDLIN(  61)									int rectTop = yIter31->start;
HXDLIN(  61)									int rectRight = xIter31->max;
HXDLIN(  61)									bool forceClear = false;
HXDLIN(  61)									{
HXLINE(  61)										int _g = rectTop;
HXDLIN(  61)										int _g1 = yIter31->max;
HXDLIN(  61)										while((_g < _g1)){
HXLINE(  61)											_g = (_g + 1);
HXDLIN(  61)											int dy = (_g - 1);
HXDLIN(  61)											{
HXLINE(  61)												int _g1 = rectLeft;
HXDLIN(  61)												int _g2 = rectRight;
HXDLIN(  61)												while((_g1 < _g2)){
HXLINE(  61)													_g1 = (_g1 + 1);
HXDLIN(  61)													int dx = (_g1 - 1);
HXDLIN(  61)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)													int index;
HXDLIN(  61)													if (pixelShape->useVirtualPos) {
HXLINE(  61)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  61)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  61)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)													int col;
HXDLIN(  61)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  61)														col = c;
            													}
HXDLIN(  61)													bool _hx_tmp;
HXDLIN(  61)													if (pixelShape->useMask) {
HXLINE(  61)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  61)														_hx_tmp = false;
            													}
HXDLIN(  61)													if (_hx_tmp) {
HXLINE(  61)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  61)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  61)														int index;
HXDLIN(  61)														if (this1->useVirtualPos) {
HXLINE(  61)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  61)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  61)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  61)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  61)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)														int v;
HXDLIN(  61)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  61)															v = c;
            														}
HXDLIN(  61)														int this3 = v;
HXDLIN(  61)														int maskPixel = this3;
HXDLIN(  61)														int this4 = col;
HXDLIN(  61)														int this5 = this4;
HXDLIN(  61)														if ((maskPixel == 0)) {
HXLINE(  61)															int this1 = this5;
HXDLIN(  61)															col = this1;
            														}
            														else {
HXLINE(  61)															Float m0;
HXDLIN(  61)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  61)															if ((this1 == 0)) {
HXLINE(  61)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m1;
HXDLIN(  61)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  61)															if ((this2 == 0)) {
HXLINE(  61)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m2;
HXDLIN(  61)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  61)															if ((this3 == 0)) {
HXLINE(  61)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float m3;
HXDLIN(  61)															int this4 = (maskPixel & 255);
HXDLIN(  61)															if ((this4 == 0)) {
HXLINE(  61)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  61)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  61)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  61)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  61)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  61)													if ((col != 0)) {
HXLINE(  61)														int x = (dx - rectLeft);
HXDLIN(  61)														int y = (dy - rectTop);
HXDLIN(  61)														int this1 = col;
HXDLIN(  61)														int c = this1;
HXDLIN(  61)														bool _hx_tmp;
HXDLIN(  61)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE(  61)															_hx_tmp = false;
            														}
HXDLIN(  61)														if (_hx_tmp) {
HXLINE(  61)															int location;
HXDLIN(  61)															if (undoImage1->useVirtualPos) {
HXLINE(  61)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  61)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  61)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)															int this3 = this2;
HXDLIN(  61)															int this4;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  61)																this4 = this3;
            															}
HXDLIN(  61)															Float a1;
HXDLIN(  61)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)															if ((this5 == 0)) {
HXLINE(  61)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r1;
HXDLIN(  61)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)															if ((this6 == 0)) {
HXLINE(  61)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g1;
HXDLIN(  61)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)															if ((this7 == 0)) {
HXLINE(  61)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b1;
HXDLIN(  61)															int this8 = (this4 & 255);
HXDLIN(  61)															if ((this8 == 0)) {
HXLINE(  61)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a2;
HXDLIN(  61)															int this9 = ((col >> 24) & 255);
HXDLIN(  61)															if ((this9 == 0)) {
HXLINE(  61)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r2;
HXDLIN(  61)															int this10 = ((col >> 16) & 255);
HXDLIN(  61)															if ((this10 == 0)) {
HXLINE(  61)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g2;
HXDLIN(  61)															int this11 = ((col >> 8) & 255);
HXDLIN(  61)															if ((this11 == 0)) {
HXLINE(  61)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b2;
HXDLIN(  61)															int this12 = (col & 255);
HXDLIN(  61)															if ((this12 == 0)) {
HXLINE(  61)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)															{
HXLINE(  61)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  61)																int value;
HXDLIN(  61)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  61)																	value = blended;
            																}
HXDLIN(  61)																bool _hx_tmp;
HXDLIN(  61)																if ((location >= 0)) {
HXLINE(  61)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  61)																	_hx_tmp = false;
            																}
HXDLIN(  61)																if (_hx_tmp) {
HXLINE(  61)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  61)															int index;
HXDLIN(  61)															if (undoImage1->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  61)															int value;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  61)																value = c;
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  61)														if (forceClear) {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  61)															int x = (dx - rectLeft);
HXDLIN(  61)															int y = (dy - rectTop);
HXDLIN(  61)															int index;
HXDLIN(  61)															if (undoImage1->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							bool found1 = false;
HXDLIN(  61)							Float s1 = ((Float)0.);
HXDLIN(  61)							Float t1 = ((Float)0.);
HXDLIN(  61)							Float sxx1 = ((Float)0.);
HXDLIN(  61)							Float txx1 = ((Float)0.);
HXDLIN(  61)							{
HXLINE(  61)								int _g_min1 = xIter31->start;
HXDLIN(  61)								int _g_max1 = xIter31->max;
HXDLIN(  61)								while((_g_min1 < _g_max1)){
HXLINE(  61)									_g_min1 = (_g_min1 + 1);
HXDLIN(  61)									int x = (_g_min1 - 1);
HXDLIN(  61)									sxx1 = (sx1 * ( (Float)(x) ));
HXLINE(  62)									txx1 = (tx1 * ( (Float)(x) ));
HXLINE(  63)									found1 = false;
HXLINE(  61)									{
HXLINE(  61)										int _g_min = yIter31->start;
HXDLIN(  61)										int _g_max = yIter31->max;
HXDLIN(  61)										while((_g_min < _g_max)){
HXLINE(  61)											_g_min = (_g_min + 1);
HXDLIN(  61)											int y = (_g_min - 1);
HXLINE(  65)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE(  66)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  61)											bool _hx_tmp;
HXDLIN(  61)											if (!((s1 <= 0))) {
HXLINE(  61)												_hx_tmp = (t1 <= 0);
            											}
            											else {
HXLINE(  61)												_hx_tmp = true;
            											}
HXDLIN(  61)											if (_hx_tmp) {
HXLINE(  61)												if (found1) {
HXLINE(  61)													goto _hx_goto_14;
            												}
            											}
            											else {
HXLINE(  61)												if (((s1 + t1) < A1)) {
HXLINE(  61)													{
HXLINE(  61)														int this1 = color;
HXDLIN(  61)														int c = this1;
HXDLIN(  61)														bool _hx_tmp;
HXDLIN(  61)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)															_hx_tmp = pixelShape->transparent;
            														}
            														else {
HXLINE(  61)															_hx_tmp = false;
            														}
HXDLIN(  61)														if (_hx_tmp) {
HXLINE(  61)															int location;
HXDLIN(  61)															if (pixelShape->useVirtualPos) {
HXLINE(  61)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  61)																location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  61)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  61)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  61)															int this3 = this2;
HXDLIN(  61)															int this4;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  61)																this4 = this3;
            															}
HXDLIN(  61)															Float a1;
HXDLIN(  61)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)															if ((this5 == 0)) {
HXLINE(  61)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r1;
HXDLIN(  61)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)															if ((this6 == 0)) {
HXLINE(  61)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g1;
HXDLIN(  61)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)															if ((this7 == 0)) {
HXLINE(  61)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b1;
HXDLIN(  61)															int this8 = (this4 & 255);
HXDLIN(  61)															if ((this8 == 0)) {
HXLINE(  61)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a2;
HXDLIN(  61)															int this9 = ((color >> 24) & 255);
HXDLIN(  61)															if ((this9 == 0)) {
HXLINE(  61)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float r2;
HXDLIN(  61)															int this10 = ((color >> 16) & 255);
HXDLIN(  61)															if ((this10 == 0)) {
HXLINE(  61)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float g2;
HXDLIN(  61)															int this11 = ((color >> 8) & 255);
HXDLIN(  61)															if ((this11 == 0)) {
HXLINE(  61)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float b2;
HXDLIN(  61)															int this12 = (color & 255);
HXDLIN(  61)															if ((this12 == 0)) {
HXLINE(  61)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  61)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  61)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)															{
HXLINE(  61)																::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  61)																int value;
HXDLIN(  61)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  61)																	value = blended;
            																}
HXDLIN(  61)																bool _hx_tmp;
HXDLIN(  61)																if ((location >= 0)) {
HXLINE(  61)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  61)																	_hx_tmp = false;
            																}
HXDLIN(  61)																if (_hx_tmp) {
HXLINE(  61)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  61)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  61)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  61)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  61)															int index;
HXDLIN(  61)															if (pixelShape->useVirtualPos) {
HXLINE(  61)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            															}
            															else {
HXLINE(  61)																index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            															}
HXDLIN(  61)															int value;
HXDLIN(  61)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  61)																value = c;
            															}
HXDLIN(  61)															bool _hx_tmp;
HXDLIN(  61)															if ((index >= 0)) {
HXLINE(  61)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  61)																_hx_tmp = false;
            															}
HXDLIN(  61)															if (_hx_tmp) {
HXLINE(  61)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  61)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  61)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  61)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  61)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  61)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE(  74)													found1 = true;
            												}
            												else {
HXLINE(  61)													if (found1) {
HXLINE(  61)														goto _hx_goto_14;
            													}
            												}
            											}
            										}
            										_hx_goto_14:;
            									}
            								}
            							}
HXDLIN(  61)							if ((hasHit == true)) {
HXLINE(  61)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  61)								if (hasUndo1) {
HXLINE(  61)									v->undoImage = undoImage1;
HXDLIN(  61)									v->undoX = xIter31->start;
HXDLIN(  61)									v->undoY = yIter31->start;
            								}
            							}
            						}
            					}
HXDLIN(  61)					if ((hasHit == true)) {
HXLINE(  61)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            					}
            				}
            			}
            		}
            		else {
HXLINE(  64)			if (this->luxury) {
HXLINE(  65)				int color = this->strokeColor;
HXDLIN(  65)				Float soft = this->soft;
HXDLIN(  65)				bool softAB = true;
HXDLIN(  65)				bool softBC = true;
HXDLIN(  65)				bool softCD = true;
HXDLIN(  65)				bool softDA = true;
HXDLIN(  65)				bool hasHit = true;
HXDLIN(  65)				Float o = (qy - py);
HXDLIN(  65)				Float a = (qx - px);
HXDLIN(  65)				Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  65)				Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  65)				{
HXLINE(  65)					 ::Dynamic debugCorners = false;
HXDLIN(  65)					if (::hx::IsNull( debugCorners )) {
HXLINE( 359)						debugCorners = false;
            					}
HXLINE(  65)					Float sin = ::Math_obj::sin(theta);
HXDLIN(  65)					Float cos = ::Math_obj::cos(theta);
HXDLIN(  65)					Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  65)					Float dx = ((Float)0.1);
HXDLIN(  65)					Float dy = radius;
HXDLIN(  65)					Float cx = h;
HXDLIN(  65)					Float cy = radius;
HXDLIN(  65)					Float bx = h;
HXDLIN(  65)					Float by = -(radius);
HXDLIN(  65)					Float ax = ((Float)0.1);
HXDLIN(  65)					Float ay = -(radius);
HXDLIN(  65)					Float temp = ((Float)0.);
HXLINE( 136)					temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 137)					ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 138)					ax = temp;
HXLINE( 140)					temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 141)					by = (py + ((by * cos) + (bx * sin)));
HXLINE( 142)					bx = temp;
HXLINE( 144)					temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 145)					cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 146)					cx = temp;
HXLINE( 148)					temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 149)					dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 150)					dx = temp;
HXLINE(  65)					if (( (bool)(debugCorners) )) {
HXLINE(  65)						{
HXLINE(  65)							Float x = (ax - ((Float)6.));
HXDLIN(  65)							Float y = (ay - ((Float)6.));
HXDLIN(  65)							int p = ::Std_obj::_hx_int(x);
HXDLIN(  65)							int xx = p;
HXDLIN(  65)							int q = ::Std_obj::_hx_int(y);
HXDLIN(  65)							int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  65)							int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  65)							while(true){
HXLINE(  65)								{
HXLINE(  65)									p = (p + 1);
HXDLIN(  65)									int x = (p - 1);
HXDLIN(  65)									int this1 = -65536;
HXDLIN(  65)									int c = this1;
HXDLIN(  65)									bool _hx_tmp;
HXDLIN(  65)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)										_hx_tmp = pixelShape->transparent;
            									}
            									else {
HXLINE(  65)										_hx_tmp = false;
            									}
HXDLIN(  65)									if (_hx_tmp) {
HXLINE(  65)										int location;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)										int this3 = this2;
HXDLIN(  65)										int this4;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  65)											this4 = this3;
            										}
HXDLIN(  65)										Float a1;
HXDLIN(  65)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)										if ((this5 == 0)) {
HXLINE(  65)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r1;
HXDLIN(  65)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)										if ((this6 == 0)) {
HXLINE(  65)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g1;
HXDLIN(  65)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)										if ((this7 == 0)) {
HXLINE(  65)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b1;
HXDLIN(  65)										int this8 = (this4 & 255);
HXDLIN(  65)										if ((this8 == 0)) {
HXLINE(  65)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a2;
HXDLIN(  65)										int this9 = ((-65536 >> 24) & 255);
HXDLIN(  65)										if ((this9 == 0)) {
HXLINE(  65)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r2;
HXDLIN(  65)										int this10 = ((-65536 >> 16) & 255);
HXDLIN(  65)										if ((this10 == 0)) {
HXLINE(  65)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g2;
HXDLIN(  65)										int this11 = ((-65536 >> 8) & 255);
HXDLIN(  65)										if ((this11 == 0)) {
HXLINE(  65)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b2;
HXDLIN(  65)										int this12 = (-65536 & 255);
HXDLIN(  65)										if ((this12 == 0)) {
HXLINE(  65)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)										{
HXLINE(  65)											::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  65)											int value;
HXDLIN(  65)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  65)												value = blended;
            											}
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											if ((location >= 0)) {
HXLINE(  65)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										int index;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										int value;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  65)											value = c;
            										}
HXDLIN(  65)										bool _hx_tmp;
HXDLIN(  65)										if ((index >= 0)) {
HXLINE(  65)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  65)											_hx_tmp = false;
            										}
HXDLIN(  65)										if (_hx_tmp) {
HXLINE(  65)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXDLIN(  65)								if ((p > maxX)) {
HXLINE( 247)									p = xx;
HXLINE(  65)									q = (q + 1);
            								}
HXDLIN(  65)								if ((q > maxY)) {
HXLINE(  65)									goto _hx_goto_15;
            								}
            							}
            							_hx_goto_15:;
            						}
HXDLIN(  65)						{
HXLINE(  65)							Float x1 = (bx - ((Float)6.));
HXDLIN(  65)							Float y1 = (by - ((Float)6.));
HXDLIN(  65)							int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  65)							int xx1 = p1;
HXDLIN(  65)							int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  65)							int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  65)							int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  65)							while(true){
HXLINE(  65)								{
HXLINE(  65)									p1 = (p1 + 1);
HXDLIN(  65)									int x = (p1 - 1);
HXDLIN(  65)									int this1 = -16711936;
HXDLIN(  65)									int c = this1;
HXDLIN(  65)									bool _hx_tmp;
HXDLIN(  65)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)										_hx_tmp = pixelShape->transparent;
            									}
            									else {
HXLINE(  65)										_hx_tmp = false;
            									}
HXDLIN(  65)									if (_hx_tmp) {
HXLINE(  65)										int location;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)										int this3 = this2;
HXDLIN(  65)										int this4;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  65)											this4 = this3;
            										}
HXDLIN(  65)										Float a1;
HXDLIN(  65)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)										if ((this5 == 0)) {
HXLINE(  65)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r1;
HXDLIN(  65)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)										if ((this6 == 0)) {
HXLINE(  65)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g1;
HXDLIN(  65)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)										if ((this7 == 0)) {
HXLINE(  65)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b1;
HXDLIN(  65)										int this8 = (this4 & 255);
HXDLIN(  65)										if ((this8 == 0)) {
HXLINE(  65)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a2;
HXDLIN(  65)										int this9 = ((-16711936 >> 24) & 255);
HXDLIN(  65)										if ((this9 == 0)) {
HXLINE(  65)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r2;
HXDLIN(  65)										int this10 = ((-16711936 >> 16) & 255);
HXDLIN(  65)										if ((this10 == 0)) {
HXLINE(  65)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g2;
HXDLIN(  65)										int this11 = ((-16711936 >> 8) & 255);
HXDLIN(  65)										if ((this11 == 0)) {
HXLINE(  65)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b2;
HXDLIN(  65)										int this12 = (-16711936 & 255);
HXDLIN(  65)										if ((this12 == 0)) {
HXLINE(  65)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)										{
HXLINE(  65)											::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  65)											int value;
HXDLIN(  65)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  65)												value = blended;
            											}
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											if ((location >= 0)) {
HXLINE(  65)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										int index;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										int value;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  65)											value = c;
            										}
HXDLIN(  65)										bool _hx_tmp;
HXDLIN(  65)										if ((index >= 0)) {
HXLINE(  65)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  65)											_hx_tmp = false;
            										}
HXDLIN(  65)										if (_hx_tmp) {
HXLINE(  65)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXDLIN(  65)								if ((p1 > maxX1)) {
HXLINE( 247)									p1 = xx1;
HXLINE(  65)									q1 = (q1 + 1);
            								}
HXDLIN(  65)								if ((q1 > maxY1)) {
HXLINE(  65)									goto _hx_goto_16;
            								}
            							}
            							_hx_goto_16:;
            						}
HXDLIN(  65)						{
HXLINE(  65)							Float x2 = (cx - ((Float)6.));
HXDLIN(  65)							Float y2 = (cy - ((Float)6.));
HXDLIN(  65)							int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  65)							int xx2 = p2;
HXDLIN(  65)							int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  65)							int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  65)							int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  65)							while(true){
HXLINE(  65)								{
HXLINE(  65)									p2 = (p2 + 1);
HXDLIN(  65)									int x = (p2 - 1);
HXDLIN(  65)									int this1 = -16776961;
HXDLIN(  65)									int c = this1;
HXDLIN(  65)									bool _hx_tmp;
HXDLIN(  65)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)										_hx_tmp = pixelShape->transparent;
            									}
            									else {
HXLINE(  65)										_hx_tmp = false;
            									}
HXDLIN(  65)									if (_hx_tmp) {
HXLINE(  65)										int location;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)										int this3 = this2;
HXDLIN(  65)										int this4;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  65)											this4 = this3;
            										}
HXDLIN(  65)										Float a1;
HXDLIN(  65)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)										if ((this5 == 0)) {
HXLINE(  65)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r1;
HXDLIN(  65)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)										if ((this6 == 0)) {
HXLINE(  65)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g1;
HXDLIN(  65)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)										if ((this7 == 0)) {
HXLINE(  65)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b1;
HXDLIN(  65)										int this8 = (this4 & 255);
HXDLIN(  65)										if ((this8 == 0)) {
HXLINE(  65)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a2;
HXDLIN(  65)										int this9 = ((-16776961 >> 24) & 255);
HXDLIN(  65)										if ((this9 == 0)) {
HXLINE(  65)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r2;
HXDLIN(  65)										int this10 = ((-16776961 >> 16) & 255);
HXDLIN(  65)										if ((this10 == 0)) {
HXLINE(  65)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g2;
HXDLIN(  65)										int this11 = ((-16776961 >> 8) & 255);
HXDLIN(  65)										if ((this11 == 0)) {
HXLINE(  65)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b2;
HXDLIN(  65)										int this12 = (-16776961 & 255);
HXDLIN(  65)										if ((this12 == 0)) {
HXLINE(  65)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)										{
HXLINE(  65)											::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  65)											int value;
HXDLIN(  65)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  65)												value = blended;
            											}
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											if ((location >= 0)) {
HXLINE(  65)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										int index;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										int value;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  65)											value = c;
            										}
HXDLIN(  65)										bool _hx_tmp;
HXDLIN(  65)										if ((index >= 0)) {
HXLINE(  65)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  65)											_hx_tmp = false;
            										}
HXDLIN(  65)										if (_hx_tmp) {
HXLINE(  65)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXDLIN(  65)								if ((p2 > maxX2)) {
HXLINE( 247)									p2 = xx2;
HXLINE(  65)									q2 = (q2 + 1);
            								}
HXDLIN(  65)								if ((q2 > maxY2)) {
HXLINE(  65)									goto _hx_goto_17;
            								}
            							}
            							_hx_goto_17:;
            						}
HXDLIN(  65)						{
HXLINE(  65)							Float x3 = (dx - ((Float)6.));
HXDLIN(  65)							Float y3 = (dy - ((Float)6.));
HXDLIN(  65)							int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  65)							int xx3 = p3;
HXDLIN(  65)							int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  65)							int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  65)							int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  65)							while(true){
HXLINE(  65)								{
HXLINE(  65)									p3 = (p3 + 1);
HXDLIN(  65)									int x = (p3 - 1);
HXDLIN(  65)									int this1 = -1048336;
HXDLIN(  65)									int c = this1;
HXDLIN(  65)									bool _hx_tmp;
HXDLIN(  65)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)										_hx_tmp = pixelShape->transparent;
            									}
            									else {
HXLINE(  65)										_hx_tmp = false;
            									}
HXDLIN(  65)									if (_hx_tmp) {
HXLINE(  65)										int location;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											location = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)										int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)										int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)										int this3 = this2;
HXDLIN(  65)										int this4;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  65)											this4 = this3;
            										}
HXDLIN(  65)										Float a1;
HXDLIN(  65)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)										if ((this5 == 0)) {
HXLINE(  65)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r1;
HXDLIN(  65)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)										if ((this6 == 0)) {
HXLINE(  65)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g1;
HXDLIN(  65)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)										if ((this7 == 0)) {
HXLINE(  65)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b1;
HXDLIN(  65)										int this8 = (this4 & 255);
HXDLIN(  65)										if ((this8 == 0)) {
HXLINE(  65)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a2;
HXDLIN(  65)										int this9 = ((-1048336 >> 24) & 255);
HXDLIN(  65)										if ((this9 == 0)) {
HXLINE(  65)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float r2;
HXDLIN(  65)										int this10 = ((-1048336 >> 16) & 255);
HXDLIN(  65)										if ((this10 == 0)) {
HXLINE(  65)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float g2;
HXDLIN(  65)										int this11 = ((-1048336 >> 8) & 255);
HXDLIN(  65)										if ((this11 == 0)) {
HXLINE(  65)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float b2;
HXDLIN(  65)										int this12 = (-1048336 & 255);
HXDLIN(  65)										if ((this12 == 0)) {
HXLINE(  65)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  65)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  65)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)										int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)										int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)										{
HXLINE(  65)											::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  65)											int value;
HXDLIN(  65)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)												value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  65)												value = blended;
            											}
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											if ((location >= 0)) {
HXLINE(  65)												_hx_tmp = (location < (this13->byteLength >> 2));
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)												int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  65)										::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)										int index;
HXDLIN(  65)										if (pixelShape->useVirtualPos) {
HXLINE(  65)											index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            										}
            										else {
HXLINE(  65)											index = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            										}
HXDLIN(  65)										int value;
HXDLIN(  65)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)											value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  65)											value = c;
            										}
HXDLIN(  65)										bool _hx_tmp;
HXDLIN(  65)										if ((index >= 0)) {
HXLINE(  65)											_hx_tmp = (index < (this1->byteLength >> 2));
            										}
            										else {
HXLINE(  65)											_hx_tmp = false;
            										}
HXDLIN(  65)										if (_hx_tmp) {
HXLINE(  65)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
HXDLIN(  65)								if ((p3 > maxX3)) {
HXLINE( 247)									p3 = xx3;
HXLINE(  65)									q3 = (q3 + 1);
            								}
HXDLIN(  65)								if ((q3 > maxY3)) {
HXLINE(  65)									goto _hx_goto_18;
            								}
            							}
            							_hx_goto_18:;
            						}
            					}
HXDLIN(  65)					{
HXLINE(  65)						{
HXLINE(  65)							bool hasUndo = true;
HXDLIN(  65)							int aA = ((color >> 24) & 255);
HXDLIN(  65)							int rA = ((color >> 16) & 255);
HXDLIN(  65)							int gA = ((color >> 8) & 255);
HXDLIN(  65)							int bA = (color & 255);
HXDLIN(  65)							Float bcx = (bx - cx);
HXDLIN(  65)							Float bcy = (by - cy);
HXDLIN(  65)							Float acx = (ax - cx);
HXDLIN(  65)							Float acy = (ay - cy);
HXDLIN(  65)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  65)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  65)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  65)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  65)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  65)							if ((ax > bx)) {
HXLINE(  65)								if ((ax > cx)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((bx > cx)) {
HXLINE(  65)										min = ::Math_obj::floor(cx);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::floor(bx);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter3 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  65)								if ((bx > cx)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((ax > cx)) {
HXLINE(  65)										min = ::Math_obj::floor(cx);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::ceil(ax);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter3 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(ax);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter3 = this1;
            								}
            							}
HXDLIN(  65)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  65)							if ((ay > by)) {
HXLINE(  65)								if ((ay > cy)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((by > cy)) {
HXLINE(  65)										min = ::Math_obj::floor(cy);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::floor(by);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter3 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  65)								if ((by > cy)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((ay > cy)) {
HXLINE(  65)										min = ::Math_obj::floor(cy);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::ceil(ay);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter3 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(ay);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter3 = this1;
            								}
            							}
HXDLIN(  65)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  65)							if (hasUndo) {
HXLINE(  65)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  65)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  65)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  65)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  65)								undoImage = this3;
HXDLIN(  65)								{
HXLINE(  65)									int rectLeft = xIter3->start;
HXDLIN(  65)									int rectTop = yIter3->start;
HXDLIN(  65)									int rectRight = xIter3->max;
HXDLIN(  65)									bool forceClear = false;
HXDLIN(  65)									{
HXLINE(  65)										int _g = rectTop;
HXDLIN(  65)										int _g1 = yIter3->max;
HXDLIN(  65)										while((_g < _g1)){
HXLINE(  65)											_g = (_g + 1);
HXDLIN(  65)											int dy = (_g - 1);
HXDLIN(  65)											{
HXLINE(  65)												int _g1 = rectLeft;
HXDLIN(  65)												int _g2 = rectRight;
HXDLIN(  65)												while((_g1 < _g2)){
HXLINE(  65)													_g1 = (_g1 + 1);
HXDLIN(  65)													int dx = (_g1 - 1);
HXDLIN(  65)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)													int index;
HXDLIN(  65)													if (pixelShape->useVirtualPos) {
HXLINE(  65)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  65)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  65)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)													int col;
HXDLIN(  65)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  65)														col = c;
            													}
HXDLIN(  65)													bool _hx_tmp;
HXDLIN(  65)													if (pixelShape->useMask) {
HXLINE(  65)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  65)														_hx_tmp = false;
            													}
HXDLIN(  65)													if (_hx_tmp) {
HXLINE(  65)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  65)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  65)														int index;
HXDLIN(  65)														if (this1->useVirtualPos) {
HXLINE(  65)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  65)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  65)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  65)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  65)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)														int v;
HXDLIN(  65)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  65)															v = c;
            														}
HXDLIN(  65)														int this3 = v;
HXDLIN(  65)														int maskPixel = this3;
HXDLIN(  65)														int this4 = col;
HXDLIN(  65)														int this5 = this4;
HXDLIN(  65)														if ((maskPixel == 0)) {
HXLINE(  65)															int this1 = this5;
HXDLIN(  65)															col = this1;
            														}
            														else {
HXLINE(  65)															Float m0;
HXDLIN(  65)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  65)															if ((this1 == 0)) {
HXLINE(  65)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m1;
HXDLIN(  65)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  65)															if ((this2 == 0)) {
HXLINE(  65)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m2;
HXDLIN(  65)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  65)															if ((this3 == 0)) {
HXLINE(  65)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m3;
HXDLIN(  65)															int this4 = (maskPixel & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  65)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  65)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  65)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  65)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  65)													if ((col != 0)) {
HXLINE(  65)														int x = (dx - rectLeft);
HXDLIN(  65)														int y = (dy - rectTop);
HXDLIN(  65)														int this1 = col;
HXDLIN(  65)														int c = this1;
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															int location;
HXDLIN(  65)															if (undoImage->useVirtualPos) {
HXLINE(  65)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  65)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int this4;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																this4 = this3;
            															}
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this8 = (this4 & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this9 = ((col >> 24) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this10 = ((col >> 16) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this11 = ((col >> 8) & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this12 = (col & 255);
HXDLIN(  65)															if ((this12 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  65)															int index;
HXDLIN(  65)															if (undoImage->useVirtualPos) {
HXLINE(  65)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  65)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  65)															int value;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  65)																value = c;
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((index >= 0)) {
HXLINE(  65)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  65)														if (forceClear) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  65)															int x = (dx - rectLeft);
HXDLIN(  65)															int y = (dy - rectTop);
HXDLIN(  65)															int index;
HXDLIN(  65)															if (undoImage->useVirtualPos) {
HXLINE(  65)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  65)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((index >= 0)) {
HXLINE(  65)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  65)							bool found = false;
HXDLIN(  65)							Float min = ( (Float)(0) );
HXDLIN(  65)							Float max = ( (Float)(0) );
HXDLIN(  65)							int a1 = 0;
HXDLIN(  65)							int r = 0;
HXDLIN(  65)							int g = 0;
HXDLIN(  65)							int b = 0;
HXDLIN(  65)							{
HXLINE(  65)								int _g_min = xIter3->start;
HXDLIN(  65)								int _g_max = xIter3->max;
HXDLIN(  65)								while((_g_min < _g_max)){
HXLINE(  65)									_g_min = (_g_min + 1);
HXDLIN(  65)									int px = (_g_min - 1);
HXDLIN(  65)									Float pcx = (( (Float)(px) ) - cx);
HXLINE( 813)									found = false;
HXLINE(  65)									{
HXLINE(  65)										int _g_min1 = yIter3->start;
HXDLIN(  65)										int _g_max = yIter3->max;
HXDLIN(  65)										while((_g_min1 < _g_max)){
HXLINE(  65)											_g_min1 = (_g_min1 + 1);
HXDLIN(  65)											int py = (_g_min1 - 1);
HXDLIN(  65)											Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  65)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  65)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  65)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  65)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  65)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											bool _hx_tmp1;
HXDLIN(  65)											if ((ratioA >= 0)) {
HXLINE(  65)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  65)												_hx_tmp1 = false;
            											}
HXDLIN(  65)											if (_hx_tmp1) {
HXLINE(  65)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												int i = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  65)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  65)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  65)												int this1 = i;
HXLINE( 822)												r = this1;
HXLINE(  65)												int i1 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  65)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  65)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  65)												int this2 = i1;
HXLINE( 823)												g = this2;
HXLINE(  65)												int i2 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  65)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  65)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  65)												int this3 = i2;
HXLINE( 824)												b = this3;
HXLINE(  65)												bool _hx_tmp;
HXDLIN(  65)												bool _hx_tmp1;
HXDLIN(  65)												if ((softAB == true)) {
HXLINE(  65)													_hx_tmp1 = (softBC == false);
            												}
            												else {
HXLINE(  65)													_hx_tmp1 = false;
            												}
HXDLIN(  65)												if (_hx_tmp1) {
HXLINE(  65)													_hx_tmp = false;
            												}
            												else {
HXLINE(  65)													_hx_tmp = false;
            												}
HXDLIN(  65)												if (_hx_tmp) {
HXLINE(  65)													if ((ratioA < ratioC)) {
HXLINE(  65)														min = ratioA;
            													}
            													else {
HXLINE(  65)														min = ratioC;
            													}
HXDLIN(  65)													if ((ratioA > ratioB)) {
HXLINE(  65)														max = ratioA;
            													}
            													else {
HXLINE(  65)														max = ratioB;
            													}
HXDLIN(  65)													if (!((max > ratioC))) {
HXLINE(  65)														max = ratioC;
            													}
HXLINE( 830)													max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  65)													if (!((min < max))) {
HXLINE(  65)														min = ((max + min) / ( (Float)(2) ));
            													}
HXDLIN(  65)													int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  65)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  65)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  65)													int this1 = i;
HXLINE( 833)													a1 = this1;
HXLINE(  65)													{
HXLINE(  65)														int location;
HXDLIN(  65)														if (pixelShape->useVirtualPos) {
HXLINE(  65)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  65)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if (pixelShape->transparent) {
HXLINE(  65)															_hx_tmp = (a1 < 254);
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int old;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																old = this3;
            															}
HXDLIN(  65)															int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															Float a11;
HXDLIN(  65)															int this4 = ((old >> 24) & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																a11 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this5 = ((old >> 16) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this6 = ((old >> 8) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this7 = (old & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this11 = (rhs & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															int value;
HXDLIN(  65)															if (pixelShape->isLittle) {
HXLINE(  65)																value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  65)																value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((location >= 0)) {
HXLINE(  65)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
HXDLIN(  65)												bool _hx_tmp2;
HXDLIN(  65)												if ((softAB == true)) {
HXLINE(  65)													_hx_tmp2 = (softBC == true);
            												}
            												else {
HXLINE(  65)													_hx_tmp2 = false;
            												}
HXDLIN(  65)												if (_hx_tmp2) {
HXLINE(  65)													if ((ratioB < ratioC)) {
HXLINE(  65)														min = ratioB;
            													}
            													else {
HXLINE(  65)														min = ratioC;
            													}
HXDLIN(  65)													if ((ratioA > ratioB)) {
HXLINE(  65)														max = ratioA;
            													}
            													else {
HXLINE(  65)														max = ratioB;
            													}
HXDLIN(  65)													if (!((max > ratioC))) {
HXLINE(  65)														max = ratioC;
            													}
HXLINE( 843)													max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  65)													if (!((min < max))) {
HXLINE(  65)														min = ((max + min) / ( (Float)(2) ));
            													}
HXDLIN(  65)													int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  65)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  65)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  65)													int this1 = i;
HXLINE( 846)													a1 = this1;
HXLINE(  65)													{
HXLINE(  65)														int location;
HXDLIN(  65)														if (pixelShape->useVirtualPos) {
HXLINE(  65)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  65)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if (pixelShape->transparent) {
HXLINE(  65)															_hx_tmp = (a1 < 254);
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int old;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																old = this3;
            															}
HXDLIN(  65)															int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															Float a11;
HXDLIN(  65)															int this4 = ((old >> 24) & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																a11 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this5 = ((old >> 16) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this6 = ((old >> 8) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this7 = (old & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this11 = (rhs & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															int value;
HXDLIN(  65)															if (pixelShape->isLittle) {
HXLINE(  65)																value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  65)																value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((location >= 0)) {
HXLINE(  65)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
HXLINE( 851)												found = true;
            											}
            											else {
HXLINE(  65)												if (found) {
HXLINE(  65)													goto _hx_goto_22;
            												}
            											}
            										}
            										_hx_goto_22:;
            									}
            								}
            							}
HXDLIN(  65)							if ((hasHit == false)) {
HXLINE(  65)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN(  65)								if (hasUndo) {
HXLINE(  65)									v->undoImage = undoImage;
HXDLIN(  65)									v->undoX = xIter3->start;
HXDLIN(  65)									v->undoY = yIter3->start;
            								}
            							}
            						}
HXDLIN(  65)						{
HXLINE(  65)							bool hasUndo1 = true;
HXDLIN(  65)							int aA1 = ((color >> 24) & 255);
HXDLIN(  65)							int rA1 = ((color >> 16) & 255);
HXDLIN(  65)							int gA1 = ((color >> 8) & 255);
HXDLIN(  65)							int bA1 = (color & 255);
HXDLIN(  65)							Float bcx1 = (cx - ax);
HXDLIN(  65)							Float bcy1 = (cy - ay);
HXDLIN(  65)							Float acx1 = (dx - ax);
HXDLIN(  65)							Float acy1 = (dy - ay);
HXDLIN(  65)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  65)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  65)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  65)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  65)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  65)							if ((dx > cx)) {
HXLINE(  65)								if ((dx > ax)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((cx > ax)) {
HXLINE(  65)										min = ::Math_obj::floor(ax);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::floor(cx);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter31 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(cx);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  65)								if ((cx > ax)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((dx > ax)) {
HXLINE(  65)										min = ::Math_obj::floor(ax);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::ceil(dx);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter31 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(dx);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter31 = this1;
            								}
            							}
HXDLIN(  65)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  65)							if ((dy > cy)) {
HXLINE(  65)								if ((dy > ay)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((cy > ay)) {
HXLINE(  65)										min = ::Math_obj::floor(ay);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::floor(cy);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter31 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(cy);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  65)								if ((cy > ay)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((dy > ay)) {
HXLINE(  65)										min = ::Math_obj::floor(ay);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::ceil(dy);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter31 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(dy);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter31 = this1;
            								}
            							}
HXDLIN(  65)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  65)							if (hasUndo1) {
HXLINE(  65)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  65)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  65)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  65)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  65)								undoImage1 = this3;
HXDLIN(  65)								{
HXLINE(  65)									int rectLeft = xIter31->start;
HXDLIN(  65)									int rectTop = yIter31->start;
HXDLIN(  65)									int rectRight = xIter31->max;
HXDLIN(  65)									bool forceClear = false;
HXDLIN(  65)									{
HXLINE(  65)										int _g = rectTop;
HXDLIN(  65)										int _g1 = yIter31->max;
HXDLIN(  65)										while((_g < _g1)){
HXLINE(  65)											_g = (_g + 1);
HXDLIN(  65)											int dy = (_g - 1);
HXDLIN(  65)											{
HXLINE(  65)												int _g1 = rectLeft;
HXDLIN(  65)												int _g2 = rectRight;
HXDLIN(  65)												while((_g1 < _g2)){
HXLINE(  65)													_g1 = (_g1 + 1);
HXDLIN(  65)													int dx = (_g1 - 1);
HXDLIN(  65)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)													int index;
HXDLIN(  65)													if (pixelShape->useVirtualPos) {
HXLINE(  65)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  65)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  65)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)													int col;
HXDLIN(  65)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  65)														col = c;
            													}
HXDLIN(  65)													bool _hx_tmp;
HXDLIN(  65)													if (pixelShape->useMask) {
HXLINE(  65)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  65)														_hx_tmp = false;
            													}
HXDLIN(  65)													if (_hx_tmp) {
HXLINE(  65)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  65)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  65)														int index;
HXDLIN(  65)														if (this1->useVirtualPos) {
HXLINE(  65)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  65)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  65)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  65)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  65)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)														int v;
HXDLIN(  65)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  65)															v = c;
            														}
HXDLIN(  65)														int this3 = v;
HXDLIN(  65)														int maskPixel = this3;
HXDLIN(  65)														int this4 = col;
HXDLIN(  65)														int this5 = this4;
HXDLIN(  65)														if ((maskPixel == 0)) {
HXLINE(  65)															int this1 = this5;
HXDLIN(  65)															col = this1;
            														}
            														else {
HXLINE(  65)															Float m0;
HXDLIN(  65)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  65)															if ((this1 == 0)) {
HXLINE(  65)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m1;
HXDLIN(  65)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  65)															if ((this2 == 0)) {
HXLINE(  65)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m2;
HXDLIN(  65)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  65)															if ((this3 == 0)) {
HXLINE(  65)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m3;
HXDLIN(  65)															int this4 = (maskPixel & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  65)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  65)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  65)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  65)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  65)													if ((col != 0)) {
HXLINE(  65)														int x = (dx - rectLeft);
HXDLIN(  65)														int y = (dy - rectTop);
HXDLIN(  65)														int this1 = col;
HXDLIN(  65)														int c = this1;
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															int location;
HXDLIN(  65)															if (undoImage1->useVirtualPos) {
HXLINE(  65)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  65)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int this4;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																this4 = this3;
            															}
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this8 = (this4 & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this9 = ((col >> 24) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this10 = ((col >> 16) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this11 = ((col >> 8) & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this12 = (col & 255);
HXDLIN(  65)															if ((this12 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  65)															int index;
HXDLIN(  65)															if (undoImage1->useVirtualPos) {
HXLINE(  65)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  65)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  65)															int value;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  65)																value = c;
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((index >= 0)) {
HXLINE(  65)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  65)														if (forceClear) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  65)															int x = (dx - rectLeft);
HXDLIN(  65)															int y = (dy - rectTop);
HXDLIN(  65)															int index;
HXDLIN(  65)															if (undoImage1->useVirtualPos) {
HXLINE(  65)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  65)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((index >= 0)) {
HXLINE(  65)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  65)							bool found1 = false;
HXDLIN(  65)							Float min1 = ( (Float)(0) );
HXDLIN(  65)							Float max1 = ( (Float)(0) );
HXDLIN(  65)							int a2 = 0;
HXDLIN(  65)							int r1 = 0;
HXDLIN(  65)							int g1 = 0;
HXDLIN(  65)							int b1 = 0;
HXDLIN(  65)							{
HXLINE(  65)								int _g_min1 = xIter31->start;
HXDLIN(  65)								int _g_max1 = xIter31->max;
HXDLIN(  65)								while((_g_min1 < _g_max1)){
HXLINE(  65)									_g_min1 = (_g_min1 + 1);
HXDLIN(  65)									int px = (_g_min1 - 1);
HXDLIN(  65)									Float pcx = (( (Float)(px) ) - ax);
HXLINE( 813)									found1 = false;
HXLINE(  65)									{
HXLINE(  65)										int _g_min = yIter31->start;
HXDLIN(  65)										int _g_max = yIter31->max;
HXDLIN(  65)										while((_g_min < _g_max)){
HXLINE(  65)											_g_min = (_g_min + 1);
HXDLIN(  65)											int py = (_g_min - 1);
HXDLIN(  65)											Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  65)											Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  65)											Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  65)											Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  65)											Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  65)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											bool _hx_tmp1;
HXDLIN(  65)											if ((ratioA >= 0)) {
HXLINE(  65)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  65)												_hx_tmp1 = false;
            											}
HXDLIN(  65)											if (_hx_tmp1) {
HXLINE(  65)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												int i = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  65)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  65)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  65)												int this1 = i;
HXLINE( 822)												r1 = this1;
HXLINE(  65)												int i1 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  65)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  65)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  65)												int this2 = i1;
HXLINE( 823)												g1 = this2;
HXLINE(  65)												int i2 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  65)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  65)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  65)												int this3 = i2;
HXLINE( 824)												b1 = this3;
HXLINE(  65)												bool _hx_tmp;
HXDLIN(  65)												if ((softCD == true)) {
HXLINE(  65)													_hx_tmp = (softDA == true);
            												}
            												else {
HXLINE(  65)													_hx_tmp = false;
            												}
HXDLIN(  65)												if (_hx_tmp) {
HXLINE(  65)													if ((ratioA < ratioC)) {
HXLINE(  65)														min1 = ratioA;
            													}
            													else {
HXLINE(  65)														min1 = ratioC;
            													}
HXDLIN(  65)													if ((ratioA > ratioB)) {
HXLINE(  65)														max1 = ratioA;
            													}
            													else {
HXLINE(  65)														max1 = ratioB;
            													}
HXDLIN(  65)													if (!((max1 > ratioC))) {
HXLINE(  65)														max1 = ratioC;
            													}
HXLINE( 830)													max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  65)													if (!((min1 < max1))) {
HXLINE(  65)														min1 = ((max1 + min1) / ( (Float)(2) ));
            													}
HXDLIN(  65)													int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  65)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  65)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  65)													int this1 = i;
HXLINE( 833)													a2 = this1;
HXLINE(  65)													{
HXLINE(  65)														int location;
HXDLIN(  65)														if (pixelShape->useVirtualPos) {
HXLINE(  65)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  65)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if (pixelShape->transparent) {
HXLINE(  65)															_hx_tmp = (a2 < 254);
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int old;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																old = this3;
            															}
HXDLIN(  65)															int rhs = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this4 = ((old >> 24) & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r11;
HXDLIN(  65)															int this5 = ((old >> 16) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																r11 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g11;
HXDLIN(  65)															int this6 = ((old >> 8) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																g11 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b11;
HXDLIN(  65)															int this7 = (old & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																b11 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a21;
HXDLIN(  65)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																a21 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a21 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this11 = (rhs & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a1 * (( (Float)(1) ) - a21));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a21))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a21))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a21))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a21)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															int value;
HXDLIN(  65)															if (pixelShape->isLittle) {
HXLINE(  65)																value = ((((a2 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            															}
            															else {
HXLINE(  65)																value = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((location >= 0)) {
HXLINE(  65)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
HXDLIN(  65)												bool _hx_tmp1;
HXDLIN(  65)												bool _hx_tmp2;
HXDLIN(  65)												if ((softCD == true)) {
HXLINE(  65)													_hx_tmp2 = false;
            												}
            												else {
HXLINE(  65)													_hx_tmp2 = false;
            												}
HXDLIN(  65)												if (_hx_tmp2) {
HXLINE(  65)													_hx_tmp1 = (softDA == false);
            												}
            												else {
HXLINE(  65)													_hx_tmp1 = false;
            												}
HXDLIN(  65)												if (_hx_tmp1) {
HXLINE(  65)													if ((ratioB < ratioC)) {
HXLINE(  65)														min1 = ratioB;
            													}
            													else {
HXLINE(  65)														min1 = ratioC;
            													}
HXDLIN(  65)													if ((ratioA > ratioB)) {
HXLINE(  65)														max1 = ratioA;
            													}
            													else {
HXLINE(  65)														max1 = ratioB;
            													}
HXDLIN(  65)													if (!((max1 > ratioC))) {
HXLINE(  65)														max1 = ratioC;
            													}
HXLINE( 843)													max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  65)													if (!((min1 < max1))) {
HXLINE(  65)														min1 = ((max1 + min1) / ( (Float)(2) ));
            													}
HXDLIN(  65)													int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  65)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  65)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  65)													int this1 = i;
HXLINE( 846)													a2 = this1;
HXLINE(  65)													{
HXLINE(  65)														int location;
HXDLIN(  65)														if (pixelShape->useVirtualPos) {
HXLINE(  65)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  65)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if (pixelShape->transparent) {
HXLINE(  65)															_hx_tmp = (a2 < 254);
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int old;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																old = this3;
            															}
HXDLIN(  65)															int rhs = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this4 = ((old >> 24) & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r11;
HXDLIN(  65)															int this5 = ((old >> 16) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																r11 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g11;
HXDLIN(  65)															int this6 = ((old >> 8) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																g11 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b11;
HXDLIN(  65)															int this7 = (old & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																b11 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a21;
HXDLIN(  65)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																a21 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a21 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this11 = (rhs & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a1 * (( (Float)(1) ) - a21));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a21))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a21))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a21))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a21)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															int value;
HXDLIN(  65)															if (pixelShape->isLittle) {
HXLINE(  65)																value = ((((a2 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            															}
            															else {
HXLINE(  65)																value = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((location >= 0)) {
HXLINE(  65)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
HXLINE( 851)												found1 = true;
            											}
            											else {
HXLINE(  65)												if (found1) {
HXLINE(  65)													goto _hx_goto_26;
            												}
            											}
            										}
            										_hx_goto_26:;
            									}
            								}
            							}
HXDLIN(  65)							if ((hasHit == false)) {
HXLINE(  65)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,dx,dy,cx,cy,ax,ay,true);
HXDLIN(  65)								if (hasUndo1) {
HXLINE(  65)									v->undoImage = undoImage1;
HXDLIN(  65)									v->undoX = xIter31->start;
HXDLIN(  65)									v->undoY = yIter31->start;
            								}
            							}
            						}
HXDLIN(  65)						{
HXLINE(  65)							bool hasUndo2 = true;
HXDLIN(  65)							int aA2 = ((color >> 24) & 255);
HXDLIN(  65)							int rA2 = ((color >> 16) & 255);
HXDLIN(  65)							int gA2 = ((color >> 8) & 255);
HXDLIN(  65)							int bA2 = (color & 255);
HXDLIN(  65)							Float bcx2 = (bx - dx);
HXDLIN(  65)							Float bcy2 = (by - dy);
HXDLIN(  65)							Float acx2 = (ax - dx);
HXDLIN(  65)							Float acy2 = (ay - dy);
HXDLIN(  65)							Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  65)							Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  65)							Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  65)							Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  65)							::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  65)							if ((ax > bx)) {
HXLINE(  65)								if ((ax > dx)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((bx > dx)) {
HXLINE(  65)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::floor(bx);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter32 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter32 = this1;
            								}
            							}
            							else {
HXLINE(  65)								if ((bx > dx)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((ax > dx)) {
HXLINE(  65)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::ceil(ax);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter32 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(ax);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter32 = this1;
            								}
            							}
HXDLIN(  65)							::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  65)							if ((ay > by)) {
HXLINE(  65)								if ((ay > dy)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((by > dy)) {
HXLINE(  65)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::floor(by);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter32 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter32 = this1;
            								}
            							}
            							else {
HXLINE(  65)								if ((by > dy)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((ay > dy)) {
HXLINE(  65)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::ceil(ay);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter32 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(ay);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter32 = this1;
            								}
            							}
HXDLIN(  65)							::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  65)							if (hasUndo2) {
HXLINE(  65)								int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  65)								int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  65)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  65)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  65)								undoImage2 = this3;
HXDLIN(  65)								{
HXLINE(  65)									int rectLeft = xIter32->start;
HXDLIN(  65)									int rectTop = yIter32->start;
HXDLIN(  65)									int rectRight = xIter32->max;
HXDLIN(  65)									bool forceClear = false;
HXDLIN(  65)									{
HXLINE(  65)										int _g = rectTop;
HXDLIN(  65)										int _g1 = yIter32->max;
HXDLIN(  65)										while((_g < _g1)){
HXLINE(  65)											_g = (_g + 1);
HXDLIN(  65)											int dy = (_g - 1);
HXDLIN(  65)											{
HXLINE(  65)												int _g1 = rectLeft;
HXDLIN(  65)												int _g2 = rectRight;
HXDLIN(  65)												while((_g1 < _g2)){
HXLINE(  65)													_g1 = (_g1 + 1);
HXDLIN(  65)													int dx = (_g1 - 1);
HXDLIN(  65)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)													int index;
HXDLIN(  65)													if (pixelShape->useVirtualPos) {
HXLINE(  65)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  65)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  65)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)													int col;
HXDLIN(  65)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  65)														col = c;
            													}
HXDLIN(  65)													bool _hx_tmp;
HXDLIN(  65)													if (pixelShape->useMask) {
HXLINE(  65)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  65)														_hx_tmp = false;
            													}
HXDLIN(  65)													if (_hx_tmp) {
HXLINE(  65)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  65)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  65)														int index;
HXDLIN(  65)														if (this1->useVirtualPos) {
HXLINE(  65)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  65)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  65)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  65)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  65)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)														int v;
HXDLIN(  65)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  65)															v = c;
            														}
HXDLIN(  65)														int this3 = v;
HXDLIN(  65)														int maskPixel = this3;
HXDLIN(  65)														int this4 = col;
HXDLIN(  65)														int this5 = this4;
HXDLIN(  65)														if ((maskPixel == 0)) {
HXLINE(  65)															int this1 = this5;
HXDLIN(  65)															col = this1;
            														}
            														else {
HXLINE(  65)															Float m0;
HXDLIN(  65)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  65)															if ((this1 == 0)) {
HXLINE(  65)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m1;
HXDLIN(  65)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  65)															if ((this2 == 0)) {
HXLINE(  65)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m2;
HXDLIN(  65)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  65)															if ((this3 == 0)) {
HXLINE(  65)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m3;
HXDLIN(  65)															int this4 = (maskPixel & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  65)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  65)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  65)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  65)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  65)													if ((col != 0)) {
HXLINE(  65)														int x = (dx - rectLeft);
HXDLIN(  65)														int y = (dy - rectTop);
HXDLIN(  65)														int this1 = col;
HXDLIN(  65)														int c = this1;
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)															_hx_tmp = undoImage2->transparent;
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															int location;
HXDLIN(  65)															if (undoImage2->useVirtualPos) {
HXLINE(  65)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE(  65)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int this4;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																this4 = this3;
            															}
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this8 = (this4 & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this9 = ((col >> 24) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this10 = ((col >> 16) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this11 = ((col >> 8) & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this12 = (col & 255);
HXDLIN(  65)															if ((this12 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  65)															int index;
HXDLIN(  65)															if (undoImage2->useVirtualPos) {
HXLINE(  65)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE(  65)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN(  65)															int value;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  65)																value = c;
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((index >= 0)) {
HXLINE(  65)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  65)														if (forceClear) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  65)															int x = (dx - rectLeft);
HXDLIN(  65)															int y = (dy - rectTop);
HXDLIN(  65)															int index;
HXDLIN(  65)															if (undoImage2->useVirtualPos) {
HXLINE(  65)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            															}
            															else {
HXLINE(  65)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((index >= 0)) {
HXLINE(  65)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  65)							bool found2 = false;
HXDLIN(  65)							Float min2 = ( (Float)(0) );
HXDLIN(  65)							Float max2 = ( (Float)(0) );
HXDLIN(  65)							int a3 = 0;
HXDLIN(  65)							int r2 = 0;
HXDLIN(  65)							int g2 = 0;
HXDLIN(  65)							int b2 = 0;
HXDLIN(  65)							{
HXLINE(  65)								int _g_min2 = xIter32->start;
HXDLIN(  65)								int _g_max2 = xIter32->max;
HXDLIN(  65)								while((_g_min2 < _g_max2)){
HXLINE(  65)									_g_min2 = (_g_min2 + 1);
HXDLIN(  65)									int px = (_g_min2 - 1);
HXDLIN(  65)									Float pcx = (( (Float)(px) ) - dx);
HXLINE( 813)									found2 = false;
HXLINE(  65)									{
HXLINE(  65)										int _g_min = yIter32->start;
HXDLIN(  65)										int _g_max = yIter32->max;
HXDLIN(  65)										while((_g_min < _g_max)){
HXLINE(  65)											_g_min = (_g_min + 1);
HXDLIN(  65)											int py = (_g_min - 1);
HXDLIN(  65)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  65)											Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  65)											Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  65)											Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  65)											Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  65)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											bool _hx_tmp1;
HXDLIN(  65)											if ((ratioA >= 0)) {
HXLINE(  65)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  65)												_hx_tmp1 = false;
            											}
HXDLIN(  65)											if (_hx_tmp1) {
HXLINE(  65)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												int i = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  65)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  65)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  65)												int this1 = i;
HXLINE( 822)												r2 = this1;
HXLINE(  65)												int i1 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  65)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  65)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  65)												int this2 = i1;
HXLINE( 823)												g2 = this2;
HXLINE(  65)												int i2 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  65)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  65)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  65)												int this3 = i2;
HXLINE( 824)												b2 = this3;
HXLINE(  65)												bool _hx_tmp;
HXDLIN(  65)												if ((softAB == true)) {
HXLINE(  65)													_hx_tmp = (softDA == true);
            												}
            												else {
HXLINE(  65)													_hx_tmp = false;
            												}
HXDLIN(  65)												if (_hx_tmp) {
HXLINE(  65)													if ((ratioA < ratioC)) {
HXLINE(  65)														min2 = ratioA;
            													}
            													else {
HXLINE(  65)														min2 = ratioC;
            													}
HXDLIN(  65)													if ((ratioA > ratioB)) {
HXLINE(  65)														max2 = ratioA;
            													}
            													else {
HXLINE(  65)														max2 = ratioB;
            													}
HXDLIN(  65)													if (!((max2 > ratioC))) {
HXLINE(  65)														max2 = ratioC;
            													}
HXLINE( 830)													max2 = ((( (Float)(1) ) - max2) / ( (Float)(2) ));
HXLINE(  65)													if (!((min2 < max2))) {
HXLINE(  65)														min2 = ((max2 + min2) / ( (Float)(2) ));
            													}
HXDLIN(  65)													int i = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min2));
HXDLIN(  65)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  65)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  65)													int this1 = i;
HXLINE( 833)													a3 = this1;
HXLINE(  65)													{
HXLINE(  65)														int location;
HXDLIN(  65)														if (pixelShape->useVirtualPos) {
HXLINE(  65)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  65)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if (pixelShape->transparent) {
HXLINE(  65)															_hx_tmp = (a3 < 254);
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int old;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																old = this3;
            															}
HXDLIN(  65)															int rhs = ((((a3 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this4 = ((old >> 24) & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this5 = ((old >> 16) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this6 = ((old >> 8) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this7 = (old & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r21;
HXDLIN(  65)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																r21 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r21 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g21;
HXDLIN(  65)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																g21 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g21 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b21;
HXDLIN(  65)															int this11 = (rhs & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																b21 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b21 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a31 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a31) + (r21 * a2))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a31) + (g21 * a2))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a31) + (b21 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															int value;
HXDLIN(  65)															if (pixelShape->isLittle) {
HXLINE(  65)																value = ((((a3 << 24) | (b2 << 16)) | (g2 << 8)) | r2);
            															}
            															else {
HXLINE(  65)																value = ((((a3 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((location >= 0)) {
HXLINE(  65)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
HXDLIN(  65)												bool _hx_tmp1;
HXDLIN(  65)												bool _hx_tmp2;
HXDLIN(  65)												if ((softAB == true)) {
HXLINE(  65)													_hx_tmp2 = false;
            												}
            												else {
HXLINE(  65)													_hx_tmp2 = false;
            												}
HXDLIN(  65)												if (_hx_tmp2) {
HXLINE(  65)													_hx_tmp1 = (softDA == false);
            												}
            												else {
HXLINE(  65)													_hx_tmp1 = false;
            												}
HXDLIN(  65)												if (_hx_tmp1) {
HXLINE(  65)													if ((ratioB < ratioC)) {
HXLINE(  65)														min2 = ratioB;
            													}
            													else {
HXLINE(  65)														min2 = ratioC;
            													}
HXDLIN(  65)													if ((ratioA > ratioB)) {
HXLINE(  65)														max2 = ratioA;
            													}
            													else {
HXLINE(  65)														max2 = ratioB;
            													}
HXDLIN(  65)													if (!((max2 > ratioC))) {
HXLINE(  65)														max2 = ratioC;
            													}
HXLINE( 843)													max2 = ((( (Float)(1) ) - max2) / ( (Float)(2) ));
HXLINE(  65)													if (!((min2 < max2))) {
HXLINE(  65)														min2 = ((max2 + min2) / ( (Float)(2) ));
            													}
HXDLIN(  65)													int i = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min2));
HXDLIN(  65)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  65)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  65)													int this1 = i;
HXLINE( 846)													a3 = this1;
HXLINE(  65)													{
HXLINE(  65)														int location;
HXDLIN(  65)														if (pixelShape->useVirtualPos) {
HXLINE(  65)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  65)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if (pixelShape->transparent) {
HXLINE(  65)															_hx_tmp = (a3 < 254);
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int old;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																old = this3;
            															}
HXDLIN(  65)															int rhs = ((((a3 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this4 = ((old >> 24) & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this5 = ((old >> 16) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this6 = ((old >> 8) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this7 = (old & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r21;
HXDLIN(  65)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																r21 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r21 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g21;
HXDLIN(  65)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																g21 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g21 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b21;
HXDLIN(  65)															int this11 = (rhs & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																b21 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b21 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a31 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a31) + (r21 * a2))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a31) + (g21 * a2))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a31) + (b21 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															int value;
HXDLIN(  65)															if (pixelShape->isLittle) {
HXLINE(  65)																value = ((((a3 << 24) | (b2 << 16)) | (g2 << 8)) | r2);
            															}
            															else {
HXLINE(  65)																value = ((((a3 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((location >= 0)) {
HXLINE(  65)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
HXLINE( 851)												found2 = true;
            											}
            											else {
HXLINE(  65)												if (found2) {
HXLINE(  65)													goto _hx_goto_30;
            												}
            											}
            										}
            										_hx_goto_30:;
            									}
            								}
            							}
HXDLIN(  65)							if ((hasHit == false)) {
HXLINE(  65)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  65)								if (hasUndo2) {
HXLINE(  65)									v->undoImage = undoImage2;
HXDLIN(  65)									v->undoX = xIter32->start;
HXDLIN(  65)									v->undoY = yIter32->start;
            								}
            							}
            						}
HXDLIN(  65)						{
HXLINE(  65)							bool hasUndo3 = true;
HXDLIN(  65)							int aA3 = ((color >> 24) & 255);
HXDLIN(  65)							int rA3 = ((color >> 16) & 255);
HXDLIN(  65)							int gA3 = ((color >> 8) & 255);
HXDLIN(  65)							int bA3 = (color & 255);
HXDLIN(  65)							Float bcx3 = (cx - dx);
HXDLIN(  65)							Float bcy3 = (cy - dy);
HXDLIN(  65)							Float acx3 = (bx - dx);
HXDLIN(  65)							Float acy3 = (by - dy);
HXDLIN(  65)							Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  65)							Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  65)							Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  65)							Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  65)							::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  65)							if ((bx > cx)) {
HXLINE(  65)								if ((bx > dx)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((cx > dx)) {
HXLINE(  65)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::floor(cx);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter33 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(cx);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter33 = this1;
            								}
            							}
            							else {
HXLINE(  65)								if ((cx > dx)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((bx > dx)) {
HXLINE(  65)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter33 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									xIter33 = this1;
            								}
            							}
HXDLIN(  65)							::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  65)							if ((by > cy)) {
HXLINE(  65)								if ((by > dy)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((cy > dy)) {
HXLINE(  65)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::floor(cy);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter33 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(cy);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter33 = this1;
            								}
            							}
            							else {
HXLINE(  65)								if ((cy > dy)) {
HXLINE(  65)									int min;
HXDLIN(  65)									if ((by > dy)) {
HXLINE(  65)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  65)										min = ::Math_obj::ceil(by);
            									}
HXDLIN(  65)									int ii_min = min;
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter33 = this1;
            								}
            								else {
HXLINE(  65)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  65)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  65)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  65)									yIter33 = this1;
            								}
            							}
HXDLIN(  65)							::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  65)							if (hasUndo3) {
HXLINE(  65)								int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  65)								int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  65)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  65)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  65)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  65)								undoImage3 = this3;
HXDLIN(  65)								{
HXLINE(  65)									int rectLeft = xIter33->start;
HXDLIN(  65)									int rectTop = yIter33->start;
HXDLIN(  65)									int rectRight = xIter33->max;
HXDLIN(  65)									bool forceClear = false;
HXDLIN(  65)									{
HXLINE(  65)										int _g = rectTop;
HXDLIN(  65)										int _g1 = yIter33->max;
HXDLIN(  65)										while((_g < _g1)){
HXLINE(  65)											_g = (_g + 1);
HXDLIN(  65)											int dy = (_g - 1);
HXDLIN(  65)											{
HXLINE(  65)												int _g1 = rectLeft;
HXDLIN(  65)												int _g2 = rectRight;
HXDLIN(  65)												while((_g1 < _g2)){
HXLINE(  65)													_g1 = (_g1 + 1);
HXDLIN(  65)													int dx = (_g1 - 1);
HXDLIN(  65)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)													int index;
HXDLIN(  65)													if (pixelShape->useVirtualPos) {
HXLINE(  65)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            													}
            													else {
HXLINE(  65)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            													}
HXDLIN(  65)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)													int col;
HXDLIN(  65)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  65)														col = c;
            													}
HXDLIN(  65)													bool _hx_tmp;
HXDLIN(  65)													if (pixelShape->useMask) {
HXLINE(  65)														_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            													}
            													else {
HXLINE(  65)														_hx_tmp = false;
            													}
HXDLIN(  65)													if (_hx_tmp) {
HXLINE(  65)														::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  65)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  65)														int index;
HXDLIN(  65)														if (this1->useVirtualPos) {
HXLINE(  65)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  65)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  65)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  65)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  65)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)														int v;
HXDLIN(  65)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  65)															v = c;
            														}
HXDLIN(  65)														int this3 = v;
HXDLIN(  65)														int maskPixel = this3;
HXDLIN(  65)														int this4 = col;
HXDLIN(  65)														int this5 = this4;
HXDLIN(  65)														if ((maskPixel == 0)) {
HXLINE(  65)															int this1 = this5;
HXDLIN(  65)															col = this1;
            														}
            														else {
HXLINE(  65)															Float m0;
HXDLIN(  65)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  65)															if ((this1 == 0)) {
HXLINE(  65)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m1;
HXDLIN(  65)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  65)															if ((this2 == 0)) {
HXLINE(  65)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m2;
HXDLIN(  65)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  65)															if ((this3 == 0)) {
HXLINE(  65)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float m3;
HXDLIN(  65)															int this4 = (maskPixel & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  65)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  65)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  65)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  65)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  65)													if ((col != 0)) {
HXLINE(  65)														int x = (dx - rectLeft);
HXDLIN(  65)														int y = (dy - rectTop);
HXDLIN(  65)														int this1 = col;
HXDLIN(  65)														int c = this1;
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  65)															_hx_tmp = undoImage3->transparent;
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															int location;
HXDLIN(  65)															if (undoImage3->useVirtualPos) {
HXLINE(  65)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  65)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int this4;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																this4 = this3;
            															}
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this8 = (this4 & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this9 = ((col >> 24) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this10 = ((col >> 16) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this11 = ((col >> 8) & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this12 = (col & 255);
HXDLIN(  65)															if ((this12 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  65)															int index;
HXDLIN(  65)															if (undoImage3->useVirtualPos) {
HXLINE(  65)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  65)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN(  65)															int value;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  65)																value = c;
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((index >= 0)) {
HXLINE(  65)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  65)														if (forceClear) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  65)															int x = (dx - rectLeft);
HXDLIN(  65)															int y = (dy - rectTop);
HXDLIN(  65)															int index;
HXDLIN(  65)															if (undoImage3->useVirtualPos) {
HXLINE(  65)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  65)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((index >= 0)) {
HXLINE(  65)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  65)							bool found3 = false;
HXDLIN(  65)							Float min3 = ( (Float)(0) );
HXDLIN(  65)							Float max3 = ( (Float)(0) );
HXDLIN(  65)							int a4 = 0;
HXDLIN(  65)							int r3 = 0;
HXDLIN(  65)							int g3 = 0;
HXDLIN(  65)							int b3 = 0;
HXDLIN(  65)							{
HXLINE(  65)								int _g_min3 = xIter33->start;
HXDLIN(  65)								int _g_max3 = xIter33->max;
HXDLIN(  65)								while((_g_min3 < _g_max3)){
HXLINE(  65)									_g_min3 = (_g_min3 + 1);
HXDLIN(  65)									int px = (_g_min3 - 1);
HXDLIN(  65)									Float pcx = (( (Float)(px) ) - dx);
HXLINE( 813)									found3 = false;
HXLINE(  65)									{
HXLINE(  65)										int _g_min = yIter33->start;
HXDLIN(  65)										int _g_max = yIter33->max;
HXDLIN(  65)										while((_g_min < _g_max)){
HXLINE(  65)											_g_min = (_g_min + 1);
HXDLIN(  65)											int py = (_g_min - 1);
HXDLIN(  65)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  65)											Float dot31 = ((pcx * bcx3) + (pcy * bcy3));
HXDLIN(  65)											Float dot32 = ((pcx * acx3) + (pcy * acy3));
HXDLIN(  65)											Float ratioA = (((dot223 * dot31) - (dot123 * dot32)) * denom13);
HXDLIN(  65)											Float ratioB = (((dot113 * dot32) - (dot123 * dot31)) * denom13);
HXDLIN(  65)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  65)											bool _hx_tmp;
HXDLIN(  65)											bool _hx_tmp1;
HXDLIN(  65)											if ((ratioA >= 0)) {
HXLINE(  65)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  65)												_hx_tmp1 = false;
            											}
HXDLIN(  65)											if (_hx_tmp1) {
HXLINE(  65)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  65)												_hx_tmp = false;
            											}
HXDLIN(  65)											if (_hx_tmp) {
HXLINE(  65)												int i = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN(  65)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  65)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  65)												int this1 = i;
HXLINE( 822)												r3 = this1;
HXLINE(  65)												int i1 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN(  65)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  65)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  65)												int this2 = i1;
HXLINE( 823)												g3 = this2;
HXLINE(  65)												int i2 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN(  65)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  65)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  65)												int this3 = i2;
HXLINE( 824)												b3 = this3;
HXLINE(  65)												bool _hx_tmp;
HXDLIN(  65)												bool _hx_tmp1;
HXDLIN(  65)												if ((softBC == true)) {
HXLINE(  65)													_hx_tmp1 = (softCD == false);
            												}
            												else {
HXLINE(  65)													_hx_tmp1 = false;
            												}
HXDLIN(  65)												if (_hx_tmp1) {
HXLINE(  65)													_hx_tmp = false;
            												}
            												else {
HXLINE(  65)													_hx_tmp = false;
            												}
HXDLIN(  65)												if (_hx_tmp) {
HXLINE(  65)													if ((ratioA < ratioC)) {
HXLINE(  65)														min3 = ratioA;
            													}
            													else {
HXLINE(  65)														min3 = ratioC;
            													}
HXDLIN(  65)													if ((ratioA > ratioB)) {
HXLINE(  65)														max3 = ratioA;
            													}
            													else {
HXLINE(  65)														max3 = ratioB;
            													}
HXDLIN(  65)													if (!((max3 > ratioC))) {
HXLINE(  65)														max3 = ratioC;
            													}
HXLINE( 830)													max3 = ((( (Float)(1) ) - max3) / ( (Float)(2) ));
HXLINE(  65)													if (!((min3 < max3))) {
HXLINE(  65)														min3 = ((max3 + min3) / ( (Float)(2) ));
            													}
HXDLIN(  65)													int i = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft) * min3));
HXDLIN(  65)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  65)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  65)													int this1 = i;
HXLINE( 833)													a4 = this1;
HXLINE(  65)													{
HXLINE(  65)														int location;
HXDLIN(  65)														if (pixelShape->useVirtualPos) {
HXLINE(  65)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  65)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if (pixelShape->transparent) {
HXLINE(  65)															_hx_tmp = (a4 < 254);
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int old;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																old = this3;
            															}
HXDLIN(  65)															int rhs = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this4 = ((old >> 24) & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this5 = ((old >> 16) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this6 = ((old >> 8) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this7 = (old & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this11 = (rhs & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															int value;
HXDLIN(  65)															if (pixelShape->isLittle) {
HXLINE(  65)																value = ((((a4 << 24) | (b3 << 16)) | (g3 << 8)) | r3);
            															}
            															else {
HXLINE(  65)																value = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((location >= 0)) {
HXLINE(  65)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
HXDLIN(  65)												bool _hx_tmp2;
HXDLIN(  65)												if ((softBC == true)) {
HXLINE(  65)													_hx_tmp2 = (softCD == true);
            												}
            												else {
HXLINE(  65)													_hx_tmp2 = false;
            												}
HXDLIN(  65)												if (_hx_tmp2) {
HXLINE(  65)													if ((ratioB < ratioC)) {
HXLINE(  65)														min3 = ratioB;
            													}
            													else {
HXLINE(  65)														min3 = ratioC;
            													}
HXDLIN(  65)													if ((ratioA > ratioB)) {
HXLINE(  65)														max3 = ratioA;
            													}
            													else {
HXLINE(  65)														max3 = ratioB;
            													}
HXDLIN(  65)													if (!((max3 > ratioC))) {
HXLINE(  65)														max3 = ratioC;
            													}
HXLINE( 843)													max3 = ((( (Float)(1) ) - max3) / ( (Float)(2) ));
HXLINE(  65)													if (!((min3 < max3))) {
HXLINE(  65)														min3 = ((max3 + min3) / ( (Float)(2) ));
            													}
HXDLIN(  65)													int i = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft) * min3));
HXDLIN(  65)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  65)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  65)													int this1 = i;
HXLINE( 846)													a4 = this1;
HXLINE(  65)													{
HXLINE(  65)														int location;
HXDLIN(  65)														if (pixelShape->useVirtualPos) {
HXLINE(  65)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  65)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  65)														bool _hx_tmp;
HXDLIN(  65)														if (pixelShape->transparent) {
HXLINE(  65)															_hx_tmp = (a4 < 254);
            														}
            														else {
HXLINE(  65)															_hx_tmp = false;
            														}
HXDLIN(  65)														if (_hx_tmp) {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  65)															int this3 = this2;
HXDLIN(  65)															int old;
HXDLIN(  65)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  65)																old = this3;
            															}
HXDLIN(  65)															int rhs = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  65)															Float a1;
HXDLIN(  65)															int this4 = ((old >> 24) & 255);
HXDLIN(  65)															if ((this4 == 0)) {
HXLINE(  65)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r1;
HXDLIN(  65)															int this5 = ((old >> 16) & 255);
HXDLIN(  65)															if ((this5 == 0)) {
HXLINE(  65)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g1;
HXDLIN(  65)															int this6 = ((old >> 8) & 255);
HXDLIN(  65)															if ((this6 == 0)) {
HXLINE(  65)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b1;
HXDLIN(  65)															int this7 = (old & 255);
HXDLIN(  65)															if ((this7 == 0)) {
HXLINE(  65)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a2;
HXDLIN(  65)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  65)															if ((this8 == 0)) {
HXLINE(  65)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float r2;
HXDLIN(  65)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  65)															if ((this9 == 0)) {
HXLINE(  65)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float g2;
HXDLIN(  65)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  65)															if ((this10 == 0)) {
HXLINE(  65)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float b2;
HXDLIN(  65)															int this11 = (rhs & 255);
HXDLIN(  65)															if ((this11 == 0)) {
HXLINE(  65)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  65)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  65)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  65)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  65)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  65)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  65)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  65)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  65)															{
HXLINE(  65)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  65)																int value;
HXDLIN(  65)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  65)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  65)																	value = blended;
            																}
HXDLIN(  65)																bool _hx_tmp;
HXDLIN(  65)																if ((location >= 0)) {
HXLINE(  65)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  65)																	_hx_tmp = false;
            																}
HXDLIN(  65)																if (_hx_tmp) {
HXLINE(  65)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  65)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  65)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  65)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  65)															int value;
HXDLIN(  65)															if (pixelShape->isLittle) {
HXLINE(  65)																value = ((((a4 << 24) | (b3 << 16)) | (g3 << 8)) | r3);
            															}
            															else {
HXLINE(  65)																value = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
            															}
HXDLIN(  65)															bool _hx_tmp;
HXDLIN(  65)															if ((location >= 0)) {
HXLINE(  65)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  65)																_hx_tmp = false;
            															}
HXDLIN(  65)															if (_hx_tmp) {
HXLINE(  65)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  65)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  65)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  65)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  65)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  65)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            												}
HXLINE( 851)												found3 = true;
            											}
            											else {
HXLINE(  65)												if (found3) {
HXLINE(  65)													goto _hx_goto_34;
            												}
            											}
            										}
            										_hx_goto_34:;
            									}
            								}
            							}
HXDLIN(  65)							if ((hasHit == false)) {
HXLINE(  65)								::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  65)								if (hasUndo3) {
HXLINE(  65)									v->undoImage = undoImage3;
HXDLIN(  65)									v->undoX = xIter33->start;
HXDLIN(  65)									v->undoY = yIter33->start;
            								}
            							}
            						}
HXDLIN(  65)						if ((hasHit == true)) {
HXLINE(  65)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            						}
            					}
            				}
            			}
            			else {
HXLINE(  67)				::haxe::Log_obj::trace(HX_("luxury!!",2d,d7,02,c7),::hx::SourceInfo(HX_("pixelimage/triangleGML/contour/LineShape.hx",d1,ed,f6,5a),67,HX_("pixelimage.triangleGML.contour.LineShape",f0,52,a6,b8),HX_("render",56,6b,29,05)));
HXLINE(  68)				{
HXLINE(  68)					int color = this->strokeColor;
HXDLIN(  68)					Float soft = this->soft;
HXDLIN(  68)					bool softAB = true;
HXDLIN(  68)					bool softBC = true;
HXDLIN(  68)					bool softCD = true;
HXDLIN(  68)					bool softDA = true;
HXDLIN(  68)					bool hasHit = true;
HXDLIN(  68)					Float o = (qy - py);
HXDLIN(  68)					Float a = (qx - px);
HXDLIN(  68)					Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  68)					Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  68)					{
HXLINE(  68)						 ::Dynamic debugCorners = false;
HXDLIN(  68)						if (::hx::IsNull( debugCorners )) {
HXLINE( 344)							debugCorners = false;
            						}
HXLINE(  68)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  68)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  68)						Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  68)						Float dx = ((Float)0.1);
HXDLIN(  68)						Float dy = radius;
HXDLIN(  68)						Float cx = h;
HXDLIN(  68)						Float cy = radius;
HXDLIN(  68)						Float bx = h;
HXDLIN(  68)						Float by = -(radius);
HXDLIN(  68)						Float ax = ((Float)0.1);
HXDLIN(  68)						Float ay = -(radius);
HXDLIN(  68)						Float temp = ((Float)0.);
HXLINE(  82)						temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  83)						ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  84)						ax = temp;
HXLINE(  86)						temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  87)						by = (py + ((by * cos) + (bx * sin)));
HXLINE(  88)						bx = temp;
HXLINE(  90)						temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  91)						cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  92)						cx = temp;
HXLINE(  94)						temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  95)						dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  96)						dx = temp;
HXLINE(  68)						if (( (bool)(debugCorners) )) {
HXLINE(  68)							{
HXLINE(  68)								Float x = (ax - ((Float)6.));
HXDLIN(  68)								Float y = (ay - ((Float)6.));
HXDLIN(  68)								int p = ::Std_obj::_hx_int(x);
HXDLIN(  68)								int xx = p;
HXDLIN(  68)								int q = ::Std_obj::_hx_int(y);
HXDLIN(  68)								int maxX = ::Std_obj::_hx_int((x + 12));
HXDLIN(  68)								int maxY = ::Std_obj::_hx_int((y + 12));
HXDLIN(  68)								while(true){
HXLINE(  68)									{
HXLINE(  68)										p = (p + 1);
HXDLIN(  68)										int x = (p - 1);
HXDLIN(  68)										int this1 = -65536;
HXDLIN(  68)										int c = this1;
HXDLIN(  68)										bool _hx_tmp;
HXDLIN(  68)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  68)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  68)											_hx_tmp = false;
            										}
HXDLIN(  68)										if (_hx_tmp) {
HXLINE(  68)											int location;
HXDLIN(  68)											if (pixelShape->useVirtualPos) {
HXLINE(  68)												location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  68)												location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            											}
HXDLIN(  68)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)											int this3 = this2;
HXDLIN(  68)											int this4;
HXDLIN(  68)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  68)												this4 = this3;
            											}
HXDLIN(  68)											Float a1;
HXDLIN(  68)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  68)											if ((this5 == 0)) {
HXLINE(  68)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float r1;
HXDLIN(  68)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  68)											if ((this6 == 0)) {
HXLINE(  68)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float g1;
HXDLIN(  68)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  68)											if ((this7 == 0)) {
HXLINE(  68)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float b1;
HXDLIN(  68)											int this8 = (this4 & 255);
HXDLIN(  68)											if ((this8 == 0)) {
HXLINE(  68)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float a2;
HXDLIN(  68)											int this9 = ((-65536 >> 24) & 255);
HXDLIN(  68)											if ((this9 == 0)) {
HXLINE(  68)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float r2;
HXDLIN(  68)											int this10 = ((-65536 >> 16) & 255);
HXDLIN(  68)											if ((this10 == 0)) {
HXLINE(  68)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float g2;
HXDLIN(  68)											int this11 = ((-65536 >> 8) & 255);
HXDLIN(  68)											if ((this11 == 0)) {
HXLINE(  68)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float b2;
HXDLIN(  68)											int this12 = (-65536 & 255);
HXDLIN(  68)											if ((this12 == 0)) {
HXLINE(  68)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  68)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  68)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  68)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  68)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  68)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  68)											{
HXLINE(  68)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  68)												int value;
HXDLIN(  68)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  68)													value = blended;
            												}
HXDLIN(  68)												bool _hx_tmp;
HXDLIN(  68)												if ((location >= 0)) {
HXLINE(  68)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  68)													_hx_tmp = false;
            												}
HXDLIN(  68)												if (_hx_tmp) {
HXLINE(  68)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  68)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  68)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  68)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)											int index;
HXDLIN(  68)											if (pixelShape->useVirtualPos) {
HXLINE(  68)												index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  68)												index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            											}
HXDLIN(  68)											int value;
HXDLIN(  68)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  68)												value = c;
            											}
HXDLIN(  68)											bool _hx_tmp;
HXDLIN(  68)											if ((index >= 0)) {
HXLINE(  68)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  68)												_hx_tmp = false;
            											}
HXDLIN(  68)											if (_hx_tmp) {
HXLINE(  68)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXDLIN(  68)									if ((p > maxX)) {
HXLINE( 247)										p = xx;
HXLINE(  68)										q = (q + 1);
            									}
HXDLIN(  68)									if ((q > maxY)) {
HXLINE(  68)										goto _hx_goto_35;
            									}
            								}
            								_hx_goto_35:;
            							}
HXDLIN(  68)							{
HXLINE(  68)								Float x1 = (bx - ((Float)6.));
HXDLIN(  68)								Float y1 = (by - ((Float)6.));
HXDLIN(  68)								int p1 = ::Std_obj::_hx_int(x1);
HXDLIN(  68)								int xx1 = p1;
HXDLIN(  68)								int q1 = ::Std_obj::_hx_int(y1);
HXDLIN(  68)								int maxX1 = ::Std_obj::_hx_int((x1 + 12));
HXDLIN(  68)								int maxY1 = ::Std_obj::_hx_int((y1 + 12));
HXDLIN(  68)								while(true){
HXLINE(  68)									{
HXLINE(  68)										p1 = (p1 + 1);
HXDLIN(  68)										int x = (p1 - 1);
HXDLIN(  68)										int this1 = -16711936;
HXDLIN(  68)										int c = this1;
HXDLIN(  68)										bool _hx_tmp;
HXDLIN(  68)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  68)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  68)											_hx_tmp = false;
            										}
HXDLIN(  68)										if (_hx_tmp) {
HXLINE(  68)											int location;
HXDLIN(  68)											if (pixelShape->useVirtualPos) {
HXLINE(  68)												location = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  68)												location = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            											}
HXDLIN(  68)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)											int this3 = this2;
HXDLIN(  68)											int this4;
HXDLIN(  68)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  68)												this4 = this3;
            											}
HXDLIN(  68)											Float a1;
HXDLIN(  68)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  68)											if ((this5 == 0)) {
HXLINE(  68)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float r1;
HXDLIN(  68)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  68)											if ((this6 == 0)) {
HXLINE(  68)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float g1;
HXDLIN(  68)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  68)											if ((this7 == 0)) {
HXLINE(  68)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float b1;
HXDLIN(  68)											int this8 = (this4 & 255);
HXDLIN(  68)											if ((this8 == 0)) {
HXLINE(  68)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float a2;
HXDLIN(  68)											int this9 = ((-16711936 >> 24) & 255);
HXDLIN(  68)											if ((this9 == 0)) {
HXLINE(  68)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float r2;
HXDLIN(  68)											int this10 = ((-16711936 >> 16) & 255);
HXDLIN(  68)											if ((this10 == 0)) {
HXLINE(  68)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float g2;
HXDLIN(  68)											int this11 = ((-16711936 >> 8) & 255);
HXDLIN(  68)											if ((this11 == 0)) {
HXLINE(  68)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float b2;
HXDLIN(  68)											int this12 = (-16711936 & 255);
HXDLIN(  68)											if ((this12 == 0)) {
HXLINE(  68)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  68)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  68)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  68)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  68)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  68)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  68)											{
HXLINE(  68)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  68)												int value;
HXDLIN(  68)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  68)													value = blended;
            												}
HXDLIN(  68)												bool _hx_tmp;
HXDLIN(  68)												if ((location >= 0)) {
HXLINE(  68)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  68)													_hx_tmp = false;
            												}
HXDLIN(  68)												if (_hx_tmp) {
HXLINE(  68)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  68)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  68)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  68)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)											int index;
HXDLIN(  68)											if (pixelShape->useVirtualPos) {
HXLINE(  68)												index = ::Std_obj::_hx_int(((((( (Float)(q1) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  68)												index = ::Std_obj::_hx_int(( (Float)(((q1 * pixelShape->width) + x)) ));
            											}
HXDLIN(  68)											int value;
HXDLIN(  68)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  68)												value = c;
            											}
HXDLIN(  68)											bool _hx_tmp;
HXDLIN(  68)											if ((index >= 0)) {
HXLINE(  68)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  68)												_hx_tmp = false;
            											}
HXDLIN(  68)											if (_hx_tmp) {
HXLINE(  68)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXDLIN(  68)									if ((p1 > maxX1)) {
HXLINE( 247)										p1 = xx1;
HXLINE(  68)										q1 = (q1 + 1);
            									}
HXDLIN(  68)									if ((q1 > maxY1)) {
HXLINE(  68)										goto _hx_goto_36;
            									}
            								}
            								_hx_goto_36:;
            							}
HXDLIN(  68)							{
HXLINE(  68)								Float x2 = (cx - ((Float)6.));
HXDLIN(  68)								Float y2 = (cy - ((Float)6.));
HXDLIN(  68)								int p2 = ::Std_obj::_hx_int(x2);
HXDLIN(  68)								int xx2 = p2;
HXDLIN(  68)								int q2 = ::Std_obj::_hx_int(y2);
HXDLIN(  68)								int maxX2 = ::Std_obj::_hx_int((x2 + 12));
HXDLIN(  68)								int maxY2 = ::Std_obj::_hx_int((y2 + 12));
HXDLIN(  68)								while(true){
HXLINE(  68)									{
HXLINE(  68)										p2 = (p2 + 1);
HXDLIN(  68)										int x = (p2 - 1);
HXDLIN(  68)										int this1 = -16776961;
HXDLIN(  68)										int c = this1;
HXDLIN(  68)										bool _hx_tmp;
HXDLIN(  68)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  68)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  68)											_hx_tmp = false;
            										}
HXDLIN(  68)										if (_hx_tmp) {
HXLINE(  68)											int location;
HXDLIN(  68)											if (pixelShape->useVirtualPos) {
HXLINE(  68)												location = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  68)												location = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            											}
HXDLIN(  68)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)											int this3 = this2;
HXDLIN(  68)											int this4;
HXDLIN(  68)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  68)												this4 = this3;
            											}
HXDLIN(  68)											Float a1;
HXDLIN(  68)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  68)											if ((this5 == 0)) {
HXLINE(  68)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float r1;
HXDLIN(  68)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  68)											if ((this6 == 0)) {
HXLINE(  68)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float g1;
HXDLIN(  68)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  68)											if ((this7 == 0)) {
HXLINE(  68)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float b1;
HXDLIN(  68)											int this8 = (this4 & 255);
HXDLIN(  68)											if ((this8 == 0)) {
HXLINE(  68)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float a2;
HXDLIN(  68)											int this9 = ((-16776961 >> 24) & 255);
HXDLIN(  68)											if ((this9 == 0)) {
HXLINE(  68)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float r2;
HXDLIN(  68)											int this10 = ((-16776961 >> 16) & 255);
HXDLIN(  68)											if ((this10 == 0)) {
HXLINE(  68)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float g2;
HXDLIN(  68)											int this11 = ((-16776961 >> 8) & 255);
HXDLIN(  68)											if ((this11 == 0)) {
HXLINE(  68)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float b2;
HXDLIN(  68)											int this12 = (-16776961 & 255);
HXDLIN(  68)											if ((this12 == 0)) {
HXLINE(  68)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  68)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  68)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  68)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  68)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  68)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  68)											{
HXLINE(  68)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  68)												int value;
HXDLIN(  68)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  68)													value = blended;
            												}
HXDLIN(  68)												bool _hx_tmp;
HXDLIN(  68)												if ((location >= 0)) {
HXLINE(  68)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  68)													_hx_tmp = false;
            												}
HXDLIN(  68)												if (_hx_tmp) {
HXLINE(  68)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  68)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  68)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  68)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)											int index;
HXDLIN(  68)											if (pixelShape->useVirtualPos) {
HXLINE(  68)												index = ::Std_obj::_hx_int(((((( (Float)(q2) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  68)												index = ::Std_obj::_hx_int(( (Float)(((q2 * pixelShape->width) + x)) ));
            											}
HXDLIN(  68)											int value;
HXDLIN(  68)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  68)												value = c;
            											}
HXDLIN(  68)											bool _hx_tmp;
HXDLIN(  68)											if ((index >= 0)) {
HXLINE(  68)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  68)												_hx_tmp = false;
            											}
HXDLIN(  68)											if (_hx_tmp) {
HXLINE(  68)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXDLIN(  68)									if ((p2 > maxX2)) {
HXLINE( 247)										p2 = xx2;
HXLINE(  68)										q2 = (q2 + 1);
            									}
HXDLIN(  68)									if ((q2 > maxY2)) {
HXLINE(  68)										goto _hx_goto_37;
            									}
            								}
            								_hx_goto_37:;
            							}
HXDLIN(  68)							{
HXLINE(  68)								Float x3 = (dx - ((Float)6.));
HXDLIN(  68)								Float y3 = (dy - ((Float)6.));
HXDLIN(  68)								int p3 = ::Std_obj::_hx_int(x3);
HXDLIN(  68)								int xx3 = p3;
HXDLIN(  68)								int q3 = ::Std_obj::_hx_int(y3);
HXDLIN(  68)								int maxX3 = ::Std_obj::_hx_int((x3 + 12));
HXDLIN(  68)								int maxY3 = ::Std_obj::_hx_int((y3 + 12));
HXDLIN(  68)								while(true){
HXLINE(  68)									{
HXLINE(  68)										p3 = (p3 + 1);
HXDLIN(  68)										int x = (p3 - 1);
HXDLIN(  68)										int this1 = -1048336;
HXDLIN(  68)										int c = this1;
HXDLIN(  68)										bool _hx_tmp;
HXDLIN(  68)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  68)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  68)											_hx_tmp = false;
            										}
HXDLIN(  68)										if (_hx_tmp) {
HXLINE(  68)											int location;
HXDLIN(  68)											if (pixelShape->useVirtualPos) {
HXLINE(  68)												location = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  68)												location = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            											}
HXDLIN(  68)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)											int this3 = this2;
HXDLIN(  68)											int this4;
HXDLIN(  68)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  68)												this4 = this3;
            											}
HXDLIN(  68)											Float a1;
HXDLIN(  68)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  68)											if ((this5 == 0)) {
HXLINE(  68)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float r1;
HXDLIN(  68)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  68)											if ((this6 == 0)) {
HXLINE(  68)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float g1;
HXDLIN(  68)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  68)											if ((this7 == 0)) {
HXLINE(  68)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float b1;
HXDLIN(  68)											int this8 = (this4 & 255);
HXDLIN(  68)											if ((this8 == 0)) {
HXLINE(  68)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float a2;
HXDLIN(  68)											int this9 = ((-1048336 >> 24) & 255);
HXDLIN(  68)											if ((this9 == 0)) {
HXLINE(  68)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float r2;
HXDLIN(  68)											int this10 = ((-1048336 >> 16) & 255);
HXDLIN(  68)											if ((this10 == 0)) {
HXLINE(  68)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float g2;
HXDLIN(  68)											int this11 = ((-1048336 >> 8) & 255);
HXDLIN(  68)											if ((this11 == 0)) {
HXLINE(  68)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float b2;
HXDLIN(  68)											int this12 = (-1048336 & 255);
HXDLIN(  68)											if ((this12 == 0)) {
HXLINE(  68)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  68)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  68)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  68)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  68)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  68)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  68)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  68)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  68)											{
HXLINE(  68)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  68)												int value;
HXDLIN(  68)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  68)													value = blended;
            												}
HXDLIN(  68)												bool _hx_tmp;
HXDLIN(  68)												if ((location >= 0)) {
HXLINE(  68)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  68)													_hx_tmp = false;
            												}
HXDLIN(  68)												if (_hx_tmp) {
HXLINE(  68)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  68)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  68)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  68)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)											int index;
HXDLIN(  68)											if (pixelShape->useVirtualPos) {
HXLINE(  68)												index = ::Std_obj::_hx_int(((((( (Float)(q3) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  68)												index = ::Std_obj::_hx_int(( (Float)(((q3 * pixelShape->width) + x)) ));
            											}
HXDLIN(  68)											int value;
HXDLIN(  68)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  68)												value = c;
            											}
HXDLIN(  68)											bool _hx_tmp;
HXDLIN(  68)											if ((index >= 0)) {
HXLINE(  68)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  68)												_hx_tmp = false;
            											}
HXDLIN(  68)											if (_hx_tmp) {
HXLINE(  68)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXDLIN(  68)									if ((p3 > maxX3)) {
HXLINE( 247)										p3 = xx3;
HXLINE(  68)										q3 = (q3 + 1);
            									}
HXDLIN(  68)									if ((q3 > maxY3)) {
HXLINE(  68)										goto _hx_goto_38;
            									}
            								}
            								_hx_goto_38:;
            							}
            						}
HXDLIN(  68)						{
HXLINE(  68)							{
HXLINE(  68)								bool hasUndo = true;
HXDLIN(  68)								int aA = ((color >> 24) & 255);
HXDLIN(  68)								int rA = ((color >> 16) & 255);
HXDLIN(  68)								int gA = ((color >> 8) & 255);
HXDLIN(  68)								int bA = (color & 255);
HXDLIN(  68)								Float bcx = (bx - dx);
HXDLIN(  68)								Float bcy = (by - dy);
HXDLIN(  68)								Float acx = (ax - dx);
HXDLIN(  68)								Float acy = (ay - dy);
HXDLIN(  68)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  68)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  68)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  68)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  68)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  68)								if ((ax > bx)) {
HXLINE(  68)									if ((ax > dx)) {
HXLINE(  68)										int min;
HXDLIN(  68)										if ((bx > dx)) {
HXLINE(  68)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  68)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  68)										int ii_min = min;
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										xIter3 = this1;
            									}
            									else {
HXLINE(  68)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  68)									if ((bx > dx)) {
HXLINE(  68)										int min;
HXDLIN(  68)										if ((ax > dx)) {
HXLINE(  68)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  68)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  68)										int ii_min = min;
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										xIter3 = this1;
            									}
            									else {
HXLINE(  68)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										xIter3 = this1;
            									}
            								}
HXDLIN(  68)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  68)								if ((ay > by)) {
HXLINE(  68)									if ((ay > dy)) {
HXLINE(  68)										int min;
HXDLIN(  68)										if ((by > dy)) {
HXLINE(  68)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  68)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  68)										int ii_min = min;
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										yIter3 = this1;
            									}
            									else {
HXLINE(  68)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  68)									if ((by > dy)) {
HXLINE(  68)										int min;
HXDLIN(  68)										if ((ay > dy)) {
HXLINE(  68)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  68)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  68)										int ii_min = min;
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										yIter3 = this1;
            									}
            									else {
HXLINE(  68)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										yIter3 = this1;
            									}
            								}
HXDLIN(  68)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  68)								if (hasUndo) {
HXLINE(  68)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  68)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  68)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  68)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  68)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  68)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  68)									undoImage = this3;
HXDLIN(  68)									{
HXLINE(  68)										int rectLeft = xIter3->start;
HXDLIN(  68)										int rectTop = yIter3->start;
HXDLIN(  68)										int rectRight = xIter3->max;
HXDLIN(  68)										bool forceClear = false;
HXDLIN(  68)										{
HXLINE(  68)											int _g = rectTop;
HXDLIN(  68)											int _g1 = yIter3->max;
HXDLIN(  68)											while((_g < _g1)){
HXLINE(  68)												_g = (_g + 1);
HXDLIN(  68)												int dy = (_g - 1);
HXDLIN(  68)												{
HXLINE(  68)													int _g1 = rectLeft;
HXDLIN(  68)													int _g2 = rectRight;
HXDLIN(  68)													while((_g1 < _g2)){
HXLINE(  68)														_g1 = (_g1 + 1);
HXDLIN(  68)														int dx = (_g1 - 1);
HXDLIN(  68)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)														int index;
HXDLIN(  68)														if (pixelShape->useVirtualPos) {
HXLINE(  68)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  68)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  68)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)														int col;
HXDLIN(  68)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  68)															col = c;
            														}
HXDLIN(  68)														bool _hx_tmp;
HXDLIN(  68)														if (pixelShape->useMask) {
HXLINE(  68)															_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  68)															_hx_tmp = false;
            														}
HXDLIN(  68)														if (_hx_tmp) {
HXLINE(  68)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  68)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  68)															int index;
HXDLIN(  68)															if (this1->useVirtualPos) {
HXLINE(  68)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  68)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  68)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  68)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  68)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)															int v;
HXDLIN(  68)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  68)																v = c;
            															}
HXDLIN(  68)															int this3 = v;
HXDLIN(  68)															int maskPixel = this3;
HXDLIN(  68)															int this4 = col;
HXDLIN(  68)															int this5 = this4;
HXDLIN(  68)															if ((maskPixel == 0)) {
HXLINE(  68)																int this1 = this5;
HXDLIN(  68)																col = this1;
            															}
            															else {
HXLINE(  68)																Float m0;
HXDLIN(  68)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  68)																if ((this1 == 0)) {
HXLINE(  68)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float m1;
HXDLIN(  68)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  68)																if ((this2 == 0)) {
HXLINE(  68)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float m2;
HXDLIN(  68)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  68)																if ((this3 == 0)) {
HXLINE(  68)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float m3;
HXDLIN(  68)																int this4 = (maskPixel & 255);
HXDLIN(  68)																if ((this4 == 0)) {
HXLINE(  68)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  68)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  68)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  68)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  68)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  68)														if ((col != 0)) {
HXLINE(  68)															int x = (dx - rectLeft);
HXDLIN(  68)															int y = (dy - rectTop);
HXDLIN(  68)															int this1 = col;
HXDLIN(  68)															int c = this1;
HXDLIN(  68)															bool _hx_tmp;
HXDLIN(  68)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  68)																_hx_tmp = undoImage->transparent;
            															}
            															else {
HXLINE(  68)																_hx_tmp = false;
            															}
HXDLIN(  68)															if (_hx_tmp) {
HXLINE(  68)																int location;
HXDLIN(  68)																if (undoImage->useVirtualPos) {
HXLINE(  68)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  68)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  68)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  68)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)																int this3 = this2;
HXDLIN(  68)																int this4;
HXDLIN(  68)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  68)																	this4 = this3;
            																}
HXDLIN(  68)																Float a1;
HXDLIN(  68)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  68)																if ((this5 == 0)) {
HXLINE(  68)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float r1;
HXDLIN(  68)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  68)																if ((this6 == 0)) {
HXLINE(  68)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float g1;
HXDLIN(  68)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  68)																if ((this7 == 0)) {
HXLINE(  68)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float b1;
HXDLIN(  68)																int this8 = (this4 & 255);
HXDLIN(  68)																if ((this8 == 0)) {
HXLINE(  68)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float a2;
HXDLIN(  68)																int this9 = ((col >> 24) & 255);
HXDLIN(  68)																if ((this9 == 0)) {
HXLINE(  68)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float r2;
HXDLIN(  68)																int this10 = ((col >> 16) & 255);
HXDLIN(  68)																if ((this10 == 0)) {
HXLINE(  68)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float g2;
HXDLIN(  68)																int this11 = ((col >> 8) & 255);
HXDLIN(  68)																if ((this11 == 0)) {
HXLINE(  68)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float b2;
HXDLIN(  68)																int this12 = (col & 255);
HXDLIN(  68)																if ((this12 == 0)) {
HXLINE(  68)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  68)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  68)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  68)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  68)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  68)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  68)																{
HXLINE(  68)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  68)																	int value;
HXDLIN(  68)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  68)																		value = blended;
            																	}
HXDLIN(  68)																	bool _hx_tmp;
HXDLIN(  68)																	if ((location >= 0)) {
HXLINE(  68)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  68)																		_hx_tmp = false;
            																	}
HXDLIN(  68)																	if (_hx_tmp) {
HXLINE(  68)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  68)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  68)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  68)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  68)																int index;
HXDLIN(  68)																if (undoImage->useVirtualPos) {
HXLINE(  68)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  68)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  68)																int value;
HXDLIN(  68)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  68)																	value = c;
            																}
HXDLIN(  68)																bool _hx_tmp;
HXDLIN(  68)																if ((index >= 0)) {
HXLINE(  68)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  68)																	_hx_tmp = false;
            																}
HXDLIN(  68)																if (_hx_tmp) {
HXLINE(  68)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  68)															if (forceClear) {
HXLINE(  68)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  68)																int x = (dx - rectLeft);
HXDLIN(  68)																int y = (dy - rectTop);
HXDLIN(  68)																int index;
HXDLIN(  68)																if (undoImage->useVirtualPos) {
HXLINE(  68)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  68)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  68)																bool _hx_tmp;
HXDLIN(  68)																if ((index >= 0)) {
HXLINE(  68)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  68)																	_hx_tmp = false;
            																}
HXDLIN(  68)																if (_hx_tmp) {
HXLINE(  68)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  68)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  68)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  68)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  68)								bool found = false;
HXDLIN(  68)								Float min = ( (Float)(0) );
HXDLIN(  68)								Float max = ( (Float)(0) );
HXDLIN(  68)								int a1 = 0;
HXDLIN(  68)								int r = 0;
HXDLIN(  68)								int g = 0;
HXDLIN(  68)								int b = 0;
HXDLIN(  68)								{
HXLINE(  68)									int _g_min = xIter3->start;
HXDLIN(  68)									int _g_max = xIter3->max;
HXDLIN(  68)									while((_g_min < _g_max)){
HXLINE(  68)										_g_min = (_g_min + 1);
HXDLIN(  68)										int px = (_g_min - 1);
HXDLIN(  68)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found = false;
HXLINE(  68)										{
HXLINE(  68)											int _g_min1 = yIter3->start;
HXDLIN(  68)											int _g_max = yIter3->max;
HXDLIN(  68)											while((_g_min1 < _g_max)){
HXLINE(  68)												_g_min1 = (_g_min1 + 1);
HXDLIN(  68)												int py = (_g_min1 - 1);
HXDLIN(  68)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  68)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  68)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  68)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  68)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  68)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  68)												bool _hx_tmp;
HXDLIN(  68)												bool _hx_tmp1;
HXDLIN(  68)												if ((ratioA >= 0)) {
HXLINE(  68)													_hx_tmp1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  68)													_hx_tmp1 = false;
            												}
HXDLIN(  68)												if (_hx_tmp1) {
HXLINE(  68)													_hx_tmp = (ratioC >= 0);
            												}
            												else {
HXLINE(  68)													_hx_tmp = false;
            												}
HXDLIN(  68)												if (_hx_tmp) {
HXLINE(  68)													if (softAB) {
HXLINE(  68)														if (softDA) {
HXLINE(  68)															if ((ratioA < ratioC)) {
HXLINE(  68)																min = ratioA;
            															}
            															else {
HXLINE(  68)																min = ratioC;
            															}
HXDLIN(  68)															if ((ratioA > ratioB)) {
HXLINE(  68)																max = ratioA;
            															}
            															else {
HXLINE(  68)																max = ratioB;
            															}
HXDLIN(  68)															if (!((max > ratioC))) {
HXLINE(  68)																max = ratioC;
            															}
HXLINE( 729)															max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  68)															if (!((min < max))) {
HXLINE(  68)																min = ((max + min) / ( (Float)(2) ));
            															}
HXDLIN(  68)															int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  68)															if ((i > 255)) {
HXLINE(  24)																i = 255;
            															}
HXLINE(  68)															if ((i < 0)) {
HXLINE(  25)																i = 0;
            															}
HXLINE(  68)															int this1 = i;
HXDLIN(  68)															a1 = this1;
            														}
            														else {
HXLINE( 723)															min = ratioC;
HXLINE(  68)															int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  68)															if ((i > 255)) {
HXLINE(  24)																i = 255;
            															}
HXLINE(  68)															if ((i < 0)) {
HXLINE(  25)																i = 0;
            															}
HXLINE(  68)															int this1 = i;
HXDLIN(  68)															a1 = this1;
            														}
            													}
            													else {
HXLINE(  68)														if (softDA) {
HXLINE( 710)															min = ratioA;
HXLINE(  68)															int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  68)															if ((i > 255)) {
HXLINE(  24)																i = 255;
            															}
HXLINE(  68)															if ((i < 0)) {
HXLINE(  25)																i = 0;
            															}
HXLINE(  68)															int this1 = i;
HXDLIN(  68)															a1 = this1;
            														}
            														else {
HXLINE(  68)															int i = ::Std_obj::_hx_int(( (Float)(aA) ));
HXDLIN(  68)															if ((i > 255)) {
HXLINE(  24)																i = 255;
            															}
HXLINE(  68)															if ((i < 0)) {
HXLINE(  25)																i = 0;
            															}
HXLINE(  68)															int this1 = i;
HXDLIN(  68)															a1 = this1;
            														}
            													}
HXDLIN(  68)													int i = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  68)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  68)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  68)													int this1 = i;
HXLINE( 748)													r = this1;
HXLINE(  68)													int i1 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  68)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  68)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  68)													int this2 = i1;
HXLINE( 749)													g = this2;
HXLINE(  68)													int i2 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  68)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  68)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  68)													int this3 = i2;
HXLINE( 750)													b = this3;
HXLINE(  68)													{
HXLINE(  68)														int location;
HXDLIN(  68)														if (pixelShape->useVirtualPos) {
HXLINE(  68)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  68)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  68)														bool _hx_tmp;
HXDLIN(  68)														if (pixelShape->transparent) {
HXLINE(  68)															_hx_tmp = (a1 < 254);
            														}
            														else {
HXLINE(  68)															_hx_tmp = false;
            														}
HXDLIN(  68)														if (_hx_tmp) {
HXLINE(  68)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)															int this3 = this2;
HXDLIN(  68)															int old;
HXDLIN(  68)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  68)																old = this3;
            															}
HXDLIN(  68)															int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  68)															Float a11;
HXDLIN(  68)															int this4 = ((old >> 24) & 255);
HXDLIN(  68)															if ((this4 == 0)) {
HXLINE(  68)																a11 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float r1;
HXDLIN(  68)															int this5 = ((old >> 16) & 255);
HXDLIN(  68)															if ((this5 == 0)) {
HXLINE(  68)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float g1;
HXDLIN(  68)															int this6 = ((old >> 8) & 255);
HXDLIN(  68)															if ((this6 == 0)) {
HXLINE(  68)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float b1;
HXDLIN(  68)															int this7 = (old & 255);
HXDLIN(  68)															if ((this7 == 0)) {
HXLINE(  68)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float a2;
HXDLIN(  68)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  68)															if ((this8 == 0)) {
HXLINE(  68)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float r2;
HXDLIN(  68)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  68)															if ((this9 == 0)) {
HXLINE(  68)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float g2;
HXDLIN(  68)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  68)															if ((this10 == 0)) {
HXLINE(  68)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float b2;
HXDLIN(  68)															int this11 = (rhs & 255);
HXDLIN(  68)															if ((this11 == 0)) {
HXLINE(  68)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  68)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  68)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  68)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  68)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  68)															int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  68)															{
HXLINE(  68)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  68)																int value;
HXDLIN(  68)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  68)																	value = blended;
            																}
HXDLIN(  68)																bool _hx_tmp;
HXDLIN(  68)																if ((location >= 0)) {
HXLINE(  68)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  68)																	_hx_tmp = false;
            																}
HXDLIN(  68)																if (_hx_tmp) {
HXLINE(  68)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  68)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  68)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  68)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)															int value;
HXDLIN(  68)															if (pixelShape->isLittle) {
HXLINE(  68)																value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  68)																value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  68)															bool _hx_tmp;
HXDLIN(  68)															if ((location >= 0)) {
HXLINE(  68)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  68)																_hx_tmp = false;
            															}
HXDLIN(  68)															if (_hx_tmp) {
HXLINE(  68)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found = true;
            												}
            												else {
HXLINE(  68)													if (found) {
HXLINE(  68)														goto _hx_goto_42;
            													}
            												}
            											}
            											_hx_goto_42:;
            										}
            									}
            								}
HXDLIN(  68)								if ((hasHit == false)) {
HXLINE(  68)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  68)									if (hasUndo) {
HXLINE(  68)										v->undoImage = undoImage;
HXDLIN(  68)										v->undoX = xIter3->start;
HXDLIN(  68)										v->undoY = yIter3->start;
            									}
            								}
            							}
HXDLIN(  68)							{
HXLINE(  68)								bool hasUndo1 = true;
HXDLIN(  68)								int aA1 = ((color >> 24) & 255);
HXDLIN(  68)								int rA1 = ((color >> 16) & 255);
HXDLIN(  68)								int gA1 = ((color >> 8) & 255);
HXDLIN(  68)								int bA1 = (color & 255);
HXDLIN(  68)								Float bcx1 = (cx - dx);
HXDLIN(  68)								Float bcy1 = (cy - dy);
HXDLIN(  68)								Float acx1 = (bx - dx);
HXDLIN(  68)								Float acy1 = (by - dy);
HXDLIN(  68)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  68)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  68)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  68)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  68)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  68)								if ((bx > cx)) {
HXLINE(  68)									if ((bx > dx)) {
HXLINE(  68)										int min;
HXDLIN(  68)										if ((cx > dx)) {
HXLINE(  68)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  68)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  68)										int ii_min = min;
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										xIter31 = this1;
            									}
            									else {
HXLINE(  68)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  68)									if ((cx > dx)) {
HXLINE(  68)										int min;
HXDLIN(  68)										if ((bx > dx)) {
HXLINE(  68)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  68)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  68)										int ii_min = min;
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										xIter31 = this1;
            									}
            									else {
HXLINE(  68)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										xIter31 = this1;
            									}
            								}
HXDLIN(  68)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  68)								if ((by > cy)) {
HXLINE(  68)									if ((by > dy)) {
HXLINE(  68)										int min;
HXDLIN(  68)										if ((cy > dy)) {
HXLINE(  68)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  68)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  68)										int ii_min = min;
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										yIter31 = this1;
            									}
            									else {
HXLINE(  68)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  68)									if ((cy > dy)) {
HXLINE(  68)										int min;
HXDLIN(  68)										if ((by > dy)) {
HXLINE(  68)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  68)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  68)										int ii_min = min;
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										yIter31 = this1;
            									}
            									else {
HXLINE(  68)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  68)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  68)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  68)										yIter31 = this1;
            									}
            								}
HXDLIN(  68)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  68)								if (hasUndo1) {
HXLINE(  68)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  68)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  68)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  68)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  68)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  68)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  68)									undoImage1 = this3;
HXDLIN(  68)									{
HXLINE(  68)										int rectLeft = xIter31->start;
HXDLIN(  68)										int rectTop = yIter31->start;
HXDLIN(  68)										int rectRight = xIter31->max;
HXDLIN(  68)										bool forceClear = false;
HXDLIN(  68)										{
HXLINE(  68)											int _g = rectTop;
HXDLIN(  68)											int _g1 = yIter31->max;
HXDLIN(  68)											while((_g < _g1)){
HXLINE(  68)												_g = (_g + 1);
HXDLIN(  68)												int dy = (_g - 1);
HXDLIN(  68)												{
HXLINE(  68)													int _g1 = rectLeft;
HXDLIN(  68)													int _g2 = rectRight;
HXDLIN(  68)													while((_g1 < _g2)){
HXLINE(  68)														_g1 = (_g1 + 1);
HXDLIN(  68)														int dx = (_g1 - 1);
HXDLIN(  68)														::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)														int index;
HXDLIN(  68)														if (pixelShape->useVirtualPos) {
HXLINE(  68)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  68)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            														}
HXDLIN(  68)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)														int col;
HXDLIN(  68)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  68)															col = c;
            														}
HXDLIN(  68)														bool _hx_tmp;
HXDLIN(  68)														if (pixelShape->useMask) {
HXLINE(  68)															_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            														}
            														else {
HXLINE(  68)															_hx_tmp = false;
            														}
HXDLIN(  68)														if (_hx_tmp) {
HXLINE(  68)															::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  68)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  68)															int index;
HXDLIN(  68)															if (this1->useVirtualPos) {
HXLINE(  68)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  68)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  68)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  68)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  68)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)															int v;
HXDLIN(  68)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  68)																v = c;
            															}
HXDLIN(  68)															int this3 = v;
HXDLIN(  68)															int maskPixel = this3;
HXDLIN(  68)															int this4 = col;
HXDLIN(  68)															int this5 = this4;
HXDLIN(  68)															if ((maskPixel == 0)) {
HXLINE(  68)																int this1 = this5;
HXDLIN(  68)																col = this1;
            															}
            															else {
HXLINE(  68)																Float m0;
HXDLIN(  68)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  68)																if ((this1 == 0)) {
HXLINE(  68)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float m1;
HXDLIN(  68)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  68)																if ((this2 == 0)) {
HXLINE(  68)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float m2;
HXDLIN(  68)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  68)																if ((this3 == 0)) {
HXLINE(  68)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float m3;
HXDLIN(  68)																int this4 = (maskPixel & 255);
HXDLIN(  68)																if ((this4 == 0)) {
HXLINE(  68)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  68)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  68)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  68)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  68)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  68)														if ((col != 0)) {
HXLINE(  68)															int x = (dx - rectLeft);
HXDLIN(  68)															int y = (dy - rectTop);
HXDLIN(  68)															int this1 = col;
HXDLIN(  68)															int c = this1;
HXDLIN(  68)															bool _hx_tmp;
HXDLIN(  68)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  68)																_hx_tmp = undoImage1->transparent;
            															}
            															else {
HXLINE(  68)																_hx_tmp = false;
            															}
HXDLIN(  68)															if (_hx_tmp) {
HXLINE(  68)																int location;
HXDLIN(  68)																if (undoImage1->useVirtualPos) {
HXLINE(  68)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  68)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  68)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  68)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)																int this3 = this2;
HXDLIN(  68)																int this4;
HXDLIN(  68)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  68)																	this4 = this3;
            																}
HXDLIN(  68)																Float a1;
HXDLIN(  68)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  68)																if ((this5 == 0)) {
HXLINE(  68)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float r1;
HXDLIN(  68)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  68)																if ((this6 == 0)) {
HXLINE(  68)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float g1;
HXDLIN(  68)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  68)																if ((this7 == 0)) {
HXLINE(  68)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float b1;
HXDLIN(  68)																int this8 = (this4 & 255);
HXDLIN(  68)																if ((this8 == 0)) {
HXLINE(  68)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float a2;
HXDLIN(  68)																int this9 = ((col >> 24) & 255);
HXDLIN(  68)																if ((this9 == 0)) {
HXLINE(  68)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float r2;
HXDLIN(  68)																int this10 = ((col >> 16) & 255);
HXDLIN(  68)																if ((this10 == 0)) {
HXLINE(  68)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float g2;
HXDLIN(  68)																int this11 = ((col >> 8) & 255);
HXDLIN(  68)																if ((this11 == 0)) {
HXLINE(  68)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float b2;
HXDLIN(  68)																int this12 = (col & 255);
HXDLIN(  68)																if ((this12 == 0)) {
HXLINE(  68)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  68)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  68)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  68)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  68)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  68)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  68)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  68)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  68)																{
HXLINE(  68)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  68)																	int value;
HXDLIN(  68)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  68)																		value = blended;
            																	}
HXDLIN(  68)																	bool _hx_tmp;
HXDLIN(  68)																	if ((location >= 0)) {
HXLINE(  68)																		_hx_tmp = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  68)																		_hx_tmp = false;
            																	}
HXDLIN(  68)																	if (_hx_tmp) {
HXLINE(  68)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  68)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  68)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  68)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  68)																int index;
HXDLIN(  68)																if (undoImage1->useVirtualPos) {
HXLINE(  68)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  68)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  68)																int value;
HXDLIN(  68)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  68)																	value = c;
            																}
HXDLIN(  68)																bool _hx_tmp;
HXDLIN(  68)																if ((index >= 0)) {
HXLINE(  68)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  68)																	_hx_tmp = false;
            																}
HXDLIN(  68)																if (_hx_tmp) {
HXLINE(  68)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  68)															if (forceClear) {
HXLINE(  68)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  68)																int x = (dx - rectLeft);
HXDLIN(  68)																int y = (dy - rectTop);
HXDLIN(  68)																int index;
HXDLIN(  68)																if (undoImage1->useVirtualPos) {
HXLINE(  68)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  68)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  68)																bool _hx_tmp;
HXDLIN(  68)																if ((index >= 0)) {
HXLINE(  68)																	_hx_tmp = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  68)																	_hx_tmp = false;
            																}
HXDLIN(  68)																if (_hx_tmp) {
HXLINE(  68)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  68)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  68)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  68)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  68)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  68)								bool found1 = false;
HXDLIN(  68)								Float min1 = ( (Float)(0) );
HXDLIN(  68)								Float max1 = ( (Float)(0) );
HXDLIN(  68)								int a2 = 0;
HXDLIN(  68)								int r1 = 0;
HXDLIN(  68)								int g1 = 0;
HXDLIN(  68)								int b1 = 0;
HXDLIN(  68)								{
HXLINE(  68)									int _g_min1 = xIter31->start;
HXDLIN(  68)									int _g_max1 = xIter31->max;
HXDLIN(  68)									while((_g_min1 < _g_max1)){
HXLINE(  68)										_g_min1 = (_g_min1 + 1);
HXDLIN(  68)										int px = (_g_min1 - 1);
HXDLIN(  68)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found1 = false;
HXLINE(  68)										{
HXLINE(  68)											int _g_min = yIter31->start;
HXDLIN(  68)											int _g_max = yIter31->max;
HXDLIN(  68)											while((_g_min < _g_max)){
HXLINE(  68)												_g_min = (_g_min + 1);
HXDLIN(  68)												int py = (_g_min - 1);
HXDLIN(  68)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  68)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  68)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  68)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  68)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  68)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  68)												bool _hx_tmp;
HXDLIN(  68)												bool _hx_tmp1;
HXDLIN(  68)												if ((ratioA >= 0)) {
HXLINE(  68)													_hx_tmp1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  68)													_hx_tmp1 = false;
            												}
HXDLIN(  68)												if (_hx_tmp1) {
HXLINE(  68)													_hx_tmp = (ratioC >= 0);
            												}
            												else {
HXLINE(  68)													_hx_tmp = false;
            												}
HXDLIN(  68)												if (_hx_tmp) {
HXLINE(  68)													if (softBC) {
HXLINE(  68)														if (softCD) {
HXLINE(  68)															if ((ratioB < ratioC)) {
HXLINE(  68)																min1 = ratioB;
            															}
            															else {
HXLINE(  68)																min1 = ratioC;
            															}
HXDLIN(  68)															if ((ratioA > ratioB)) {
HXLINE(  68)																max1 = ratioA;
            															}
            															else {
HXLINE(  68)																max1 = ratioB;
            															}
HXDLIN(  68)															if (!((max1 > ratioC))) {
HXLINE(  68)																max1 = ratioC;
            															}
HXLINE( 736)															max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  68)															if (!((min1 < max1))) {
HXLINE(  68)																min1 = ((max1 + min1) / ( (Float)(2) ));
            															}
HXDLIN(  68)															int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  68)															if ((i > 255)) {
HXLINE(  24)																i = 255;
            															}
HXLINE(  68)															if ((i < 0)) {
HXLINE(  25)																i = 0;
            															}
HXLINE(  68)															int this1 = i;
HXDLIN(  68)															a2 = this1;
            														}
            														else {
HXLINE( 723)															min1 = ratioC;
HXLINE(  68)															int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  68)															if ((i > 255)) {
HXLINE(  24)																i = 255;
            															}
HXLINE(  68)															if ((i < 0)) {
HXLINE(  25)																i = 0;
            															}
HXLINE(  68)															int this1 = i;
HXDLIN(  68)															a2 = this1;
            														}
            													}
            													else {
HXLINE(  68)														if (softCD) {
HXLINE( 713)															min1 = ratioB;
HXLINE(  68)															int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  68)															if ((i > 255)) {
HXLINE(  24)																i = 255;
            															}
HXLINE(  68)															if ((i < 0)) {
HXLINE(  25)																i = 0;
            															}
HXLINE(  68)															int this1 = i;
HXDLIN(  68)															a2 = this1;
            														}
            														else {
HXLINE(  68)															int i = ::Std_obj::_hx_int(( (Float)(aA1) ));
HXDLIN(  68)															if ((i > 255)) {
HXLINE(  24)																i = 255;
            															}
HXLINE(  68)															if ((i < 0)) {
HXLINE(  25)																i = 0;
            															}
HXLINE(  68)															int this1 = i;
HXDLIN(  68)															a2 = this1;
            														}
            													}
HXDLIN(  68)													int i = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  68)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  68)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  68)													int this1 = i;
HXLINE( 748)													r1 = this1;
HXLINE(  68)													int i1 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  68)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  68)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  68)													int this2 = i1;
HXLINE( 749)													g1 = this2;
HXLINE(  68)													int i2 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  68)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  68)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  68)													int this3 = i2;
HXLINE( 750)													b1 = this3;
HXLINE(  68)													{
HXLINE(  68)														int location;
HXDLIN(  68)														if (pixelShape->useVirtualPos) {
HXLINE(  68)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            														}
            														else {
HXLINE(  68)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            														}
HXDLIN(  68)														bool _hx_tmp;
HXDLIN(  68)														if (pixelShape->transparent) {
HXLINE(  68)															_hx_tmp = (a2 < 254);
            														}
            														else {
HXLINE(  68)															_hx_tmp = false;
            														}
HXDLIN(  68)														if (_hx_tmp) {
HXLINE(  68)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  68)															int this3 = this2;
HXDLIN(  68)															int old;
HXDLIN(  68)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  68)																old = this3;
            															}
HXDLIN(  68)															int rhs = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  68)															Float a1;
HXDLIN(  68)															int this4 = ((old >> 24) & 255);
HXDLIN(  68)															if ((this4 == 0)) {
HXLINE(  68)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float r11;
HXDLIN(  68)															int this5 = ((old >> 16) & 255);
HXDLIN(  68)															if ((this5 == 0)) {
HXLINE(  68)																r11 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float g11;
HXDLIN(  68)															int this6 = ((old >> 8) & 255);
HXDLIN(  68)															if ((this6 == 0)) {
HXLINE(  68)																g11 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float b11;
HXDLIN(  68)															int this7 = (old & 255);
HXDLIN(  68)															if ((this7 == 0)) {
HXLINE(  68)																b11 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float a21;
HXDLIN(  68)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  68)															if ((this8 == 0)) {
HXLINE(  68)																a21 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																a21 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float r2;
HXDLIN(  68)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  68)															if ((this9 == 0)) {
HXLINE(  68)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float g2;
HXDLIN(  68)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  68)															if ((this10 == 0)) {
HXLINE(  68)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float b2;
HXDLIN(  68)															int this11 = (rhs & 255);
HXDLIN(  68)															if ((this11 == 0)) {
HXLINE(  68)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  68)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  68)															Float a3 = (a1 * (( (Float)(1) ) - a21));
HXDLIN(  68)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a21))));
HXDLIN(  68)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a21))));
HXDLIN(  68)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a21))));
HXDLIN(  68)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a21)));
HXDLIN(  68)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  68)															{
HXLINE(  68)																::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  68)																int value;
HXDLIN(  68)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  68)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  68)																	value = blended;
            																}
HXDLIN(  68)																bool _hx_tmp;
HXDLIN(  68)																if ((location >= 0)) {
HXLINE(  68)																	_hx_tmp = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  68)																	_hx_tmp = false;
            																}
HXDLIN(  68)																if (_hx_tmp) {
HXLINE(  68)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  68)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  68)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  68)															::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  68)															int value;
HXDLIN(  68)															if (pixelShape->isLittle) {
HXLINE(  68)																value = ((((a2 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            															}
            															else {
HXLINE(  68)																value = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            															}
HXDLIN(  68)															bool _hx_tmp;
HXDLIN(  68)															if ((location >= 0)) {
HXLINE(  68)																_hx_tmp = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  68)																_hx_tmp = false;
            															}
HXDLIN(  68)															if (_hx_tmp) {
HXLINE(  68)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  68)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  68)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  68)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  68)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  68)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found1 = true;
            												}
            												else {
HXLINE(  68)													if (found1) {
HXLINE(  68)														goto _hx_goto_46;
            													}
            												}
            											}
            											_hx_goto_46:;
            										}
            									}
            								}
HXDLIN(  68)								if ((hasHit == false)) {
HXLINE(  68)									::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  68)									if (hasUndo1) {
HXLINE(  68)										v->undoImage = undoImage1;
HXDLIN(  68)										v->undoX = xIter31->start;
HXDLIN(  68)										v->undoY = yIter31->start;
            									}
            								}
            							}
HXDLIN(  68)							if ((hasHit == true)) {
HXLINE(  68)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  71)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< LineShape_obj > LineShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_luxury) {
	::hx::ObjectPtr< LineShape_obj > __this = new LineShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_x1,__o_y1,__o_x2,__o_y2,__o_soft,__o_luxury);
	return __this;
}

::hx::ObjectPtr< LineShape_obj > LineShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_luxury) {
	LineShape_obj *__this = (LineShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(LineShape_obj), true, "pixelimage.triangleGML.contour.LineShape"));
	*(void **)__this = LineShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_x1,__o_y1,__o_x2,__o_y2,__o_soft,__o_luxury);
	return __this;
}

LineShape_obj::LineShape_obj()
{
}

::hx::Val LineShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { return ::hx::Val( x1 ); }
		if (HX_FIELD_EQ(inName,"y1") ) { return ::hx::Val( y1 ); }
		if (HX_FIELD_EQ(inName,"x2") ) { return ::hx::Val( x2 ); }
		if (HX_FIELD_EQ(inName,"y2") ) { return ::hx::Val( y2 ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"soft") ) { return ::hx::Val( soft ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"luxury") ) { return ::hx::Val( luxury ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val LineShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { x1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y1") ) { y1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x2") ) { x2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y2") ) { y2=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"soft") ) { soft=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"luxury") ) { luxury=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void LineShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x1",b9,68,00,00));
	outFields->push(HX_("y1",98,69,00,00));
	outFields->push(HX_("x2",ba,68,00,00));
	outFields->push(HX_("y2",99,69,00,00));
	outFields->push(HX_("soft",ea,1c,58,4c));
	outFields->push(HX_("luxury",0d,9d,17,dc));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo LineShape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(LineShape_obj,x1),HX_("x1",b9,68,00,00)},
	{::hx::fsFloat,(int)offsetof(LineShape_obj,y1),HX_("y1",98,69,00,00)},
	{::hx::fsFloat,(int)offsetof(LineShape_obj,x2),HX_("x2",ba,68,00,00)},
	{::hx::fsFloat,(int)offsetof(LineShape_obj,y2),HX_("y2",99,69,00,00)},
	{::hx::fsFloat,(int)offsetof(LineShape_obj,soft),HX_("soft",ea,1c,58,4c)},
	{::hx::fsBool,(int)offsetof(LineShape_obj,luxury),HX_("luxury",0d,9d,17,dc)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *LineShape_obj_sStaticStorageInfo = 0;
#endif

static ::String LineShape_obj_sMemberFields[] = {
	HX_("x1",b9,68,00,00),
	HX_("y1",98,69,00,00),
	HX_("x2",ba,68,00,00),
	HX_("y2",99,69,00,00),
	HX_("soft",ea,1c,58,4c),
	HX_("luxury",0d,9d,17,dc),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class LineShape_obj::__mClass;

void LineShape_obj::__register()
{
	LineShape_obj _hx_dummy;
	LineShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.contour.LineShape",f0,52,a6,b8);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(LineShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< LineShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LineShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LineShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace contour
