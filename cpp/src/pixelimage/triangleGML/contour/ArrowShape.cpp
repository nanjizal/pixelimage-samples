// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTriArray
#include <pixelimage/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_contour_ArrowShape
#include <pixelimage/triangleGML/contour/ArrowShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1d8a5f19eda99257_34_new,"pixelimage.triangleGML.contour.ArrowShape","new",0x16425a47,"pixelimage.triangleGML.contour.ArrowShape.new","pixelimage/triangleGML/contour/ArrowShape.hx",34,0xaa1345a6)
HX_LOCAL_STACK_FRAME(_hx_pos_1d8a5f19eda99257_48_setParameter,"pixelimage.triangleGML.contour.ArrowShape","setParameter",0x86aa76e0,"pixelimage.triangleGML.contour.ArrowShape.setParameter","pixelimage/triangleGML/contour/ArrowShape.hx",48,0xaa1345a6)
HX_LOCAL_STACK_FRAME(_hx_pos_1d8a5f19eda99257_73_render,"pixelimage.triangleGML.contour.ArrowShape","render",0xfee6cbcf,"pixelimage.triangleGML.contour.ArrowShape.render","pixelimage/triangleGML/contour/ArrowShape.hx",73,0xaa1345a6)
namespace pixelimage{
namespace triangleGML{
namespace contour{

void ArrowShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< bool >  __o_both,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_arrowWidth,::hx::Null< Float >  __o_arrowHeight,::hx::Null< Float >  __o_soft){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(-1048576);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		bool both = __o_both.Default(false);
            		bool flare = __o_flare.Default(false);
            		bool reverseFlare = __o_reverseFlare.Default(false);
            		Float x1 = __o_x1.Default(((Float)0.));
            		Float y1 = __o_y1.Default(((Float)0.));
            		Float x2 = __o_x2.Default(((Float)0.));
            		Float y2 = __o_y2.Default(((Float)0.));
            		Float arrowWidth = __o_arrowWidth.Default(((Float)0.));
            		Float arrowHeight = __o_arrowHeight.Default(((Float)0.));
            		Float soft = __o_soft.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_1d8a5f19eda99257_34_new)
HXLINE(  35)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
HXLINE(  36)		this->both = both;
HXLINE(  37)		this->flare = flare;
HXLINE(  38)		this->reverseFlare = reverseFlare;
HXLINE(  39)		this->x1 = x1;
HXLINE(  40)		this->y1 = y1;
HXLINE(  41)		this->x2 = x2;
HXLINE(  42)		this->y2 = y2;
HXLINE(  43)		this->arrowHeight = arrowHeight;
HXLINE(  44)		this->arrowWidth = arrowWidth;
HXLINE(  45)		this->soft = soft;
            	}

Dynamic ArrowShape_obj::__CreateEmpty() { return new ArrowShape_obj; }

void *ArrowShape_obj::_hx_vtable = 0;

Dynamic ArrowShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ArrowShape_obj > _hx_result = new ArrowShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14]);
	return _hx_result;
}

bool ArrowShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2091632c) {
		if (inClassId<=(int)0x02800709) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x02800709;
		} else {
			return inClassId==(int)0x2091632c;
		}
	} else {
		return inClassId==(int)0x24e92cfb;
	}
}

void ArrowShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_1d8a5f19eda99257_48_setParameter)
HXDLIN(  48)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("arrowHeight",90,f2,2a,bd)) ){
HXLINE(  66)			this->arrowHeight = ::Std_obj::parseFloat(value);
HXDLIN(  66)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("arrowWidth",7d,93,05,3e)) ){
HXLINE(  64)			this->arrowWidth = ::Std_obj::parseFloat(value);
HXDLIN(  64)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("both",81,88,1b,41)) ){
HXLINE(  50)			bool _hx_tmp;
HXDLIN(  50)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  50)				_hx_tmp = true;
            			}
            			else {
HXLINE(  50)				_hx_tmp = false;
            			}
HXDLIN(  50)			this->both = _hx_tmp;
HXDLIN(  50)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("flare",ce,34,8c,02)) ){
HXLINE(  52)			bool _hx_tmp;
HXDLIN(  52)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  52)				_hx_tmp = true;
            			}
            			else {
HXLINE(  52)				_hx_tmp = false;
            			}
HXDLIN(  52)			this->flare = _hx_tmp;
HXDLIN(  52)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("reverseFlare",4c,10,f1,18)) ){
HXLINE(  54)			bool _hx_tmp;
HXDLIN(  54)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  54)				_hx_tmp = true;
            			}
            			else {
HXLINE(  54)				_hx_tmp = false;
            			}
HXDLIN(  54)			this->reverseFlare = _hx_tmp;
HXDLIN(  54)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("soft",ea,1c,58,4c)) ){
HXLINE(  68)			this->soft = ::Std_obj::parseFloat(value);
HXDLIN(  68)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x1",b9,68,00,00)) ){
HXLINE(  56)			this->x1 = ::Std_obj::parseFloat(value);
HXDLIN(  56)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("x2",ba,68,00,00)) ){
HXLINE(  60)			this->x2 = ::Std_obj::parseFloat(value);
HXDLIN(  60)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y1",98,69,00,00)) ){
HXLINE(  58)			this->y1 = ::Std_obj::parseFloat(value);
HXDLIN(  58)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("y2",99,69,00,00)) ){
HXLINE(  62)			this->y2 = ::Std_obj::parseFloat(value);
HXDLIN(  62)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  70)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct ArrowShape_obj::render(::pixelimage::ImageStruct pixelImage){
            	HX_GC_STACKFRAME(&_hx_pos_1d8a5f19eda99257_73_render)
HXLINE(  74)		Float px = (this->x1 + this->offX);
HXLINE(  75)		Float qx = (this->x2 + this->offX);
HXLINE(  76)		Float py = (this->y1 + this->offY);
HXLINE(  77)		Float qy = (this->y2 + this->offY);
HXLINE(  78)		if ((this->soft != 0)) {
HXLINE(  79)			if ((this->both == false)) {
HXLINE(  80)				bool _hx_tmp;
HXDLIN(  80)				if (!((this->arrowHeight > ((Float)0.)))) {
HXLINE(  80)					_hx_tmp = (this->arrowWidth > ((Float)0.));
            				}
            				else {
HXLINE(  80)					_hx_tmp = true;
            				}
HXDLIN(  80)				if (_hx_tmp) {
HXLINE(  81)					Float arrowWidth = this->arrowWidth;
HXDLIN(  81)					Float arrowHeight = this->arrowHeight;
HXDLIN(  81)					Float thick = this->strokeWidth;
HXDLIN(  81)					int color = this->strokeColor;
HXDLIN(  81)					Float soft = this->soft;
HXDLIN(  81)					bool hasHit = true;
HXDLIN(  81)					{
HXLINE(  81)						Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  81)						Float o = (py - py);
HXDLIN(  81)						Float a = (px - px);
HXDLIN(  81)						Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  81)						Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  81)						Float thicker;
HXDLIN(  81)						if ((arrowWidth > (thick * ((Float)1.1)))) {
HXLINE(  81)							thicker = arrowWidth;
            						}
            						else {
HXLINE(  81)							thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            						}
HXDLIN(  81)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  81)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  81)						Float radius = (thick / ( (Float)(2) ));
HXDLIN(  81)						Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  81)						Float h2;
HXDLIN(  81)						if ((arrowHeight < (h * ((Float)1.1)))) {
HXLINE(  81)							h2 = (h - arrowHeight);
            						}
            						else {
HXLINE(  81)							h2 = (h / goldenRatio);
            						}
HXDLIN(  81)						::pixelimage::algo::HitQuad hitQuad;
HXDLIN(  81)						if (this->flare) {
HXLINE(  81)							if (this->reverseFlare) {
HXLINE(  81)								Float sin = ::Math_obj::sin(theta);
HXDLIN(  81)								Float cos = ::Math_obj::cos(theta);
HXDLIN(  81)								Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  81)								Float radius2 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  81)								Float dx = ((Float)0.1);
HXDLIN(  81)								Float dy = radius1;
HXDLIN(  81)								Float cx = h2;
HXDLIN(  81)								Float cy = radius2;
HXDLIN(  81)								Float bx = h2;
HXDLIN(  81)								Float by = -(radius2);
HXDLIN(  81)								Float ax = ((Float)0.1);
HXDLIN(  81)								Float ay = -(radius1);
HXDLIN(  81)								Float temp = ((Float)0.);
HXLINE( 288)								temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)								ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)								ax = temp;
HXLINE( 292)								temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)								by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)								bx = temp;
HXLINE( 296)								temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)								cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)								cx = temp;
HXLINE( 300)								temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)								dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)								dx = temp;
HXLINE(  81)								Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN(  81)								Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN(  81)								bool hasUndo = false;
HXDLIN(  81)								int aA = ((color >> 24) & 255);
HXDLIN(  81)								int rA = ((color >> 16) & 255);
HXDLIN(  81)								int gA = ((color >> 8) & 255);
HXDLIN(  81)								int bA = (color & 255);
HXDLIN(  81)								Float bcx = (ax - bx);
HXDLIN(  81)								Float bcy = (ay - by);
HXDLIN(  81)								Float acx = (ex - bx);
HXDLIN(  81)								Float acy = (ey - by);
HXDLIN(  81)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  81)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  81)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  81)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  81)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  81)								if ((ex > ax)) {
HXLINE(  81)									if ((ex > bx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ax > bx)) {
HXLINE(  81)											min = ::Math_obj::floor(bx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(ax);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((ax > bx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ex > bx)) {
HXLINE(  81)											min = ::Math_obj::floor(bx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  81)								if ((ey > ay)) {
HXLINE(  81)									if ((ey > by)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ay > by)) {
HXLINE(  81)											min = ::Math_obj::floor(by);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(ay);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((ay > by)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ey > by)) {
HXLINE(  81)											min = ::Math_obj::floor(by);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  81)								if (hasUndo) {
HXLINE(  81)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  81)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  81)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)									undoImage = this3;
HXDLIN(  81)									{
HXLINE(  81)										int rectLeft = xIter3->start;
HXDLIN(  81)										int rectTop = yIter3->start;
HXDLIN(  81)										int rectRight = xIter3->max;
HXDLIN(  81)										bool forceClear = false;
HXDLIN(  81)										{
HXLINE(  81)											int _g = rectTop;
HXDLIN(  81)											int _g1 = yIter3->max;
HXDLIN(  81)											while((_g < _g1)){
HXLINE(  81)												_g = (_g + 1);
HXDLIN(  81)												int dy = (_g - 1);
HXDLIN(  81)												{
HXLINE(  81)													int _g1 = rectLeft;
HXDLIN(  81)													int _g2 = rectRight;
HXDLIN(  81)													while((_g1 < _g2)){
HXLINE(  81)														_g1 = (_g1 + 1);
HXDLIN(  81)														int dx = (_g1 - 1);
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int col;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															col = c;
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->useMask) {
HXLINE(  81)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)															int index;
HXDLIN(  81)															if (this1->useVirtualPos) {
HXLINE(  81)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  81)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  81)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int v;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  81)																v = c;
            															}
HXDLIN(  81)															int this3 = v;
HXDLIN(  81)															int maskPixel = this3;
HXDLIN(  81)															int this4 = col;
HXDLIN(  81)															int this5 = this4;
HXDLIN(  81)															if ((maskPixel == 0)) {
HXLINE(  81)																int this1 = this5;
HXDLIN(  81)																col = this1;
            															}
            															else {
HXLINE(  81)																Float m0;
HXDLIN(  81)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																if ((this1 == 0)) {
HXLINE(  81)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m1;
HXDLIN(  81)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																if ((this2 == 0)) {
HXLINE(  81)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m2;
HXDLIN(  81)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																if ((this3 == 0)) {
HXLINE(  81)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m3;
HXDLIN(  81)																int this4 = (maskPixel & 255);
HXDLIN(  81)																if ((this4 == 0)) {
HXLINE(  81)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  81)														if ((col != 0)) {
HXLINE(  81)															int x = (dx - rectLeft);
HXDLIN(  81)															int y = (dy - rectTop);
HXDLIN(  81)															int this1 = col;
HXDLIN(  81)															int c = this1;
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																int location;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int this3 = this2;
HXDLIN(  81)																int this4;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	this4 = this3;
            																}
HXDLIN(  81)																Float a1;
HXDLIN(  81)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																if ((this5 == 0)) {
HXLINE(  81)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r1;
HXDLIN(  81)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																if ((this6 == 0)) {
HXLINE(  81)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g1;
HXDLIN(  81)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																if ((this7 == 0)) {
HXLINE(  81)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b1;
HXDLIN(  81)																int this8 = (this4 & 255);
HXDLIN(  81)																if ((this8 == 0)) {
HXLINE(  81)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a2;
HXDLIN(  81)																int this9 = ((col >> 24) & 255);
HXDLIN(  81)																if ((this9 == 0)) {
HXLINE(  81)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r2;
HXDLIN(  81)																int this10 = ((col >> 16) & 255);
HXDLIN(  81)																if ((this10 == 0)) {
HXLINE(  81)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g2;
HXDLIN(  81)																int this11 = ((col >> 8) & 255);
HXDLIN(  81)																if ((this11 == 0)) {
HXLINE(  81)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b2;
HXDLIN(  81)																int this12 = (col & 255);
HXDLIN(  81)																if ((this12 == 0)) {
HXLINE(  81)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																{
HXLINE(  81)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  81)																	int value;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		value = blended;
            																	}
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((location >= 0)) {
HXLINE(  81)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															if (forceClear) {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																int x = (dx - rectLeft);
HXDLIN(  81)																int y = (dy - rectTop);
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool found = false;
HXDLIN(  81)								{
HXLINE(  81)									int _g_min = xIter3->start;
HXDLIN(  81)									int _g_max = xIter3->max;
HXDLIN(  81)									while((_g_min < _g_max)){
HXLINE(  81)										_g_min = (_g_min + 1);
HXDLIN(  81)										int px = (_g_min - 1);
HXDLIN(  81)										Float pcx = (( (Float)(px) ) - bx);
HXLINE( 620)										found = false;
HXLINE(  81)										{
HXLINE(  81)											int _g_min1 = yIter3->start;
HXDLIN(  81)											int _g_max = yIter3->max;
HXDLIN(  81)											while((_g_min1 < _g_max)){
HXLINE(  81)												_g_min1 = (_g_min1 + 1);
HXDLIN(  81)												int py = (_g_min1 - 1);
HXDLIN(  81)												Float pcy = (( (Float)(py) ) - by);
HXDLIN(  81)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  81)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  81)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  81)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  81)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)												bool hitQuad;
HXDLIN(  81)												bool hitQuad1;
HXDLIN(  81)												if ((ratioA >= 0)) {
HXLINE(  81)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad1 = false;
            												}
HXDLIN(  81)												if (hitQuad1) {
HXLINE(  81)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad = false;
            												}
HXDLIN(  81)												if (hitQuad) {
HXLINE(  81)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (soft * ratioB)));
HXDLIN(  81)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  81)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  81)													int this1 = i;
HXDLIN(  81)													int a = this1;
HXDLIN(  81)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  81)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  81)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  81)													int this2 = i1;
HXDLIN(  81)													int r = this2;
HXDLIN(  81)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  81)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  81)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  81)													int this3 = i2;
HXDLIN(  81)													int g = this3;
HXDLIN(  81)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  81)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  81)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  81)													int this4 = i3;
HXDLIN(  81)													int b = this4;
HXDLIN(  81)													{
HXLINE(  81)														int location;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->transparent) {
HXLINE(  81)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int this3 = this2;
HXDLIN(  81)															int old;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  81)																old = this3;
            															}
HXDLIN(  81)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)															Float a1;
HXDLIN(  81)															int this4 = ((old >> 24) & 255);
HXDLIN(  81)															if ((this4 == 0)) {
HXLINE(  81)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r1;
HXDLIN(  81)															int this5 = ((old >> 16) & 255);
HXDLIN(  81)															if ((this5 == 0)) {
HXLINE(  81)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g1;
HXDLIN(  81)															int this6 = ((old >> 8) & 255);
HXDLIN(  81)															if ((this6 == 0)) {
HXLINE(  81)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b1;
HXDLIN(  81)															int this7 = (old & 255);
HXDLIN(  81)															if ((this7 == 0)) {
HXLINE(  81)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a2;
HXDLIN(  81)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)															if ((this8 == 0)) {
HXLINE(  81)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r2;
HXDLIN(  81)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)															if ((this9 == 0)) {
HXLINE(  81)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g2;
HXDLIN(  81)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)															if ((this10 == 0)) {
HXLINE(  81)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b2;
HXDLIN(  81)															int this11 = (rhs & 255);
HXDLIN(  81)															if ((this11 == 0)) {
HXLINE(  81)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  81)															{
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = blended;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((location >= 0)) {
HXLINE(  81)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (pixelImage->isLittle) {
HXLINE(  81)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  81)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found = true;
            												}
            												else {
HXLINE(  81)													if (found) {
HXLINE(  81)														goto _hx_goto_6;
            													}
            												}
            											}
            											_hx_goto_6:;
            										}
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  81)								int v_undoY;
HXDLIN(  81)								int v_undoX;
HXDLIN(  81)								Float v_ty;
HXDLIN(  81)								Float v_tx;
HXDLIN(  81)								Float v_t0;
HXDLIN(  81)								Float v_sy;
HXDLIN(  81)								Float v_sx;
HXDLIN(  81)								Float v_s0;
HXDLIN(  81)								Float v_A;
HXDLIN(  81)								Float ax1 = ex;
HXDLIN(  81)								Float ay1 = ey;
HXDLIN(  81)								Float bx1 = ax;
HXDLIN(  81)								Float by1 = ay;
HXDLIN(  81)								Float cx1 = bx;
HXDLIN(  81)								Float cy1 = by;
HXDLIN(  81)								::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  81)								bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN(  81)								if (!(adjustWinding)) {
HXLINE(  81)									Float bx_ = bx1;
HXDLIN(  81)									Float by_ = by1;
HXLINE(  35)									bx1 = cx1;
HXLINE(  36)									by1 = cy1;
HXLINE(  37)									cx1 = bx_;
HXLINE(  38)									cy1 = by_;
            								}
HXLINE(  81)								Float v_ax = ax1;
HXDLIN(  81)								Float v_ay = ay1;
HXDLIN(  81)								Float v_bx = bx1;
HXDLIN(  81)								Float v_by = by1;
HXDLIN(  81)								Float v_cx = cx1;
HXDLIN(  81)								Float v_cy = cy1;
HXDLIN(  81)								bool v_preCalculated = true;
HXDLIN(  81)								{
HXLINE(  81)									v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  81)									v_sx = (v_cy - v_ay);
HXDLIN(  81)									v_sy = (v_ax - v_cx);
HXDLIN(  81)									v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  81)									v_tx = (v_ay - v_by);
HXDLIN(  81)									v_ty = (v_bx - v_ax);
HXDLIN(  81)									v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  81)									Float a = v_ax;
HXDLIN(  81)									Float b = v_bx;
HXDLIN(  81)									Float c = v_cx;
HXDLIN(  81)									if ((a > b)) {
HXLINE(  81)										if ((a > c)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b > c)) {
HXLINE(  81)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b > c)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a > c)) {
HXLINE(  81)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter3 = this1;
            										}
            									}
HXDLIN(  81)									Float a1 = v_ay;
HXDLIN(  81)									Float b1 = v_by;
HXDLIN(  81)									Float c1 = v_cy;
HXDLIN(  81)									if ((a1 > b1)) {
HXLINE(  81)										if ((a1 > c1)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b1 > c1)) {
HXLINE(  81)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b1);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b1);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b1 > c1)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a1 > c1)) {
HXLINE(  81)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a1);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a1);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter3 = this1;
            										}
            									}
            								}
HXDLIN(  81)								if (hasUndo) {
HXLINE(  81)									v_undoImage = undoImage;
HXDLIN(  81)									v_undoX = xIter3->start;
HXDLIN(  81)									v_undoY = yIter3->start;
            								}
HXDLIN(  81)								{
HXLINE(  81)									Float bx2 = bx;
HXDLIN(  81)									Float by2 = by;
HXDLIN(  81)									Float cx2 = cx;
HXDLIN(  81)									Float cy2 = cy;
HXDLIN(  81)									bool hasUndo1 = false;
HXDLIN(  81)									bool adjustWinding1 = (((((ex * by2) - (bx2 * ey)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ey) - (ex * cy2))) > 0);
HXDLIN(  81)									if (!(adjustWinding1)) {
HXLINE(  81)										Float bx_ = bx2;
HXDLIN(  81)										Float by_ = by2;
HXLINE(  26)										bx2 = cx2;
HXLINE(  27)										by2 = cy2;
HXLINE(  28)										cx2 = bx_;
HXLINE(  29)										cy2 = by_;
            									}
HXLINE(  81)									{
HXLINE(  81)										Float s0 = ((ey * cx2) - (ex * cy2));
HXDLIN(  81)										Float sx = (cy2 - ey);
HXDLIN(  81)										Float sy = (ex - cx2);
HXDLIN(  81)										Float t0 = ((ex * by2) - (ey * bx2));
HXDLIN(  81)										Float tx = (ey - by2);
HXDLIN(  81)										Float ty = (bx2 - ex);
HXDLIN(  81)										Float A = ((((-(by2) * cx2) + (ey * (-(bx2) + cx2))) + (ex * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  81)										::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  81)										if ((ex > bx2)) {
HXLINE(  81)											if ((ex > cx2)) {
HXLINE(  81)												int min;
HXDLIN(  81)												if ((bx2 > cx2)) {
HXLINE(  81)													min = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  81)													min = ::Math_obj::floor(bx2);
            												}
HXDLIN(  81)												int ii_min = min;
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												xIter31 = this1;
            											}
            											else {
HXLINE(  81)												int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												xIter31 = this1;
            											}
            										}
            										else {
HXLINE(  81)											if ((bx2 > cx2)) {
HXLINE(  81)												int min;
HXDLIN(  81)												if ((ex > cx2)) {
HXLINE(  81)													min = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  81)													min = ::Math_obj::ceil(ex);
            												}
HXDLIN(  81)												int ii_min = min;
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												xIter31 = this1;
            											}
            											else {
HXLINE(  81)												int ii_min = ::Math_obj::floor(ex);
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												xIter31 = this1;
            											}
            										}
HXDLIN(  81)										::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  81)										if ((ey > by2)) {
HXLINE(  81)											if ((ey > cy2)) {
HXLINE(  81)												int min;
HXDLIN(  81)												if ((by2 > cy2)) {
HXLINE(  81)													min = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  81)													min = ::Math_obj::floor(by2);
            												}
HXDLIN(  81)												int ii_min = min;
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												yIter31 = this1;
            											}
            											else {
HXLINE(  81)												int ii_min = ::Math_obj::floor(by2);
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												yIter31 = this1;
            											}
            										}
            										else {
HXLINE(  81)											if ((by2 > cy2)) {
HXLINE(  81)												int min;
HXDLIN(  81)												if ((ey > cy2)) {
HXLINE(  81)													min = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  81)													min = ::Math_obj::ceil(ey);
            												}
HXDLIN(  81)												int ii_min = min;
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												yIter31 = this1;
            											}
            											else {
HXLINE(  81)												int ii_min = ::Math_obj::floor(ey);
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												yIter31 = this1;
            											}
            										}
HXDLIN(  81)										::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  81)										if (hasUndo1) {
HXLINE(  81)											int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  81)											int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  81)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)											undoImage1 = this3;
HXDLIN(  81)											{
HXLINE(  81)												int rectLeft = xIter31->start;
HXDLIN(  81)												int rectTop = yIter31->start;
HXDLIN(  81)												int rectRight = xIter31->max;
HXDLIN(  81)												bool forceClear = false;
HXDLIN(  81)												{
HXLINE(  81)													int _g = rectTop;
HXDLIN(  81)													int _g1 = yIter31->max;
HXDLIN(  81)													while((_g < _g1)){
HXLINE(  81)														_g = (_g + 1);
HXDLIN(  81)														int dy = (_g - 1);
HXDLIN(  81)														{
HXLINE(  81)															int _g1 = rectLeft;
HXDLIN(  81)															int _g2 = rectRight;
HXDLIN(  81)															while((_g1 < _g2)){
HXLINE(  81)																_g1 = (_g1 + 1);
HXDLIN(  81)																int dx = (_g1 - 1);
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (pixelImage->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            																}
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int col;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	col = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if (pixelImage->useMask) {
HXLINE(  81)																	hitQuad = ::hx::IsNotNull( pixelImage->mask );
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)																	int index;
HXDLIN(  81)																	if (this1->useVirtualPos) {
HXLINE(  81)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  81)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  81)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																	int v;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		v = c;
            																	}
HXDLIN(  81)																	int this3 = v;
HXDLIN(  81)																	int maskPixel = this3;
HXDLIN(  81)																	int this4 = col;
HXDLIN(  81)																	int this5 = this4;
HXDLIN(  81)																	if ((maskPixel == 0)) {
HXLINE(  81)																		int this1 = this5;
HXDLIN(  81)																		col = this1;
            																	}
            																	else {
HXLINE(  81)																		Float m0;
HXDLIN(  81)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																		if ((this1 == 0)) {
HXLINE(  81)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float m1;
HXDLIN(  81)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																		if ((this2 == 0)) {
HXLINE(  81)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float m2;
HXDLIN(  81)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																		if ((this3 == 0)) {
HXLINE(  81)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float m3;
HXDLIN(  81)																		int this4 = (maskPixel & 255);
HXDLIN(  81)																		if ((this4 == 0)) {
HXLINE(  81)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  81)																if ((col != 0)) {
HXLINE(  81)																	int x = (dx - rectLeft);
HXDLIN(  81)																	int y = (dy - rectTop);
HXDLIN(  81)																	int this1 = col;
HXDLIN(  81)																	int c = this1;
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																		hitQuad = undoImage1->transparent;
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		int location;
HXDLIN(  81)																		if (undoImage1->useVirtualPos) {
HXLINE(  81)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  81)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  81)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																		int this3 = this2;
HXDLIN(  81)																		int this4;
HXDLIN(  81)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  81)																			this4 = this3;
            																		}
HXDLIN(  81)																		Float a1;
HXDLIN(  81)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																		if ((this5 == 0)) {
HXLINE(  81)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float r1;
HXDLIN(  81)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																		if ((this6 == 0)) {
HXLINE(  81)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float g1;
HXDLIN(  81)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																		if ((this7 == 0)) {
HXLINE(  81)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float b1;
HXDLIN(  81)																		int this8 = (this4 & 255);
HXDLIN(  81)																		if ((this8 == 0)) {
HXLINE(  81)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float a2;
HXDLIN(  81)																		int this9 = ((col >> 24) & 255);
HXDLIN(  81)																		if ((this9 == 0)) {
HXLINE(  81)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float r2;
HXDLIN(  81)																		int this10 = ((col >> 16) & 255);
HXDLIN(  81)																		if ((this10 == 0)) {
HXLINE(  81)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float g2;
HXDLIN(  81)																		int this11 = ((col >> 8) & 255);
HXDLIN(  81)																		if ((this11 == 0)) {
HXLINE(  81)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float b2;
HXDLIN(  81)																		int this12 = (col & 255);
HXDLIN(  81)																		if ((this12 == 0)) {
HXLINE(  81)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																		{
HXLINE(  81)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  81)																			int value;
HXDLIN(  81)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  81)																				value = blended;
            																			}
HXDLIN(  81)																			bool hitQuad;
HXDLIN(  81)																			if ((location >= 0)) {
HXLINE(  81)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  81)																				hitQuad = false;
            																			}
HXDLIN(  81)																			if (hitQuad) {
HXLINE(  81)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  81)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																		int index;
HXDLIN(  81)																		if (undoImage1->useVirtualPos) {
HXLINE(  81)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  81)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  81)																		int value;
HXDLIN(  81)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  81)																			value = c;
            																		}
HXDLIN(  81)																		bool hitQuad;
HXDLIN(  81)																		if ((index >= 0)) {
HXLINE(  81)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  81)																			hitQuad = false;
            																		}
HXDLIN(  81)																		if (hitQuad) {
HXLINE(  81)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  81)																	if (forceClear) {
HXLINE(  81)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																		int x = (dx - rectLeft);
HXDLIN(  81)																		int y = (dy - rectTop);
HXDLIN(  81)																		int index;
HXDLIN(  81)																		if (undoImage1->useVirtualPos) {
HXLINE(  81)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  81)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  81)																		bool hitQuad;
HXDLIN(  81)																		if ((index >= 0)) {
HXLINE(  81)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  81)																			hitQuad = false;
            																		}
HXDLIN(  81)																		if (hitQuad) {
HXLINE(  81)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  81)										bool found1 = false;
HXDLIN(  81)										Float s = ((Float)0.);
HXDLIN(  81)										Float t = ((Float)0.);
HXDLIN(  81)										Float sxx = ((Float)0.);
HXDLIN(  81)										Float txx = ((Float)0.);
HXDLIN(  81)										{
HXLINE(  81)											int _g_min1 = xIter31->start;
HXDLIN(  81)											int _g_max1 = xIter31->max;
HXDLIN(  81)											while((_g_min1 < _g_max1)){
HXLINE(  81)												_g_min1 = (_g_min1 + 1);
HXDLIN(  81)												int x = (_g_min1 - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found1 = false;
HXLINE(  81)												{
HXLINE(  81)													int _g_min = yIter31->start;
HXDLIN(  81)													int _g_max = yIter31->max;
HXDLIN(  81)													while((_g_min < _g_max)){
HXLINE(  81)														_g_min = (_g_min + 1);
HXDLIN(  81)														int y = (_g_min - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  81)														bool hitQuad;
HXDLIN(  81)														if (!((s <= 0))) {
HXLINE(  81)															hitQuad = (t <= 0);
            														}
            														else {
HXLINE(  81)															hitQuad = true;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															if (found1) {
HXLINE(  81)																goto _hx_goto_10;
            															}
            														}
            														else {
HXLINE(  81)															if (((s + t) < A)) {
HXLINE(  81)																{
HXLINE(  81)																	int this1 = color;
HXDLIN(  81)																	int c = this1;
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																		hitQuad = pixelImage->transparent;
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		int location;
HXDLIN(  81)																		if (pixelImage->useVirtualPos) {
HXLINE(  81)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  81)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  81)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																		int this3 = this2;
HXDLIN(  81)																		int this4;
HXDLIN(  81)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  81)																			this4 = this3;
            																		}
HXDLIN(  81)																		Float a1;
HXDLIN(  81)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																		if ((this5 == 0)) {
HXLINE(  81)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float r1;
HXDLIN(  81)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																		if ((this6 == 0)) {
HXLINE(  81)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float g1;
HXDLIN(  81)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																		if ((this7 == 0)) {
HXLINE(  81)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float b1;
HXDLIN(  81)																		int this8 = (this4 & 255);
HXDLIN(  81)																		if ((this8 == 0)) {
HXLINE(  81)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float a2;
HXDLIN(  81)																		int this9 = ((color >> 24) & 255);
HXDLIN(  81)																		if ((this9 == 0)) {
HXLINE(  81)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float r2;
HXDLIN(  81)																		int this10 = ((color >> 16) & 255);
HXDLIN(  81)																		if ((this10 == 0)) {
HXLINE(  81)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float g2;
HXDLIN(  81)																		int this11 = ((color >> 8) & 255);
HXDLIN(  81)																		if ((this11 == 0)) {
HXLINE(  81)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float b2;
HXDLIN(  81)																		int this12 = (color & 255);
HXDLIN(  81)																		if ((this12 == 0)) {
HXLINE(  81)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																		{
HXLINE(  81)																			::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN(  81)																			int value;
HXDLIN(  81)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  81)																				value = blended;
            																			}
HXDLIN(  81)																			bool hitQuad;
HXDLIN(  81)																			if ((location >= 0)) {
HXLINE(  81)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  81)																				hitQuad = false;
            																			}
HXDLIN(  81)																			if (hitQuad) {
HXLINE(  81)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  81)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)																		int index;
HXDLIN(  81)																		if (pixelImage->useVirtualPos) {
HXLINE(  81)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  81)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  81)																		int value;
HXDLIN(  81)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  81)																			value = c;
            																		}
HXDLIN(  81)																		bool hitQuad;
HXDLIN(  81)																		if ((index >= 0)) {
HXLINE(  81)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  81)																			hitQuad = false;
            																		}
HXDLIN(  81)																		if (hitQuad) {
HXLINE(  81)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found1 = true;
            															}
            															else {
HXLINE(  81)																if (found1) {
HXLINE(  81)																	goto _hx_goto_10;
            																}
            															}
            														}
            													}
            													_hx_goto_10:;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool hasUndo2 = false;
HXDLIN(  81)								int aA1 = ((color >> 24) & 255);
HXDLIN(  81)								int rA1 = ((color >> 16) & 255);
HXDLIN(  81)								int gA1 = ((color >> 8) & 255);
HXDLIN(  81)								int bA1 = (color & 255);
HXDLIN(  81)								Float bcx1 = (cx - dx);
HXDLIN(  81)								Float bcy1 = (cy - dy);
HXDLIN(  81)								Float acx1 = (ex - dx);
HXDLIN(  81)								Float acy1 = (ey - dy);
HXDLIN(  81)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  81)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  81)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  81)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  81)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  81)								if ((ex > cx)) {
HXLINE(  81)									if ((ex > dx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((cx > dx)) {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter32 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((cx > dx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ex > dx)) {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter32 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter32 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  81)								if ((ey > cy)) {
HXLINE(  81)									if ((ey > dy)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((cy > dy)) {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter32 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((cy > dy)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ey > dy)) {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter32 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter32 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  81)								if (hasUndo2) {
HXLINE(  81)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  81)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  81)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)									undoImage2 = this3;
HXDLIN(  81)									{
HXLINE(  81)										int rectLeft = xIter32->start;
HXDLIN(  81)										int rectTop = yIter32->start;
HXDLIN(  81)										int rectRight = xIter32->max;
HXDLIN(  81)										bool forceClear = false;
HXDLIN(  81)										{
HXLINE(  81)											int _g = rectTop;
HXDLIN(  81)											int _g1 = yIter32->max;
HXDLIN(  81)											while((_g < _g1)){
HXLINE(  81)												_g = (_g + 1);
HXDLIN(  81)												int dy = (_g - 1);
HXDLIN(  81)												{
HXLINE(  81)													int _g1 = rectLeft;
HXDLIN(  81)													int _g2 = rectRight;
HXDLIN(  81)													while((_g1 < _g2)){
HXLINE(  81)														_g1 = (_g1 + 1);
HXDLIN(  81)														int dx = (_g1 - 1);
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int col;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															col = c;
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->useMask) {
HXLINE(  81)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)															int index;
HXDLIN(  81)															if (this1->useVirtualPos) {
HXLINE(  81)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  81)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  81)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int v;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  81)																v = c;
            															}
HXDLIN(  81)															int this3 = v;
HXDLIN(  81)															int maskPixel = this3;
HXDLIN(  81)															int this4 = col;
HXDLIN(  81)															int this5 = this4;
HXDLIN(  81)															if ((maskPixel == 0)) {
HXLINE(  81)																int this1 = this5;
HXDLIN(  81)																col = this1;
            															}
            															else {
HXLINE(  81)																Float m0;
HXDLIN(  81)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																if ((this1 == 0)) {
HXLINE(  81)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m1;
HXDLIN(  81)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																if ((this2 == 0)) {
HXLINE(  81)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m2;
HXDLIN(  81)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																if ((this3 == 0)) {
HXLINE(  81)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m3;
HXDLIN(  81)																int this4 = (maskPixel & 255);
HXDLIN(  81)																if ((this4 == 0)) {
HXLINE(  81)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  81)														if ((col != 0)) {
HXLINE(  81)															int x = (dx - rectLeft);
HXDLIN(  81)															int y = (dy - rectTop);
HXDLIN(  81)															int this1 = col;
HXDLIN(  81)															int c = this1;
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																hitQuad = undoImage2->transparent;
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																int location;
HXDLIN(  81)																if (undoImage2->useVirtualPos) {
HXLINE(  81)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  81)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int this3 = this2;
HXDLIN(  81)																int this4;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	this4 = this3;
            																}
HXDLIN(  81)																Float a1;
HXDLIN(  81)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																if ((this5 == 0)) {
HXLINE(  81)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r1;
HXDLIN(  81)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																if ((this6 == 0)) {
HXLINE(  81)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g1;
HXDLIN(  81)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																if ((this7 == 0)) {
HXLINE(  81)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b1;
HXDLIN(  81)																int this8 = (this4 & 255);
HXDLIN(  81)																if ((this8 == 0)) {
HXLINE(  81)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a2;
HXDLIN(  81)																int this9 = ((col >> 24) & 255);
HXDLIN(  81)																if ((this9 == 0)) {
HXLINE(  81)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r2;
HXDLIN(  81)																int this10 = ((col >> 16) & 255);
HXDLIN(  81)																if ((this10 == 0)) {
HXLINE(  81)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g2;
HXDLIN(  81)																int this11 = ((col >> 8) & 255);
HXDLIN(  81)																if ((this11 == 0)) {
HXLINE(  81)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b2;
HXDLIN(  81)																int this12 = (col & 255);
HXDLIN(  81)																if ((this12 == 0)) {
HXLINE(  81)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																{
HXLINE(  81)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  81)																	int value;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		value = blended;
            																	}
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((location >= 0)) {
HXLINE(  81)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage2->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															if (forceClear) {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  81)																int x = (dx - rectLeft);
HXDLIN(  81)																int y = (dy - rectTop);
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage2->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool found2 = false;
HXDLIN(  81)								{
HXLINE(  81)									int _g_min2 = xIter32->start;
HXDLIN(  81)									int _g_max2 = xIter32->max;
HXDLIN(  81)									while((_g_min2 < _g_max2)){
HXLINE(  81)										_g_min2 = (_g_min2 + 1);
HXDLIN(  81)										int px = (_g_min2 - 1);
HXDLIN(  81)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 620)										found2 = false;
HXLINE(  81)										{
HXLINE(  81)											int _g_min = yIter32->start;
HXDLIN(  81)											int _g_max = yIter32->max;
HXDLIN(  81)											while((_g_min < _g_max)){
HXLINE(  81)												_g_min = (_g_min + 1);
HXDLIN(  81)												int py = (_g_min - 1);
HXDLIN(  81)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  81)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  81)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  81)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  81)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  81)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)												bool hitQuad;
HXDLIN(  81)												bool hitQuad1;
HXDLIN(  81)												if ((ratioA >= 0)) {
HXLINE(  81)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad1 = false;
            												}
HXDLIN(  81)												if (hitQuad1) {
HXLINE(  81)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad = false;
            												}
HXDLIN(  81)												if (hitQuad) {
HXLINE(  81)													int i = ::Std_obj::_hx_int((( (Float)(aA1) ) * (soft * ratioB)));
HXDLIN(  81)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  81)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  81)													int this1 = i;
HXDLIN(  81)													int a = this1;
HXDLIN(  81)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  81)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  81)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  81)													int this2 = i1;
HXDLIN(  81)													int r = this2;
HXDLIN(  81)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  81)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  81)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  81)													int this3 = i2;
HXDLIN(  81)													int g = this3;
HXDLIN(  81)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  81)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  81)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  81)													int this4 = i3;
HXDLIN(  81)													int b = this4;
HXDLIN(  81)													{
HXLINE(  81)														int location;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->transparent) {
HXLINE(  81)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int this3 = this2;
HXDLIN(  81)															int old;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  81)																old = this3;
            															}
HXDLIN(  81)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)															Float a1;
HXDLIN(  81)															int this4 = ((old >> 24) & 255);
HXDLIN(  81)															if ((this4 == 0)) {
HXLINE(  81)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r1;
HXDLIN(  81)															int this5 = ((old >> 16) & 255);
HXDLIN(  81)															if ((this5 == 0)) {
HXLINE(  81)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g1;
HXDLIN(  81)															int this6 = ((old >> 8) & 255);
HXDLIN(  81)															if ((this6 == 0)) {
HXLINE(  81)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b1;
HXDLIN(  81)															int this7 = (old & 255);
HXDLIN(  81)															if ((this7 == 0)) {
HXLINE(  81)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a2;
HXDLIN(  81)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)															if ((this8 == 0)) {
HXLINE(  81)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r2;
HXDLIN(  81)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)															if ((this9 == 0)) {
HXLINE(  81)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g2;
HXDLIN(  81)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)															if ((this10 == 0)) {
HXLINE(  81)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b2;
HXDLIN(  81)															int this11 = (rhs & 255);
HXDLIN(  81)															if ((this11 == 0)) {
HXLINE(  81)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  81)															{
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = blended;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((location >= 0)) {
HXLINE(  81)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (pixelImage->isLittle) {
HXLINE(  81)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  81)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found2 = true;
            												}
            												else {
HXLINE(  81)													if (found2) {
HXLINE(  81)														goto _hx_goto_14;
            													}
            												}
            											}
            											_hx_goto_14:;
            										}
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  81)								int v_undoY1;
HXDLIN(  81)								int v_undoX1;
HXDLIN(  81)								Float v_ty1;
HXDLIN(  81)								Float v_tx1;
HXDLIN(  81)								Float v_t01;
HXDLIN(  81)								Float v_sy1;
HXDLIN(  81)								Float v_sx1;
HXDLIN(  81)								Float v_s01;
HXDLIN(  81)								Float v_A1;
HXDLIN(  81)								Float ax2 = ex;
HXDLIN(  81)								Float ay2 = ey;
HXDLIN(  81)								Float bx3 = cx;
HXDLIN(  81)								Float by3 = cy;
HXDLIN(  81)								Float cx3 = dx;
HXDLIN(  81)								Float cy3 = dy;
HXDLIN(  81)								::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  81)								bool adjustWinding2 = (((((ax2 * by3) - (bx3 * ay2)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay2) - (ax2 * cy3))) > 0);
HXDLIN(  81)								if (!(adjustWinding2)) {
HXLINE(  81)									Float bx_ = bx3;
HXDLIN(  81)									Float by_ = by3;
HXLINE(  35)									bx3 = cx3;
HXLINE(  36)									by3 = cy3;
HXLINE(  37)									cx3 = bx_;
HXLINE(  38)									cy3 = by_;
            								}
HXLINE(  81)								Float v_ax1 = ax2;
HXDLIN(  81)								Float v_ay1 = ay2;
HXDLIN(  81)								Float v_bx1 = bx3;
HXDLIN(  81)								Float v_by1 = by3;
HXDLIN(  81)								Float v_cx1 = cx3;
HXDLIN(  81)								Float v_cy1 = cy3;
HXDLIN(  81)								bool v_preCalculated1 = true;
HXDLIN(  81)								{
HXLINE(  81)									v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  81)									v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  81)									v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  81)									v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  81)									v_tx1 = (v_ay1 - v_by1);
HXDLIN(  81)									v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  81)									v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  81)									Float a2 = v_ax1;
HXDLIN(  81)									Float b2 = v_bx1;
HXDLIN(  81)									Float c2 = v_cx1;
HXDLIN(  81)									if ((a2 > b2)) {
HXLINE(  81)										if ((a2 > c2)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b2 > c2)) {
HXLINE(  81)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b2);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b2);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter31 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b2 > c2)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a2 > c2)) {
HXLINE(  81)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a2);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a2);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter31 = this1;
            										}
            									}
HXDLIN(  81)									Float a3 = v_ay1;
HXDLIN(  81)									Float b3 = v_by1;
HXDLIN(  81)									Float c3 = v_cy1;
HXDLIN(  81)									if ((a3 > b3)) {
HXLINE(  81)										if ((a3 > c3)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b3 > c3)) {
HXLINE(  81)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b3);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b3);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter31 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b3 > c3)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a3 > c3)) {
HXLINE(  81)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a3);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a3);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter31 = this1;
            										}
            									}
            								}
HXDLIN(  81)								if (hasUndo2) {
HXLINE(  81)									v_undoImage1 = undoImage2;
HXDLIN(  81)									v_undoX1 = xIter32->start;
HXDLIN(  81)									v_undoY1 = yIter32->start;
            								}
HXDLIN(  81)								bool hasUndo3 = false;
HXDLIN(  81)								int aA2 = ((color >> 24) & 255);
HXDLIN(  81)								int rA2 = ((color >> 16) & 255);
HXDLIN(  81)								int gA2 = ((color >> 8) & 255);
HXDLIN(  81)								int bA2 = (color & 255);
HXDLIN(  81)								Float bcx2 = (dx - ax);
HXDLIN(  81)								Float bcy2 = (dy - ay);
HXDLIN(  81)								Float acx2 = (ex - ax);
HXDLIN(  81)								Float acy2 = (ey - ay);
HXDLIN(  81)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  81)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  81)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  81)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  81)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  81)								if ((ex > dx)) {
HXLINE(  81)									if ((ex > ax)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((dx > ax)) {
HXLINE(  81)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter33 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(dx);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((dx > ax)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ex > ax)) {
HXLINE(  81)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter33 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter33 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  81)								if ((ey > dy)) {
HXLINE(  81)									if ((ey > ay)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((dy > ay)) {
HXLINE(  81)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter33 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(dy);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((dy > ay)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ey > ay)) {
HXLINE(  81)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter33 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter33 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  81)								if (hasUndo3) {
HXLINE(  81)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  81)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  81)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)									undoImage3 = this3;
HXDLIN(  81)									{
HXLINE(  81)										int rectLeft = xIter33->start;
HXDLIN(  81)										int rectTop = yIter33->start;
HXDLIN(  81)										int rectRight = xIter33->max;
HXDLIN(  81)										bool forceClear = false;
HXDLIN(  81)										{
HXLINE(  81)											int _g = rectTop;
HXDLIN(  81)											int _g1 = yIter33->max;
HXDLIN(  81)											while((_g < _g1)){
HXLINE(  81)												_g = (_g + 1);
HXDLIN(  81)												int dy = (_g - 1);
HXDLIN(  81)												{
HXLINE(  81)													int _g1 = rectLeft;
HXDLIN(  81)													int _g2 = rectRight;
HXDLIN(  81)													while((_g1 < _g2)){
HXLINE(  81)														_g1 = (_g1 + 1);
HXDLIN(  81)														int dx = (_g1 - 1);
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int col;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															col = c;
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->useMask) {
HXLINE(  81)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)															int index;
HXDLIN(  81)															if (this1->useVirtualPos) {
HXLINE(  81)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  81)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  81)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int v;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  81)																v = c;
            															}
HXDLIN(  81)															int this3 = v;
HXDLIN(  81)															int maskPixel = this3;
HXDLIN(  81)															int this4 = col;
HXDLIN(  81)															int this5 = this4;
HXDLIN(  81)															if ((maskPixel == 0)) {
HXLINE(  81)																int this1 = this5;
HXDLIN(  81)																col = this1;
            															}
            															else {
HXLINE(  81)																Float m0;
HXDLIN(  81)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																if ((this1 == 0)) {
HXLINE(  81)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m1;
HXDLIN(  81)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																if ((this2 == 0)) {
HXLINE(  81)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m2;
HXDLIN(  81)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																if ((this3 == 0)) {
HXLINE(  81)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m3;
HXDLIN(  81)																int this4 = (maskPixel & 255);
HXDLIN(  81)																if ((this4 == 0)) {
HXLINE(  81)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  81)														if ((col != 0)) {
HXLINE(  81)															int x = (dx - rectLeft);
HXDLIN(  81)															int y = (dy - rectTop);
HXDLIN(  81)															int this1 = col;
HXDLIN(  81)															int c = this1;
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																hitQuad = undoImage3->transparent;
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																int location;
HXDLIN(  81)																if (undoImage3->useVirtualPos) {
HXLINE(  81)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  81)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int this3 = this2;
HXDLIN(  81)																int this4;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	this4 = this3;
            																}
HXDLIN(  81)																Float a1;
HXDLIN(  81)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																if ((this5 == 0)) {
HXLINE(  81)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r1;
HXDLIN(  81)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																if ((this6 == 0)) {
HXLINE(  81)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g1;
HXDLIN(  81)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																if ((this7 == 0)) {
HXLINE(  81)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b1;
HXDLIN(  81)																int this8 = (this4 & 255);
HXDLIN(  81)																if ((this8 == 0)) {
HXLINE(  81)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a2;
HXDLIN(  81)																int this9 = ((col >> 24) & 255);
HXDLIN(  81)																if ((this9 == 0)) {
HXLINE(  81)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r2;
HXDLIN(  81)																int this10 = ((col >> 16) & 255);
HXDLIN(  81)																if ((this10 == 0)) {
HXLINE(  81)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g2;
HXDLIN(  81)																int this11 = ((col >> 8) & 255);
HXDLIN(  81)																if ((this11 == 0)) {
HXLINE(  81)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b2;
HXDLIN(  81)																int this12 = (col & 255);
HXDLIN(  81)																if ((this12 == 0)) {
HXLINE(  81)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																{
HXLINE(  81)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  81)																	int value;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		value = blended;
            																	}
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((location >= 0)) {
HXLINE(  81)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage3->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															if (forceClear) {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  81)																int x = (dx - rectLeft);
HXDLIN(  81)																int y = (dy - rectTop);
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage3->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool found3 = false;
HXDLIN(  81)								{
HXLINE(  81)									int _g_min3 = xIter33->start;
HXDLIN(  81)									int _g_max3 = xIter33->max;
HXDLIN(  81)									while((_g_min3 < _g_max3)){
HXLINE(  81)										_g_min3 = (_g_min3 + 1);
HXDLIN(  81)										int px = (_g_min3 - 1);
HXDLIN(  81)										Float pcx = (( (Float)(px) ) - ax);
HXLINE( 620)										found3 = false;
HXLINE(  81)										{
HXLINE(  81)											int _g_min = yIter33->start;
HXDLIN(  81)											int _g_max = yIter33->max;
HXDLIN(  81)											while((_g_min < _g_max)){
HXLINE(  81)												_g_min = (_g_min + 1);
HXDLIN(  81)												int py = (_g_min - 1);
HXDLIN(  81)												Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  81)												Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  81)												Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  81)												Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  81)												Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  81)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)												bool hitQuad;
HXDLIN(  81)												bool hitQuad1;
HXDLIN(  81)												if ((ratioA >= 0)) {
HXLINE(  81)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad1 = false;
            												}
HXDLIN(  81)												if (hitQuad1) {
HXLINE(  81)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad = false;
            												}
HXDLIN(  81)												if (hitQuad) {
HXLINE(  81)													int i = ::Std_obj::_hx_int((( (Float)(aA2) ) * (soft * ratioB)));
HXDLIN(  81)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  81)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  81)													int this1 = i;
HXDLIN(  81)													int a = this1;
HXDLIN(  81)													int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  81)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  81)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  81)													int this2 = i1;
HXDLIN(  81)													int r = this2;
HXDLIN(  81)													int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  81)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  81)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  81)													int this3 = i2;
HXDLIN(  81)													int g = this3;
HXDLIN(  81)													int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  81)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  81)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  81)													int this4 = i3;
HXDLIN(  81)													int b = this4;
HXDLIN(  81)													{
HXLINE(  81)														int location;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->transparent) {
HXLINE(  81)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int this3 = this2;
HXDLIN(  81)															int old;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  81)																old = this3;
            															}
HXDLIN(  81)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)															Float a1;
HXDLIN(  81)															int this4 = ((old >> 24) & 255);
HXDLIN(  81)															if ((this4 == 0)) {
HXLINE(  81)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r1;
HXDLIN(  81)															int this5 = ((old >> 16) & 255);
HXDLIN(  81)															if ((this5 == 0)) {
HXLINE(  81)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g1;
HXDLIN(  81)															int this6 = ((old >> 8) & 255);
HXDLIN(  81)															if ((this6 == 0)) {
HXLINE(  81)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b1;
HXDLIN(  81)															int this7 = (old & 255);
HXDLIN(  81)															if ((this7 == 0)) {
HXLINE(  81)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a2;
HXDLIN(  81)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)															if ((this8 == 0)) {
HXLINE(  81)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r2;
HXDLIN(  81)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)															if ((this9 == 0)) {
HXLINE(  81)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g2;
HXDLIN(  81)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)															if ((this10 == 0)) {
HXLINE(  81)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b2;
HXDLIN(  81)															int this11 = (rhs & 255);
HXDLIN(  81)															if ((this11 == 0)) {
HXLINE(  81)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  81)															{
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = blended;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((location >= 0)) {
HXLINE(  81)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (pixelImage->isLittle) {
HXLINE(  81)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  81)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found3 = true;
            												}
            												else {
HXLINE(  81)													if (found3) {
HXLINE(  81)														goto _hx_goto_18;
            													}
            												}
            											}
            											_hx_goto_18:;
            										}
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_yIter32;
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_xIter32;
HXDLIN(  81)								int v_undoY2;
HXDLIN(  81)								int v_undoX2;
HXDLIN(  81)								Float v_ty2;
HXDLIN(  81)								Float v_tx2;
HXDLIN(  81)								Float v_t02;
HXDLIN(  81)								Float v_sy2;
HXDLIN(  81)								Float v_sx2;
HXDLIN(  81)								Float v_s02;
HXDLIN(  81)								Float v_A2;
HXDLIN(  81)								Float ax3 = ex;
HXDLIN(  81)								Float ay3 = ey;
HXDLIN(  81)								Float bx4 = dx;
HXDLIN(  81)								Float by4 = dy;
HXDLIN(  81)								Float cx4 = ax;
HXDLIN(  81)								Float cy4 = ay;
HXDLIN(  81)								::pixelimage::ImageStruct v_undoImage2 = null();
HXDLIN(  81)								bool adjustWinding3 = (((((ax3 * by4) - (bx4 * ay3)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay3) - (ax3 * cy4))) > 0);
HXDLIN(  81)								if (!(adjustWinding3)) {
HXLINE(  81)									Float bx_ = bx4;
HXDLIN(  81)									Float by_ = by4;
HXLINE(  35)									bx4 = cx4;
HXLINE(  36)									by4 = cy4;
HXLINE(  37)									cx4 = bx_;
HXLINE(  38)									cy4 = by_;
            								}
HXLINE(  81)								Float v_ax2 = ax3;
HXDLIN(  81)								Float v_ay2 = ay3;
HXDLIN(  81)								Float v_bx2 = bx4;
HXDLIN(  81)								Float v_by2 = by4;
HXDLIN(  81)								Float v_cx2 = cx4;
HXDLIN(  81)								Float v_cy2 = cy4;
HXDLIN(  81)								bool v_preCalculated2 = true;
HXDLIN(  81)								{
HXLINE(  81)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  81)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  81)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  81)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  81)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  81)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  81)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  81)									Float a4 = v_ax2;
HXDLIN(  81)									Float b4 = v_bx2;
HXDLIN(  81)									Float c4 = v_cx2;
HXDLIN(  81)									if ((a4 > b4)) {
HXLINE(  81)										if ((a4 > c4)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b4 > c4)) {
HXLINE(  81)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b4);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a4);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b4);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter32 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b4 > c4)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a4 > c4)) {
HXLINE(  81)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a4);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b4);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a4);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter32 = this1;
            										}
            									}
HXDLIN(  81)									Float a5 = v_ay2;
HXDLIN(  81)									Float b5 = v_by2;
HXDLIN(  81)									Float c5 = v_cy2;
HXDLIN(  81)									if ((a5 > b5)) {
HXLINE(  81)										if ((a5 > c5)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b5 > c5)) {
HXLINE(  81)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b5);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a5);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b5);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter32 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b5 > c5)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a5 > c5)) {
HXLINE(  81)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a5);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b5);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a5);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter32 = this1;
            										}
            									}
            								}
HXDLIN(  81)								if (hasUndo3) {
HXLINE(  81)									v_undoImage2 = undoImage3;
HXDLIN(  81)									v_undoX2 = xIter33->start;
HXDLIN(  81)									v_undoY2 = yIter33->start;
            								}
HXDLIN(  81)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  81)								hitQuad = v;
            							}
            							else {
HXLINE(  81)								Float sin = ::Math_obj::sin(theta);
HXDLIN(  81)								Float cos = ::Math_obj::cos(theta);
HXDLIN(  81)								Float radius1 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  81)								Float radius2 = (thick / ( (Float)(2) ));
HXDLIN(  81)								Float dx = ((Float)0.1);
HXDLIN(  81)								Float dy = radius1;
HXDLIN(  81)								Float cx = h2;
HXDLIN(  81)								Float cy = radius2;
HXDLIN(  81)								Float bx = h2;
HXDLIN(  81)								Float by = -(radius2);
HXDLIN(  81)								Float ax = ((Float)0.1);
HXDLIN(  81)								Float ay = -(radius1);
HXDLIN(  81)								Float temp = ((Float)0.);
HXLINE( 288)								temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)								ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)								ax = temp;
HXLINE( 292)								temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)								by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)								bx = temp;
HXLINE( 296)								temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)								cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)								cx = temp;
HXLINE( 300)								temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)								dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)								dx = temp;
HXLINE(  81)								Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN(  81)								Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN(  81)								bool hasUndo = false;
HXDLIN(  81)								int aA = ((color >> 24) & 255);
HXDLIN(  81)								int rA = ((color >> 16) & 255);
HXDLIN(  81)								int gA = ((color >> 8) & 255);
HXDLIN(  81)								int bA = (color & 255);
HXDLIN(  81)								Float bcx = (ax - bx);
HXDLIN(  81)								Float bcy = (ay - by);
HXDLIN(  81)								Float acx = (ex - bx);
HXDLIN(  81)								Float acy = (ey - by);
HXDLIN(  81)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  81)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  81)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  81)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  81)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  81)								if ((ex > ax)) {
HXLINE(  81)									if ((ex > bx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ax > bx)) {
HXLINE(  81)											min = ::Math_obj::floor(bx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(ax);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((ax > bx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ex > bx)) {
HXLINE(  81)											min = ::Math_obj::floor(bx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  81)								if ((ey > ay)) {
HXLINE(  81)									if ((ey > by)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ay > by)) {
HXLINE(  81)											min = ::Math_obj::floor(by);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(ay);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((ay > by)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ey > by)) {
HXLINE(  81)											min = ::Math_obj::floor(by);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  81)								if (hasUndo) {
HXLINE(  81)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  81)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  81)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)									undoImage = this3;
HXDLIN(  81)									{
HXLINE(  81)										int rectLeft = xIter3->start;
HXDLIN(  81)										int rectTop = yIter3->start;
HXDLIN(  81)										int rectRight = xIter3->max;
HXDLIN(  81)										bool forceClear = false;
HXDLIN(  81)										{
HXLINE(  81)											int _g = rectTop;
HXDLIN(  81)											int _g1 = yIter3->max;
HXDLIN(  81)											while((_g < _g1)){
HXLINE(  81)												_g = (_g + 1);
HXDLIN(  81)												int dy = (_g - 1);
HXDLIN(  81)												{
HXLINE(  81)													int _g1 = rectLeft;
HXDLIN(  81)													int _g2 = rectRight;
HXDLIN(  81)													while((_g1 < _g2)){
HXLINE(  81)														_g1 = (_g1 + 1);
HXDLIN(  81)														int dx = (_g1 - 1);
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int col;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															col = c;
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->useMask) {
HXLINE(  81)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)															int index;
HXDLIN(  81)															if (this1->useVirtualPos) {
HXLINE(  81)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  81)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  81)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int v;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  81)																v = c;
            															}
HXDLIN(  81)															int this3 = v;
HXDLIN(  81)															int maskPixel = this3;
HXDLIN(  81)															int this4 = col;
HXDLIN(  81)															int this5 = this4;
HXDLIN(  81)															if ((maskPixel == 0)) {
HXLINE(  81)																int this1 = this5;
HXDLIN(  81)																col = this1;
            															}
            															else {
HXLINE(  81)																Float m0;
HXDLIN(  81)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																if ((this1 == 0)) {
HXLINE(  81)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m1;
HXDLIN(  81)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																if ((this2 == 0)) {
HXLINE(  81)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m2;
HXDLIN(  81)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																if ((this3 == 0)) {
HXLINE(  81)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m3;
HXDLIN(  81)																int this4 = (maskPixel & 255);
HXDLIN(  81)																if ((this4 == 0)) {
HXLINE(  81)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  81)														if ((col != 0)) {
HXLINE(  81)															int x = (dx - rectLeft);
HXDLIN(  81)															int y = (dy - rectTop);
HXDLIN(  81)															int this1 = col;
HXDLIN(  81)															int c = this1;
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																int location;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int this3 = this2;
HXDLIN(  81)																int this4;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	this4 = this3;
            																}
HXDLIN(  81)																Float a1;
HXDLIN(  81)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																if ((this5 == 0)) {
HXLINE(  81)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r1;
HXDLIN(  81)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																if ((this6 == 0)) {
HXLINE(  81)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g1;
HXDLIN(  81)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																if ((this7 == 0)) {
HXLINE(  81)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b1;
HXDLIN(  81)																int this8 = (this4 & 255);
HXDLIN(  81)																if ((this8 == 0)) {
HXLINE(  81)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a2;
HXDLIN(  81)																int this9 = ((col >> 24) & 255);
HXDLIN(  81)																if ((this9 == 0)) {
HXLINE(  81)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r2;
HXDLIN(  81)																int this10 = ((col >> 16) & 255);
HXDLIN(  81)																if ((this10 == 0)) {
HXLINE(  81)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g2;
HXDLIN(  81)																int this11 = ((col >> 8) & 255);
HXDLIN(  81)																if ((this11 == 0)) {
HXLINE(  81)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b2;
HXDLIN(  81)																int this12 = (col & 255);
HXDLIN(  81)																if ((this12 == 0)) {
HXLINE(  81)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																{
HXLINE(  81)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  81)																	int value;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		value = blended;
            																	}
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((location >= 0)) {
HXLINE(  81)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															if (forceClear) {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																int x = (dx - rectLeft);
HXDLIN(  81)																int y = (dy - rectTop);
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool found = false;
HXDLIN(  81)								{
HXLINE(  81)									int _g_min = xIter3->start;
HXDLIN(  81)									int _g_max = xIter3->max;
HXDLIN(  81)									while((_g_min < _g_max)){
HXLINE(  81)										_g_min = (_g_min + 1);
HXDLIN(  81)										int px = (_g_min - 1);
HXDLIN(  81)										Float pcx = (( (Float)(px) ) - bx);
HXLINE( 620)										found = false;
HXLINE(  81)										{
HXLINE(  81)											int _g_min1 = yIter3->start;
HXDLIN(  81)											int _g_max = yIter3->max;
HXDLIN(  81)											while((_g_min1 < _g_max)){
HXLINE(  81)												_g_min1 = (_g_min1 + 1);
HXDLIN(  81)												int py = (_g_min1 - 1);
HXDLIN(  81)												Float pcy = (( (Float)(py) ) - by);
HXDLIN(  81)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  81)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  81)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  81)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  81)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)												bool hitQuad;
HXDLIN(  81)												bool hitQuad1;
HXDLIN(  81)												if ((ratioA >= 0)) {
HXLINE(  81)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad1 = false;
            												}
HXDLIN(  81)												if (hitQuad1) {
HXLINE(  81)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad = false;
            												}
HXDLIN(  81)												if (hitQuad) {
HXLINE(  81)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (soft * ratioB)));
HXDLIN(  81)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  81)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  81)													int this1 = i;
HXDLIN(  81)													int a = this1;
HXDLIN(  81)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  81)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  81)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  81)													int this2 = i1;
HXDLIN(  81)													int r = this2;
HXDLIN(  81)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  81)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  81)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  81)													int this3 = i2;
HXDLIN(  81)													int g = this3;
HXDLIN(  81)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  81)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  81)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  81)													int this4 = i3;
HXDLIN(  81)													int b = this4;
HXDLIN(  81)													{
HXLINE(  81)														int location;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->transparent) {
HXLINE(  81)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int this3 = this2;
HXDLIN(  81)															int old;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  81)																old = this3;
            															}
HXDLIN(  81)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)															Float a1;
HXDLIN(  81)															int this4 = ((old >> 24) & 255);
HXDLIN(  81)															if ((this4 == 0)) {
HXLINE(  81)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r1;
HXDLIN(  81)															int this5 = ((old >> 16) & 255);
HXDLIN(  81)															if ((this5 == 0)) {
HXLINE(  81)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g1;
HXDLIN(  81)															int this6 = ((old >> 8) & 255);
HXDLIN(  81)															if ((this6 == 0)) {
HXLINE(  81)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b1;
HXDLIN(  81)															int this7 = (old & 255);
HXDLIN(  81)															if ((this7 == 0)) {
HXLINE(  81)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a2;
HXDLIN(  81)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)															if ((this8 == 0)) {
HXLINE(  81)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r2;
HXDLIN(  81)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)															if ((this9 == 0)) {
HXLINE(  81)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g2;
HXDLIN(  81)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)															if ((this10 == 0)) {
HXLINE(  81)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b2;
HXDLIN(  81)															int this11 = (rhs & 255);
HXDLIN(  81)															if ((this11 == 0)) {
HXLINE(  81)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  81)															{
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = blended;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((location >= 0)) {
HXLINE(  81)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (pixelImage->isLittle) {
HXLINE(  81)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  81)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found = true;
            												}
            												else {
HXLINE(  81)													if (found) {
HXLINE(  81)														goto _hx_goto_22;
            													}
            												}
            											}
            											_hx_goto_22:;
            										}
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  81)								int v_undoY;
HXDLIN(  81)								int v_undoX;
HXDLIN(  81)								Float v_ty;
HXDLIN(  81)								Float v_tx;
HXDLIN(  81)								Float v_t0;
HXDLIN(  81)								Float v_sy;
HXDLIN(  81)								Float v_sx;
HXDLIN(  81)								Float v_s0;
HXDLIN(  81)								Float v_A;
HXDLIN(  81)								Float ax1 = ex;
HXDLIN(  81)								Float ay1 = ey;
HXDLIN(  81)								Float bx1 = ax;
HXDLIN(  81)								Float by1 = ay;
HXDLIN(  81)								Float cx1 = bx;
HXDLIN(  81)								Float cy1 = by;
HXDLIN(  81)								::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  81)								bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN(  81)								if (!(adjustWinding)) {
HXLINE(  81)									Float bx_ = bx1;
HXDLIN(  81)									Float by_ = by1;
HXLINE(  35)									bx1 = cx1;
HXLINE(  36)									by1 = cy1;
HXLINE(  37)									cx1 = bx_;
HXLINE(  38)									cy1 = by_;
            								}
HXLINE(  81)								Float v_ax = ax1;
HXDLIN(  81)								Float v_ay = ay1;
HXDLIN(  81)								Float v_bx = bx1;
HXDLIN(  81)								Float v_by = by1;
HXDLIN(  81)								Float v_cx = cx1;
HXDLIN(  81)								Float v_cy = cy1;
HXDLIN(  81)								bool v_preCalculated = true;
HXDLIN(  81)								{
HXLINE(  81)									v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  81)									v_sx = (v_cy - v_ay);
HXDLIN(  81)									v_sy = (v_ax - v_cx);
HXDLIN(  81)									v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  81)									v_tx = (v_ay - v_by);
HXDLIN(  81)									v_ty = (v_bx - v_ax);
HXDLIN(  81)									v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  81)									Float a = v_ax;
HXDLIN(  81)									Float b = v_bx;
HXDLIN(  81)									Float c = v_cx;
HXDLIN(  81)									if ((a > b)) {
HXLINE(  81)										if ((a > c)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b > c)) {
HXLINE(  81)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b > c)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a > c)) {
HXLINE(  81)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter3 = this1;
            										}
            									}
HXDLIN(  81)									Float a1 = v_ay;
HXDLIN(  81)									Float b1 = v_by;
HXDLIN(  81)									Float c1 = v_cy;
HXDLIN(  81)									if ((a1 > b1)) {
HXLINE(  81)										if ((a1 > c1)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b1 > c1)) {
HXLINE(  81)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b1);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b1);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b1 > c1)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a1 > c1)) {
HXLINE(  81)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a1);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a1);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter3 = this1;
            										}
            									}
            								}
HXDLIN(  81)								if (hasUndo) {
HXLINE(  81)									v_undoImage = undoImage;
HXDLIN(  81)									v_undoX = xIter3->start;
HXDLIN(  81)									v_undoY = yIter3->start;
            								}
HXDLIN(  81)								{
HXLINE(  81)									Float bx2 = bx;
HXDLIN(  81)									Float by2 = by;
HXDLIN(  81)									Float cx2 = cx;
HXDLIN(  81)									Float cy2 = cy;
HXDLIN(  81)									bool hasUndo1 = false;
HXDLIN(  81)									bool adjustWinding1 = (((((ex * by2) - (bx2 * ey)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ey) - (ex * cy2))) > 0);
HXDLIN(  81)									if (!(adjustWinding1)) {
HXLINE(  81)										Float bx_ = bx2;
HXDLIN(  81)										Float by_ = by2;
HXLINE(  26)										bx2 = cx2;
HXLINE(  27)										by2 = cy2;
HXLINE(  28)										cx2 = bx_;
HXLINE(  29)										cy2 = by_;
            									}
HXLINE(  81)									{
HXLINE(  81)										Float s0 = ((ey * cx2) - (ex * cy2));
HXDLIN(  81)										Float sx = (cy2 - ey);
HXDLIN(  81)										Float sy = (ex - cx2);
HXDLIN(  81)										Float t0 = ((ex * by2) - (ey * bx2));
HXDLIN(  81)										Float tx = (ey - by2);
HXDLIN(  81)										Float ty = (bx2 - ex);
HXDLIN(  81)										Float A = ((((-(by2) * cx2) + (ey * (-(bx2) + cx2))) + (ex * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  81)										::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  81)										if ((ex > bx2)) {
HXLINE(  81)											if ((ex > cx2)) {
HXLINE(  81)												int min;
HXDLIN(  81)												if ((bx2 > cx2)) {
HXLINE(  81)													min = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  81)													min = ::Math_obj::floor(bx2);
            												}
HXDLIN(  81)												int ii_min = min;
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												xIter31 = this1;
            											}
            											else {
HXLINE(  81)												int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												xIter31 = this1;
            											}
            										}
            										else {
HXLINE(  81)											if ((bx2 > cx2)) {
HXLINE(  81)												int min;
HXDLIN(  81)												if ((ex > cx2)) {
HXLINE(  81)													min = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  81)													min = ::Math_obj::ceil(ex);
            												}
HXDLIN(  81)												int ii_min = min;
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												xIter31 = this1;
            											}
            											else {
HXLINE(  81)												int ii_min = ::Math_obj::floor(ex);
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												xIter31 = this1;
            											}
            										}
HXDLIN(  81)										::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  81)										if ((ey > by2)) {
HXLINE(  81)											if ((ey > cy2)) {
HXLINE(  81)												int min;
HXDLIN(  81)												if ((by2 > cy2)) {
HXLINE(  81)													min = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  81)													min = ::Math_obj::floor(by2);
            												}
HXDLIN(  81)												int ii_min = min;
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												yIter31 = this1;
            											}
            											else {
HXLINE(  81)												int ii_min = ::Math_obj::floor(by2);
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												yIter31 = this1;
            											}
            										}
            										else {
HXLINE(  81)											if ((by2 > cy2)) {
HXLINE(  81)												int min;
HXDLIN(  81)												if ((ey > cy2)) {
HXLINE(  81)													min = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  81)													min = ::Math_obj::ceil(ey);
            												}
HXDLIN(  81)												int ii_min = min;
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												yIter31 = this1;
            											}
            											else {
HXLINE(  81)												int ii_min = ::Math_obj::floor(ey);
HXDLIN(  81)												int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  81)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)												yIter31 = this1;
            											}
            										}
HXDLIN(  81)										::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  81)										if (hasUndo1) {
HXLINE(  81)											int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  81)											int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  81)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)											undoImage1 = this3;
HXDLIN(  81)											{
HXLINE(  81)												int rectLeft = xIter31->start;
HXDLIN(  81)												int rectTop = yIter31->start;
HXDLIN(  81)												int rectRight = xIter31->max;
HXDLIN(  81)												bool forceClear = false;
HXDLIN(  81)												{
HXLINE(  81)													int _g = rectTop;
HXDLIN(  81)													int _g1 = yIter31->max;
HXDLIN(  81)													while((_g < _g1)){
HXLINE(  81)														_g = (_g + 1);
HXDLIN(  81)														int dy = (_g - 1);
HXDLIN(  81)														{
HXLINE(  81)															int _g1 = rectLeft;
HXDLIN(  81)															int _g2 = rectRight;
HXDLIN(  81)															while((_g1 < _g2)){
HXLINE(  81)																_g1 = (_g1 + 1);
HXDLIN(  81)																int dx = (_g1 - 1);
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (pixelImage->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            																}
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int col;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	col = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if (pixelImage->useMask) {
HXLINE(  81)																	hitQuad = ::hx::IsNotNull( pixelImage->mask );
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)																	int index;
HXDLIN(  81)																	if (this1->useVirtualPos) {
HXLINE(  81)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  81)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  81)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																	int v;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		v = c;
            																	}
HXDLIN(  81)																	int this3 = v;
HXDLIN(  81)																	int maskPixel = this3;
HXDLIN(  81)																	int this4 = col;
HXDLIN(  81)																	int this5 = this4;
HXDLIN(  81)																	if ((maskPixel == 0)) {
HXLINE(  81)																		int this1 = this5;
HXDLIN(  81)																		col = this1;
            																	}
            																	else {
HXLINE(  81)																		Float m0;
HXDLIN(  81)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																		if ((this1 == 0)) {
HXLINE(  81)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float m1;
HXDLIN(  81)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																		if ((this2 == 0)) {
HXLINE(  81)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float m2;
HXDLIN(  81)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																		if ((this3 == 0)) {
HXLINE(  81)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float m3;
HXDLIN(  81)																		int this4 = (maskPixel & 255);
HXDLIN(  81)																		if ((this4 == 0)) {
HXLINE(  81)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  81)																if ((col != 0)) {
HXLINE(  81)																	int x = (dx - rectLeft);
HXDLIN(  81)																	int y = (dy - rectTop);
HXDLIN(  81)																	int this1 = col;
HXDLIN(  81)																	int c = this1;
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																		hitQuad = undoImage1->transparent;
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		int location;
HXDLIN(  81)																		if (undoImage1->useVirtualPos) {
HXLINE(  81)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  81)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  81)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																		int this3 = this2;
HXDLIN(  81)																		int this4;
HXDLIN(  81)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  81)																			this4 = this3;
            																		}
HXDLIN(  81)																		Float a1;
HXDLIN(  81)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																		if ((this5 == 0)) {
HXLINE(  81)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float r1;
HXDLIN(  81)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																		if ((this6 == 0)) {
HXLINE(  81)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float g1;
HXDLIN(  81)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																		if ((this7 == 0)) {
HXLINE(  81)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float b1;
HXDLIN(  81)																		int this8 = (this4 & 255);
HXDLIN(  81)																		if ((this8 == 0)) {
HXLINE(  81)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float a2;
HXDLIN(  81)																		int this9 = ((col >> 24) & 255);
HXDLIN(  81)																		if ((this9 == 0)) {
HXLINE(  81)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float r2;
HXDLIN(  81)																		int this10 = ((col >> 16) & 255);
HXDLIN(  81)																		if ((this10 == 0)) {
HXLINE(  81)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float g2;
HXDLIN(  81)																		int this11 = ((col >> 8) & 255);
HXDLIN(  81)																		if ((this11 == 0)) {
HXLINE(  81)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float b2;
HXDLIN(  81)																		int this12 = (col & 255);
HXDLIN(  81)																		if ((this12 == 0)) {
HXLINE(  81)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																		{
HXLINE(  81)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  81)																			int value;
HXDLIN(  81)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  81)																				value = blended;
            																			}
HXDLIN(  81)																			bool hitQuad;
HXDLIN(  81)																			if ((location >= 0)) {
HXLINE(  81)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  81)																				hitQuad = false;
            																			}
HXDLIN(  81)																			if (hitQuad) {
HXLINE(  81)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  81)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																		int index;
HXDLIN(  81)																		if (undoImage1->useVirtualPos) {
HXLINE(  81)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  81)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  81)																		int value;
HXDLIN(  81)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  81)																			value = c;
            																		}
HXDLIN(  81)																		bool hitQuad;
HXDLIN(  81)																		if ((index >= 0)) {
HXLINE(  81)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  81)																			hitQuad = false;
            																		}
HXDLIN(  81)																		if (hitQuad) {
HXLINE(  81)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  81)																	if (forceClear) {
HXLINE(  81)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																		int x = (dx - rectLeft);
HXDLIN(  81)																		int y = (dy - rectTop);
HXDLIN(  81)																		int index;
HXDLIN(  81)																		if (undoImage1->useVirtualPos) {
HXLINE(  81)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  81)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  81)																		bool hitQuad;
HXDLIN(  81)																		if ((index >= 0)) {
HXLINE(  81)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  81)																			hitQuad = false;
            																		}
HXDLIN(  81)																		if (hitQuad) {
HXLINE(  81)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  81)										bool found1 = false;
HXDLIN(  81)										Float s = ((Float)0.);
HXDLIN(  81)										Float t = ((Float)0.);
HXDLIN(  81)										Float sxx = ((Float)0.);
HXDLIN(  81)										Float txx = ((Float)0.);
HXDLIN(  81)										{
HXLINE(  81)											int _g_min1 = xIter31->start;
HXDLIN(  81)											int _g_max1 = xIter31->max;
HXDLIN(  81)											while((_g_min1 < _g_max1)){
HXLINE(  81)												_g_min1 = (_g_min1 + 1);
HXDLIN(  81)												int x = (_g_min1 - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found1 = false;
HXLINE(  81)												{
HXLINE(  81)													int _g_min = yIter31->start;
HXDLIN(  81)													int _g_max = yIter31->max;
HXDLIN(  81)													while((_g_min < _g_max)){
HXLINE(  81)														_g_min = (_g_min + 1);
HXDLIN(  81)														int y = (_g_min - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  81)														bool hitQuad;
HXDLIN(  81)														if (!((s <= 0))) {
HXLINE(  81)															hitQuad = (t <= 0);
            														}
            														else {
HXLINE(  81)															hitQuad = true;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															if (found1) {
HXLINE(  81)																goto _hx_goto_26;
            															}
            														}
            														else {
HXLINE(  81)															if (((s + t) < A)) {
HXLINE(  81)																{
HXLINE(  81)																	int this1 = color;
HXDLIN(  81)																	int c = this1;
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																		hitQuad = pixelImage->transparent;
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		int location;
HXDLIN(  81)																		if (pixelImage->useVirtualPos) {
HXLINE(  81)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  81)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  81)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																		int this3 = this2;
HXDLIN(  81)																		int this4;
HXDLIN(  81)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  81)																			this4 = this3;
            																		}
HXDLIN(  81)																		Float a1;
HXDLIN(  81)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																		if ((this5 == 0)) {
HXLINE(  81)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float r1;
HXDLIN(  81)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																		if ((this6 == 0)) {
HXLINE(  81)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float g1;
HXDLIN(  81)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																		if ((this7 == 0)) {
HXLINE(  81)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float b1;
HXDLIN(  81)																		int this8 = (this4 & 255);
HXDLIN(  81)																		if ((this8 == 0)) {
HXLINE(  81)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float a2;
HXDLIN(  81)																		int this9 = ((color >> 24) & 255);
HXDLIN(  81)																		if ((this9 == 0)) {
HXLINE(  81)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float r2;
HXDLIN(  81)																		int this10 = ((color >> 16) & 255);
HXDLIN(  81)																		if ((this10 == 0)) {
HXLINE(  81)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float g2;
HXDLIN(  81)																		int this11 = ((color >> 8) & 255);
HXDLIN(  81)																		if ((this11 == 0)) {
HXLINE(  81)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float b2;
HXDLIN(  81)																		int this12 = (color & 255);
HXDLIN(  81)																		if ((this12 == 0)) {
HXLINE(  81)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  81)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  81)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																		{
HXLINE(  81)																			::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN(  81)																			int value;
HXDLIN(  81)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  81)																				value = blended;
            																			}
HXDLIN(  81)																			bool hitQuad;
HXDLIN(  81)																			if ((location >= 0)) {
HXLINE(  81)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  81)																				hitQuad = false;
            																			}
HXDLIN(  81)																			if (hitQuad) {
HXLINE(  81)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  81)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)																		int index;
HXDLIN(  81)																		if (pixelImage->useVirtualPos) {
HXLINE(  81)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  81)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  81)																		int value;
HXDLIN(  81)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  81)																			value = c;
            																		}
HXDLIN(  81)																		bool hitQuad;
HXDLIN(  81)																		if ((index >= 0)) {
HXLINE(  81)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  81)																			hitQuad = false;
            																		}
HXDLIN(  81)																		if (hitQuad) {
HXLINE(  81)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found1 = true;
            															}
            															else {
HXLINE(  81)																if (found1) {
HXLINE(  81)																	goto _hx_goto_26;
            																}
            															}
            														}
            													}
            													_hx_goto_26:;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool hasUndo2 = false;
HXDLIN(  81)								int aA1 = ((color >> 24) & 255);
HXDLIN(  81)								int rA1 = ((color >> 16) & 255);
HXDLIN(  81)								int gA1 = ((color >> 8) & 255);
HXDLIN(  81)								int bA1 = (color & 255);
HXDLIN(  81)								Float bcx1 = (cx - dx);
HXDLIN(  81)								Float bcy1 = (cy - dy);
HXDLIN(  81)								Float acx1 = (ex - dx);
HXDLIN(  81)								Float acy1 = (ey - dy);
HXDLIN(  81)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  81)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  81)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  81)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  81)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  81)								if ((ex > cx)) {
HXLINE(  81)									if ((ex > dx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((cx > dx)) {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter32 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((cx > dx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ex > dx)) {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter32 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter32 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  81)								if ((ey > cy)) {
HXLINE(  81)									if ((ey > dy)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((cy > dy)) {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter32 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((cy > dy)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ey > dy)) {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter32 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter32 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  81)								if (hasUndo2) {
HXLINE(  81)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  81)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  81)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)									undoImage2 = this3;
HXDLIN(  81)									{
HXLINE(  81)										int rectLeft = xIter32->start;
HXDLIN(  81)										int rectTop = yIter32->start;
HXDLIN(  81)										int rectRight = xIter32->max;
HXDLIN(  81)										bool forceClear = false;
HXDLIN(  81)										{
HXLINE(  81)											int _g = rectTop;
HXDLIN(  81)											int _g1 = yIter32->max;
HXDLIN(  81)											while((_g < _g1)){
HXLINE(  81)												_g = (_g + 1);
HXDLIN(  81)												int dy = (_g - 1);
HXDLIN(  81)												{
HXLINE(  81)													int _g1 = rectLeft;
HXDLIN(  81)													int _g2 = rectRight;
HXDLIN(  81)													while((_g1 < _g2)){
HXLINE(  81)														_g1 = (_g1 + 1);
HXDLIN(  81)														int dx = (_g1 - 1);
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int col;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															col = c;
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->useMask) {
HXLINE(  81)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)															int index;
HXDLIN(  81)															if (this1->useVirtualPos) {
HXLINE(  81)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  81)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  81)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int v;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  81)																v = c;
            															}
HXDLIN(  81)															int this3 = v;
HXDLIN(  81)															int maskPixel = this3;
HXDLIN(  81)															int this4 = col;
HXDLIN(  81)															int this5 = this4;
HXDLIN(  81)															if ((maskPixel == 0)) {
HXLINE(  81)																int this1 = this5;
HXDLIN(  81)																col = this1;
            															}
            															else {
HXLINE(  81)																Float m0;
HXDLIN(  81)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																if ((this1 == 0)) {
HXLINE(  81)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m1;
HXDLIN(  81)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																if ((this2 == 0)) {
HXLINE(  81)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m2;
HXDLIN(  81)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																if ((this3 == 0)) {
HXLINE(  81)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m3;
HXDLIN(  81)																int this4 = (maskPixel & 255);
HXDLIN(  81)																if ((this4 == 0)) {
HXLINE(  81)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  81)														if ((col != 0)) {
HXLINE(  81)															int x = (dx - rectLeft);
HXDLIN(  81)															int y = (dy - rectTop);
HXDLIN(  81)															int this1 = col;
HXDLIN(  81)															int c = this1;
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																hitQuad = undoImage2->transparent;
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																int location;
HXDLIN(  81)																if (undoImage2->useVirtualPos) {
HXLINE(  81)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  81)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int this3 = this2;
HXDLIN(  81)																int this4;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	this4 = this3;
            																}
HXDLIN(  81)																Float a1;
HXDLIN(  81)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																if ((this5 == 0)) {
HXLINE(  81)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r1;
HXDLIN(  81)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																if ((this6 == 0)) {
HXLINE(  81)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g1;
HXDLIN(  81)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																if ((this7 == 0)) {
HXLINE(  81)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b1;
HXDLIN(  81)																int this8 = (this4 & 255);
HXDLIN(  81)																if ((this8 == 0)) {
HXLINE(  81)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a2;
HXDLIN(  81)																int this9 = ((col >> 24) & 255);
HXDLIN(  81)																if ((this9 == 0)) {
HXLINE(  81)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r2;
HXDLIN(  81)																int this10 = ((col >> 16) & 255);
HXDLIN(  81)																if ((this10 == 0)) {
HXLINE(  81)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g2;
HXDLIN(  81)																int this11 = ((col >> 8) & 255);
HXDLIN(  81)																if ((this11 == 0)) {
HXLINE(  81)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b2;
HXDLIN(  81)																int this12 = (col & 255);
HXDLIN(  81)																if ((this12 == 0)) {
HXLINE(  81)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																{
HXLINE(  81)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  81)																	int value;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		value = blended;
            																	}
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((location >= 0)) {
HXLINE(  81)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage2->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															if (forceClear) {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  81)																int x = (dx - rectLeft);
HXDLIN(  81)																int y = (dy - rectTop);
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage2->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool found2 = false;
HXDLIN(  81)								{
HXLINE(  81)									int _g_min2 = xIter32->start;
HXDLIN(  81)									int _g_max2 = xIter32->max;
HXDLIN(  81)									while((_g_min2 < _g_max2)){
HXLINE(  81)										_g_min2 = (_g_min2 + 1);
HXDLIN(  81)										int px = (_g_min2 - 1);
HXDLIN(  81)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 620)										found2 = false;
HXLINE(  81)										{
HXLINE(  81)											int _g_min = yIter32->start;
HXDLIN(  81)											int _g_max = yIter32->max;
HXDLIN(  81)											while((_g_min < _g_max)){
HXLINE(  81)												_g_min = (_g_min + 1);
HXDLIN(  81)												int py = (_g_min - 1);
HXDLIN(  81)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  81)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  81)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  81)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  81)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  81)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)												bool hitQuad;
HXDLIN(  81)												bool hitQuad1;
HXDLIN(  81)												if ((ratioA >= 0)) {
HXLINE(  81)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad1 = false;
            												}
HXDLIN(  81)												if (hitQuad1) {
HXLINE(  81)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad = false;
            												}
HXDLIN(  81)												if (hitQuad) {
HXLINE(  81)													int i = ::Std_obj::_hx_int((( (Float)(aA1) ) * (soft * ratioB)));
HXDLIN(  81)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  81)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  81)													int this1 = i;
HXDLIN(  81)													int a = this1;
HXDLIN(  81)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  81)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  81)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  81)													int this2 = i1;
HXDLIN(  81)													int r = this2;
HXDLIN(  81)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  81)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  81)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  81)													int this3 = i2;
HXDLIN(  81)													int g = this3;
HXDLIN(  81)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  81)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  81)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  81)													int this4 = i3;
HXDLIN(  81)													int b = this4;
HXDLIN(  81)													{
HXLINE(  81)														int location;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->transparent) {
HXLINE(  81)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int this3 = this2;
HXDLIN(  81)															int old;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  81)																old = this3;
            															}
HXDLIN(  81)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)															Float a1;
HXDLIN(  81)															int this4 = ((old >> 24) & 255);
HXDLIN(  81)															if ((this4 == 0)) {
HXLINE(  81)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r1;
HXDLIN(  81)															int this5 = ((old >> 16) & 255);
HXDLIN(  81)															if ((this5 == 0)) {
HXLINE(  81)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g1;
HXDLIN(  81)															int this6 = ((old >> 8) & 255);
HXDLIN(  81)															if ((this6 == 0)) {
HXLINE(  81)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b1;
HXDLIN(  81)															int this7 = (old & 255);
HXDLIN(  81)															if ((this7 == 0)) {
HXLINE(  81)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a2;
HXDLIN(  81)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)															if ((this8 == 0)) {
HXLINE(  81)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r2;
HXDLIN(  81)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)															if ((this9 == 0)) {
HXLINE(  81)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g2;
HXDLIN(  81)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)															if ((this10 == 0)) {
HXLINE(  81)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b2;
HXDLIN(  81)															int this11 = (rhs & 255);
HXDLIN(  81)															if ((this11 == 0)) {
HXLINE(  81)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  81)															{
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = blended;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((location >= 0)) {
HXLINE(  81)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (pixelImage->isLittle) {
HXLINE(  81)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  81)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found2 = true;
            												}
            												else {
HXLINE(  81)													if (found2) {
HXLINE(  81)														goto _hx_goto_30;
            													}
            												}
            											}
            											_hx_goto_30:;
            										}
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  81)								int v_undoY1;
HXDLIN(  81)								int v_undoX1;
HXDLIN(  81)								Float v_ty1;
HXDLIN(  81)								Float v_tx1;
HXDLIN(  81)								Float v_t01;
HXDLIN(  81)								Float v_sy1;
HXDLIN(  81)								Float v_sx1;
HXDLIN(  81)								Float v_s01;
HXDLIN(  81)								Float v_A1;
HXDLIN(  81)								Float ax2 = ex;
HXDLIN(  81)								Float ay2 = ey;
HXDLIN(  81)								Float bx3 = cx;
HXDLIN(  81)								Float by3 = cy;
HXDLIN(  81)								Float cx3 = dx;
HXDLIN(  81)								Float cy3 = dy;
HXDLIN(  81)								::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  81)								bool adjustWinding2 = (((((ax2 * by3) - (bx3 * ay2)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay2) - (ax2 * cy3))) > 0);
HXDLIN(  81)								if (!(adjustWinding2)) {
HXLINE(  81)									Float bx_ = bx3;
HXDLIN(  81)									Float by_ = by3;
HXLINE(  35)									bx3 = cx3;
HXLINE(  36)									by3 = cy3;
HXLINE(  37)									cx3 = bx_;
HXLINE(  38)									cy3 = by_;
            								}
HXLINE(  81)								Float v_ax1 = ax2;
HXDLIN(  81)								Float v_ay1 = ay2;
HXDLIN(  81)								Float v_bx1 = bx3;
HXDLIN(  81)								Float v_by1 = by3;
HXDLIN(  81)								Float v_cx1 = cx3;
HXDLIN(  81)								Float v_cy1 = cy3;
HXDLIN(  81)								bool v_preCalculated1 = true;
HXDLIN(  81)								{
HXLINE(  81)									v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  81)									v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  81)									v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  81)									v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  81)									v_tx1 = (v_ay1 - v_by1);
HXDLIN(  81)									v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  81)									v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  81)									Float a2 = v_ax1;
HXDLIN(  81)									Float b2 = v_bx1;
HXDLIN(  81)									Float c2 = v_cx1;
HXDLIN(  81)									if ((a2 > b2)) {
HXLINE(  81)										if ((a2 > c2)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b2 > c2)) {
HXLINE(  81)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b2);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b2);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter31 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b2 > c2)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a2 > c2)) {
HXLINE(  81)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a2);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a2);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter31 = this1;
            										}
            									}
HXDLIN(  81)									Float a3 = v_ay1;
HXDLIN(  81)									Float b3 = v_by1;
HXDLIN(  81)									Float c3 = v_cy1;
HXDLIN(  81)									if ((a3 > b3)) {
HXLINE(  81)										if ((a3 > c3)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b3 > c3)) {
HXLINE(  81)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b3);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b3);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter31 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b3 > c3)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a3 > c3)) {
HXLINE(  81)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a3);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a3);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter31 = this1;
            										}
            									}
            								}
HXDLIN(  81)								if (hasUndo2) {
HXLINE(  81)									v_undoImage1 = undoImage2;
HXDLIN(  81)									v_undoX1 = xIter32->start;
HXDLIN(  81)									v_undoY1 = yIter32->start;
            								}
HXDLIN(  81)								bool hasUndo3 = false;
HXDLIN(  81)								int aA2 = ((color >> 24) & 255);
HXDLIN(  81)								int rA2 = ((color >> 16) & 255);
HXDLIN(  81)								int gA2 = ((color >> 8) & 255);
HXDLIN(  81)								int bA2 = (color & 255);
HXDLIN(  81)								Float bcx2 = (dx - ax);
HXDLIN(  81)								Float bcy2 = (dy - ay);
HXDLIN(  81)								Float acx2 = (ex - ax);
HXDLIN(  81)								Float acy2 = (ey - ay);
HXDLIN(  81)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  81)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  81)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  81)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  81)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  81)								if ((ex > dx)) {
HXLINE(  81)									if ((ex > ax)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((dx > ax)) {
HXLINE(  81)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter33 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(dx);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((dx > ax)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ex > ax)) {
HXLINE(  81)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter33 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter33 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  81)								if ((ey > dy)) {
HXLINE(  81)									if ((ey > ay)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((dy > ay)) {
HXLINE(  81)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter33 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(dy);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((dy > ay)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ey > ay)) {
HXLINE(  81)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter33 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter33 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  81)								if (hasUndo3) {
HXLINE(  81)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  81)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  81)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)									undoImage3 = this3;
HXDLIN(  81)									{
HXLINE(  81)										int rectLeft = xIter33->start;
HXDLIN(  81)										int rectTop = yIter33->start;
HXDLIN(  81)										int rectRight = xIter33->max;
HXDLIN(  81)										bool forceClear = false;
HXDLIN(  81)										{
HXLINE(  81)											int _g = rectTop;
HXDLIN(  81)											int _g1 = yIter33->max;
HXDLIN(  81)											while((_g < _g1)){
HXLINE(  81)												_g = (_g + 1);
HXDLIN(  81)												int dy = (_g - 1);
HXDLIN(  81)												{
HXLINE(  81)													int _g1 = rectLeft;
HXDLIN(  81)													int _g2 = rectRight;
HXDLIN(  81)													while((_g1 < _g2)){
HXLINE(  81)														_g1 = (_g1 + 1);
HXDLIN(  81)														int dx = (_g1 - 1);
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int col;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															col = c;
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->useMask) {
HXLINE(  81)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)															int index;
HXDLIN(  81)															if (this1->useVirtualPos) {
HXLINE(  81)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  81)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  81)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int v;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  81)																v = c;
            															}
HXDLIN(  81)															int this3 = v;
HXDLIN(  81)															int maskPixel = this3;
HXDLIN(  81)															int this4 = col;
HXDLIN(  81)															int this5 = this4;
HXDLIN(  81)															if ((maskPixel == 0)) {
HXLINE(  81)																int this1 = this5;
HXDLIN(  81)																col = this1;
            															}
            															else {
HXLINE(  81)																Float m0;
HXDLIN(  81)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																if ((this1 == 0)) {
HXLINE(  81)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m1;
HXDLIN(  81)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																if ((this2 == 0)) {
HXLINE(  81)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m2;
HXDLIN(  81)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																if ((this3 == 0)) {
HXLINE(  81)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m3;
HXDLIN(  81)																int this4 = (maskPixel & 255);
HXDLIN(  81)																if ((this4 == 0)) {
HXLINE(  81)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  81)														if ((col != 0)) {
HXLINE(  81)															int x = (dx - rectLeft);
HXDLIN(  81)															int y = (dy - rectTop);
HXDLIN(  81)															int this1 = col;
HXDLIN(  81)															int c = this1;
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																hitQuad = undoImage3->transparent;
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																int location;
HXDLIN(  81)																if (undoImage3->useVirtualPos) {
HXLINE(  81)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  81)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int this3 = this2;
HXDLIN(  81)																int this4;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	this4 = this3;
            																}
HXDLIN(  81)																Float a1;
HXDLIN(  81)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																if ((this5 == 0)) {
HXLINE(  81)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r1;
HXDLIN(  81)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																if ((this6 == 0)) {
HXLINE(  81)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g1;
HXDLIN(  81)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																if ((this7 == 0)) {
HXLINE(  81)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b1;
HXDLIN(  81)																int this8 = (this4 & 255);
HXDLIN(  81)																if ((this8 == 0)) {
HXLINE(  81)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a2;
HXDLIN(  81)																int this9 = ((col >> 24) & 255);
HXDLIN(  81)																if ((this9 == 0)) {
HXLINE(  81)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r2;
HXDLIN(  81)																int this10 = ((col >> 16) & 255);
HXDLIN(  81)																if ((this10 == 0)) {
HXLINE(  81)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g2;
HXDLIN(  81)																int this11 = ((col >> 8) & 255);
HXDLIN(  81)																if ((this11 == 0)) {
HXLINE(  81)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b2;
HXDLIN(  81)																int this12 = (col & 255);
HXDLIN(  81)																if ((this12 == 0)) {
HXLINE(  81)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																{
HXLINE(  81)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  81)																	int value;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		value = blended;
            																	}
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((location >= 0)) {
HXLINE(  81)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage3->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															if (forceClear) {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  81)																int x = (dx - rectLeft);
HXDLIN(  81)																int y = (dy - rectTop);
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage3->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool found3 = false;
HXDLIN(  81)								{
HXLINE(  81)									int _g_min3 = xIter33->start;
HXDLIN(  81)									int _g_max3 = xIter33->max;
HXDLIN(  81)									while((_g_min3 < _g_max3)){
HXLINE(  81)										_g_min3 = (_g_min3 + 1);
HXDLIN(  81)										int px = (_g_min3 - 1);
HXDLIN(  81)										Float pcx = (( (Float)(px) ) - ax);
HXLINE( 620)										found3 = false;
HXLINE(  81)										{
HXLINE(  81)											int _g_min = yIter33->start;
HXDLIN(  81)											int _g_max = yIter33->max;
HXDLIN(  81)											while((_g_min < _g_max)){
HXLINE(  81)												_g_min = (_g_min + 1);
HXDLIN(  81)												int py = (_g_min - 1);
HXDLIN(  81)												Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  81)												Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  81)												Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  81)												Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  81)												Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  81)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)												bool hitQuad;
HXDLIN(  81)												bool hitQuad1;
HXDLIN(  81)												if ((ratioA >= 0)) {
HXLINE(  81)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad1 = false;
            												}
HXDLIN(  81)												if (hitQuad1) {
HXLINE(  81)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad = false;
            												}
HXDLIN(  81)												if (hitQuad) {
HXLINE(  81)													int i = ::Std_obj::_hx_int((( (Float)(aA2) ) * (soft * ratioB)));
HXDLIN(  81)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  81)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  81)													int this1 = i;
HXDLIN(  81)													int a = this1;
HXDLIN(  81)													int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  81)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  81)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  81)													int this2 = i1;
HXDLIN(  81)													int r = this2;
HXDLIN(  81)													int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  81)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  81)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  81)													int this3 = i2;
HXDLIN(  81)													int g = this3;
HXDLIN(  81)													int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  81)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  81)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  81)													int this4 = i3;
HXDLIN(  81)													int b = this4;
HXDLIN(  81)													{
HXLINE(  81)														int location;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->transparent) {
HXLINE(  81)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int this3 = this2;
HXDLIN(  81)															int old;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  81)																old = this3;
            															}
HXDLIN(  81)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)															Float a1;
HXDLIN(  81)															int this4 = ((old >> 24) & 255);
HXDLIN(  81)															if ((this4 == 0)) {
HXLINE(  81)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r1;
HXDLIN(  81)															int this5 = ((old >> 16) & 255);
HXDLIN(  81)															if ((this5 == 0)) {
HXLINE(  81)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g1;
HXDLIN(  81)															int this6 = ((old >> 8) & 255);
HXDLIN(  81)															if ((this6 == 0)) {
HXLINE(  81)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b1;
HXDLIN(  81)															int this7 = (old & 255);
HXDLIN(  81)															if ((this7 == 0)) {
HXLINE(  81)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a2;
HXDLIN(  81)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)															if ((this8 == 0)) {
HXLINE(  81)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r2;
HXDLIN(  81)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)															if ((this9 == 0)) {
HXLINE(  81)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g2;
HXDLIN(  81)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)															if ((this10 == 0)) {
HXLINE(  81)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b2;
HXDLIN(  81)															int this11 = (rhs & 255);
HXDLIN(  81)															if ((this11 == 0)) {
HXLINE(  81)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  81)															{
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = blended;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((location >= 0)) {
HXLINE(  81)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (pixelImage->isLittle) {
HXLINE(  81)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  81)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found3 = true;
            												}
            												else {
HXLINE(  81)													if (found3) {
HXLINE(  81)														goto _hx_goto_34;
            													}
            												}
            											}
            											_hx_goto_34:;
            										}
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_yIter32;
HXDLIN(  81)								::pixelimage::iter::IntIterStart v_xIter32;
HXDLIN(  81)								int v_undoY2;
HXDLIN(  81)								int v_undoX2;
HXDLIN(  81)								Float v_ty2;
HXDLIN(  81)								Float v_tx2;
HXDLIN(  81)								Float v_t02;
HXDLIN(  81)								Float v_sy2;
HXDLIN(  81)								Float v_sx2;
HXDLIN(  81)								Float v_s02;
HXDLIN(  81)								Float v_A2;
HXDLIN(  81)								Float ax3 = ex;
HXDLIN(  81)								Float ay3 = ey;
HXDLIN(  81)								Float bx4 = dx;
HXDLIN(  81)								Float by4 = dy;
HXDLIN(  81)								Float cx4 = ax;
HXDLIN(  81)								Float cy4 = ay;
HXDLIN(  81)								::pixelimage::ImageStruct v_undoImage2 = null();
HXDLIN(  81)								bool adjustWinding3 = (((((ax3 * by4) - (bx4 * ay3)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay3) - (ax3 * cy4))) > 0);
HXDLIN(  81)								if (!(adjustWinding3)) {
HXLINE(  81)									Float bx_ = bx4;
HXDLIN(  81)									Float by_ = by4;
HXLINE(  35)									bx4 = cx4;
HXLINE(  36)									by4 = cy4;
HXLINE(  37)									cx4 = bx_;
HXLINE(  38)									cy4 = by_;
            								}
HXLINE(  81)								Float v_ax2 = ax3;
HXDLIN(  81)								Float v_ay2 = ay3;
HXDLIN(  81)								Float v_bx2 = bx4;
HXDLIN(  81)								Float v_by2 = by4;
HXDLIN(  81)								Float v_cx2 = cx4;
HXDLIN(  81)								Float v_cy2 = cy4;
HXDLIN(  81)								bool v_preCalculated2 = true;
HXDLIN(  81)								{
HXLINE(  81)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  81)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  81)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  81)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  81)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  81)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  81)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  81)									Float a4 = v_ax2;
HXDLIN(  81)									Float b4 = v_bx2;
HXDLIN(  81)									Float c4 = v_cx2;
HXDLIN(  81)									if ((a4 > b4)) {
HXLINE(  81)										if ((a4 > c4)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b4 > c4)) {
HXLINE(  81)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b4);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a4);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b4);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter32 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b4 > c4)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a4 > c4)) {
HXLINE(  81)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a4);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b4);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a4);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_xIter32 = this1;
            										}
            									}
HXDLIN(  81)									Float a5 = v_ay2;
HXDLIN(  81)									Float b5 = v_by2;
HXDLIN(  81)									Float c5 = v_cy2;
HXDLIN(  81)									if ((a5 > b5)) {
HXLINE(  81)										if ((a5 > c5)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((b5 > c5)) {
HXLINE(  81)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::floor(b5);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(a5);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(b5);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter32 = this1;
            										}
            									}
            									else {
HXLINE(  81)										if ((b5 > c5)) {
HXLINE(  81)											int min;
HXDLIN(  81)											if ((a5 > c5)) {
HXLINE(  81)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  81)												min = ::Math_obj::ceil(a5);
            											}
HXDLIN(  81)											int ii_min = min;
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(b5);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  81)											int ii_min = ::Math_obj::floor(a5);
HXDLIN(  81)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  81)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)											v_yIter32 = this1;
            										}
            									}
            								}
HXDLIN(  81)								if (hasUndo3) {
HXLINE(  81)									v_undoImage2 = undoImage3;
HXDLIN(  81)									v_undoX2 = xIter33->start;
HXDLIN(  81)									v_undoY2 = yIter33->start;
            								}
HXDLIN(  81)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  81)								hitQuad = v;
            							}
            						}
            						else {
HXLINE(  81)							Float sin = ::Math_obj::sin(theta);
HXDLIN(  81)							Float cos = ::Math_obj::cos(theta);
HXDLIN(  81)							Float radius = (thick / ( (Float)(2) ));
HXDLIN(  81)							Float dx = ((Float)0.1);
HXDLIN(  81)							Float dy = radius;
HXDLIN(  81)							Float cx = h2;
HXDLIN(  81)							Float cy = radius;
HXDLIN(  81)							Float bx = h2;
HXDLIN(  81)							Float by = -(radius);
HXDLIN(  81)							Float ax = ((Float)0.1);
HXDLIN(  81)							Float ay = -(radius);
HXDLIN(  81)							Float temp = ((Float)0.);
HXLINE(  82)							temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  83)							ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  84)							ax = temp;
HXLINE(  86)							temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  87)							by = (py + ((by * cos) + (bx * sin)));
HXLINE(  88)							bx = temp;
HXLINE(  90)							temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  91)							cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  92)							cx = temp;
HXLINE(  94)							temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  95)							dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  96)							dx = temp;
HXLINE(  81)							{
HXLINE(  81)								bool hasUndo = true;
HXDLIN(  81)								int aA = ((color >> 24) & 255);
HXDLIN(  81)								int rA = ((color >> 16) & 255);
HXDLIN(  81)								int gA = ((color >> 8) & 255);
HXDLIN(  81)								int bA = (color & 255);
HXDLIN(  81)								Float bcx = (bx - dx);
HXDLIN(  81)								Float bcy = (by - dy);
HXDLIN(  81)								Float acx = (ax - dx);
HXDLIN(  81)								Float acy = (ay - dy);
HXDLIN(  81)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  81)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  81)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  81)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  81)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  81)								if ((ax > bx)) {
HXLINE(  81)									if ((ax > dx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((bx > dx)) {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((bx > dx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ax > dx)) {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter3 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  81)								if ((ay > by)) {
HXLINE(  81)									if ((ay > dy)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((by > dy)) {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((by > dy)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((ay > dy)) {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter3 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  81)								if (hasUndo) {
HXLINE(  81)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  81)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  81)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)									undoImage = this3;
HXDLIN(  81)									{
HXLINE(  81)										int rectLeft = xIter3->start;
HXDLIN(  81)										int rectTop = yIter3->start;
HXDLIN(  81)										int rectRight = xIter3->max;
HXDLIN(  81)										bool forceClear = false;
HXDLIN(  81)										{
HXLINE(  81)											int _g = rectTop;
HXDLIN(  81)											int _g1 = yIter3->max;
HXDLIN(  81)											while((_g < _g1)){
HXLINE(  81)												_g = (_g + 1);
HXDLIN(  81)												int dy = (_g - 1);
HXDLIN(  81)												{
HXLINE(  81)													int _g1 = rectLeft;
HXDLIN(  81)													int _g2 = rectRight;
HXDLIN(  81)													while((_g1 < _g2)){
HXLINE(  81)														_g1 = (_g1 + 1);
HXDLIN(  81)														int dx = (_g1 - 1);
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int col;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															col = c;
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->useMask) {
HXLINE(  81)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)															int index;
HXDLIN(  81)															if (this1->useVirtualPos) {
HXLINE(  81)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  81)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  81)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int v;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  81)																v = c;
            															}
HXDLIN(  81)															int this3 = v;
HXDLIN(  81)															int maskPixel = this3;
HXDLIN(  81)															int this4 = col;
HXDLIN(  81)															int this5 = this4;
HXDLIN(  81)															if ((maskPixel == 0)) {
HXLINE(  81)																int this1 = this5;
HXDLIN(  81)																col = this1;
            															}
            															else {
HXLINE(  81)																Float m0;
HXDLIN(  81)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																if ((this1 == 0)) {
HXLINE(  81)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m1;
HXDLIN(  81)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																if ((this2 == 0)) {
HXLINE(  81)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m2;
HXDLIN(  81)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																if ((this3 == 0)) {
HXLINE(  81)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m3;
HXDLIN(  81)																int this4 = (maskPixel & 255);
HXDLIN(  81)																if ((this4 == 0)) {
HXLINE(  81)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  81)														if ((col != 0)) {
HXLINE(  81)															int x = (dx - rectLeft);
HXDLIN(  81)															int y = (dy - rectTop);
HXDLIN(  81)															int this1 = col;
HXDLIN(  81)															int c = this1;
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																int location;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int this3 = this2;
HXDLIN(  81)																int this4;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	this4 = this3;
            																}
HXDLIN(  81)																Float a1;
HXDLIN(  81)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																if ((this5 == 0)) {
HXLINE(  81)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r1;
HXDLIN(  81)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																if ((this6 == 0)) {
HXLINE(  81)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g1;
HXDLIN(  81)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																if ((this7 == 0)) {
HXLINE(  81)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b1;
HXDLIN(  81)																int this8 = (this4 & 255);
HXDLIN(  81)																if ((this8 == 0)) {
HXLINE(  81)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a2;
HXDLIN(  81)																int this9 = ((col >> 24) & 255);
HXDLIN(  81)																if ((this9 == 0)) {
HXLINE(  81)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r2;
HXDLIN(  81)																int this10 = ((col >> 16) & 255);
HXDLIN(  81)																if ((this10 == 0)) {
HXLINE(  81)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g2;
HXDLIN(  81)																int this11 = ((col >> 8) & 255);
HXDLIN(  81)																if ((this11 == 0)) {
HXLINE(  81)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b2;
HXDLIN(  81)																int this12 = (col & 255);
HXDLIN(  81)																if ((this12 == 0)) {
HXLINE(  81)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																{
HXLINE(  81)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  81)																	int value;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		value = blended;
            																	}
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((location >= 0)) {
HXLINE(  81)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															if (forceClear) {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)																int x = (dx - rectLeft);
HXDLIN(  81)																int y = (dy - rectTop);
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool found = false;
HXDLIN(  81)								Float min = ( (Float)(0) );
HXDLIN(  81)								Float max = ( (Float)(0) );
HXDLIN(  81)								int a = 0;
HXDLIN(  81)								int r = 0;
HXDLIN(  81)								int g = 0;
HXDLIN(  81)								int b = 0;
HXDLIN(  81)								{
HXLINE(  81)									int _g_min = xIter3->start;
HXDLIN(  81)									int _g_max = xIter3->max;
HXDLIN(  81)									while((_g_min < _g_max)){
HXLINE(  81)										_g_min = (_g_min + 1);
HXDLIN(  81)										int px = (_g_min - 1);
HXDLIN(  81)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found = false;
HXLINE(  81)										{
HXLINE(  81)											int _g_min1 = yIter3->start;
HXDLIN(  81)											int _g_max = yIter3->max;
HXDLIN(  81)											while((_g_min1 < _g_max)){
HXLINE(  81)												_g_min1 = (_g_min1 + 1);
HXDLIN(  81)												int py = (_g_min1 - 1);
HXDLIN(  81)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  81)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  81)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  81)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  81)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  81)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)												bool hitQuad;
HXDLIN(  81)												bool hitQuad1;
HXDLIN(  81)												if ((ratioA >= 0)) {
HXLINE(  81)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad1 = false;
            												}
HXDLIN(  81)												if (hitQuad1) {
HXLINE(  81)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad = false;
            												}
HXDLIN(  81)												if (hitQuad) {
HXLINE(  81)													if ((ratioA < ratioC)) {
HXLINE(  81)														min = ratioA;
            													}
            													else {
HXLINE(  81)														min = ratioC;
            													}
HXDLIN(  81)													if ((ratioA > ratioB)) {
HXLINE(  81)														max = ratioA;
            													}
            													else {
HXLINE(  81)														max = ratioB;
            													}
HXDLIN(  81)													if (!((max > ratioC))) {
HXLINE(  81)														max = ratioC;
            													}
HXLINE( 729)													max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  81)													if (!((min < max))) {
HXLINE(  81)														min = ((max + min) / ( (Float)(2) ));
            													}
HXDLIN(  81)													int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  81)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  81)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  81)													int this1 = i;
HXDLIN(  81)													a = this1;
HXDLIN(  81)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  81)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  81)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  81)													int this2 = i1;
HXLINE( 748)													r = this2;
HXLINE(  81)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  81)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  81)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  81)													int this3 = i2;
HXLINE( 749)													g = this3;
HXLINE(  81)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  81)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  81)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  81)													int this4 = i3;
HXLINE( 750)													b = this4;
HXLINE(  81)													{
HXLINE(  81)														int location;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->transparent) {
HXLINE(  81)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int this3 = this2;
HXDLIN(  81)															int old;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  81)																old = this3;
            															}
HXDLIN(  81)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)															Float a1;
HXDLIN(  81)															int this4 = ((old >> 24) & 255);
HXDLIN(  81)															if ((this4 == 0)) {
HXLINE(  81)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r1;
HXDLIN(  81)															int this5 = ((old >> 16) & 255);
HXDLIN(  81)															if ((this5 == 0)) {
HXLINE(  81)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g1;
HXDLIN(  81)															int this6 = ((old >> 8) & 255);
HXDLIN(  81)															if ((this6 == 0)) {
HXLINE(  81)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b1;
HXDLIN(  81)															int this7 = (old & 255);
HXDLIN(  81)															if ((this7 == 0)) {
HXLINE(  81)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a2;
HXDLIN(  81)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)															if ((this8 == 0)) {
HXLINE(  81)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r2;
HXDLIN(  81)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)															if ((this9 == 0)) {
HXLINE(  81)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g2;
HXDLIN(  81)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)															if ((this10 == 0)) {
HXLINE(  81)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b2;
HXDLIN(  81)															int this11 = (rhs & 255);
HXDLIN(  81)															if ((this11 == 0)) {
HXLINE(  81)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  81)															{
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = blended;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((location >= 0)) {
HXLINE(  81)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (pixelImage->isLittle) {
HXLINE(  81)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  81)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found = true;
            												}
            												else {
HXLINE(  81)													if (found) {
HXLINE(  81)														goto _hx_goto_38;
            													}
            												}
            											}
            											_hx_goto_38:;
            										}
            									}
            								}
            							}
HXDLIN(  81)							{
HXLINE(  81)								bool hasUndo1 = true;
HXDLIN(  81)								int aA1 = ((color >> 24) & 255);
HXDLIN(  81)								int rA1 = ((color >> 16) & 255);
HXDLIN(  81)								int gA1 = ((color >> 8) & 255);
HXDLIN(  81)								int bA1 = (color & 255);
HXDLIN(  81)								Float bcx1 = (cx - dx);
HXDLIN(  81)								Float bcy1 = (cy - dy);
HXDLIN(  81)								Float acx1 = (bx - dx);
HXDLIN(  81)								Float acy1 = (by - dy);
HXDLIN(  81)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  81)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  81)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  81)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  81)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  81)								if ((bx > cx)) {
HXLINE(  81)									if ((bx > dx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((cx > dx)) {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter31 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((cx > dx)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((bx > dx)) {
HXLINE(  81)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter31 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										xIter31 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  81)								if ((by > cy)) {
HXLINE(  81)									if ((by > dy)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((cy > dy)) {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter31 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  81)									if ((cy > dy)) {
HXLINE(  81)										int min;
HXDLIN(  81)										if ((by > dy)) {
HXLINE(  81)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  81)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  81)										int ii_min = min;
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter31 = this1;
            									}
            									else {
HXLINE(  81)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  81)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  81)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)										yIter31 = this1;
            									}
            								}
HXDLIN(  81)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  81)								if (hasUndo1) {
HXLINE(  81)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  81)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  81)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)									undoImage1 = this3;
HXDLIN(  81)									{
HXLINE(  81)										int rectLeft = xIter31->start;
HXDLIN(  81)										int rectTop = yIter31->start;
HXDLIN(  81)										int rectRight = xIter31->max;
HXDLIN(  81)										bool forceClear = false;
HXDLIN(  81)										{
HXLINE(  81)											int _g = rectTop;
HXDLIN(  81)											int _g1 = yIter31->max;
HXDLIN(  81)											while((_g < _g1)){
HXLINE(  81)												_g = (_g + 1);
HXDLIN(  81)												int dy = (_g - 1);
HXDLIN(  81)												{
HXLINE(  81)													int _g1 = rectLeft;
HXDLIN(  81)													int _g2 = rectRight;
HXDLIN(  81)													while((_g1 < _g2)){
HXLINE(  81)														_g1 = (_g1 + 1);
HXDLIN(  81)														int dx = (_g1 - 1);
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int col;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															col = c;
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->useMask) {
HXLINE(  81)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)															int index;
HXDLIN(  81)															if (this1->useVirtualPos) {
HXLINE(  81)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  81)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  81)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int v;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  81)																v = c;
            															}
HXDLIN(  81)															int this3 = v;
HXDLIN(  81)															int maskPixel = this3;
HXDLIN(  81)															int this4 = col;
HXDLIN(  81)															int this5 = this4;
HXDLIN(  81)															if ((maskPixel == 0)) {
HXLINE(  81)																int this1 = this5;
HXDLIN(  81)																col = this1;
            															}
            															else {
HXLINE(  81)																Float m0;
HXDLIN(  81)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)																if ((this1 == 0)) {
HXLINE(  81)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m1;
HXDLIN(  81)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)																if ((this2 == 0)) {
HXLINE(  81)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m2;
HXDLIN(  81)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)																if ((this3 == 0)) {
HXLINE(  81)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float m3;
HXDLIN(  81)																int this4 = (maskPixel & 255);
HXDLIN(  81)																if ((this4 == 0)) {
HXLINE(  81)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  81)														if ((col != 0)) {
HXLINE(  81)															int x = (dx - rectLeft);
HXDLIN(  81)															int y = (dy - rectTop);
HXDLIN(  81)															int this1 = col;
HXDLIN(  81)															int c = this1;
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																int location;
HXDLIN(  81)																if (undoImage1->useVirtualPos) {
HXLINE(  81)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  81)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)																int this3 = this2;
HXDLIN(  81)																int this4;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	this4 = this3;
            																}
HXDLIN(  81)																Float a1;
HXDLIN(  81)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)																if ((this5 == 0)) {
HXLINE(  81)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r1;
HXDLIN(  81)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)																if ((this6 == 0)) {
HXLINE(  81)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g1;
HXDLIN(  81)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)																if ((this7 == 0)) {
HXLINE(  81)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b1;
HXDLIN(  81)																int this8 = (this4 & 255);
HXDLIN(  81)																if ((this8 == 0)) {
HXLINE(  81)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a2;
HXDLIN(  81)																int this9 = ((col >> 24) & 255);
HXDLIN(  81)																if ((this9 == 0)) {
HXLINE(  81)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float r2;
HXDLIN(  81)																int this10 = ((col >> 16) & 255);
HXDLIN(  81)																if ((this10 == 0)) {
HXLINE(  81)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float g2;
HXDLIN(  81)																int this11 = ((col >> 8) & 255);
HXDLIN(  81)																if ((this11 == 0)) {
HXLINE(  81)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float b2;
HXDLIN(  81)																int this12 = (col & 255);
HXDLIN(  81)																if ((this12 == 0)) {
HXLINE(  81)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  81)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  81)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)																{
HXLINE(  81)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  81)																	int value;
HXDLIN(  81)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  81)																		value = blended;
            																	}
HXDLIN(  81)																	bool hitQuad;
HXDLIN(  81)																	if ((location >= 0)) {
HXLINE(  81)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  81)																		hitQuad = false;
            																	}
HXDLIN(  81)																	if (hitQuad) {
HXLINE(  81)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage1->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = c;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															if (forceClear) {
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  81)																int x = (dx - rectLeft);
HXDLIN(  81)																int y = (dy - rectTop);
HXDLIN(  81)																int index;
HXDLIN(  81)																if (undoImage1->useVirtualPos) {
HXLINE(  81)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  81)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((index >= 0)) {
HXLINE(  81)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  81)								bool found1 = false;
HXDLIN(  81)								Float min1 = ( (Float)(0) );
HXDLIN(  81)								Float max1 = ( (Float)(0) );
HXDLIN(  81)								int a1 = 0;
HXDLIN(  81)								int r1 = 0;
HXDLIN(  81)								int g1 = 0;
HXDLIN(  81)								int b1 = 0;
HXDLIN(  81)								{
HXLINE(  81)									int _g_min1 = xIter31->start;
HXDLIN(  81)									int _g_max1 = xIter31->max;
HXDLIN(  81)									while((_g_min1 < _g_max1)){
HXLINE(  81)										_g_min1 = (_g_min1 + 1);
HXDLIN(  81)										int px = (_g_min1 - 1);
HXDLIN(  81)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found1 = false;
HXLINE(  81)										{
HXLINE(  81)											int _g_min = yIter31->start;
HXDLIN(  81)											int _g_max = yIter31->max;
HXDLIN(  81)											while((_g_min < _g_max)){
HXLINE(  81)												_g_min = (_g_min + 1);
HXDLIN(  81)												int py = (_g_min - 1);
HXDLIN(  81)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  81)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  81)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  81)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  81)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  81)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)												bool hitQuad;
HXDLIN(  81)												bool hitQuad1;
HXDLIN(  81)												if ((ratioA >= 0)) {
HXLINE(  81)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad1 = false;
            												}
HXDLIN(  81)												if (hitQuad1) {
HXLINE(  81)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  81)													hitQuad = false;
            												}
HXDLIN(  81)												if (hitQuad) {
HXLINE( 713)													min1 = ratioB;
HXLINE(  81)													int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  81)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  81)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  81)													int this1 = i;
HXDLIN(  81)													a1 = this1;
HXDLIN(  81)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  81)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  81)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  81)													int this2 = i1;
HXLINE( 748)													r1 = this2;
HXLINE(  81)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  81)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  81)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  81)													int this3 = i2;
HXLINE( 749)													g1 = this3;
HXLINE(  81)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  81)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  81)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  81)													int this4 = i3;
HXLINE( 750)													b1 = this4;
HXLINE(  81)													{
HXLINE(  81)														int location;
HXDLIN(  81)														if (pixelImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  81)														bool hitQuad;
HXDLIN(  81)														if (pixelImage->transparent) {
HXLINE(  81)															hitQuad = (a1 < 254);
            														}
            														else {
HXLINE(  81)															hitQuad = false;
            														}
HXDLIN(  81)														if (hitQuad) {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)															int this3 = this2;
HXDLIN(  81)															int old;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  81)																old = this3;
            															}
HXDLIN(  81)															int rhs = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  81)															Float a11;
HXDLIN(  81)															int this4 = ((old >> 24) & 255);
HXDLIN(  81)															if ((this4 == 0)) {
HXLINE(  81)																a11 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r11;
HXDLIN(  81)															int this5 = ((old >> 16) & 255);
HXDLIN(  81)															if ((this5 == 0)) {
HXLINE(  81)																r11 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g11;
HXDLIN(  81)															int this6 = ((old >> 8) & 255);
HXDLIN(  81)															if ((this6 == 0)) {
HXLINE(  81)																g11 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b11;
HXDLIN(  81)															int this7 = (old & 255);
HXDLIN(  81)															if ((this7 == 0)) {
HXLINE(  81)																b11 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a2;
HXDLIN(  81)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)															if ((this8 == 0)) {
HXLINE(  81)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float r2;
HXDLIN(  81)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)															if ((this9 == 0)) {
HXLINE(  81)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float g2;
HXDLIN(  81)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)															if ((this10 == 0)) {
HXLINE(  81)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float b2;
HXDLIN(  81)															int this11 = (rhs & 255);
HXDLIN(  81)															if ((this11 == 0)) {
HXLINE(  81)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  81)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  81)															Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  81)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a2))));
HXDLIN(  81)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a2))));
HXDLIN(  81)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a2))));
HXDLIN(  81)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)															{
HXLINE(  81)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)																int value;
HXDLIN(  81)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  81)																	value = blended;
            																}
HXDLIN(  81)																bool hitQuad;
HXDLIN(  81)																if ((location >= 0)) {
HXLINE(  81)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  81)																	hitQuad = false;
            																}
HXDLIN(  81)																if (hitQuad) {
HXLINE(  81)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (pixelImage->isLittle) {
HXLINE(  81)																value = ((((a1 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            															}
            															else {
HXLINE(  81)																value = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            															}
HXDLIN(  81)															bool hitQuad;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																hitQuad = false;
            															}
HXDLIN(  81)															if (hitQuad) {
HXLINE(  81)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found1 = true;
            												}
            												else {
HXLINE(  81)													if (found1) {
HXLINE(  81)														goto _hx_goto_42;
            													}
            												}
            											}
            											_hx_goto_42:;
            										}
            									}
            								}
            							}
HXDLIN(  81)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  81)							hitQuad = v;
            						}
HXDLIN(  81)						Float cx = h2;
HXDLIN(  81)						Float cy = radius2;
HXDLIN(  81)						Float bx = h2;
HXDLIN(  81)						Float by = -(radius2);
HXDLIN(  81)						Float temp = ((Float)0.);
HXLINE( 468)						temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 469)						by = (py + ((by * cos) + (bx * sin)));
HXLINE( 470)						bx = temp;
HXLINE( 471)						temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 472)						cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 473)						cx = temp;
HXLINE(  81)						bool hasUndo = true;
HXDLIN(  81)						int aA = ((color >> 24) & 255);
HXDLIN(  81)						int rA = ((color >> 16) & 255);
HXDLIN(  81)						int gA = ((color >> 8) & 255);
HXDLIN(  81)						int bA = (color & 255);
HXDLIN(  81)						Float bcx = (bx - cx);
HXDLIN(  81)						Float bcy = (by - cy);
HXDLIN(  81)						Float acx = (px - cx);
HXDLIN(  81)						Float acy = (py - cy);
HXDLIN(  81)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  81)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  81)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  81)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  81)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  81)						if ((px > bx)) {
HXLINE(  81)							if ((px > cx)) {
HXLINE(  81)								int min;
HXDLIN(  81)								if ((bx > cx)) {
HXLINE(  81)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE(  81)									min = ::Math_obj::floor(bx);
            								}
HXDLIN(  81)								int ii_min = min;
HXDLIN(  81)								int ii_max = ::Math_obj::ceil(px);
HXDLIN(  81)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)								xIter3 = this1;
            							}
            							else {
HXLINE(  81)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  81)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  81)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  81)							if ((bx > cx)) {
HXLINE(  81)								int min;
HXDLIN(  81)								if ((px > cx)) {
HXLINE(  81)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE(  81)									min = ::Math_obj::ceil(px);
            								}
HXDLIN(  81)								int ii_min = min;
HXDLIN(  81)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  81)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)								xIter3 = this1;
            							}
            							else {
HXLINE(  81)								int ii_min = ::Math_obj::floor(px);
HXDLIN(  81)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  81)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)								xIter3 = this1;
            							}
            						}
HXDLIN(  81)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  81)						if ((py > by)) {
HXLINE(  81)							if ((py > cy)) {
HXLINE(  81)								int min;
HXDLIN(  81)								if ((by > cy)) {
HXLINE(  81)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE(  81)									min = ::Math_obj::floor(by);
            								}
HXDLIN(  81)								int ii_min = min;
HXDLIN(  81)								int ii_max = ::Math_obj::ceil(py);
HXDLIN(  81)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)								yIter3 = this1;
            							}
            							else {
HXLINE(  81)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  81)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  81)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  81)							if ((by > cy)) {
HXLINE(  81)								int min;
HXDLIN(  81)								if ((py > cy)) {
HXLINE(  81)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE(  81)									min = ::Math_obj::ceil(py);
            								}
HXDLIN(  81)								int ii_min = min;
HXDLIN(  81)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  81)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)								yIter3 = this1;
            							}
            							else {
HXLINE(  81)								int ii_min = ::Math_obj::floor(py);
HXDLIN(  81)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  81)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  81)								yIter3 = this1;
            							}
            						}
HXDLIN(  81)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  81)						if (hasUndo) {
HXLINE(  81)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  81)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  81)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  81)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  81)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  81)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  81)							undoImage = this3;
HXDLIN(  81)							{
HXLINE(  81)								int rectLeft = xIter3->start;
HXDLIN(  81)								int rectTop = yIter3->start;
HXDLIN(  81)								int rectRight = xIter3->max;
HXDLIN(  81)								bool forceClear = false;
HXDLIN(  81)								{
HXLINE(  81)									int _g = rectTop;
HXDLIN(  81)									int _g1 = yIter3->max;
HXDLIN(  81)									while((_g < _g1)){
HXLINE(  81)										_g = (_g + 1);
HXDLIN(  81)										int dy = (_g - 1);
HXDLIN(  81)										{
HXLINE(  81)											int _g1 = rectLeft;
HXDLIN(  81)											int _g2 = rectRight;
HXDLIN(  81)											while((_g1 < _g2)){
HXLINE(  81)												_g1 = (_g1 + 1);
HXDLIN(  81)												int dx = (_g1 - 1);
HXDLIN(  81)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)												int index;
HXDLIN(  81)												if (pixelImage->useVirtualPos) {
HXLINE(  81)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  81)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN(  81)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)												int col;
HXDLIN(  81)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  81)													col = c;
            												}
HXDLIN(  81)												bool _hx_tmp;
HXDLIN(  81)												if (pixelImage->useMask) {
HXLINE(  81)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE(  81)													_hx_tmp = false;
            												}
HXDLIN(  81)												if (_hx_tmp) {
HXLINE(  81)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  81)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  81)													int index;
HXDLIN(  81)													if (this1->useVirtualPos) {
HXLINE(  81)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  81)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  81)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  81)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  81)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)													int v;
HXDLIN(  81)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  81)														v = c;
            													}
HXDLIN(  81)													int this3 = v;
HXDLIN(  81)													int maskPixel = this3;
HXDLIN(  81)													int this4 = col;
HXDLIN(  81)													int this5 = this4;
HXDLIN(  81)													if ((maskPixel == 0)) {
HXLINE(  81)														int this1 = this5;
HXDLIN(  81)														col = this1;
            													}
            													else {
HXLINE(  81)														Float m0;
HXDLIN(  81)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  81)														if ((this1 == 0)) {
HXLINE(  81)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float m1;
HXDLIN(  81)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  81)														if ((this2 == 0)) {
HXLINE(  81)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float m2;
HXDLIN(  81)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  81)														if ((this3 == 0)) {
HXLINE(  81)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float m3;
HXDLIN(  81)														int this4 = (maskPixel & 255);
HXDLIN(  81)														if ((this4 == 0)) {
HXLINE(  81)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  81)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  81)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  81)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  81)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  81)												if ((col != 0)) {
HXLINE(  81)													int x = (dx - rectLeft);
HXDLIN(  81)													int y = (dy - rectTop);
HXDLIN(  81)													int this1 = col;
HXDLIN(  81)													int c = this1;
HXDLIN(  81)													bool _hx_tmp;
HXDLIN(  81)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  81)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  81)														_hx_tmp = false;
            													}
HXDLIN(  81)													if (_hx_tmp) {
HXLINE(  81)														int location;
HXDLIN(  81)														if (undoImage->useVirtualPos) {
HXLINE(  81)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  81)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  81)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)														int this3 = this2;
HXDLIN(  81)														int this4;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  81)															this4 = this3;
            														}
HXDLIN(  81)														Float a1;
HXDLIN(  81)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  81)														if ((this5 == 0)) {
HXLINE(  81)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float r1;
HXDLIN(  81)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  81)														if ((this6 == 0)) {
HXLINE(  81)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float g1;
HXDLIN(  81)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  81)														if ((this7 == 0)) {
HXLINE(  81)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float b1;
HXDLIN(  81)														int this8 = (this4 & 255);
HXDLIN(  81)														if ((this8 == 0)) {
HXLINE(  81)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float a2;
HXDLIN(  81)														int this9 = ((col >> 24) & 255);
HXDLIN(  81)														if ((this9 == 0)) {
HXLINE(  81)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float r2;
HXDLIN(  81)														int this10 = ((col >> 16) & 255);
HXDLIN(  81)														if ((this10 == 0)) {
HXLINE(  81)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float g2;
HXDLIN(  81)														int this11 = ((col >> 8) & 255);
HXDLIN(  81)														if ((this11 == 0)) {
HXLINE(  81)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float b2;
HXDLIN(  81)														int this12 = (col & 255);
HXDLIN(  81)														if ((this12 == 0)) {
HXLINE(  81)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  81)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  81)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  81)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)														{
HXLINE(  81)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  81)															int value;
HXDLIN(  81)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  81)																value = blended;
            															}
HXDLIN(  81)															bool _hx_tmp;
HXDLIN(  81)															if ((location >= 0)) {
HXLINE(  81)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  81)																_hx_tmp = false;
            															}
HXDLIN(  81)															if (_hx_tmp) {
HXLINE(  81)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  81)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  81)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  81)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)														int index;
HXDLIN(  81)														if (undoImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  81)														int value;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  81)															value = c;
            														}
HXDLIN(  81)														bool _hx_tmp;
HXDLIN(  81)														if ((index >= 0)) {
HXLINE(  81)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  81)															_hx_tmp = false;
            														}
HXDLIN(  81)														if (_hx_tmp) {
HXLINE(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  81)													if (forceClear) {
HXLINE(  81)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  81)														int x = (dx - rectLeft);
HXDLIN(  81)														int y = (dy - rectTop);
HXDLIN(  81)														int index;
HXDLIN(  81)														if (undoImage->useVirtualPos) {
HXLINE(  81)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  81)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  81)														bool _hx_tmp;
HXDLIN(  81)														if ((index >= 0)) {
HXLINE(  81)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  81)															_hx_tmp = false;
            														}
HXDLIN(  81)														if (_hx_tmp) {
HXLINE(  81)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  81)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  81)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  81)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  81)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  81)						bool found = false;
HXDLIN(  81)						Float min = ( (Float)(0) );
HXDLIN(  81)						Float max = ( (Float)(0) );
HXDLIN(  81)						int a1 = 0;
HXDLIN(  81)						int r = 0;
HXDLIN(  81)						int g = 0;
HXDLIN(  81)						int b = 0;
HXDLIN(  81)						{
HXLINE(  81)							int _g_min = xIter3->start;
HXDLIN(  81)							int _g_max = xIter3->max;
HXDLIN(  81)							while((_g_min < _g_max)){
HXLINE(  81)								_g_min = (_g_min + 1);
HXDLIN(  81)								int px = (_g_min - 1);
HXDLIN(  81)								Float pcx = (( (Float)(px) ) - cx);
HXLINE( 696)								found = false;
HXLINE(  81)								{
HXLINE(  81)									int _g_min1 = yIter3->start;
HXDLIN(  81)									int _g_max = yIter3->max;
HXDLIN(  81)									while((_g_min1 < _g_max)){
HXLINE(  81)										_g_min1 = (_g_min1 + 1);
HXDLIN(  81)										int py = (_g_min1 - 1);
HXDLIN(  81)										Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  81)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  81)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  81)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  81)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  81)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  81)										bool _hx_tmp;
HXDLIN(  81)										bool _hx_tmp1;
HXDLIN(  81)										if ((ratioA >= 0)) {
HXLINE(  81)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  81)											_hx_tmp1 = false;
            										}
HXDLIN(  81)										if (_hx_tmp1) {
HXLINE(  81)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  81)											_hx_tmp = false;
            										}
HXDLIN(  81)										if (_hx_tmp) {
HXLINE(  81)											Float min;
HXDLIN(  81)											if ((ratioA < ratioB)) {
HXLINE(  81)												min = ratioA;
            											}
            											else {
HXLINE(  81)												min = ratioB;
            											}
HXDLIN(  81)											if (!((min < ratioC))) {
HXLINE(  81)												min = ratioC;
            											}
HXDLIN(  81)											Float max;
HXDLIN(  81)											if ((ratioA > ratioB)) {
HXLINE(  81)												max = ratioA;
            											}
            											else {
HXLINE(  81)												max = ratioB;
            											}
HXDLIN(  81)											if (!((max > ratioC))) {
HXLINE(  81)												max = ratioC;
            											}
HXLINE( 744)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  81)											Float min1;
HXDLIN(  81)											if ((min < max)) {
HXLINE(  81)												min1 = min;
            											}
            											else {
HXLINE(  81)												min1 = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  81)											int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min1));
HXDLIN(  81)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  81)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  81)											int this1 = i;
HXDLIN(  81)											a1 = this1;
HXDLIN(  81)											int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  81)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  81)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  81)											int this2 = i1;
HXLINE( 748)											r = this2;
HXLINE(  81)											int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  81)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  81)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  81)											int this3 = i2;
HXLINE( 749)											g = this3;
HXLINE(  81)											int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  81)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  81)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  81)											int this4 = i3;
HXLINE( 750)											b = this4;
HXLINE(  81)											{
HXLINE(  81)												int location;
HXDLIN(  81)												if (pixelImage->useVirtualPos) {
HXLINE(  81)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  81)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            												}
HXDLIN(  81)												bool _hx_tmp;
HXDLIN(  81)												if (pixelImage->transparent) {
HXLINE(  81)													_hx_tmp = (a1 < 254);
            												}
            												else {
HXLINE(  81)													_hx_tmp = false;
            												}
HXDLIN(  81)												if (_hx_tmp) {
HXLINE(  81)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  81)													int this3 = this2;
HXDLIN(  81)													int old;
HXDLIN(  81)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  81)														old = this3;
            													}
HXDLIN(  81)													int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  81)													Float a11;
HXDLIN(  81)													int this4 = ((old >> 24) & 255);
HXDLIN(  81)													if ((this4 == 0)) {
HXLINE(  81)														a11 = ((Float)0.);
            													}
            													else {
HXLINE(  81)														a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  81)													Float r1;
HXDLIN(  81)													int this5 = ((old >> 16) & 255);
HXDLIN(  81)													if ((this5 == 0)) {
HXLINE(  81)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  81)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  81)													Float g1;
HXDLIN(  81)													int this6 = ((old >> 8) & 255);
HXDLIN(  81)													if ((this6 == 0)) {
HXLINE(  81)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  81)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  81)													Float b1;
HXDLIN(  81)													int this7 = (old & 255);
HXDLIN(  81)													if ((this7 == 0)) {
HXLINE(  81)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  81)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  81)													Float a2;
HXDLIN(  81)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  81)													if ((this8 == 0)) {
HXLINE(  81)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  81)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  81)													Float r2;
HXDLIN(  81)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  81)													if ((this9 == 0)) {
HXLINE(  81)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  81)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  81)													Float g2;
HXDLIN(  81)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  81)													if ((this10 == 0)) {
HXLINE(  81)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  81)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  81)													Float b2;
HXDLIN(  81)													int this11 = (rhs & 255);
HXDLIN(  81)													if ((this11 == 0)) {
HXLINE(  81)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  81)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  81)													Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  81)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  81)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  81)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  81)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  81)													int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  81)													{
HXLINE(  81)														::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  81)														int value;
HXDLIN(  81)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  81)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  81)															value = blended;
            														}
HXDLIN(  81)														bool _hx_tmp;
HXDLIN(  81)														if ((location >= 0)) {
HXLINE(  81)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  81)															_hx_tmp = false;
            														}
HXDLIN(  81)														if (_hx_tmp) {
HXLINE(  81)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  81)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  81)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  81)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  81)													int value;
HXDLIN(  81)													if (pixelImage->isLittle) {
HXLINE(  81)														value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  81)														value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  81)													bool _hx_tmp;
HXDLIN(  81)													if ((location >= 0)) {
HXLINE(  81)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  81)														_hx_tmp = false;
            													}
HXDLIN(  81)													if (_hx_tmp) {
HXLINE(  81)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  81)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  81)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  81)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  81)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  81)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 752)											found = true;
            										}
            										else {
HXLINE(  81)											if (found) {
HXLINE(  81)												goto _hx_goto_46;
            											}
            										}
            									}
            									_hx_goto_46:;
            								}
            							}
            						}
HXDLIN(  81)						::pixelimage::algo::HitTri hitTri;
HXDLIN(  81)						if ((hasHit == false)) {
HXLINE(  81)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx,by,cx,cy,true);
HXDLIN(  81)							if (hasUndo) {
HXLINE(  81)								v->undoImage = undoImage;
HXDLIN(  81)								v->undoX = xIter3->start;
HXDLIN(  81)								v->undoY = yIter3->start;
            							}
HXDLIN(  81)							hitTri = v;
            						}
            						else {
HXLINE(  81)							hitTri = null();
            						}
HXDLIN(  81)						if (hasHit) {
HXLINE(  81)							::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN(  81)							if (::hx::IsNotNull( hitQuad )) {
HXLINE(  81)								hitArr->triArr->push(hitQuad->triABD);
            							}
HXDLIN(  81)							hitArr->triArr->push(hitQuad->triBCD);
            						}
            					}
            				}
            				else {
HXLINE(  83)					Float thick = this->strokeWidth;
HXDLIN(  83)					int color = this->strokeColor;
HXDLIN(  83)					Float soft = this->soft;
HXDLIN(  83)					bool hasHit = true;
HXDLIN(  83)					{
HXLINE(  83)						Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  83)						Float o = (py - py);
HXDLIN(  83)						Float a = (px - px);
HXDLIN(  83)						Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  83)						Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  83)						Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN(  83)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  83)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  83)						Float radius = (thick / ( (Float)(2) ));
HXDLIN(  83)						Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  83)						Float h2 = (h / goldenRatio);
HXDLIN(  83)						::pixelimage::algo::HitQuad hitQuad;
HXDLIN(  83)						if (this->flare) {
HXLINE(  83)							if (this->reverseFlare) {
HXLINE(  83)								Float sin = ::Math_obj::sin(theta);
HXDLIN(  83)								Float cos = ::Math_obj::cos(theta);
HXDLIN(  83)								Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  83)								Float radius2 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  83)								Float dx = ((Float)0.1);
HXDLIN(  83)								Float dy = radius1;
HXDLIN(  83)								Float cx = h2;
HXDLIN(  83)								Float cy = radius2;
HXDLIN(  83)								Float bx = h2;
HXDLIN(  83)								Float by = -(radius2);
HXDLIN(  83)								Float ax = ((Float)0.1);
HXDLIN(  83)								Float ay = -(radius1);
HXDLIN(  83)								Float temp = ((Float)0.);
HXLINE( 288)								temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)								ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)								ax = temp;
HXLINE( 292)								temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)								by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)								bx = temp;
HXLINE( 296)								temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)								cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)								cx = temp;
HXLINE( 300)								temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)								dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)								dx = temp;
HXLINE(  83)								Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN(  83)								Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN(  83)								{
HXLINE(  83)									Float bx1 = ax;
HXDLIN(  83)									Float by1 = ay;
HXDLIN(  83)									Float cx1 = bx;
HXDLIN(  83)									Float cy1 = by;
HXDLIN(  83)									bool hasUndo = false;
HXDLIN(  83)									bool adjustWinding = (((((ex * by1) - (bx1 * ey)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ey) - (ex * cy1))) > 0);
HXDLIN(  83)									if (!(adjustWinding)) {
HXLINE(  83)										Float bx_ = bx1;
HXDLIN(  83)										Float by_ = by1;
HXLINE(  26)										bx1 = cx1;
HXLINE(  27)										by1 = cy1;
HXLINE(  28)										cx1 = bx_;
HXLINE(  29)										cy1 = by_;
            									}
HXLINE(  83)									{
HXLINE(  83)										Float s0 = ((ey * cx1) - (ex * cy1));
HXDLIN(  83)										Float sx = (cy1 - ey);
HXDLIN(  83)										Float sy = (ex - cx1);
HXDLIN(  83)										Float t0 = ((ex * by1) - (ey * bx1));
HXDLIN(  83)										Float tx = (ey - by1);
HXDLIN(  83)										Float ty = (bx1 - ex);
HXDLIN(  83)										Float A = ((((-(by1) * cx1) + (ey * (-(bx1) + cx1))) + (ex * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  83)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  83)										if ((ex > bx1)) {
HXLINE(  83)											if ((ex > cx1)) {
HXLINE(  83)												int min;
HXDLIN(  83)												if ((bx1 > cx1)) {
HXLINE(  83)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  83)													min = ::Math_obj::floor(bx1);
            												}
HXDLIN(  83)												int ii_min = min;
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												xIter3 = this1;
            											}
            											else {
HXLINE(  83)												int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  83)											if ((bx1 > cx1)) {
HXLINE(  83)												int min;
HXDLIN(  83)												if ((ex > cx1)) {
HXLINE(  83)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  83)													min = ::Math_obj::ceil(ex);
            												}
HXDLIN(  83)												int ii_min = min;
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												xIter3 = this1;
            											}
            											else {
HXLINE(  83)												int ii_min = ::Math_obj::floor(ex);
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												xIter3 = this1;
            											}
            										}
HXDLIN(  83)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  83)										if ((ey > by1)) {
HXLINE(  83)											if ((ey > cy1)) {
HXLINE(  83)												int min;
HXDLIN(  83)												if ((by1 > cy1)) {
HXLINE(  83)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  83)													min = ::Math_obj::floor(by1);
            												}
HXDLIN(  83)												int ii_min = min;
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												yIter3 = this1;
            											}
            											else {
HXLINE(  83)												int ii_min = ::Math_obj::floor(by1);
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  83)											if ((by1 > cy1)) {
HXLINE(  83)												int min;
HXDLIN(  83)												if ((ey > cy1)) {
HXLINE(  83)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  83)													min = ::Math_obj::ceil(ey);
            												}
HXDLIN(  83)												int ii_min = min;
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												yIter3 = this1;
            											}
            											else {
HXLINE(  83)												int ii_min = ::Math_obj::floor(ey);
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												yIter3 = this1;
            											}
            										}
HXDLIN(  83)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  83)										if (hasUndo) {
HXLINE(  83)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  83)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  83)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)											undoImage = this3;
HXDLIN(  83)											{
HXLINE(  83)												int rectLeft = xIter3->start;
HXDLIN(  83)												int rectTop = yIter3->start;
HXDLIN(  83)												int rectRight = xIter3->max;
HXDLIN(  83)												bool forceClear = false;
HXDLIN(  83)												{
HXLINE(  83)													int _g = rectTop;
HXDLIN(  83)													int _g1 = yIter3->max;
HXDLIN(  83)													while((_g < _g1)){
HXLINE(  83)														_g = (_g + 1);
HXDLIN(  83)														int dy = (_g - 1);
HXDLIN(  83)														{
HXLINE(  83)															int _g1 = rectLeft;
HXDLIN(  83)															int _g2 = rectRight;
HXDLIN(  83)															while((_g1 < _g2)){
HXLINE(  83)																_g1 = (_g1 + 1);
HXDLIN(  83)																int dx = (_g1 - 1);
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (pixelImage->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            																}
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int col;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	col = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if (pixelImage->useMask) {
HXLINE(  83)																	hitQuad = ::hx::IsNotNull( pixelImage->mask );
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)																	int index;
HXDLIN(  83)																	if (this1->useVirtualPos) {
HXLINE(  83)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  83)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  83)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																	int v;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		v = c;
            																	}
HXDLIN(  83)																	int this3 = v;
HXDLIN(  83)																	int maskPixel = this3;
HXDLIN(  83)																	int this4 = col;
HXDLIN(  83)																	int this5 = this4;
HXDLIN(  83)																	if ((maskPixel == 0)) {
HXLINE(  83)																		int this1 = this5;
HXDLIN(  83)																		col = this1;
            																	}
            																	else {
HXLINE(  83)																		Float m0;
HXDLIN(  83)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																		if ((this1 == 0)) {
HXLINE(  83)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float m1;
HXDLIN(  83)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																		if ((this2 == 0)) {
HXLINE(  83)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float m2;
HXDLIN(  83)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																		if ((this3 == 0)) {
HXLINE(  83)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float m3;
HXDLIN(  83)																		int this4 = (maskPixel & 255);
HXDLIN(  83)																		if ((this4 == 0)) {
HXLINE(  83)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  83)																if ((col != 0)) {
HXLINE(  83)																	int x = (dx - rectLeft);
HXDLIN(  83)																	int y = (dy - rectTop);
HXDLIN(  83)																	int this1 = col;
HXDLIN(  83)																	int c = this1;
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																		hitQuad = undoImage->transparent;
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		int location;
HXDLIN(  83)																		if (undoImage->useVirtualPos) {
HXLINE(  83)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  83)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																		int this3 = this2;
HXDLIN(  83)																		int this4;
HXDLIN(  83)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  83)																			this4 = this3;
            																		}
HXDLIN(  83)																		Float a1;
HXDLIN(  83)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																		if ((this5 == 0)) {
HXLINE(  83)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float r1;
HXDLIN(  83)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																		if ((this6 == 0)) {
HXLINE(  83)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float g1;
HXDLIN(  83)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																		if ((this7 == 0)) {
HXLINE(  83)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float b1;
HXDLIN(  83)																		int this8 = (this4 & 255);
HXDLIN(  83)																		if ((this8 == 0)) {
HXLINE(  83)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float a2;
HXDLIN(  83)																		int this9 = ((col >> 24) & 255);
HXDLIN(  83)																		if ((this9 == 0)) {
HXLINE(  83)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float r2;
HXDLIN(  83)																		int this10 = ((col >> 16) & 255);
HXDLIN(  83)																		if ((this10 == 0)) {
HXLINE(  83)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float g2;
HXDLIN(  83)																		int this11 = ((col >> 8) & 255);
HXDLIN(  83)																		if ((this11 == 0)) {
HXLINE(  83)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float b2;
HXDLIN(  83)																		int this12 = (col & 255);
HXDLIN(  83)																		if ((this12 == 0)) {
HXLINE(  83)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																		{
HXLINE(  83)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  83)																			int value;
HXDLIN(  83)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  83)																				value = blended;
            																			}
HXDLIN(  83)																			bool hitQuad;
HXDLIN(  83)																			if ((location >= 0)) {
HXLINE(  83)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  83)																				hitQuad = false;
            																			}
HXDLIN(  83)																			if (hitQuad) {
HXLINE(  83)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  83)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																		int index;
HXDLIN(  83)																		if (undoImage->useVirtualPos) {
HXLINE(  83)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  83)																		int value;
HXDLIN(  83)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  83)																			value = c;
            																		}
HXDLIN(  83)																		bool hitQuad;
HXDLIN(  83)																		if ((index >= 0)) {
HXLINE(  83)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  83)																			hitQuad = false;
            																		}
HXDLIN(  83)																		if (hitQuad) {
HXLINE(  83)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  83)																	if (forceClear) {
HXLINE(  83)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																		int x = (dx - rectLeft);
HXDLIN(  83)																		int y = (dy - rectTop);
HXDLIN(  83)																		int index;
HXDLIN(  83)																		if (undoImage->useVirtualPos) {
HXLINE(  83)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  83)																		bool hitQuad;
HXDLIN(  83)																		if ((index >= 0)) {
HXLINE(  83)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  83)																			hitQuad = false;
            																		}
HXDLIN(  83)																		if (hitQuad) {
HXLINE(  83)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  83)										bool found = false;
HXDLIN(  83)										Float s = ((Float)0.);
HXDLIN(  83)										Float t = ((Float)0.);
HXDLIN(  83)										Float sxx = ((Float)0.);
HXDLIN(  83)										Float txx = ((Float)0.);
HXDLIN(  83)										{
HXLINE(  83)											int _g_min = xIter3->start;
HXDLIN(  83)											int _g_max = xIter3->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int x = (_g_min - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found = false;
HXLINE(  83)												{
HXLINE(  83)													int _g_min1 = yIter3->start;
HXDLIN(  83)													int _g_max = yIter3->max;
HXDLIN(  83)													while((_g_min1 < _g_max)){
HXLINE(  83)														_g_min1 = (_g_min1 + 1);
HXDLIN(  83)														int y = (_g_min1 - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  83)														bool hitQuad;
HXDLIN(  83)														if (!((s <= 0))) {
HXLINE(  83)															hitQuad = (t <= 0);
            														}
            														else {
HXLINE(  83)															hitQuad = true;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															if (found) {
HXLINE(  83)																goto _hx_goto_50;
            															}
            														}
            														else {
HXLINE(  83)															if (((s + t) < A)) {
HXLINE(  83)																{
HXLINE(  83)																	int this1 = color;
HXDLIN(  83)																	int c = this1;
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																		hitQuad = pixelImage->transparent;
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		int location;
HXDLIN(  83)																		if (pixelImage->useVirtualPos) {
HXLINE(  83)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  83)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																		int this3 = this2;
HXDLIN(  83)																		int this4;
HXDLIN(  83)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  83)																			this4 = this3;
            																		}
HXDLIN(  83)																		Float a1;
HXDLIN(  83)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																		if ((this5 == 0)) {
HXLINE(  83)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float r1;
HXDLIN(  83)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																		if ((this6 == 0)) {
HXLINE(  83)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float g1;
HXDLIN(  83)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																		if ((this7 == 0)) {
HXLINE(  83)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float b1;
HXDLIN(  83)																		int this8 = (this4 & 255);
HXDLIN(  83)																		if ((this8 == 0)) {
HXLINE(  83)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float a2;
HXDLIN(  83)																		int this9 = ((color >> 24) & 255);
HXDLIN(  83)																		if ((this9 == 0)) {
HXLINE(  83)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float r2;
HXDLIN(  83)																		int this10 = ((color >> 16) & 255);
HXDLIN(  83)																		if ((this10 == 0)) {
HXLINE(  83)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float g2;
HXDLIN(  83)																		int this11 = ((color >> 8) & 255);
HXDLIN(  83)																		if ((this11 == 0)) {
HXLINE(  83)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float b2;
HXDLIN(  83)																		int this12 = (color & 255);
HXDLIN(  83)																		if ((this12 == 0)) {
HXLINE(  83)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																		{
HXLINE(  83)																			::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN(  83)																			int value;
HXDLIN(  83)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  83)																				value = blended;
            																			}
HXDLIN(  83)																			bool hitQuad;
HXDLIN(  83)																			if ((location >= 0)) {
HXLINE(  83)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  83)																				hitQuad = false;
            																			}
HXDLIN(  83)																			if (hitQuad) {
HXLINE(  83)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  83)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)																		int index;
HXDLIN(  83)																		if (pixelImage->useVirtualPos) {
HXLINE(  83)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  83)																		int value;
HXDLIN(  83)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  83)																			value = c;
            																		}
HXDLIN(  83)																		bool hitQuad;
HXDLIN(  83)																		if ((index >= 0)) {
HXLINE(  83)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  83)																			hitQuad = false;
            																		}
HXDLIN(  83)																		if (hitQuad) {
HXLINE(  83)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found = true;
            															}
            															else {
HXLINE(  83)																if (found) {
HXLINE(  83)																	goto _hx_goto_50;
            																}
            															}
            														}
            													}
            													_hx_goto_50:;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool hasUndo1 = false;
HXDLIN(  83)								int aA = ((color >> 24) & 255);
HXDLIN(  83)								int rA = ((color >> 16) & 255);
HXDLIN(  83)								int gA = ((color >> 8) & 255);
HXDLIN(  83)								int bA = (color & 255);
HXDLIN(  83)								Float bcx = (bx - cx);
HXDLIN(  83)								Float bcy = (by - cy);
HXDLIN(  83)								Float acx = (ex - cx);
HXDLIN(  83)								Float acy = (ey - cy);
HXDLIN(  83)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  83)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  83)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  83)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  83)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  83)								if ((ex > bx)) {
HXLINE(  83)									if ((ex > cx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((bx > cx)) {
HXLINE(  83)											min = ::Math_obj::floor(cx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((bx > cx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ex > cx)) {
HXLINE(  83)											min = ::Math_obj::floor(cx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  83)								if ((ey > by)) {
HXLINE(  83)									if ((ey > cy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((by > cy)) {
HXLINE(  83)											min = ::Math_obj::floor(cy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((by > cy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ey > cy)) {
HXLINE(  83)											min = ::Math_obj::floor(cy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  83)								if (hasUndo1) {
HXLINE(  83)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  83)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  83)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)									undoImage1 = this3;
HXDLIN(  83)									{
HXLINE(  83)										int rectLeft = xIter31->start;
HXDLIN(  83)										int rectTop = yIter31->start;
HXDLIN(  83)										int rectRight = xIter31->max;
HXDLIN(  83)										bool forceClear = false;
HXDLIN(  83)										{
HXLINE(  83)											int _g = rectTop;
HXDLIN(  83)											int _g1 = yIter31->max;
HXDLIN(  83)											while((_g < _g1)){
HXLINE(  83)												_g = (_g + 1);
HXDLIN(  83)												int dy = (_g - 1);
HXDLIN(  83)												{
HXLINE(  83)													int _g1 = rectLeft;
HXDLIN(  83)													int _g2 = rectRight;
HXDLIN(  83)													while((_g1 < _g2)){
HXLINE(  83)														_g1 = (_g1 + 1);
HXDLIN(  83)														int dx = (_g1 - 1);
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int col;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															col = c;
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->useMask) {
HXLINE(  83)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)															int index;
HXDLIN(  83)															if (this1->useVirtualPos) {
HXLINE(  83)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  83)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  83)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int v;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  83)																v = c;
            															}
HXDLIN(  83)															int this3 = v;
HXDLIN(  83)															int maskPixel = this3;
HXDLIN(  83)															int this4 = col;
HXDLIN(  83)															int this5 = this4;
HXDLIN(  83)															if ((maskPixel == 0)) {
HXLINE(  83)																int this1 = this5;
HXDLIN(  83)																col = this1;
            															}
            															else {
HXLINE(  83)																Float m0;
HXDLIN(  83)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																if ((this1 == 0)) {
HXLINE(  83)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m1;
HXDLIN(  83)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																if ((this2 == 0)) {
HXLINE(  83)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m2;
HXDLIN(  83)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																if ((this3 == 0)) {
HXLINE(  83)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m3;
HXDLIN(  83)																int this4 = (maskPixel & 255);
HXDLIN(  83)																if ((this4 == 0)) {
HXLINE(  83)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  83)														if ((col != 0)) {
HXLINE(  83)															int x = (dx - rectLeft);
HXDLIN(  83)															int y = (dy - rectTop);
HXDLIN(  83)															int this1 = col;
HXDLIN(  83)															int c = this1;
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																int location;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int this3 = this2;
HXDLIN(  83)																int this4;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	this4 = this3;
            																}
HXDLIN(  83)																Float a1;
HXDLIN(  83)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																if ((this5 == 0)) {
HXLINE(  83)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r1;
HXDLIN(  83)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																if ((this6 == 0)) {
HXLINE(  83)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g1;
HXDLIN(  83)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																if ((this7 == 0)) {
HXLINE(  83)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b1;
HXDLIN(  83)																int this8 = (this4 & 255);
HXDLIN(  83)																if ((this8 == 0)) {
HXLINE(  83)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a2;
HXDLIN(  83)																int this9 = ((col >> 24) & 255);
HXDLIN(  83)																if ((this9 == 0)) {
HXLINE(  83)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r2;
HXDLIN(  83)																int this10 = ((col >> 16) & 255);
HXDLIN(  83)																if ((this10 == 0)) {
HXLINE(  83)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g2;
HXDLIN(  83)																int this11 = ((col >> 8) & 255);
HXDLIN(  83)																if ((this11 == 0)) {
HXLINE(  83)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b2;
HXDLIN(  83)																int this12 = (col & 255);
HXDLIN(  83)																if ((this12 == 0)) {
HXLINE(  83)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																{
HXLINE(  83)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  83)																	int value;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		value = blended;
            																	}
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((location >= 0)) {
HXLINE(  83)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															if (forceClear) {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																int x = (dx - rectLeft);
HXDLIN(  83)																int y = (dy - rectTop);
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool found1 = false;
HXDLIN(  83)								{
HXLINE(  83)									int _g_min1 = xIter31->start;
HXDLIN(  83)									int _g_max1 = xIter31->max;
HXDLIN(  83)									while((_g_min1 < _g_max1)){
HXLINE(  83)										_g_min1 = (_g_min1 + 1);
HXDLIN(  83)										int px = (_g_min1 - 1);
HXDLIN(  83)										Float pcx = (( (Float)(px) ) - cx);
HXLINE( 620)										found1 = false;
HXLINE(  83)										{
HXLINE(  83)											int _g_min = yIter31->start;
HXDLIN(  83)											int _g_max = yIter31->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int py = (_g_min - 1);
HXDLIN(  83)												Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  83)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  83)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  83)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  83)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  83)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)												bool hitQuad;
HXDLIN(  83)												bool hitQuad1;
HXDLIN(  83)												if ((ratioA >= 0)) {
HXLINE(  83)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad1 = false;
            												}
HXDLIN(  83)												if (hitQuad1) {
HXLINE(  83)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad = false;
            												}
HXDLIN(  83)												if (hitQuad) {
HXLINE(  83)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (soft * ratioB)));
HXDLIN(  83)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  83)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  83)													int this1 = i;
HXDLIN(  83)													int a = this1;
HXDLIN(  83)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  83)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  83)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  83)													int this2 = i1;
HXDLIN(  83)													int r = this2;
HXDLIN(  83)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  83)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  83)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  83)													int this3 = i2;
HXDLIN(  83)													int g = this3;
HXDLIN(  83)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  83)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  83)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  83)													int this4 = i3;
HXDLIN(  83)													int b = this4;
HXDLIN(  83)													{
HXLINE(  83)														int location;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->transparent) {
HXLINE(  83)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int this3 = this2;
HXDLIN(  83)															int old;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  83)																old = this3;
            															}
HXDLIN(  83)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)															Float a1;
HXDLIN(  83)															int this4 = ((old >> 24) & 255);
HXDLIN(  83)															if ((this4 == 0)) {
HXLINE(  83)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r1;
HXDLIN(  83)															int this5 = ((old >> 16) & 255);
HXDLIN(  83)															if ((this5 == 0)) {
HXLINE(  83)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g1;
HXDLIN(  83)															int this6 = ((old >> 8) & 255);
HXDLIN(  83)															if ((this6 == 0)) {
HXLINE(  83)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b1;
HXDLIN(  83)															int this7 = (old & 255);
HXDLIN(  83)															if ((this7 == 0)) {
HXLINE(  83)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a2;
HXDLIN(  83)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)															if ((this8 == 0)) {
HXLINE(  83)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r2;
HXDLIN(  83)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)															if ((this9 == 0)) {
HXLINE(  83)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g2;
HXDLIN(  83)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)															if ((this10 == 0)) {
HXLINE(  83)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b2;
HXDLIN(  83)															int this11 = (rhs & 255);
HXDLIN(  83)															if ((this11 == 0)) {
HXLINE(  83)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  83)															{
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = blended;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((location >= 0)) {
HXLINE(  83)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (pixelImage->isLittle) {
HXLINE(  83)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  83)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found1 = true;
            												}
            												else {
HXLINE(  83)													if (found1) {
HXLINE(  83)														goto _hx_goto_54;
            													}
            												}
            											}
            											_hx_goto_54:;
            										}
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  83)								int v_undoY;
HXDLIN(  83)								int v_undoX;
HXDLIN(  83)								Float v_ty;
HXDLIN(  83)								Float v_tx;
HXDLIN(  83)								Float v_t0;
HXDLIN(  83)								Float v_sy;
HXDLIN(  83)								Float v_sx;
HXDLIN(  83)								Float v_s0;
HXDLIN(  83)								Float v_A;
HXDLIN(  83)								Float ax1 = ex;
HXDLIN(  83)								Float ay1 = ey;
HXDLIN(  83)								Float bx2 = bx;
HXDLIN(  83)								Float by2 = by;
HXDLIN(  83)								Float cx2 = cx;
HXDLIN(  83)								Float cy2 = cy;
HXDLIN(  83)								::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  83)								bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  83)								if (!(adjustWinding1)) {
HXLINE(  83)									Float bx_ = bx2;
HXDLIN(  83)									Float by_ = by2;
HXLINE(  35)									bx2 = cx2;
HXLINE(  36)									by2 = cy2;
HXLINE(  37)									cx2 = bx_;
HXLINE(  38)									cy2 = by_;
            								}
HXLINE(  83)								Float v_ax = ax1;
HXDLIN(  83)								Float v_ay = ay1;
HXDLIN(  83)								Float v_bx = bx2;
HXDLIN(  83)								Float v_by = by2;
HXDLIN(  83)								Float v_cx = cx2;
HXDLIN(  83)								Float v_cy = cy2;
HXDLIN(  83)								bool v_preCalculated = true;
HXDLIN(  83)								{
HXLINE(  83)									v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  83)									v_sx = (v_cy - v_ay);
HXDLIN(  83)									v_sy = (v_ax - v_cx);
HXDLIN(  83)									v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  83)									v_tx = (v_ay - v_by);
HXDLIN(  83)									v_ty = (v_bx - v_ax);
HXDLIN(  83)									v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  83)									Float a = v_ax;
HXDLIN(  83)									Float b = v_bx;
HXDLIN(  83)									Float c = v_cx;
HXDLIN(  83)									if ((a > b)) {
HXLINE(  83)										if ((a > c)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b > c)) {
HXLINE(  83)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b > c)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a > c)) {
HXLINE(  83)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter3 = this1;
            										}
            									}
HXDLIN(  83)									Float a1 = v_ay;
HXDLIN(  83)									Float b1 = v_by;
HXDLIN(  83)									Float c1 = v_cy;
HXDLIN(  83)									if ((a1 > b1)) {
HXLINE(  83)										if ((a1 > c1)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b1 > c1)) {
HXLINE(  83)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b1);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b1);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b1 > c1)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a1 > c1)) {
HXLINE(  83)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a1);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a1);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter3 = this1;
            										}
            									}
            								}
HXDLIN(  83)								if (hasUndo1) {
HXLINE(  83)									v_undoImage = undoImage1;
HXDLIN(  83)									v_undoX = xIter31->start;
HXDLIN(  83)									v_undoY = yIter31->start;
            								}
HXDLIN(  83)								bool hasUndo2 = false;
HXDLIN(  83)								int aA1 = ((color >> 24) & 255);
HXDLIN(  83)								int rA1 = ((color >> 16) & 255);
HXDLIN(  83)								int gA1 = ((color >> 8) & 255);
HXDLIN(  83)								int bA1 = (color & 255);
HXDLIN(  83)								Float bcx1 = (cx - dx);
HXDLIN(  83)								Float bcy1 = (cy - dy);
HXDLIN(  83)								Float acx1 = (ex - dx);
HXDLIN(  83)								Float acy1 = (ey - dy);
HXDLIN(  83)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  83)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  83)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  83)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  83)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  83)								if ((ex > cx)) {
HXLINE(  83)									if ((ex > dx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((cx > dx)) {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter32 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((cx > dx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ex > dx)) {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter32 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter32 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  83)								if ((ey > cy)) {
HXLINE(  83)									if ((ey > dy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((cy > dy)) {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter32 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((cy > dy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ey > dy)) {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter32 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter32 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  83)								if (hasUndo2) {
HXLINE(  83)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  83)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  83)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)									undoImage2 = this3;
HXDLIN(  83)									{
HXLINE(  83)										int rectLeft = xIter32->start;
HXDLIN(  83)										int rectTop = yIter32->start;
HXDLIN(  83)										int rectRight = xIter32->max;
HXDLIN(  83)										bool forceClear = false;
HXDLIN(  83)										{
HXLINE(  83)											int _g = rectTop;
HXDLIN(  83)											int _g1 = yIter32->max;
HXDLIN(  83)											while((_g < _g1)){
HXLINE(  83)												_g = (_g + 1);
HXDLIN(  83)												int dy = (_g - 1);
HXDLIN(  83)												{
HXLINE(  83)													int _g1 = rectLeft;
HXDLIN(  83)													int _g2 = rectRight;
HXDLIN(  83)													while((_g1 < _g2)){
HXLINE(  83)														_g1 = (_g1 + 1);
HXDLIN(  83)														int dx = (_g1 - 1);
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int col;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															col = c;
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->useMask) {
HXLINE(  83)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)															int index;
HXDLIN(  83)															if (this1->useVirtualPos) {
HXLINE(  83)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  83)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  83)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int v;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  83)																v = c;
            															}
HXDLIN(  83)															int this3 = v;
HXDLIN(  83)															int maskPixel = this3;
HXDLIN(  83)															int this4 = col;
HXDLIN(  83)															int this5 = this4;
HXDLIN(  83)															if ((maskPixel == 0)) {
HXLINE(  83)																int this1 = this5;
HXDLIN(  83)																col = this1;
            															}
            															else {
HXLINE(  83)																Float m0;
HXDLIN(  83)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																if ((this1 == 0)) {
HXLINE(  83)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m1;
HXDLIN(  83)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																if ((this2 == 0)) {
HXLINE(  83)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m2;
HXDLIN(  83)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																if ((this3 == 0)) {
HXLINE(  83)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m3;
HXDLIN(  83)																int this4 = (maskPixel & 255);
HXDLIN(  83)																if ((this4 == 0)) {
HXLINE(  83)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  83)														if ((col != 0)) {
HXLINE(  83)															int x = (dx - rectLeft);
HXDLIN(  83)															int y = (dy - rectTop);
HXDLIN(  83)															int this1 = col;
HXDLIN(  83)															int c = this1;
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																hitQuad = undoImage2->transparent;
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																int location;
HXDLIN(  83)																if (undoImage2->useVirtualPos) {
HXLINE(  83)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  83)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int this3 = this2;
HXDLIN(  83)																int this4;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	this4 = this3;
            																}
HXDLIN(  83)																Float a1;
HXDLIN(  83)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																if ((this5 == 0)) {
HXLINE(  83)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r1;
HXDLIN(  83)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																if ((this6 == 0)) {
HXLINE(  83)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g1;
HXDLIN(  83)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																if ((this7 == 0)) {
HXLINE(  83)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b1;
HXDLIN(  83)																int this8 = (this4 & 255);
HXDLIN(  83)																if ((this8 == 0)) {
HXLINE(  83)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a2;
HXDLIN(  83)																int this9 = ((col >> 24) & 255);
HXDLIN(  83)																if ((this9 == 0)) {
HXLINE(  83)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r2;
HXDLIN(  83)																int this10 = ((col >> 16) & 255);
HXDLIN(  83)																if ((this10 == 0)) {
HXLINE(  83)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g2;
HXDLIN(  83)																int this11 = ((col >> 8) & 255);
HXDLIN(  83)																if ((this11 == 0)) {
HXLINE(  83)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b2;
HXDLIN(  83)																int this12 = (col & 255);
HXDLIN(  83)																if ((this12 == 0)) {
HXLINE(  83)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																{
HXLINE(  83)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  83)																	int value;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		value = blended;
            																	}
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((location >= 0)) {
HXLINE(  83)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage2->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															if (forceClear) {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  83)																int x = (dx - rectLeft);
HXDLIN(  83)																int y = (dy - rectTop);
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage2->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool found2 = false;
HXDLIN(  83)								{
HXLINE(  83)									int _g_min2 = xIter32->start;
HXDLIN(  83)									int _g_max2 = xIter32->max;
HXDLIN(  83)									while((_g_min2 < _g_max2)){
HXLINE(  83)										_g_min2 = (_g_min2 + 1);
HXDLIN(  83)										int px = (_g_min2 - 1);
HXDLIN(  83)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 620)										found2 = false;
HXLINE(  83)										{
HXLINE(  83)											int _g_min = yIter32->start;
HXDLIN(  83)											int _g_max = yIter32->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int py = (_g_min - 1);
HXDLIN(  83)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  83)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  83)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  83)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  83)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  83)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)												bool hitQuad;
HXDLIN(  83)												bool hitQuad1;
HXDLIN(  83)												if ((ratioA >= 0)) {
HXLINE(  83)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad1 = false;
            												}
HXDLIN(  83)												if (hitQuad1) {
HXLINE(  83)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad = false;
            												}
HXDLIN(  83)												if (hitQuad) {
HXLINE(  83)													int i = ::Std_obj::_hx_int((( (Float)(aA1) ) * (soft * ratioB)));
HXDLIN(  83)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  83)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  83)													int this1 = i;
HXDLIN(  83)													int a = this1;
HXDLIN(  83)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  83)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  83)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  83)													int this2 = i1;
HXDLIN(  83)													int r = this2;
HXDLIN(  83)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  83)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  83)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  83)													int this3 = i2;
HXDLIN(  83)													int g = this3;
HXDLIN(  83)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  83)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  83)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  83)													int this4 = i3;
HXDLIN(  83)													int b = this4;
HXDLIN(  83)													{
HXLINE(  83)														int location;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->transparent) {
HXLINE(  83)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int this3 = this2;
HXDLIN(  83)															int old;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  83)																old = this3;
            															}
HXDLIN(  83)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)															Float a1;
HXDLIN(  83)															int this4 = ((old >> 24) & 255);
HXDLIN(  83)															if ((this4 == 0)) {
HXLINE(  83)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r1;
HXDLIN(  83)															int this5 = ((old >> 16) & 255);
HXDLIN(  83)															if ((this5 == 0)) {
HXLINE(  83)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g1;
HXDLIN(  83)															int this6 = ((old >> 8) & 255);
HXDLIN(  83)															if ((this6 == 0)) {
HXLINE(  83)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b1;
HXDLIN(  83)															int this7 = (old & 255);
HXDLIN(  83)															if ((this7 == 0)) {
HXLINE(  83)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a2;
HXDLIN(  83)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)															if ((this8 == 0)) {
HXLINE(  83)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r2;
HXDLIN(  83)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)															if ((this9 == 0)) {
HXLINE(  83)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g2;
HXDLIN(  83)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)															if ((this10 == 0)) {
HXLINE(  83)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b2;
HXDLIN(  83)															int this11 = (rhs & 255);
HXDLIN(  83)															if ((this11 == 0)) {
HXLINE(  83)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  83)															{
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = blended;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((location >= 0)) {
HXLINE(  83)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (pixelImage->isLittle) {
HXLINE(  83)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  83)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found2 = true;
            												}
            												else {
HXLINE(  83)													if (found2) {
HXLINE(  83)														goto _hx_goto_58;
            													}
            												}
            											}
            											_hx_goto_58:;
            										}
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  83)								int v_undoY1;
HXDLIN(  83)								int v_undoX1;
HXDLIN(  83)								Float v_ty1;
HXDLIN(  83)								Float v_tx1;
HXDLIN(  83)								Float v_t01;
HXDLIN(  83)								Float v_sy1;
HXDLIN(  83)								Float v_sx1;
HXDLIN(  83)								Float v_s01;
HXDLIN(  83)								Float v_A1;
HXDLIN(  83)								Float ax2 = ex;
HXDLIN(  83)								Float ay2 = ey;
HXDLIN(  83)								Float bx3 = cx;
HXDLIN(  83)								Float by3 = cy;
HXDLIN(  83)								Float cx3 = dx;
HXDLIN(  83)								Float cy3 = dy;
HXDLIN(  83)								::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  83)								bool adjustWinding2 = (((((ax2 * by3) - (bx3 * ay2)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay2) - (ax2 * cy3))) > 0);
HXDLIN(  83)								if (!(adjustWinding2)) {
HXLINE(  83)									Float bx_ = bx3;
HXDLIN(  83)									Float by_ = by3;
HXLINE(  35)									bx3 = cx3;
HXLINE(  36)									by3 = cy3;
HXLINE(  37)									cx3 = bx_;
HXLINE(  38)									cy3 = by_;
            								}
HXLINE(  83)								Float v_ax1 = ax2;
HXDLIN(  83)								Float v_ay1 = ay2;
HXDLIN(  83)								Float v_bx1 = bx3;
HXDLIN(  83)								Float v_by1 = by3;
HXDLIN(  83)								Float v_cx1 = cx3;
HXDLIN(  83)								Float v_cy1 = cy3;
HXDLIN(  83)								bool v_preCalculated1 = true;
HXDLIN(  83)								{
HXLINE(  83)									v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  83)									v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  83)									v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  83)									v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  83)									v_tx1 = (v_ay1 - v_by1);
HXDLIN(  83)									v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  83)									v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  83)									Float a2 = v_ax1;
HXDLIN(  83)									Float b2 = v_bx1;
HXDLIN(  83)									Float c2 = v_cx1;
HXDLIN(  83)									if ((a2 > b2)) {
HXLINE(  83)										if ((a2 > c2)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b2 > c2)) {
HXLINE(  83)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b2);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b2);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter31 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b2 > c2)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a2 > c2)) {
HXLINE(  83)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a2);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a2);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter31 = this1;
            										}
            									}
HXDLIN(  83)									Float a3 = v_ay1;
HXDLIN(  83)									Float b3 = v_by1;
HXDLIN(  83)									Float c3 = v_cy1;
HXDLIN(  83)									if ((a3 > b3)) {
HXLINE(  83)										if ((a3 > c3)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b3 > c3)) {
HXLINE(  83)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b3);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b3);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter31 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b3 > c3)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a3 > c3)) {
HXLINE(  83)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a3);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a3);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter31 = this1;
            										}
            									}
            								}
HXDLIN(  83)								if (hasUndo2) {
HXLINE(  83)									v_undoImage1 = undoImage2;
HXDLIN(  83)									v_undoX1 = xIter32->start;
HXDLIN(  83)									v_undoY1 = yIter32->start;
            								}
HXDLIN(  83)								bool hasUndo3 = false;
HXDLIN(  83)								int aA2 = ((color >> 24) & 255);
HXDLIN(  83)								int rA2 = ((color >> 16) & 255);
HXDLIN(  83)								int gA2 = ((color >> 8) & 255);
HXDLIN(  83)								int bA2 = (color & 255);
HXDLIN(  83)								Float bcx2 = (dx - ax);
HXDLIN(  83)								Float bcy2 = (dy - ay);
HXDLIN(  83)								Float acx2 = (ex - ax);
HXDLIN(  83)								Float acy2 = (ey - ay);
HXDLIN(  83)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  83)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  83)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  83)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  83)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  83)								if ((ex > dx)) {
HXLINE(  83)									if ((ex > ax)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((dx > ax)) {
HXLINE(  83)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter33 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(dx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((dx > ax)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ex > ax)) {
HXLINE(  83)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter33 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter33 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  83)								if ((ey > dy)) {
HXLINE(  83)									if ((ey > ay)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((dy > ay)) {
HXLINE(  83)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter33 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(dy);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((dy > ay)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ey > ay)) {
HXLINE(  83)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter33 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter33 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  83)								if (hasUndo3) {
HXLINE(  83)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  83)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  83)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)									undoImage3 = this3;
HXDLIN(  83)									{
HXLINE(  83)										int rectLeft = xIter33->start;
HXDLIN(  83)										int rectTop = yIter33->start;
HXDLIN(  83)										int rectRight = xIter33->max;
HXDLIN(  83)										bool forceClear = false;
HXDLIN(  83)										{
HXLINE(  83)											int _g = rectTop;
HXDLIN(  83)											int _g1 = yIter33->max;
HXDLIN(  83)											while((_g < _g1)){
HXLINE(  83)												_g = (_g + 1);
HXDLIN(  83)												int dy = (_g - 1);
HXDLIN(  83)												{
HXLINE(  83)													int _g1 = rectLeft;
HXDLIN(  83)													int _g2 = rectRight;
HXDLIN(  83)													while((_g1 < _g2)){
HXLINE(  83)														_g1 = (_g1 + 1);
HXDLIN(  83)														int dx = (_g1 - 1);
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int col;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															col = c;
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->useMask) {
HXLINE(  83)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)															int index;
HXDLIN(  83)															if (this1->useVirtualPos) {
HXLINE(  83)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  83)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  83)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int v;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  83)																v = c;
            															}
HXDLIN(  83)															int this3 = v;
HXDLIN(  83)															int maskPixel = this3;
HXDLIN(  83)															int this4 = col;
HXDLIN(  83)															int this5 = this4;
HXDLIN(  83)															if ((maskPixel == 0)) {
HXLINE(  83)																int this1 = this5;
HXDLIN(  83)																col = this1;
            															}
            															else {
HXLINE(  83)																Float m0;
HXDLIN(  83)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																if ((this1 == 0)) {
HXLINE(  83)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m1;
HXDLIN(  83)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																if ((this2 == 0)) {
HXLINE(  83)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m2;
HXDLIN(  83)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																if ((this3 == 0)) {
HXLINE(  83)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m3;
HXDLIN(  83)																int this4 = (maskPixel & 255);
HXDLIN(  83)																if ((this4 == 0)) {
HXLINE(  83)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  83)														if ((col != 0)) {
HXLINE(  83)															int x = (dx - rectLeft);
HXDLIN(  83)															int y = (dy - rectTop);
HXDLIN(  83)															int this1 = col;
HXDLIN(  83)															int c = this1;
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																hitQuad = undoImage3->transparent;
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																int location;
HXDLIN(  83)																if (undoImage3->useVirtualPos) {
HXLINE(  83)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  83)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int this3 = this2;
HXDLIN(  83)																int this4;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	this4 = this3;
            																}
HXDLIN(  83)																Float a1;
HXDLIN(  83)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																if ((this5 == 0)) {
HXLINE(  83)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r1;
HXDLIN(  83)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																if ((this6 == 0)) {
HXLINE(  83)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g1;
HXDLIN(  83)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																if ((this7 == 0)) {
HXLINE(  83)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b1;
HXDLIN(  83)																int this8 = (this4 & 255);
HXDLIN(  83)																if ((this8 == 0)) {
HXLINE(  83)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a2;
HXDLIN(  83)																int this9 = ((col >> 24) & 255);
HXDLIN(  83)																if ((this9 == 0)) {
HXLINE(  83)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r2;
HXDLIN(  83)																int this10 = ((col >> 16) & 255);
HXDLIN(  83)																if ((this10 == 0)) {
HXLINE(  83)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g2;
HXDLIN(  83)																int this11 = ((col >> 8) & 255);
HXDLIN(  83)																if ((this11 == 0)) {
HXLINE(  83)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b2;
HXDLIN(  83)																int this12 = (col & 255);
HXDLIN(  83)																if ((this12 == 0)) {
HXLINE(  83)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																{
HXLINE(  83)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  83)																	int value;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		value = blended;
            																	}
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((location >= 0)) {
HXLINE(  83)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage3->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															if (forceClear) {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  83)																int x = (dx - rectLeft);
HXDLIN(  83)																int y = (dy - rectTop);
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage3->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool found3 = false;
HXDLIN(  83)								{
HXLINE(  83)									int _g_min3 = xIter33->start;
HXDLIN(  83)									int _g_max3 = xIter33->max;
HXDLIN(  83)									while((_g_min3 < _g_max3)){
HXLINE(  83)										_g_min3 = (_g_min3 + 1);
HXDLIN(  83)										int px = (_g_min3 - 1);
HXDLIN(  83)										Float pcx = (( (Float)(px) ) - ax);
HXLINE( 620)										found3 = false;
HXLINE(  83)										{
HXLINE(  83)											int _g_min = yIter33->start;
HXDLIN(  83)											int _g_max = yIter33->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int py = (_g_min - 1);
HXDLIN(  83)												Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  83)												Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  83)												Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  83)												Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  83)												Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  83)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)												bool hitQuad;
HXDLIN(  83)												bool hitQuad1;
HXDLIN(  83)												if ((ratioA >= 0)) {
HXLINE(  83)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad1 = false;
            												}
HXDLIN(  83)												if (hitQuad1) {
HXLINE(  83)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad = false;
            												}
HXDLIN(  83)												if (hitQuad) {
HXLINE(  83)													int i = ::Std_obj::_hx_int((( (Float)(aA2) ) * (soft * ratioB)));
HXDLIN(  83)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  83)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  83)													int this1 = i;
HXDLIN(  83)													int a = this1;
HXDLIN(  83)													int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  83)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  83)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  83)													int this2 = i1;
HXDLIN(  83)													int r = this2;
HXDLIN(  83)													int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  83)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  83)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  83)													int this3 = i2;
HXDLIN(  83)													int g = this3;
HXDLIN(  83)													int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  83)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  83)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  83)													int this4 = i3;
HXDLIN(  83)													int b = this4;
HXDLIN(  83)													{
HXLINE(  83)														int location;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->transparent) {
HXLINE(  83)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int this3 = this2;
HXDLIN(  83)															int old;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  83)																old = this3;
            															}
HXDLIN(  83)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)															Float a1;
HXDLIN(  83)															int this4 = ((old >> 24) & 255);
HXDLIN(  83)															if ((this4 == 0)) {
HXLINE(  83)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r1;
HXDLIN(  83)															int this5 = ((old >> 16) & 255);
HXDLIN(  83)															if ((this5 == 0)) {
HXLINE(  83)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g1;
HXDLIN(  83)															int this6 = ((old >> 8) & 255);
HXDLIN(  83)															if ((this6 == 0)) {
HXLINE(  83)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b1;
HXDLIN(  83)															int this7 = (old & 255);
HXDLIN(  83)															if ((this7 == 0)) {
HXLINE(  83)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a2;
HXDLIN(  83)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)															if ((this8 == 0)) {
HXLINE(  83)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r2;
HXDLIN(  83)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)															if ((this9 == 0)) {
HXLINE(  83)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g2;
HXDLIN(  83)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)															if ((this10 == 0)) {
HXLINE(  83)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b2;
HXDLIN(  83)															int this11 = (rhs & 255);
HXDLIN(  83)															if ((this11 == 0)) {
HXLINE(  83)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  83)															{
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = blended;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((location >= 0)) {
HXLINE(  83)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (pixelImage->isLittle) {
HXLINE(  83)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  83)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found3 = true;
            												}
            												else {
HXLINE(  83)													if (found3) {
HXLINE(  83)														goto _hx_goto_62;
            													}
            												}
            											}
            											_hx_goto_62:;
            										}
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_yIter32;
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_xIter32;
HXDLIN(  83)								int v_undoY2;
HXDLIN(  83)								int v_undoX2;
HXDLIN(  83)								Float v_ty2;
HXDLIN(  83)								Float v_tx2;
HXDLIN(  83)								Float v_t02;
HXDLIN(  83)								Float v_sy2;
HXDLIN(  83)								Float v_sx2;
HXDLIN(  83)								Float v_s02;
HXDLIN(  83)								Float v_A2;
HXDLIN(  83)								Float ax3 = ex;
HXDLIN(  83)								Float ay3 = ey;
HXDLIN(  83)								Float bx4 = dx;
HXDLIN(  83)								Float by4 = dy;
HXDLIN(  83)								Float cx4 = ax;
HXDLIN(  83)								Float cy4 = ay;
HXDLIN(  83)								::pixelimage::ImageStruct v_undoImage2 = null();
HXDLIN(  83)								bool adjustWinding3 = (((((ax3 * by4) - (bx4 * ay3)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay3) - (ax3 * cy4))) > 0);
HXDLIN(  83)								if (!(adjustWinding3)) {
HXLINE(  83)									Float bx_ = bx4;
HXDLIN(  83)									Float by_ = by4;
HXLINE(  35)									bx4 = cx4;
HXLINE(  36)									by4 = cy4;
HXLINE(  37)									cx4 = bx_;
HXLINE(  38)									cy4 = by_;
            								}
HXLINE(  83)								Float v_ax2 = ax3;
HXDLIN(  83)								Float v_ay2 = ay3;
HXDLIN(  83)								Float v_bx2 = bx4;
HXDLIN(  83)								Float v_by2 = by4;
HXDLIN(  83)								Float v_cx2 = cx4;
HXDLIN(  83)								Float v_cy2 = cy4;
HXDLIN(  83)								bool v_preCalculated2 = true;
HXDLIN(  83)								{
HXLINE(  83)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  83)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  83)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  83)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  83)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  83)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  83)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  83)									Float a4 = v_ax2;
HXDLIN(  83)									Float b4 = v_bx2;
HXDLIN(  83)									Float c4 = v_cx2;
HXDLIN(  83)									if ((a4 > b4)) {
HXLINE(  83)										if ((a4 > c4)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b4 > c4)) {
HXLINE(  83)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b4);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a4);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b4);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter32 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b4 > c4)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a4 > c4)) {
HXLINE(  83)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a4);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b4);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a4);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter32 = this1;
            										}
            									}
HXDLIN(  83)									Float a5 = v_ay2;
HXDLIN(  83)									Float b5 = v_by2;
HXDLIN(  83)									Float c5 = v_cy2;
HXDLIN(  83)									if ((a5 > b5)) {
HXLINE(  83)										if ((a5 > c5)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b5 > c5)) {
HXLINE(  83)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b5);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a5);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b5);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter32 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b5 > c5)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a5 > c5)) {
HXLINE(  83)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a5);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b5);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a5);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter32 = this1;
            										}
            									}
            								}
HXDLIN(  83)								if (hasUndo3) {
HXLINE(  83)									v_undoImage2 = undoImage3;
HXDLIN(  83)									v_undoX2 = xIter33->start;
HXDLIN(  83)									v_undoY2 = yIter33->start;
            								}
HXDLIN(  83)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  83)								hitQuad = v;
            							}
            							else {
HXLINE(  83)								Float sin = ::Math_obj::sin(theta);
HXDLIN(  83)								Float cos = ::Math_obj::cos(theta);
HXDLIN(  83)								Float radius1 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  83)								Float radius2 = (thick / ( (Float)(2) ));
HXDLIN(  83)								Float dx = ((Float)0.1);
HXDLIN(  83)								Float dy = radius1;
HXDLIN(  83)								Float cx = h2;
HXDLIN(  83)								Float cy = radius2;
HXDLIN(  83)								Float bx = h2;
HXDLIN(  83)								Float by = -(radius2);
HXDLIN(  83)								Float ax = ((Float)0.1);
HXDLIN(  83)								Float ay = -(radius1);
HXDLIN(  83)								Float temp = ((Float)0.);
HXLINE( 288)								temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)								ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)								ax = temp;
HXLINE( 292)								temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)								by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)								bx = temp;
HXLINE( 296)								temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)								cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)								cx = temp;
HXLINE( 300)								temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)								dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)								dx = temp;
HXLINE(  83)								Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN(  83)								Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN(  83)								{
HXLINE(  83)									Float bx1 = ax;
HXDLIN(  83)									Float by1 = ay;
HXDLIN(  83)									Float cx1 = bx;
HXDLIN(  83)									Float cy1 = by;
HXDLIN(  83)									bool hasUndo = false;
HXDLIN(  83)									bool adjustWinding = (((((ex * by1) - (bx1 * ey)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ey) - (ex * cy1))) > 0);
HXDLIN(  83)									if (!(adjustWinding)) {
HXLINE(  83)										Float bx_ = bx1;
HXDLIN(  83)										Float by_ = by1;
HXLINE(  26)										bx1 = cx1;
HXLINE(  27)										by1 = cy1;
HXLINE(  28)										cx1 = bx_;
HXLINE(  29)										cy1 = by_;
            									}
HXLINE(  83)									{
HXLINE(  83)										Float s0 = ((ey * cx1) - (ex * cy1));
HXDLIN(  83)										Float sx = (cy1 - ey);
HXDLIN(  83)										Float sy = (ex - cx1);
HXDLIN(  83)										Float t0 = ((ex * by1) - (ey * bx1));
HXDLIN(  83)										Float tx = (ey - by1);
HXDLIN(  83)										Float ty = (bx1 - ex);
HXDLIN(  83)										Float A = ((((-(by1) * cx1) + (ey * (-(bx1) + cx1))) + (ex * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  83)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  83)										if ((ex > bx1)) {
HXLINE(  83)											if ((ex > cx1)) {
HXLINE(  83)												int min;
HXDLIN(  83)												if ((bx1 > cx1)) {
HXLINE(  83)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  83)													min = ::Math_obj::floor(bx1);
            												}
HXDLIN(  83)												int ii_min = min;
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												xIter3 = this1;
            											}
            											else {
HXLINE(  83)												int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  83)											if ((bx1 > cx1)) {
HXLINE(  83)												int min;
HXDLIN(  83)												if ((ex > cx1)) {
HXLINE(  83)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  83)													min = ::Math_obj::ceil(ex);
            												}
HXDLIN(  83)												int ii_min = min;
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												xIter3 = this1;
            											}
            											else {
HXLINE(  83)												int ii_min = ::Math_obj::floor(ex);
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												xIter3 = this1;
            											}
            										}
HXDLIN(  83)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  83)										if ((ey > by1)) {
HXLINE(  83)											if ((ey > cy1)) {
HXLINE(  83)												int min;
HXDLIN(  83)												if ((by1 > cy1)) {
HXLINE(  83)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  83)													min = ::Math_obj::floor(by1);
            												}
HXDLIN(  83)												int ii_min = min;
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												yIter3 = this1;
            											}
            											else {
HXLINE(  83)												int ii_min = ::Math_obj::floor(by1);
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  83)											if ((by1 > cy1)) {
HXLINE(  83)												int min;
HXDLIN(  83)												if ((ey > cy1)) {
HXLINE(  83)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  83)													min = ::Math_obj::ceil(ey);
            												}
HXDLIN(  83)												int ii_min = min;
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												yIter3 = this1;
            											}
            											else {
HXLINE(  83)												int ii_min = ::Math_obj::floor(ey);
HXDLIN(  83)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  83)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)												yIter3 = this1;
            											}
            										}
HXDLIN(  83)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  83)										if (hasUndo) {
HXLINE(  83)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  83)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  83)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)											undoImage = this3;
HXDLIN(  83)											{
HXLINE(  83)												int rectLeft = xIter3->start;
HXDLIN(  83)												int rectTop = yIter3->start;
HXDLIN(  83)												int rectRight = xIter3->max;
HXDLIN(  83)												bool forceClear = false;
HXDLIN(  83)												{
HXLINE(  83)													int _g = rectTop;
HXDLIN(  83)													int _g1 = yIter3->max;
HXDLIN(  83)													while((_g < _g1)){
HXLINE(  83)														_g = (_g + 1);
HXDLIN(  83)														int dy = (_g - 1);
HXDLIN(  83)														{
HXLINE(  83)															int _g1 = rectLeft;
HXDLIN(  83)															int _g2 = rectRight;
HXDLIN(  83)															while((_g1 < _g2)){
HXLINE(  83)																_g1 = (_g1 + 1);
HXDLIN(  83)																int dx = (_g1 - 1);
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (pixelImage->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            																}
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int col;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	col = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if (pixelImage->useMask) {
HXLINE(  83)																	hitQuad = ::hx::IsNotNull( pixelImage->mask );
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)																	int index;
HXDLIN(  83)																	if (this1->useVirtualPos) {
HXLINE(  83)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  83)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  83)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																	int v;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		v = c;
            																	}
HXDLIN(  83)																	int this3 = v;
HXDLIN(  83)																	int maskPixel = this3;
HXDLIN(  83)																	int this4 = col;
HXDLIN(  83)																	int this5 = this4;
HXDLIN(  83)																	if ((maskPixel == 0)) {
HXLINE(  83)																		int this1 = this5;
HXDLIN(  83)																		col = this1;
            																	}
            																	else {
HXLINE(  83)																		Float m0;
HXDLIN(  83)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																		if ((this1 == 0)) {
HXLINE(  83)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float m1;
HXDLIN(  83)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																		if ((this2 == 0)) {
HXLINE(  83)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float m2;
HXDLIN(  83)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																		if ((this3 == 0)) {
HXLINE(  83)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float m3;
HXDLIN(  83)																		int this4 = (maskPixel & 255);
HXDLIN(  83)																		if ((this4 == 0)) {
HXLINE(  83)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  83)																if ((col != 0)) {
HXLINE(  83)																	int x = (dx - rectLeft);
HXDLIN(  83)																	int y = (dy - rectTop);
HXDLIN(  83)																	int this1 = col;
HXDLIN(  83)																	int c = this1;
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																		hitQuad = undoImage->transparent;
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		int location;
HXDLIN(  83)																		if (undoImage->useVirtualPos) {
HXLINE(  83)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  83)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																		int this3 = this2;
HXDLIN(  83)																		int this4;
HXDLIN(  83)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  83)																			this4 = this3;
            																		}
HXDLIN(  83)																		Float a1;
HXDLIN(  83)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																		if ((this5 == 0)) {
HXLINE(  83)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float r1;
HXDLIN(  83)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																		if ((this6 == 0)) {
HXLINE(  83)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float g1;
HXDLIN(  83)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																		if ((this7 == 0)) {
HXLINE(  83)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float b1;
HXDLIN(  83)																		int this8 = (this4 & 255);
HXDLIN(  83)																		if ((this8 == 0)) {
HXLINE(  83)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float a2;
HXDLIN(  83)																		int this9 = ((col >> 24) & 255);
HXDLIN(  83)																		if ((this9 == 0)) {
HXLINE(  83)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float r2;
HXDLIN(  83)																		int this10 = ((col >> 16) & 255);
HXDLIN(  83)																		if ((this10 == 0)) {
HXLINE(  83)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float g2;
HXDLIN(  83)																		int this11 = ((col >> 8) & 255);
HXDLIN(  83)																		if ((this11 == 0)) {
HXLINE(  83)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float b2;
HXDLIN(  83)																		int this12 = (col & 255);
HXDLIN(  83)																		if ((this12 == 0)) {
HXLINE(  83)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																		{
HXLINE(  83)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  83)																			int value;
HXDLIN(  83)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  83)																				value = blended;
            																			}
HXDLIN(  83)																			bool hitQuad;
HXDLIN(  83)																			if ((location >= 0)) {
HXLINE(  83)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  83)																				hitQuad = false;
            																			}
HXDLIN(  83)																			if (hitQuad) {
HXLINE(  83)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  83)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																		int index;
HXDLIN(  83)																		if (undoImage->useVirtualPos) {
HXLINE(  83)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  83)																		int value;
HXDLIN(  83)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  83)																			value = c;
            																		}
HXDLIN(  83)																		bool hitQuad;
HXDLIN(  83)																		if ((index >= 0)) {
HXLINE(  83)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  83)																			hitQuad = false;
            																		}
HXDLIN(  83)																		if (hitQuad) {
HXLINE(  83)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  83)																	if (forceClear) {
HXLINE(  83)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																		int x = (dx - rectLeft);
HXDLIN(  83)																		int y = (dy - rectTop);
HXDLIN(  83)																		int index;
HXDLIN(  83)																		if (undoImage->useVirtualPos) {
HXLINE(  83)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  83)																		bool hitQuad;
HXDLIN(  83)																		if ((index >= 0)) {
HXLINE(  83)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  83)																			hitQuad = false;
            																		}
HXDLIN(  83)																		if (hitQuad) {
HXLINE(  83)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  83)										bool found = false;
HXDLIN(  83)										Float s = ((Float)0.);
HXDLIN(  83)										Float t = ((Float)0.);
HXDLIN(  83)										Float sxx = ((Float)0.);
HXDLIN(  83)										Float txx = ((Float)0.);
HXDLIN(  83)										{
HXLINE(  83)											int _g_min = xIter3->start;
HXDLIN(  83)											int _g_max = xIter3->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int x = (_g_min - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found = false;
HXLINE(  83)												{
HXLINE(  83)													int _g_min1 = yIter3->start;
HXDLIN(  83)													int _g_max = yIter3->max;
HXDLIN(  83)													while((_g_min1 < _g_max)){
HXLINE(  83)														_g_min1 = (_g_min1 + 1);
HXDLIN(  83)														int y = (_g_min1 - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  83)														bool hitQuad;
HXDLIN(  83)														if (!((s <= 0))) {
HXLINE(  83)															hitQuad = (t <= 0);
            														}
            														else {
HXLINE(  83)															hitQuad = true;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															if (found) {
HXLINE(  83)																goto _hx_goto_66;
            															}
            														}
            														else {
HXLINE(  83)															if (((s + t) < A)) {
HXLINE(  83)																{
HXLINE(  83)																	int this1 = color;
HXDLIN(  83)																	int c = this1;
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																		hitQuad = pixelImage->transparent;
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		int location;
HXDLIN(  83)																		if (pixelImage->useVirtualPos) {
HXLINE(  83)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  83)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																		int this3 = this2;
HXDLIN(  83)																		int this4;
HXDLIN(  83)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  83)																			this4 = this3;
            																		}
HXDLIN(  83)																		Float a1;
HXDLIN(  83)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																		if ((this5 == 0)) {
HXLINE(  83)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float r1;
HXDLIN(  83)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																		if ((this6 == 0)) {
HXLINE(  83)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float g1;
HXDLIN(  83)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																		if ((this7 == 0)) {
HXLINE(  83)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float b1;
HXDLIN(  83)																		int this8 = (this4 & 255);
HXDLIN(  83)																		if ((this8 == 0)) {
HXLINE(  83)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float a2;
HXDLIN(  83)																		int this9 = ((color >> 24) & 255);
HXDLIN(  83)																		if ((this9 == 0)) {
HXLINE(  83)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float r2;
HXDLIN(  83)																		int this10 = ((color >> 16) & 255);
HXDLIN(  83)																		if ((this10 == 0)) {
HXLINE(  83)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float g2;
HXDLIN(  83)																		int this11 = ((color >> 8) & 255);
HXDLIN(  83)																		if ((this11 == 0)) {
HXLINE(  83)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float b2;
HXDLIN(  83)																		int this12 = (color & 255);
HXDLIN(  83)																		if ((this12 == 0)) {
HXLINE(  83)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  83)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  83)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																		{
HXLINE(  83)																			::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN(  83)																			int value;
HXDLIN(  83)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  83)																				value = blended;
            																			}
HXDLIN(  83)																			bool hitQuad;
HXDLIN(  83)																			if ((location >= 0)) {
HXLINE(  83)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  83)																				hitQuad = false;
            																			}
HXDLIN(  83)																			if (hitQuad) {
HXLINE(  83)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  83)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)																		int index;
HXDLIN(  83)																		if (pixelImage->useVirtualPos) {
HXLINE(  83)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  83)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  83)																		int value;
HXDLIN(  83)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  83)																			value = c;
            																		}
HXDLIN(  83)																		bool hitQuad;
HXDLIN(  83)																		if ((index >= 0)) {
HXLINE(  83)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  83)																			hitQuad = false;
            																		}
HXDLIN(  83)																		if (hitQuad) {
HXLINE(  83)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found = true;
            															}
            															else {
HXLINE(  83)																if (found) {
HXLINE(  83)																	goto _hx_goto_66;
            																}
            															}
            														}
            													}
            													_hx_goto_66:;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool hasUndo1 = false;
HXDLIN(  83)								int aA = ((color >> 24) & 255);
HXDLIN(  83)								int rA = ((color >> 16) & 255);
HXDLIN(  83)								int gA = ((color >> 8) & 255);
HXDLIN(  83)								int bA = (color & 255);
HXDLIN(  83)								Float bcx = (bx - cx);
HXDLIN(  83)								Float bcy = (by - cy);
HXDLIN(  83)								Float acx = (ex - cx);
HXDLIN(  83)								Float acy = (ey - cy);
HXDLIN(  83)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  83)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  83)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  83)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  83)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  83)								if ((ex > bx)) {
HXLINE(  83)									if ((ex > cx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((bx > cx)) {
HXLINE(  83)											min = ::Math_obj::floor(cx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((bx > cx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ex > cx)) {
HXLINE(  83)											min = ::Math_obj::floor(cx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  83)								if ((ey > by)) {
HXLINE(  83)									if ((ey > cy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((by > cy)) {
HXLINE(  83)											min = ::Math_obj::floor(cy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((by > cy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ey > cy)) {
HXLINE(  83)											min = ::Math_obj::floor(cy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  83)								if (hasUndo1) {
HXLINE(  83)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  83)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  83)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)									undoImage1 = this3;
HXDLIN(  83)									{
HXLINE(  83)										int rectLeft = xIter31->start;
HXDLIN(  83)										int rectTop = yIter31->start;
HXDLIN(  83)										int rectRight = xIter31->max;
HXDLIN(  83)										bool forceClear = false;
HXDLIN(  83)										{
HXLINE(  83)											int _g = rectTop;
HXDLIN(  83)											int _g1 = yIter31->max;
HXDLIN(  83)											while((_g < _g1)){
HXLINE(  83)												_g = (_g + 1);
HXDLIN(  83)												int dy = (_g - 1);
HXDLIN(  83)												{
HXLINE(  83)													int _g1 = rectLeft;
HXDLIN(  83)													int _g2 = rectRight;
HXDLIN(  83)													while((_g1 < _g2)){
HXLINE(  83)														_g1 = (_g1 + 1);
HXDLIN(  83)														int dx = (_g1 - 1);
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int col;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															col = c;
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->useMask) {
HXLINE(  83)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)															int index;
HXDLIN(  83)															if (this1->useVirtualPos) {
HXLINE(  83)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  83)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  83)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int v;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  83)																v = c;
            															}
HXDLIN(  83)															int this3 = v;
HXDLIN(  83)															int maskPixel = this3;
HXDLIN(  83)															int this4 = col;
HXDLIN(  83)															int this5 = this4;
HXDLIN(  83)															if ((maskPixel == 0)) {
HXLINE(  83)																int this1 = this5;
HXDLIN(  83)																col = this1;
            															}
            															else {
HXLINE(  83)																Float m0;
HXDLIN(  83)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																if ((this1 == 0)) {
HXLINE(  83)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m1;
HXDLIN(  83)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																if ((this2 == 0)) {
HXLINE(  83)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m2;
HXDLIN(  83)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																if ((this3 == 0)) {
HXLINE(  83)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m3;
HXDLIN(  83)																int this4 = (maskPixel & 255);
HXDLIN(  83)																if ((this4 == 0)) {
HXLINE(  83)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  83)														if ((col != 0)) {
HXLINE(  83)															int x = (dx - rectLeft);
HXDLIN(  83)															int y = (dy - rectTop);
HXDLIN(  83)															int this1 = col;
HXDLIN(  83)															int c = this1;
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																int location;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int this3 = this2;
HXDLIN(  83)																int this4;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	this4 = this3;
            																}
HXDLIN(  83)																Float a1;
HXDLIN(  83)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																if ((this5 == 0)) {
HXLINE(  83)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r1;
HXDLIN(  83)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																if ((this6 == 0)) {
HXLINE(  83)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g1;
HXDLIN(  83)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																if ((this7 == 0)) {
HXLINE(  83)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b1;
HXDLIN(  83)																int this8 = (this4 & 255);
HXDLIN(  83)																if ((this8 == 0)) {
HXLINE(  83)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a2;
HXDLIN(  83)																int this9 = ((col >> 24) & 255);
HXDLIN(  83)																if ((this9 == 0)) {
HXLINE(  83)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r2;
HXDLIN(  83)																int this10 = ((col >> 16) & 255);
HXDLIN(  83)																if ((this10 == 0)) {
HXLINE(  83)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g2;
HXDLIN(  83)																int this11 = ((col >> 8) & 255);
HXDLIN(  83)																if ((this11 == 0)) {
HXLINE(  83)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b2;
HXDLIN(  83)																int this12 = (col & 255);
HXDLIN(  83)																if ((this12 == 0)) {
HXLINE(  83)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																{
HXLINE(  83)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  83)																	int value;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		value = blended;
            																	}
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((location >= 0)) {
HXLINE(  83)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															if (forceClear) {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																int x = (dx - rectLeft);
HXDLIN(  83)																int y = (dy - rectTop);
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool found1 = false;
HXDLIN(  83)								{
HXLINE(  83)									int _g_min1 = xIter31->start;
HXDLIN(  83)									int _g_max1 = xIter31->max;
HXDLIN(  83)									while((_g_min1 < _g_max1)){
HXLINE(  83)										_g_min1 = (_g_min1 + 1);
HXDLIN(  83)										int px = (_g_min1 - 1);
HXDLIN(  83)										Float pcx = (( (Float)(px) ) - cx);
HXLINE( 620)										found1 = false;
HXLINE(  83)										{
HXLINE(  83)											int _g_min = yIter31->start;
HXDLIN(  83)											int _g_max = yIter31->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int py = (_g_min - 1);
HXDLIN(  83)												Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  83)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  83)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  83)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  83)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  83)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)												bool hitQuad;
HXDLIN(  83)												bool hitQuad1;
HXDLIN(  83)												if ((ratioA >= 0)) {
HXLINE(  83)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad1 = false;
            												}
HXDLIN(  83)												if (hitQuad1) {
HXLINE(  83)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad = false;
            												}
HXDLIN(  83)												if (hitQuad) {
HXLINE(  83)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (soft * ratioB)));
HXDLIN(  83)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  83)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  83)													int this1 = i;
HXDLIN(  83)													int a = this1;
HXDLIN(  83)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  83)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  83)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  83)													int this2 = i1;
HXDLIN(  83)													int r = this2;
HXDLIN(  83)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  83)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  83)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  83)													int this3 = i2;
HXDLIN(  83)													int g = this3;
HXDLIN(  83)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  83)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  83)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  83)													int this4 = i3;
HXDLIN(  83)													int b = this4;
HXDLIN(  83)													{
HXLINE(  83)														int location;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->transparent) {
HXLINE(  83)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int this3 = this2;
HXDLIN(  83)															int old;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  83)																old = this3;
            															}
HXDLIN(  83)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)															Float a1;
HXDLIN(  83)															int this4 = ((old >> 24) & 255);
HXDLIN(  83)															if ((this4 == 0)) {
HXLINE(  83)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r1;
HXDLIN(  83)															int this5 = ((old >> 16) & 255);
HXDLIN(  83)															if ((this5 == 0)) {
HXLINE(  83)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g1;
HXDLIN(  83)															int this6 = ((old >> 8) & 255);
HXDLIN(  83)															if ((this6 == 0)) {
HXLINE(  83)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b1;
HXDLIN(  83)															int this7 = (old & 255);
HXDLIN(  83)															if ((this7 == 0)) {
HXLINE(  83)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a2;
HXDLIN(  83)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)															if ((this8 == 0)) {
HXLINE(  83)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r2;
HXDLIN(  83)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)															if ((this9 == 0)) {
HXLINE(  83)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g2;
HXDLIN(  83)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)															if ((this10 == 0)) {
HXLINE(  83)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b2;
HXDLIN(  83)															int this11 = (rhs & 255);
HXDLIN(  83)															if ((this11 == 0)) {
HXLINE(  83)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  83)															{
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = blended;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((location >= 0)) {
HXLINE(  83)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (pixelImage->isLittle) {
HXLINE(  83)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  83)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found1 = true;
            												}
            												else {
HXLINE(  83)													if (found1) {
HXLINE(  83)														goto _hx_goto_70;
            													}
            												}
            											}
            											_hx_goto_70:;
            										}
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  83)								int v_undoY;
HXDLIN(  83)								int v_undoX;
HXDLIN(  83)								Float v_ty;
HXDLIN(  83)								Float v_tx;
HXDLIN(  83)								Float v_t0;
HXDLIN(  83)								Float v_sy;
HXDLIN(  83)								Float v_sx;
HXDLIN(  83)								Float v_s0;
HXDLIN(  83)								Float v_A;
HXDLIN(  83)								Float ax1 = ex;
HXDLIN(  83)								Float ay1 = ey;
HXDLIN(  83)								Float bx2 = bx;
HXDLIN(  83)								Float by2 = by;
HXDLIN(  83)								Float cx2 = cx;
HXDLIN(  83)								Float cy2 = cy;
HXDLIN(  83)								::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  83)								bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  83)								if (!(adjustWinding1)) {
HXLINE(  83)									Float bx_ = bx2;
HXDLIN(  83)									Float by_ = by2;
HXLINE(  35)									bx2 = cx2;
HXLINE(  36)									by2 = cy2;
HXLINE(  37)									cx2 = bx_;
HXLINE(  38)									cy2 = by_;
            								}
HXLINE(  83)								Float v_ax = ax1;
HXDLIN(  83)								Float v_ay = ay1;
HXDLIN(  83)								Float v_bx = bx2;
HXDLIN(  83)								Float v_by = by2;
HXDLIN(  83)								Float v_cx = cx2;
HXDLIN(  83)								Float v_cy = cy2;
HXDLIN(  83)								bool v_preCalculated = true;
HXDLIN(  83)								{
HXLINE(  83)									v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  83)									v_sx = (v_cy - v_ay);
HXDLIN(  83)									v_sy = (v_ax - v_cx);
HXDLIN(  83)									v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  83)									v_tx = (v_ay - v_by);
HXDLIN(  83)									v_ty = (v_bx - v_ax);
HXDLIN(  83)									v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  83)									Float a = v_ax;
HXDLIN(  83)									Float b = v_bx;
HXDLIN(  83)									Float c = v_cx;
HXDLIN(  83)									if ((a > b)) {
HXLINE(  83)										if ((a > c)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b > c)) {
HXLINE(  83)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b > c)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a > c)) {
HXLINE(  83)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter3 = this1;
            										}
            									}
HXDLIN(  83)									Float a1 = v_ay;
HXDLIN(  83)									Float b1 = v_by;
HXDLIN(  83)									Float c1 = v_cy;
HXDLIN(  83)									if ((a1 > b1)) {
HXLINE(  83)										if ((a1 > c1)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b1 > c1)) {
HXLINE(  83)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b1);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b1);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b1 > c1)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a1 > c1)) {
HXLINE(  83)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a1);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a1);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter3 = this1;
            										}
            									}
            								}
HXDLIN(  83)								if (hasUndo1) {
HXLINE(  83)									v_undoImage = undoImage1;
HXDLIN(  83)									v_undoX = xIter31->start;
HXDLIN(  83)									v_undoY = yIter31->start;
            								}
HXDLIN(  83)								bool hasUndo2 = false;
HXDLIN(  83)								int aA1 = ((color >> 24) & 255);
HXDLIN(  83)								int rA1 = ((color >> 16) & 255);
HXDLIN(  83)								int gA1 = ((color >> 8) & 255);
HXDLIN(  83)								int bA1 = (color & 255);
HXDLIN(  83)								Float bcx1 = (cx - dx);
HXDLIN(  83)								Float bcy1 = (cy - dy);
HXDLIN(  83)								Float acx1 = (ex - dx);
HXDLIN(  83)								Float acy1 = (ey - dy);
HXDLIN(  83)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  83)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  83)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  83)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  83)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  83)								if ((ex > cx)) {
HXLINE(  83)									if ((ex > dx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((cx > dx)) {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter32 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((cx > dx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ex > dx)) {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter32 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter32 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  83)								if ((ey > cy)) {
HXLINE(  83)									if ((ey > dy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((cy > dy)) {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter32 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((cy > dy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ey > dy)) {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter32 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter32 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  83)								if (hasUndo2) {
HXLINE(  83)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  83)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  83)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)									undoImage2 = this3;
HXDLIN(  83)									{
HXLINE(  83)										int rectLeft = xIter32->start;
HXDLIN(  83)										int rectTop = yIter32->start;
HXDLIN(  83)										int rectRight = xIter32->max;
HXDLIN(  83)										bool forceClear = false;
HXDLIN(  83)										{
HXLINE(  83)											int _g = rectTop;
HXDLIN(  83)											int _g1 = yIter32->max;
HXDLIN(  83)											while((_g < _g1)){
HXLINE(  83)												_g = (_g + 1);
HXDLIN(  83)												int dy = (_g - 1);
HXDLIN(  83)												{
HXLINE(  83)													int _g1 = rectLeft;
HXDLIN(  83)													int _g2 = rectRight;
HXDLIN(  83)													while((_g1 < _g2)){
HXLINE(  83)														_g1 = (_g1 + 1);
HXDLIN(  83)														int dx = (_g1 - 1);
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int col;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															col = c;
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->useMask) {
HXLINE(  83)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)															int index;
HXDLIN(  83)															if (this1->useVirtualPos) {
HXLINE(  83)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  83)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  83)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int v;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  83)																v = c;
            															}
HXDLIN(  83)															int this3 = v;
HXDLIN(  83)															int maskPixel = this3;
HXDLIN(  83)															int this4 = col;
HXDLIN(  83)															int this5 = this4;
HXDLIN(  83)															if ((maskPixel == 0)) {
HXLINE(  83)																int this1 = this5;
HXDLIN(  83)																col = this1;
            															}
            															else {
HXLINE(  83)																Float m0;
HXDLIN(  83)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																if ((this1 == 0)) {
HXLINE(  83)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m1;
HXDLIN(  83)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																if ((this2 == 0)) {
HXLINE(  83)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m2;
HXDLIN(  83)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																if ((this3 == 0)) {
HXLINE(  83)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m3;
HXDLIN(  83)																int this4 = (maskPixel & 255);
HXDLIN(  83)																if ((this4 == 0)) {
HXLINE(  83)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  83)														if ((col != 0)) {
HXLINE(  83)															int x = (dx - rectLeft);
HXDLIN(  83)															int y = (dy - rectTop);
HXDLIN(  83)															int this1 = col;
HXDLIN(  83)															int c = this1;
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																hitQuad = undoImage2->transparent;
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																int location;
HXDLIN(  83)																if (undoImage2->useVirtualPos) {
HXLINE(  83)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  83)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int this3 = this2;
HXDLIN(  83)																int this4;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	this4 = this3;
            																}
HXDLIN(  83)																Float a1;
HXDLIN(  83)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																if ((this5 == 0)) {
HXLINE(  83)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r1;
HXDLIN(  83)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																if ((this6 == 0)) {
HXLINE(  83)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g1;
HXDLIN(  83)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																if ((this7 == 0)) {
HXLINE(  83)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b1;
HXDLIN(  83)																int this8 = (this4 & 255);
HXDLIN(  83)																if ((this8 == 0)) {
HXLINE(  83)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a2;
HXDLIN(  83)																int this9 = ((col >> 24) & 255);
HXDLIN(  83)																if ((this9 == 0)) {
HXLINE(  83)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r2;
HXDLIN(  83)																int this10 = ((col >> 16) & 255);
HXDLIN(  83)																if ((this10 == 0)) {
HXLINE(  83)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g2;
HXDLIN(  83)																int this11 = ((col >> 8) & 255);
HXDLIN(  83)																if ((this11 == 0)) {
HXLINE(  83)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b2;
HXDLIN(  83)																int this12 = (col & 255);
HXDLIN(  83)																if ((this12 == 0)) {
HXLINE(  83)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																{
HXLINE(  83)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  83)																	int value;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		value = blended;
            																	}
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((location >= 0)) {
HXLINE(  83)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage2->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															if (forceClear) {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  83)																int x = (dx - rectLeft);
HXDLIN(  83)																int y = (dy - rectTop);
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage2->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool found2 = false;
HXDLIN(  83)								{
HXLINE(  83)									int _g_min2 = xIter32->start;
HXDLIN(  83)									int _g_max2 = xIter32->max;
HXDLIN(  83)									while((_g_min2 < _g_max2)){
HXLINE(  83)										_g_min2 = (_g_min2 + 1);
HXDLIN(  83)										int px = (_g_min2 - 1);
HXDLIN(  83)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 620)										found2 = false;
HXLINE(  83)										{
HXLINE(  83)											int _g_min = yIter32->start;
HXDLIN(  83)											int _g_max = yIter32->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int py = (_g_min - 1);
HXDLIN(  83)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  83)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  83)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  83)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  83)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  83)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)												bool hitQuad;
HXDLIN(  83)												bool hitQuad1;
HXDLIN(  83)												if ((ratioA >= 0)) {
HXLINE(  83)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad1 = false;
            												}
HXDLIN(  83)												if (hitQuad1) {
HXLINE(  83)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad = false;
            												}
HXDLIN(  83)												if (hitQuad) {
HXLINE(  83)													int i = ::Std_obj::_hx_int((( (Float)(aA1) ) * (soft * ratioB)));
HXDLIN(  83)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  83)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  83)													int this1 = i;
HXDLIN(  83)													int a = this1;
HXDLIN(  83)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  83)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  83)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  83)													int this2 = i1;
HXDLIN(  83)													int r = this2;
HXDLIN(  83)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  83)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  83)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  83)													int this3 = i2;
HXDLIN(  83)													int g = this3;
HXDLIN(  83)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  83)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  83)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  83)													int this4 = i3;
HXDLIN(  83)													int b = this4;
HXDLIN(  83)													{
HXLINE(  83)														int location;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->transparent) {
HXLINE(  83)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int this3 = this2;
HXDLIN(  83)															int old;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  83)																old = this3;
            															}
HXDLIN(  83)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)															Float a1;
HXDLIN(  83)															int this4 = ((old >> 24) & 255);
HXDLIN(  83)															if ((this4 == 0)) {
HXLINE(  83)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r1;
HXDLIN(  83)															int this5 = ((old >> 16) & 255);
HXDLIN(  83)															if ((this5 == 0)) {
HXLINE(  83)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g1;
HXDLIN(  83)															int this6 = ((old >> 8) & 255);
HXDLIN(  83)															if ((this6 == 0)) {
HXLINE(  83)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b1;
HXDLIN(  83)															int this7 = (old & 255);
HXDLIN(  83)															if ((this7 == 0)) {
HXLINE(  83)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a2;
HXDLIN(  83)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)															if ((this8 == 0)) {
HXLINE(  83)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r2;
HXDLIN(  83)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)															if ((this9 == 0)) {
HXLINE(  83)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g2;
HXDLIN(  83)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)															if ((this10 == 0)) {
HXLINE(  83)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b2;
HXDLIN(  83)															int this11 = (rhs & 255);
HXDLIN(  83)															if ((this11 == 0)) {
HXLINE(  83)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  83)															{
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = blended;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((location >= 0)) {
HXLINE(  83)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (pixelImage->isLittle) {
HXLINE(  83)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  83)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found2 = true;
            												}
            												else {
HXLINE(  83)													if (found2) {
HXLINE(  83)														goto _hx_goto_74;
            													}
            												}
            											}
            											_hx_goto_74:;
            										}
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  83)								int v_undoY1;
HXDLIN(  83)								int v_undoX1;
HXDLIN(  83)								Float v_ty1;
HXDLIN(  83)								Float v_tx1;
HXDLIN(  83)								Float v_t01;
HXDLIN(  83)								Float v_sy1;
HXDLIN(  83)								Float v_sx1;
HXDLIN(  83)								Float v_s01;
HXDLIN(  83)								Float v_A1;
HXDLIN(  83)								Float ax2 = ex;
HXDLIN(  83)								Float ay2 = ey;
HXDLIN(  83)								Float bx3 = cx;
HXDLIN(  83)								Float by3 = cy;
HXDLIN(  83)								Float cx3 = dx;
HXDLIN(  83)								Float cy3 = dy;
HXDLIN(  83)								::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  83)								bool adjustWinding2 = (((((ax2 * by3) - (bx3 * ay2)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay2) - (ax2 * cy3))) > 0);
HXDLIN(  83)								if (!(adjustWinding2)) {
HXLINE(  83)									Float bx_ = bx3;
HXDLIN(  83)									Float by_ = by3;
HXLINE(  35)									bx3 = cx3;
HXLINE(  36)									by3 = cy3;
HXLINE(  37)									cx3 = bx_;
HXLINE(  38)									cy3 = by_;
            								}
HXLINE(  83)								Float v_ax1 = ax2;
HXDLIN(  83)								Float v_ay1 = ay2;
HXDLIN(  83)								Float v_bx1 = bx3;
HXDLIN(  83)								Float v_by1 = by3;
HXDLIN(  83)								Float v_cx1 = cx3;
HXDLIN(  83)								Float v_cy1 = cy3;
HXDLIN(  83)								bool v_preCalculated1 = true;
HXDLIN(  83)								{
HXLINE(  83)									v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  83)									v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  83)									v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  83)									v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  83)									v_tx1 = (v_ay1 - v_by1);
HXDLIN(  83)									v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  83)									v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  83)									Float a2 = v_ax1;
HXDLIN(  83)									Float b2 = v_bx1;
HXDLIN(  83)									Float c2 = v_cx1;
HXDLIN(  83)									if ((a2 > b2)) {
HXLINE(  83)										if ((a2 > c2)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b2 > c2)) {
HXLINE(  83)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b2);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b2);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter31 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b2 > c2)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a2 > c2)) {
HXLINE(  83)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a2);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a2);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter31 = this1;
            										}
            									}
HXDLIN(  83)									Float a3 = v_ay1;
HXDLIN(  83)									Float b3 = v_by1;
HXDLIN(  83)									Float c3 = v_cy1;
HXDLIN(  83)									if ((a3 > b3)) {
HXLINE(  83)										if ((a3 > c3)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b3 > c3)) {
HXLINE(  83)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b3);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b3);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter31 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b3 > c3)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a3 > c3)) {
HXLINE(  83)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a3);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a3);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter31 = this1;
            										}
            									}
            								}
HXDLIN(  83)								if (hasUndo2) {
HXLINE(  83)									v_undoImage1 = undoImage2;
HXDLIN(  83)									v_undoX1 = xIter32->start;
HXDLIN(  83)									v_undoY1 = yIter32->start;
            								}
HXDLIN(  83)								bool hasUndo3 = false;
HXDLIN(  83)								int aA2 = ((color >> 24) & 255);
HXDLIN(  83)								int rA2 = ((color >> 16) & 255);
HXDLIN(  83)								int gA2 = ((color >> 8) & 255);
HXDLIN(  83)								int bA2 = (color & 255);
HXDLIN(  83)								Float bcx2 = (dx - ax);
HXDLIN(  83)								Float bcy2 = (dy - ay);
HXDLIN(  83)								Float acx2 = (ex - ax);
HXDLIN(  83)								Float acy2 = (ey - ay);
HXDLIN(  83)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  83)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  83)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  83)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  83)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  83)								if ((ex > dx)) {
HXLINE(  83)									if ((ex > ax)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((dx > ax)) {
HXLINE(  83)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter33 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(dx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((dx > ax)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ex > ax)) {
HXLINE(  83)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter33 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter33 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  83)								if ((ey > dy)) {
HXLINE(  83)									if ((ey > ay)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((dy > ay)) {
HXLINE(  83)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter33 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(dy);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((dy > ay)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ey > ay)) {
HXLINE(  83)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter33 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter33 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  83)								if (hasUndo3) {
HXLINE(  83)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  83)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  83)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)									undoImage3 = this3;
HXDLIN(  83)									{
HXLINE(  83)										int rectLeft = xIter33->start;
HXDLIN(  83)										int rectTop = yIter33->start;
HXDLIN(  83)										int rectRight = xIter33->max;
HXDLIN(  83)										bool forceClear = false;
HXDLIN(  83)										{
HXLINE(  83)											int _g = rectTop;
HXDLIN(  83)											int _g1 = yIter33->max;
HXDLIN(  83)											while((_g < _g1)){
HXLINE(  83)												_g = (_g + 1);
HXDLIN(  83)												int dy = (_g - 1);
HXDLIN(  83)												{
HXLINE(  83)													int _g1 = rectLeft;
HXDLIN(  83)													int _g2 = rectRight;
HXDLIN(  83)													while((_g1 < _g2)){
HXLINE(  83)														_g1 = (_g1 + 1);
HXDLIN(  83)														int dx = (_g1 - 1);
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int col;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															col = c;
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->useMask) {
HXLINE(  83)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)															int index;
HXDLIN(  83)															if (this1->useVirtualPos) {
HXLINE(  83)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  83)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  83)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int v;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  83)																v = c;
            															}
HXDLIN(  83)															int this3 = v;
HXDLIN(  83)															int maskPixel = this3;
HXDLIN(  83)															int this4 = col;
HXDLIN(  83)															int this5 = this4;
HXDLIN(  83)															if ((maskPixel == 0)) {
HXLINE(  83)																int this1 = this5;
HXDLIN(  83)																col = this1;
            															}
            															else {
HXLINE(  83)																Float m0;
HXDLIN(  83)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																if ((this1 == 0)) {
HXLINE(  83)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m1;
HXDLIN(  83)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																if ((this2 == 0)) {
HXLINE(  83)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m2;
HXDLIN(  83)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																if ((this3 == 0)) {
HXLINE(  83)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m3;
HXDLIN(  83)																int this4 = (maskPixel & 255);
HXDLIN(  83)																if ((this4 == 0)) {
HXLINE(  83)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  83)														if ((col != 0)) {
HXLINE(  83)															int x = (dx - rectLeft);
HXDLIN(  83)															int y = (dy - rectTop);
HXDLIN(  83)															int this1 = col;
HXDLIN(  83)															int c = this1;
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																hitQuad = undoImage3->transparent;
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																int location;
HXDLIN(  83)																if (undoImage3->useVirtualPos) {
HXLINE(  83)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  83)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int this3 = this2;
HXDLIN(  83)																int this4;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	this4 = this3;
            																}
HXDLIN(  83)																Float a1;
HXDLIN(  83)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																if ((this5 == 0)) {
HXLINE(  83)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r1;
HXDLIN(  83)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																if ((this6 == 0)) {
HXLINE(  83)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g1;
HXDLIN(  83)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																if ((this7 == 0)) {
HXLINE(  83)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b1;
HXDLIN(  83)																int this8 = (this4 & 255);
HXDLIN(  83)																if ((this8 == 0)) {
HXLINE(  83)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a2;
HXDLIN(  83)																int this9 = ((col >> 24) & 255);
HXDLIN(  83)																if ((this9 == 0)) {
HXLINE(  83)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r2;
HXDLIN(  83)																int this10 = ((col >> 16) & 255);
HXDLIN(  83)																if ((this10 == 0)) {
HXLINE(  83)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g2;
HXDLIN(  83)																int this11 = ((col >> 8) & 255);
HXDLIN(  83)																if ((this11 == 0)) {
HXLINE(  83)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b2;
HXDLIN(  83)																int this12 = (col & 255);
HXDLIN(  83)																if ((this12 == 0)) {
HXLINE(  83)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																{
HXLINE(  83)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  83)																	int value;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		value = blended;
            																	}
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((location >= 0)) {
HXLINE(  83)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage3->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															if (forceClear) {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  83)																int x = (dx - rectLeft);
HXDLIN(  83)																int y = (dy - rectTop);
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage3->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool found3 = false;
HXDLIN(  83)								{
HXLINE(  83)									int _g_min3 = xIter33->start;
HXDLIN(  83)									int _g_max3 = xIter33->max;
HXDLIN(  83)									while((_g_min3 < _g_max3)){
HXLINE(  83)										_g_min3 = (_g_min3 + 1);
HXDLIN(  83)										int px = (_g_min3 - 1);
HXDLIN(  83)										Float pcx = (( (Float)(px) ) - ax);
HXLINE( 620)										found3 = false;
HXLINE(  83)										{
HXLINE(  83)											int _g_min = yIter33->start;
HXDLIN(  83)											int _g_max = yIter33->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int py = (_g_min - 1);
HXDLIN(  83)												Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  83)												Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  83)												Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  83)												Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  83)												Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  83)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)												bool hitQuad;
HXDLIN(  83)												bool hitQuad1;
HXDLIN(  83)												if ((ratioA >= 0)) {
HXLINE(  83)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad1 = false;
            												}
HXDLIN(  83)												if (hitQuad1) {
HXLINE(  83)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad = false;
            												}
HXDLIN(  83)												if (hitQuad) {
HXLINE(  83)													int i = ::Std_obj::_hx_int((( (Float)(aA2) ) * (soft * ratioB)));
HXDLIN(  83)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  83)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  83)													int this1 = i;
HXDLIN(  83)													int a = this1;
HXDLIN(  83)													int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  83)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  83)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  83)													int this2 = i1;
HXDLIN(  83)													int r = this2;
HXDLIN(  83)													int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  83)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  83)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  83)													int this3 = i2;
HXDLIN(  83)													int g = this3;
HXDLIN(  83)													int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  83)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  83)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  83)													int this4 = i3;
HXDLIN(  83)													int b = this4;
HXDLIN(  83)													{
HXLINE(  83)														int location;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->transparent) {
HXLINE(  83)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int this3 = this2;
HXDLIN(  83)															int old;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  83)																old = this3;
            															}
HXDLIN(  83)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)															Float a1;
HXDLIN(  83)															int this4 = ((old >> 24) & 255);
HXDLIN(  83)															if ((this4 == 0)) {
HXLINE(  83)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r1;
HXDLIN(  83)															int this5 = ((old >> 16) & 255);
HXDLIN(  83)															if ((this5 == 0)) {
HXLINE(  83)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g1;
HXDLIN(  83)															int this6 = ((old >> 8) & 255);
HXDLIN(  83)															if ((this6 == 0)) {
HXLINE(  83)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b1;
HXDLIN(  83)															int this7 = (old & 255);
HXDLIN(  83)															if ((this7 == 0)) {
HXLINE(  83)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a2;
HXDLIN(  83)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)															if ((this8 == 0)) {
HXLINE(  83)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r2;
HXDLIN(  83)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)															if ((this9 == 0)) {
HXLINE(  83)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g2;
HXDLIN(  83)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)															if ((this10 == 0)) {
HXLINE(  83)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b2;
HXDLIN(  83)															int this11 = (rhs & 255);
HXDLIN(  83)															if ((this11 == 0)) {
HXLINE(  83)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  83)															{
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = blended;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((location >= 0)) {
HXLINE(  83)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (pixelImage->isLittle) {
HXLINE(  83)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  83)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found3 = true;
            												}
            												else {
HXLINE(  83)													if (found3) {
HXLINE(  83)														goto _hx_goto_78;
            													}
            												}
            											}
            											_hx_goto_78:;
            										}
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_yIter32;
HXDLIN(  83)								::pixelimage::iter::IntIterStart v_xIter32;
HXDLIN(  83)								int v_undoY2;
HXDLIN(  83)								int v_undoX2;
HXDLIN(  83)								Float v_ty2;
HXDLIN(  83)								Float v_tx2;
HXDLIN(  83)								Float v_t02;
HXDLIN(  83)								Float v_sy2;
HXDLIN(  83)								Float v_sx2;
HXDLIN(  83)								Float v_s02;
HXDLIN(  83)								Float v_A2;
HXDLIN(  83)								Float ax3 = ex;
HXDLIN(  83)								Float ay3 = ey;
HXDLIN(  83)								Float bx4 = dx;
HXDLIN(  83)								Float by4 = dy;
HXDLIN(  83)								Float cx4 = ax;
HXDLIN(  83)								Float cy4 = ay;
HXDLIN(  83)								::pixelimage::ImageStruct v_undoImage2 = null();
HXDLIN(  83)								bool adjustWinding3 = (((((ax3 * by4) - (bx4 * ay3)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay3) - (ax3 * cy4))) > 0);
HXDLIN(  83)								if (!(adjustWinding3)) {
HXLINE(  83)									Float bx_ = bx4;
HXDLIN(  83)									Float by_ = by4;
HXLINE(  35)									bx4 = cx4;
HXLINE(  36)									by4 = cy4;
HXLINE(  37)									cx4 = bx_;
HXLINE(  38)									cy4 = by_;
            								}
HXLINE(  83)								Float v_ax2 = ax3;
HXDLIN(  83)								Float v_ay2 = ay3;
HXDLIN(  83)								Float v_bx2 = bx4;
HXDLIN(  83)								Float v_by2 = by4;
HXDLIN(  83)								Float v_cx2 = cx4;
HXDLIN(  83)								Float v_cy2 = cy4;
HXDLIN(  83)								bool v_preCalculated2 = true;
HXDLIN(  83)								{
HXLINE(  83)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  83)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  83)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  83)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  83)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  83)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  83)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  83)									Float a4 = v_ax2;
HXDLIN(  83)									Float b4 = v_bx2;
HXDLIN(  83)									Float c4 = v_cx2;
HXDLIN(  83)									if ((a4 > b4)) {
HXLINE(  83)										if ((a4 > c4)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b4 > c4)) {
HXLINE(  83)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b4);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a4);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b4);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter32 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b4 > c4)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a4 > c4)) {
HXLINE(  83)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a4);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b4);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a4);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_xIter32 = this1;
            										}
            									}
HXDLIN(  83)									Float a5 = v_ay2;
HXDLIN(  83)									Float b5 = v_by2;
HXDLIN(  83)									Float c5 = v_cy2;
HXDLIN(  83)									if ((a5 > b5)) {
HXLINE(  83)										if ((a5 > c5)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((b5 > c5)) {
HXLINE(  83)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::floor(b5);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(a5);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(b5);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter32 = this1;
            										}
            									}
            									else {
HXLINE(  83)										if ((b5 > c5)) {
HXLINE(  83)											int min;
HXDLIN(  83)											if ((a5 > c5)) {
HXLINE(  83)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  83)												min = ::Math_obj::ceil(a5);
            											}
HXDLIN(  83)											int ii_min = min;
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(b5);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  83)											int ii_min = ::Math_obj::floor(a5);
HXDLIN(  83)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  83)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)											v_yIter32 = this1;
            										}
            									}
            								}
HXDLIN(  83)								if (hasUndo3) {
HXLINE(  83)									v_undoImage2 = undoImage3;
HXDLIN(  83)									v_undoX2 = xIter33->start;
HXDLIN(  83)									v_undoY2 = yIter33->start;
            								}
HXDLIN(  83)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  83)								hitQuad = v;
            							}
            						}
            						else {
HXLINE(  83)							Float sin = ::Math_obj::sin(theta);
HXDLIN(  83)							Float cos = ::Math_obj::cos(theta);
HXDLIN(  83)							Float radius = (thick / ( (Float)(2) ));
HXDLIN(  83)							Float dx = ((Float)0.1);
HXDLIN(  83)							Float dy = radius;
HXDLIN(  83)							Float cx = h2;
HXDLIN(  83)							Float cy = radius;
HXDLIN(  83)							Float bx = h2;
HXDLIN(  83)							Float by = -(radius);
HXDLIN(  83)							Float ax = ((Float)0.1);
HXDLIN(  83)							Float ay = -(radius);
HXDLIN(  83)							Float temp = ((Float)0.);
HXLINE(  82)							temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  83)							ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  84)							ax = temp;
HXLINE(  86)							temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  87)							by = (py + ((by * cos) + (bx * sin)));
HXLINE(  88)							bx = temp;
HXLINE(  90)							temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  91)							cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  92)							cx = temp;
HXLINE(  94)							temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  95)							dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  96)							dx = temp;
HXLINE(  83)							{
HXLINE(  83)								bool hasUndo = true;
HXDLIN(  83)								int aA = ((color >> 24) & 255);
HXDLIN(  83)								int rA = ((color >> 16) & 255);
HXDLIN(  83)								int gA = ((color >> 8) & 255);
HXDLIN(  83)								int bA = (color & 255);
HXDLIN(  83)								Float bcx = (bx - dx);
HXDLIN(  83)								Float bcy = (by - dy);
HXDLIN(  83)								Float acx = (ax - dx);
HXDLIN(  83)								Float acy = (ay - dy);
HXDLIN(  83)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  83)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  83)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  83)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  83)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  83)								if ((ax > bx)) {
HXLINE(  83)									if ((ax > dx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((bx > dx)) {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter3 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((bx > dx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ax > dx)) {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter3 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter3 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  83)								if ((ay > by)) {
HXLINE(  83)									if ((ay > dy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((by > dy)) {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter3 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((by > dy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((ay > dy)) {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter3 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter3 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  83)								if (hasUndo) {
HXLINE(  83)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  83)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  83)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)									undoImage = this3;
HXDLIN(  83)									{
HXLINE(  83)										int rectLeft = xIter3->start;
HXDLIN(  83)										int rectTop = yIter3->start;
HXDLIN(  83)										int rectRight = xIter3->max;
HXDLIN(  83)										bool forceClear = false;
HXDLIN(  83)										{
HXLINE(  83)											int _g = rectTop;
HXDLIN(  83)											int _g1 = yIter3->max;
HXDLIN(  83)											while((_g < _g1)){
HXLINE(  83)												_g = (_g + 1);
HXDLIN(  83)												int dy = (_g - 1);
HXDLIN(  83)												{
HXLINE(  83)													int _g1 = rectLeft;
HXDLIN(  83)													int _g2 = rectRight;
HXDLIN(  83)													while((_g1 < _g2)){
HXLINE(  83)														_g1 = (_g1 + 1);
HXDLIN(  83)														int dx = (_g1 - 1);
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int col;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															col = c;
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->useMask) {
HXLINE(  83)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)															int index;
HXDLIN(  83)															if (this1->useVirtualPos) {
HXLINE(  83)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  83)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  83)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int v;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  83)																v = c;
            															}
HXDLIN(  83)															int this3 = v;
HXDLIN(  83)															int maskPixel = this3;
HXDLIN(  83)															int this4 = col;
HXDLIN(  83)															int this5 = this4;
HXDLIN(  83)															if ((maskPixel == 0)) {
HXLINE(  83)																int this1 = this5;
HXDLIN(  83)																col = this1;
            															}
            															else {
HXLINE(  83)																Float m0;
HXDLIN(  83)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																if ((this1 == 0)) {
HXLINE(  83)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m1;
HXDLIN(  83)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																if ((this2 == 0)) {
HXLINE(  83)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m2;
HXDLIN(  83)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																if ((this3 == 0)) {
HXLINE(  83)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m3;
HXDLIN(  83)																int this4 = (maskPixel & 255);
HXDLIN(  83)																if ((this4 == 0)) {
HXLINE(  83)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  83)														if ((col != 0)) {
HXLINE(  83)															int x = (dx - rectLeft);
HXDLIN(  83)															int y = (dy - rectTop);
HXDLIN(  83)															int this1 = col;
HXDLIN(  83)															int c = this1;
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																int location;
HXDLIN(  83)																if (undoImage->useVirtualPos) {
HXLINE(  83)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  83)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int this3 = this2;
HXDLIN(  83)																int this4;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	this4 = this3;
            																}
HXDLIN(  83)																Float a1;
HXDLIN(  83)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																if ((this5 == 0)) {
HXLINE(  83)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r1;
HXDLIN(  83)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																if ((this6 == 0)) {
HXLINE(  83)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g1;
HXDLIN(  83)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																if ((this7 == 0)) {
HXLINE(  83)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b1;
HXDLIN(  83)																int this8 = (this4 & 255);
HXDLIN(  83)																if ((this8 == 0)) {
HXLINE(  83)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a2;
HXDLIN(  83)																int this9 = ((col >> 24) & 255);
HXDLIN(  83)																if ((this9 == 0)) {
HXLINE(  83)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r2;
HXDLIN(  83)																int this10 = ((col >> 16) & 255);
HXDLIN(  83)																if ((this10 == 0)) {
HXLINE(  83)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g2;
HXDLIN(  83)																int this11 = ((col >> 8) & 255);
HXDLIN(  83)																if ((this11 == 0)) {
HXLINE(  83)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b2;
HXDLIN(  83)																int this12 = (col & 255);
HXDLIN(  83)																if ((this12 == 0)) {
HXLINE(  83)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																{
HXLINE(  83)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  83)																	int value;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		value = blended;
            																	}
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((location >= 0)) {
HXLINE(  83)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															if (forceClear) {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)																int x = (dx - rectLeft);
HXDLIN(  83)																int y = (dy - rectTop);
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool found = false;
HXDLIN(  83)								Float min = ( (Float)(0) );
HXDLIN(  83)								Float max = ( (Float)(0) );
HXDLIN(  83)								int a = 0;
HXDLIN(  83)								int r = 0;
HXDLIN(  83)								int g = 0;
HXDLIN(  83)								int b = 0;
HXDLIN(  83)								{
HXLINE(  83)									int _g_min = xIter3->start;
HXDLIN(  83)									int _g_max = xIter3->max;
HXDLIN(  83)									while((_g_min < _g_max)){
HXLINE(  83)										_g_min = (_g_min + 1);
HXDLIN(  83)										int px = (_g_min - 1);
HXDLIN(  83)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found = false;
HXLINE(  83)										{
HXLINE(  83)											int _g_min1 = yIter3->start;
HXDLIN(  83)											int _g_max = yIter3->max;
HXDLIN(  83)											while((_g_min1 < _g_max)){
HXLINE(  83)												_g_min1 = (_g_min1 + 1);
HXDLIN(  83)												int py = (_g_min1 - 1);
HXDLIN(  83)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  83)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  83)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  83)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  83)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  83)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)												bool hitQuad;
HXDLIN(  83)												bool hitQuad1;
HXDLIN(  83)												if ((ratioA >= 0)) {
HXLINE(  83)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad1 = false;
            												}
HXDLIN(  83)												if (hitQuad1) {
HXLINE(  83)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad = false;
            												}
HXDLIN(  83)												if (hitQuad) {
HXLINE( 710)													min = ratioA;
HXLINE(  83)													int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  83)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  83)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  83)													int this1 = i;
HXDLIN(  83)													a = this1;
HXDLIN(  83)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  83)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  83)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  83)													int this2 = i1;
HXLINE( 748)													r = this2;
HXLINE(  83)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  83)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  83)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  83)													int this3 = i2;
HXLINE( 749)													g = this3;
HXLINE(  83)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  83)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  83)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  83)													int this4 = i3;
HXLINE( 750)													b = this4;
HXLINE(  83)													{
HXLINE(  83)														int location;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->transparent) {
HXLINE(  83)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int this3 = this2;
HXDLIN(  83)															int old;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  83)																old = this3;
            															}
HXDLIN(  83)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)															Float a1;
HXDLIN(  83)															int this4 = ((old >> 24) & 255);
HXDLIN(  83)															if ((this4 == 0)) {
HXLINE(  83)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r1;
HXDLIN(  83)															int this5 = ((old >> 16) & 255);
HXDLIN(  83)															if ((this5 == 0)) {
HXLINE(  83)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g1;
HXDLIN(  83)															int this6 = ((old >> 8) & 255);
HXDLIN(  83)															if ((this6 == 0)) {
HXLINE(  83)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b1;
HXDLIN(  83)															int this7 = (old & 255);
HXDLIN(  83)															if ((this7 == 0)) {
HXLINE(  83)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a2;
HXDLIN(  83)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)															if ((this8 == 0)) {
HXLINE(  83)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r2;
HXDLIN(  83)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)															if ((this9 == 0)) {
HXLINE(  83)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g2;
HXDLIN(  83)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)															if ((this10 == 0)) {
HXLINE(  83)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b2;
HXDLIN(  83)															int this11 = (rhs & 255);
HXDLIN(  83)															if ((this11 == 0)) {
HXLINE(  83)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  83)															{
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = blended;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((location >= 0)) {
HXLINE(  83)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (pixelImage->isLittle) {
HXLINE(  83)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  83)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found = true;
            												}
            												else {
HXLINE(  83)													if (found) {
HXLINE(  83)														goto _hx_goto_82;
            													}
            												}
            											}
            											_hx_goto_82:;
            										}
            									}
            								}
            							}
HXDLIN(  83)							{
HXLINE(  83)								bool hasUndo1 = true;
HXDLIN(  83)								int aA1 = ((color >> 24) & 255);
HXDLIN(  83)								int rA1 = ((color >> 16) & 255);
HXDLIN(  83)								int gA1 = ((color >> 8) & 255);
HXDLIN(  83)								int bA1 = (color & 255);
HXDLIN(  83)								Float bcx1 = (cx - dx);
HXDLIN(  83)								Float bcy1 = (cy - dy);
HXDLIN(  83)								Float acx1 = (bx - dx);
HXDLIN(  83)								Float acy1 = (by - dy);
HXDLIN(  83)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  83)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  83)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  83)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  83)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  83)								if ((bx > cx)) {
HXLINE(  83)									if ((bx > dx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((cx > dx)) {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((cx > dx)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((bx > dx)) {
HXLINE(  83)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										xIter31 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  83)								if ((by > cy)) {
HXLINE(  83)									if ((by > dy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((cy > dy)) {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  83)									if ((cy > dy)) {
HXLINE(  83)										int min;
HXDLIN(  83)										if ((by > dy)) {
HXLINE(  83)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  83)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  83)										int ii_min = min;
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            									else {
HXLINE(  83)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  83)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  83)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)										yIter31 = this1;
            									}
            								}
HXDLIN(  83)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  83)								if (hasUndo1) {
HXLINE(  83)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  83)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  83)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)									undoImage1 = this3;
HXDLIN(  83)									{
HXLINE(  83)										int rectLeft = xIter31->start;
HXDLIN(  83)										int rectTop = yIter31->start;
HXDLIN(  83)										int rectRight = xIter31->max;
HXDLIN(  83)										bool forceClear = false;
HXDLIN(  83)										{
HXLINE(  83)											int _g = rectTop;
HXDLIN(  83)											int _g1 = yIter31->max;
HXDLIN(  83)											while((_g < _g1)){
HXLINE(  83)												_g = (_g + 1);
HXDLIN(  83)												int dy = (_g - 1);
HXDLIN(  83)												{
HXLINE(  83)													int _g1 = rectLeft;
HXDLIN(  83)													int _g2 = rectRight;
HXDLIN(  83)													while((_g1 < _g2)){
HXLINE(  83)														_g1 = (_g1 + 1);
HXDLIN(  83)														int dx = (_g1 - 1);
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int col;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															col = c;
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->useMask) {
HXLINE(  83)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)															int index;
HXDLIN(  83)															if (this1->useVirtualPos) {
HXLINE(  83)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  83)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  83)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int v;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  83)																v = c;
            															}
HXDLIN(  83)															int this3 = v;
HXDLIN(  83)															int maskPixel = this3;
HXDLIN(  83)															int this4 = col;
HXDLIN(  83)															int this5 = this4;
HXDLIN(  83)															if ((maskPixel == 0)) {
HXLINE(  83)																int this1 = this5;
HXDLIN(  83)																col = this1;
            															}
            															else {
HXLINE(  83)																Float m0;
HXDLIN(  83)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)																if ((this1 == 0)) {
HXLINE(  83)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m1;
HXDLIN(  83)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)																if ((this2 == 0)) {
HXLINE(  83)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m2;
HXDLIN(  83)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)																if ((this3 == 0)) {
HXLINE(  83)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float m3;
HXDLIN(  83)																int this4 = (maskPixel & 255);
HXDLIN(  83)																if ((this4 == 0)) {
HXLINE(  83)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  83)														if ((col != 0)) {
HXLINE(  83)															int x = (dx - rectLeft);
HXDLIN(  83)															int y = (dy - rectTop);
HXDLIN(  83)															int this1 = col;
HXDLIN(  83)															int c = this1;
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																int location;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)																int this3 = this2;
HXDLIN(  83)																int this4;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	this4 = this3;
            																}
HXDLIN(  83)																Float a1;
HXDLIN(  83)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)																if ((this5 == 0)) {
HXLINE(  83)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r1;
HXDLIN(  83)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)																if ((this6 == 0)) {
HXLINE(  83)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g1;
HXDLIN(  83)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)																if ((this7 == 0)) {
HXLINE(  83)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b1;
HXDLIN(  83)																int this8 = (this4 & 255);
HXDLIN(  83)																if ((this8 == 0)) {
HXLINE(  83)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a2;
HXDLIN(  83)																int this9 = ((col >> 24) & 255);
HXDLIN(  83)																if ((this9 == 0)) {
HXLINE(  83)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float r2;
HXDLIN(  83)																int this10 = ((col >> 16) & 255);
HXDLIN(  83)																if ((this10 == 0)) {
HXLINE(  83)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float g2;
HXDLIN(  83)																int this11 = ((col >> 8) & 255);
HXDLIN(  83)																if ((this11 == 0)) {
HXLINE(  83)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float b2;
HXDLIN(  83)																int this12 = (col & 255);
HXDLIN(  83)																if ((this12 == 0)) {
HXLINE(  83)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  83)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  83)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)																{
HXLINE(  83)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  83)																	int value;
HXDLIN(  83)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  83)																		value = blended;
            																	}
HXDLIN(  83)																	bool hitQuad;
HXDLIN(  83)																	if ((location >= 0)) {
HXLINE(  83)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  83)																		hitQuad = false;
            																	}
HXDLIN(  83)																	if (hitQuad) {
HXLINE(  83)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = c;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															if (forceClear) {
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  83)																int x = (dx - rectLeft);
HXDLIN(  83)																int y = (dy - rectTop);
HXDLIN(  83)																int index;
HXDLIN(  83)																if (undoImage1->useVirtualPos) {
HXLINE(  83)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  83)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((index >= 0)) {
HXLINE(  83)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  83)								bool found1 = false;
HXDLIN(  83)								Float min1 = ( (Float)(0) );
HXDLIN(  83)								Float max1 = ( (Float)(0) );
HXDLIN(  83)								int a1 = 0;
HXDLIN(  83)								int r1 = 0;
HXDLIN(  83)								int g1 = 0;
HXDLIN(  83)								int b1 = 0;
HXDLIN(  83)								{
HXLINE(  83)									int _g_min1 = xIter31->start;
HXDLIN(  83)									int _g_max1 = xIter31->max;
HXDLIN(  83)									while((_g_min1 < _g_max1)){
HXLINE(  83)										_g_min1 = (_g_min1 + 1);
HXDLIN(  83)										int px = (_g_min1 - 1);
HXDLIN(  83)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found1 = false;
HXLINE(  83)										{
HXLINE(  83)											int _g_min = yIter31->start;
HXDLIN(  83)											int _g_max = yIter31->max;
HXDLIN(  83)											while((_g_min < _g_max)){
HXLINE(  83)												_g_min = (_g_min + 1);
HXDLIN(  83)												int py = (_g_min - 1);
HXDLIN(  83)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  83)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  83)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  83)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  83)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  83)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)												bool hitQuad;
HXDLIN(  83)												bool hitQuad1;
HXDLIN(  83)												if ((ratioA >= 0)) {
HXLINE(  83)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad1 = false;
            												}
HXDLIN(  83)												if (hitQuad1) {
HXLINE(  83)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  83)													hitQuad = false;
            												}
HXDLIN(  83)												if (hitQuad) {
HXLINE(  83)													if ((ratioB < ratioC)) {
HXLINE(  83)														min1 = ratioB;
            													}
            													else {
HXLINE(  83)														min1 = ratioC;
            													}
HXDLIN(  83)													if ((ratioA > ratioB)) {
HXLINE(  83)														max1 = ratioA;
            													}
            													else {
HXLINE(  83)														max1 = ratioB;
            													}
HXDLIN(  83)													if (!((max1 > ratioC))) {
HXLINE(  83)														max1 = ratioC;
            													}
HXLINE( 736)													max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  83)													if (!((min1 < max1))) {
HXLINE(  83)														min1 = ((max1 + min1) / ( (Float)(2) ));
            													}
HXDLIN(  83)													int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  83)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  83)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  83)													int this1 = i;
HXDLIN(  83)													a1 = this1;
HXDLIN(  83)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  83)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  83)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  83)													int this2 = i1;
HXLINE( 748)													r1 = this2;
HXLINE(  83)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  83)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  83)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  83)													int this3 = i2;
HXLINE( 749)													g1 = this3;
HXLINE(  83)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  83)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  83)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  83)													int this4 = i3;
HXLINE( 750)													b1 = this4;
HXLINE(  83)													{
HXLINE(  83)														int location;
HXDLIN(  83)														if (pixelImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  83)														bool hitQuad;
HXDLIN(  83)														if (pixelImage->transparent) {
HXLINE(  83)															hitQuad = (a1 < 254);
            														}
            														else {
HXLINE(  83)															hitQuad = false;
            														}
HXDLIN(  83)														if (hitQuad) {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)															int this3 = this2;
HXDLIN(  83)															int old;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  83)																old = this3;
            															}
HXDLIN(  83)															int rhs = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  83)															Float a11;
HXDLIN(  83)															int this4 = ((old >> 24) & 255);
HXDLIN(  83)															if ((this4 == 0)) {
HXLINE(  83)																a11 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r11;
HXDLIN(  83)															int this5 = ((old >> 16) & 255);
HXDLIN(  83)															if ((this5 == 0)) {
HXLINE(  83)																r11 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g11;
HXDLIN(  83)															int this6 = ((old >> 8) & 255);
HXDLIN(  83)															if ((this6 == 0)) {
HXLINE(  83)																g11 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b11;
HXDLIN(  83)															int this7 = (old & 255);
HXDLIN(  83)															if ((this7 == 0)) {
HXLINE(  83)																b11 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a2;
HXDLIN(  83)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)															if ((this8 == 0)) {
HXLINE(  83)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float r2;
HXDLIN(  83)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)															if ((this9 == 0)) {
HXLINE(  83)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float g2;
HXDLIN(  83)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)															if ((this10 == 0)) {
HXLINE(  83)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float b2;
HXDLIN(  83)															int this11 = (rhs & 255);
HXDLIN(  83)															if ((this11 == 0)) {
HXLINE(  83)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  83)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  83)															Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  83)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a2))));
HXDLIN(  83)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a2))));
HXDLIN(  83)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a2))));
HXDLIN(  83)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)															{
HXLINE(  83)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)																int value;
HXDLIN(  83)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  83)																	value = blended;
            																}
HXDLIN(  83)																bool hitQuad;
HXDLIN(  83)																if ((location >= 0)) {
HXLINE(  83)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  83)																	hitQuad = false;
            																}
HXDLIN(  83)																if (hitQuad) {
HXLINE(  83)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (pixelImage->isLittle) {
HXLINE(  83)																value = ((((a1 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            															}
            															else {
HXLINE(  83)																value = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            															}
HXDLIN(  83)															bool hitQuad;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																hitQuad = false;
            															}
HXDLIN(  83)															if (hitQuad) {
HXLINE(  83)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found1 = true;
            												}
            												else {
HXLINE(  83)													if (found1) {
HXLINE(  83)														goto _hx_goto_86;
            													}
            												}
            											}
            											_hx_goto_86:;
            										}
            									}
            								}
            							}
HXDLIN(  83)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  83)							hitQuad = v;
            						}
HXDLIN(  83)						Float cx = h2;
HXDLIN(  83)						Float cy = radius2;
HXDLIN(  83)						Float bx = h2;
HXDLIN(  83)						Float by = -(radius2);
HXDLIN(  83)						Float temp = ((Float)0.);
HXLINE(  92)						temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  93)						by = (py + ((by * cos) + (bx * sin)));
HXLINE(  94)						bx = temp;
HXLINE(  95)						temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  96)						cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  97)						cx = temp;
HXLINE(  83)						bool hasUndo = true;
HXDLIN(  83)						int aA = ((color >> 24) & 255);
HXDLIN(  83)						int rA = ((color >> 16) & 255);
HXDLIN(  83)						int gA = ((color >> 8) & 255);
HXDLIN(  83)						int bA = (color & 255);
HXDLIN(  83)						Float bcx = (bx - cx);
HXDLIN(  83)						Float bcy = (by - cy);
HXDLIN(  83)						Float acx = (px - cx);
HXDLIN(  83)						Float acy = (py - cy);
HXDLIN(  83)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  83)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  83)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  83)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  83)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  83)						if ((px > bx)) {
HXLINE(  83)							if ((px > cx)) {
HXLINE(  83)								int min;
HXDLIN(  83)								if ((bx > cx)) {
HXLINE(  83)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE(  83)									min = ::Math_obj::floor(bx);
            								}
HXDLIN(  83)								int ii_min = min;
HXDLIN(  83)								int ii_max = ::Math_obj::ceil(px);
HXDLIN(  83)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)								xIter3 = this1;
            							}
            							else {
HXLINE(  83)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  83)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  83)							if ((bx > cx)) {
HXLINE(  83)								int min;
HXDLIN(  83)								if ((px > cx)) {
HXLINE(  83)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE(  83)									min = ::Math_obj::ceil(px);
            								}
HXDLIN(  83)								int ii_min = min;
HXDLIN(  83)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  83)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)								xIter3 = this1;
            							}
            							else {
HXLINE(  83)								int ii_min = ::Math_obj::floor(px);
HXDLIN(  83)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  83)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)								xIter3 = this1;
            							}
            						}
HXDLIN(  83)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  83)						if ((py > by)) {
HXLINE(  83)							if ((py > cy)) {
HXLINE(  83)								int min;
HXDLIN(  83)								if ((by > cy)) {
HXLINE(  83)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE(  83)									min = ::Math_obj::floor(by);
            								}
HXDLIN(  83)								int ii_min = min;
HXDLIN(  83)								int ii_max = ::Math_obj::ceil(py);
HXDLIN(  83)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)								yIter3 = this1;
            							}
            							else {
HXLINE(  83)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  83)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  83)							if ((by > cy)) {
HXLINE(  83)								int min;
HXDLIN(  83)								if ((py > cy)) {
HXLINE(  83)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE(  83)									min = ::Math_obj::ceil(py);
            								}
HXDLIN(  83)								int ii_min = min;
HXDLIN(  83)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  83)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)								yIter3 = this1;
            							}
            							else {
HXLINE(  83)								int ii_min = ::Math_obj::floor(py);
HXDLIN(  83)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  83)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  83)								yIter3 = this1;
            							}
            						}
HXDLIN(  83)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  83)						if (hasUndo) {
HXLINE(  83)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  83)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  83)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  83)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  83)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  83)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  83)							undoImage = this3;
HXDLIN(  83)							{
HXLINE(  83)								int rectLeft = xIter3->start;
HXDLIN(  83)								int rectTop = yIter3->start;
HXDLIN(  83)								int rectRight = xIter3->max;
HXDLIN(  83)								bool forceClear = false;
HXDLIN(  83)								{
HXLINE(  83)									int _g = rectTop;
HXDLIN(  83)									int _g1 = yIter3->max;
HXDLIN(  83)									while((_g < _g1)){
HXLINE(  83)										_g = (_g + 1);
HXDLIN(  83)										int dy = (_g - 1);
HXDLIN(  83)										{
HXLINE(  83)											int _g1 = rectLeft;
HXDLIN(  83)											int _g2 = rectRight;
HXDLIN(  83)											while((_g1 < _g2)){
HXLINE(  83)												_g1 = (_g1 + 1);
HXDLIN(  83)												int dx = (_g1 - 1);
HXDLIN(  83)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)												int index;
HXDLIN(  83)												if (pixelImage->useVirtualPos) {
HXLINE(  83)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  83)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN(  83)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)												int col;
HXDLIN(  83)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  83)													col = c;
            												}
HXDLIN(  83)												bool _hx_tmp;
HXDLIN(  83)												if (pixelImage->useMask) {
HXLINE(  83)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE(  83)													_hx_tmp = false;
            												}
HXDLIN(  83)												if (_hx_tmp) {
HXLINE(  83)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  83)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  83)													int index;
HXDLIN(  83)													if (this1->useVirtualPos) {
HXLINE(  83)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  83)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  83)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  83)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  83)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)													int v;
HXDLIN(  83)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  83)														v = c;
            													}
HXDLIN(  83)													int this3 = v;
HXDLIN(  83)													int maskPixel = this3;
HXDLIN(  83)													int this4 = col;
HXDLIN(  83)													int this5 = this4;
HXDLIN(  83)													if ((maskPixel == 0)) {
HXLINE(  83)														int this1 = this5;
HXDLIN(  83)														col = this1;
            													}
            													else {
HXLINE(  83)														Float m0;
HXDLIN(  83)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  83)														if ((this1 == 0)) {
HXLINE(  83)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float m1;
HXDLIN(  83)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  83)														if ((this2 == 0)) {
HXLINE(  83)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float m2;
HXDLIN(  83)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  83)														if ((this3 == 0)) {
HXLINE(  83)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float m3;
HXDLIN(  83)														int this4 = (maskPixel & 255);
HXDLIN(  83)														if ((this4 == 0)) {
HXLINE(  83)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  83)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  83)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  83)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  83)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  83)												if ((col != 0)) {
HXLINE(  83)													int x = (dx - rectLeft);
HXDLIN(  83)													int y = (dy - rectTop);
HXDLIN(  83)													int this1 = col;
HXDLIN(  83)													int c = this1;
HXDLIN(  83)													bool _hx_tmp;
HXDLIN(  83)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  83)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  83)														_hx_tmp = false;
            													}
HXDLIN(  83)													if (_hx_tmp) {
HXLINE(  83)														int location;
HXDLIN(  83)														if (undoImage->useVirtualPos) {
HXLINE(  83)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  83)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  83)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)														int this3 = this2;
HXDLIN(  83)														int this4;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  83)															this4 = this3;
            														}
HXDLIN(  83)														Float a1;
HXDLIN(  83)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  83)														if ((this5 == 0)) {
HXLINE(  83)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float r1;
HXDLIN(  83)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  83)														if ((this6 == 0)) {
HXLINE(  83)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float g1;
HXDLIN(  83)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  83)														if ((this7 == 0)) {
HXLINE(  83)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float b1;
HXDLIN(  83)														int this8 = (this4 & 255);
HXDLIN(  83)														if ((this8 == 0)) {
HXLINE(  83)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float a2;
HXDLIN(  83)														int this9 = ((col >> 24) & 255);
HXDLIN(  83)														if ((this9 == 0)) {
HXLINE(  83)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float r2;
HXDLIN(  83)														int this10 = ((col >> 16) & 255);
HXDLIN(  83)														if ((this10 == 0)) {
HXLINE(  83)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float g2;
HXDLIN(  83)														int this11 = ((col >> 8) & 255);
HXDLIN(  83)														if ((this11 == 0)) {
HXLINE(  83)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float b2;
HXDLIN(  83)														int this12 = (col & 255);
HXDLIN(  83)														if ((this12 == 0)) {
HXLINE(  83)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  83)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  83)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  83)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)														{
HXLINE(  83)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  83)															int value;
HXDLIN(  83)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  83)																value = blended;
            															}
HXDLIN(  83)															bool _hx_tmp;
HXDLIN(  83)															if ((location >= 0)) {
HXLINE(  83)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  83)																_hx_tmp = false;
            															}
HXDLIN(  83)															if (_hx_tmp) {
HXLINE(  83)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  83)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  83)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  83)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)														int index;
HXDLIN(  83)														if (undoImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  83)														int value;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  83)															value = c;
            														}
HXDLIN(  83)														bool _hx_tmp;
HXDLIN(  83)														if ((index >= 0)) {
HXLINE(  83)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  83)															_hx_tmp = false;
            														}
HXDLIN(  83)														if (_hx_tmp) {
HXLINE(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  83)													if (forceClear) {
HXLINE(  83)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  83)														int x = (dx - rectLeft);
HXDLIN(  83)														int y = (dy - rectTop);
HXDLIN(  83)														int index;
HXDLIN(  83)														if (undoImage->useVirtualPos) {
HXLINE(  83)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  83)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  83)														bool _hx_tmp;
HXDLIN(  83)														if ((index >= 0)) {
HXLINE(  83)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  83)															_hx_tmp = false;
            														}
HXDLIN(  83)														if (_hx_tmp) {
HXLINE(  83)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  83)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  83)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  83)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  83)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  83)						bool found = false;
HXDLIN(  83)						Float min = ( (Float)(0) );
HXDLIN(  83)						Float max = ( (Float)(0) );
HXDLIN(  83)						int a1 = 0;
HXDLIN(  83)						int r = 0;
HXDLIN(  83)						int g = 0;
HXDLIN(  83)						int b = 0;
HXDLIN(  83)						{
HXLINE(  83)							int _g_min = xIter3->start;
HXDLIN(  83)							int _g_max = xIter3->max;
HXDLIN(  83)							while((_g_min < _g_max)){
HXLINE(  83)								_g_min = (_g_min + 1);
HXDLIN(  83)								int px = (_g_min - 1);
HXDLIN(  83)								Float pcx = (( (Float)(px) ) - cx);
HXLINE( 696)								found = false;
HXLINE(  83)								{
HXLINE(  83)									int _g_min1 = yIter3->start;
HXDLIN(  83)									int _g_max = yIter3->max;
HXDLIN(  83)									while((_g_min1 < _g_max)){
HXLINE(  83)										_g_min1 = (_g_min1 + 1);
HXDLIN(  83)										int py = (_g_min1 - 1);
HXDLIN(  83)										Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  83)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  83)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  83)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  83)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  83)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  83)										bool _hx_tmp;
HXDLIN(  83)										bool _hx_tmp1;
HXDLIN(  83)										if ((ratioA >= 0)) {
HXLINE(  83)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  83)											_hx_tmp1 = false;
            										}
HXDLIN(  83)										if (_hx_tmp1) {
HXLINE(  83)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  83)											_hx_tmp = false;
            										}
HXDLIN(  83)										if (_hx_tmp) {
HXLINE(  83)											Float min;
HXDLIN(  83)											if ((ratioA < ratioB)) {
HXLINE(  83)												min = ratioA;
            											}
            											else {
HXLINE(  83)												min = ratioB;
            											}
HXDLIN(  83)											if (!((min < ratioC))) {
HXLINE(  83)												min = ratioC;
            											}
HXDLIN(  83)											Float max;
HXDLIN(  83)											if ((ratioA > ratioB)) {
HXLINE(  83)												max = ratioA;
            											}
            											else {
HXLINE(  83)												max = ratioB;
            											}
HXDLIN(  83)											if (!((max > ratioC))) {
HXLINE(  83)												max = ratioC;
            											}
HXLINE( 744)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  83)											Float min1;
HXDLIN(  83)											if ((min < max)) {
HXLINE(  83)												min1 = min;
            											}
            											else {
HXLINE(  83)												min1 = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  83)											int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min1));
HXDLIN(  83)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  83)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  83)											int this1 = i;
HXDLIN(  83)											a1 = this1;
HXDLIN(  83)											int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  83)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  83)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  83)											int this2 = i1;
HXLINE( 748)											r = this2;
HXLINE(  83)											int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  83)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  83)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  83)											int this3 = i2;
HXLINE( 749)											g = this3;
HXLINE(  83)											int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  83)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  83)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  83)											int this4 = i3;
HXLINE( 750)											b = this4;
HXLINE(  83)											{
HXLINE(  83)												int location;
HXDLIN(  83)												if (pixelImage->useVirtualPos) {
HXLINE(  83)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  83)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            												}
HXDLIN(  83)												bool _hx_tmp;
HXDLIN(  83)												if (pixelImage->transparent) {
HXLINE(  83)													_hx_tmp = (a1 < 254);
            												}
            												else {
HXLINE(  83)													_hx_tmp = false;
            												}
HXDLIN(  83)												if (_hx_tmp) {
HXLINE(  83)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  83)													int this3 = this2;
HXDLIN(  83)													int old;
HXDLIN(  83)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  83)														old = this3;
            													}
HXDLIN(  83)													int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  83)													Float a11;
HXDLIN(  83)													int this4 = ((old >> 24) & 255);
HXDLIN(  83)													if ((this4 == 0)) {
HXLINE(  83)														a11 = ((Float)0.);
            													}
            													else {
HXLINE(  83)														a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  83)													Float r1;
HXDLIN(  83)													int this5 = ((old >> 16) & 255);
HXDLIN(  83)													if ((this5 == 0)) {
HXLINE(  83)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  83)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  83)													Float g1;
HXDLIN(  83)													int this6 = ((old >> 8) & 255);
HXDLIN(  83)													if ((this6 == 0)) {
HXLINE(  83)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  83)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  83)													Float b1;
HXDLIN(  83)													int this7 = (old & 255);
HXDLIN(  83)													if ((this7 == 0)) {
HXLINE(  83)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  83)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  83)													Float a2;
HXDLIN(  83)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  83)													if ((this8 == 0)) {
HXLINE(  83)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  83)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  83)													Float r2;
HXDLIN(  83)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  83)													if ((this9 == 0)) {
HXLINE(  83)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  83)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  83)													Float g2;
HXDLIN(  83)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  83)													if ((this10 == 0)) {
HXLINE(  83)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  83)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  83)													Float b2;
HXDLIN(  83)													int this11 = (rhs & 255);
HXDLIN(  83)													if ((this11 == 0)) {
HXLINE(  83)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  83)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  83)													Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  83)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  83)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  83)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  83)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  83)													int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  83)													{
HXLINE(  83)														::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  83)														int value;
HXDLIN(  83)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  83)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  83)															value = blended;
            														}
HXDLIN(  83)														bool _hx_tmp;
HXDLIN(  83)														if ((location >= 0)) {
HXLINE(  83)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  83)															_hx_tmp = false;
            														}
HXDLIN(  83)														if (_hx_tmp) {
HXLINE(  83)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  83)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  83)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  83)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  83)													int value;
HXDLIN(  83)													if (pixelImage->isLittle) {
HXLINE(  83)														value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  83)														value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  83)													bool _hx_tmp;
HXDLIN(  83)													if ((location >= 0)) {
HXLINE(  83)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  83)														_hx_tmp = false;
            													}
HXDLIN(  83)													if (_hx_tmp) {
HXLINE(  83)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  83)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  83)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  83)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  83)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  83)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 752)											found = true;
            										}
            										else {
HXLINE(  83)											if (found) {
HXLINE(  83)												goto _hx_goto_90;
            											}
            										}
            									}
            									_hx_goto_90:;
            								}
            							}
            						}
HXDLIN(  83)						::pixelimage::algo::HitTri hitTri;
HXDLIN(  83)						if ((hasHit == false)) {
HXLINE(  83)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx,by,cx,cy,true);
HXDLIN(  83)							if (hasUndo) {
HXLINE(  83)								v->undoImage = undoImage;
HXDLIN(  83)								v->undoX = xIter3->start;
HXDLIN(  83)								v->undoY = yIter3->start;
            							}
HXDLIN(  83)							hitTri = v;
            						}
            						else {
HXLINE(  83)							hitTri = null();
            						}
HXDLIN(  83)						if (hasHit) {
HXLINE(  83)							::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN(  83)							if (::hx::IsNotNull( hitQuad )) {
HXLINE(  83)								hitArr->triArr->push(hitQuad->triABD);
            							}
HXDLIN(  83)							hitArr->triArr->push(hitQuad->triBCD);
            						}
            					}
            				}
            			}
            			else {
HXLINE(  87)				bool _hx_tmp;
HXDLIN(  87)				if (!((this->arrowHeight > ((Float)0.)))) {
HXLINE(  87)					_hx_tmp = (this->arrowWidth > ((Float)0.));
            				}
            				else {
HXLINE(  87)					_hx_tmp = true;
            				}
HXDLIN(  87)				if (_hx_tmp) {
HXLINE(  88)					Float arrowWidth = this->arrowWidth;
HXDLIN(  88)					Float arrowHeight = this->arrowHeight;
HXDLIN(  88)					Float thick = this->strokeWidth;
HXDLIN(  88)					int color = this->strokeColor;
HXDLIN(  88)					Float soft = this->soft;
HXDLIN(  88)					bool hasHit = true;
HXDLIN(  88)					{
HXLINE(  88)						Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  88)						Float o = (py - py);
HXDLIN(  88)						Float a = (px - px);
HXDLIN(  88)						Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  88)						Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  88)						Float thicker;
HXDLIN(  88)						if ((arrowWidth > (thick * ((Float)1.1)))) {
HXLINE(  88)							thicker = arrowWidth;
            						}
            						else {
HXLINE(  88)							thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            						}
HXDLIN(  88)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  88)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  88)						Float radius = (thick / ( (Float)(2) ));
HXDLIN(  88)						Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  88)						Float h2;
HXDLIN(  88)						if ((arrowHeight < (h * ((Float)1.1)))) {
HXLINE(  88)							h2 = (h - arrowHeight);
            						}
            						else {
HXLINE(  88)							h2 = (h / goldenRatio);
            						}
HXDLIN(  88)						Float hSmall = (h - h2);
HXDLIN(  88)						Float px_ = hSmall;
HXDLIN(  88)						Float py_ = ((Float)0.);
HXDLIN(  88)						Float temp = ((Float)0.);
HXLINE( 654)						temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 655)						py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 656)						px_ = temp;
HXLINE(  88)						Float h1 = (h2 - hSmall);
HXDLIN(  88)						Float sin1 = ::Math_obj::sin(theta);
HXDLIN(  88)						Float cos1 = ::Math_obj::cos(theta);
HXDLIN(  88)						Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  88)						Float dx = ((Float)0.1);
HXDLIN(  88)						Float dy = radius1;
HXDLIN(  88)						Float cx = h1;
HXDLIN(  88)						Float cy = radius1;
HXDLIN(  88)						Float bx = h1;
HXDLIN(  88)						Float by = -(radius1);
HXDLIN(  88)						Float ax = ((Float)0.1);
HXDLIN(  88)						Float ay = -(radius1);
HXDLIN(  88)						Float temp1 = ((Float)0.);
HXLINE(  82)						temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE(  83)						ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE(  84)						ax = temp1;
HXLINE(  86)						temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE(  87)						by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE(  88)						bx = temp1;
HXLINE(  90)						temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE(  91)						cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE(  92)						cx = temp1;
HXLINE(  94)						temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE(  95)						dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE(  96)						dx = temp1;
HXLINE(  88)						{
HXLINE(  88)							bool hasUndo = true;
HXDLIN(  88)							int aA = ((color >> 24) & 255);
HXDLIN(  88)							int rA = ((color >> 16) & 255);
HXDLIN(  88)							int gA = ((color >> 8) & 255);
HXDLIN(  88)							int bA = (color & 255);
HXDLIN(  88)							Float bcx = (bx - dx);
HXDLIN(  88)							Float bcy = (by - dy);
HXDLIN(  88)							Float acx = (ax - dx);
HXDLIN(  88)							Float acy = (ay - dy);
HXDLIN(  88)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  88)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  88)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  88)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  88)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  88)							if ((ax > bx)) {
HXLINE(  88)								if ((ax > dx)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((bx > dx)) {
HXLINE(  88)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::floor(bx);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter3 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  88)								if ((bx > dx)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((ax > dx)) {
HXLINE(  88)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::ceil(ax);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter3 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(ax);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter3 = this1;
            								}
            							}
HXDLIN(  88)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  88)							if ((ay > by)) {
HXLINE(  88)								if ((ay > dy)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((by > dy)) {
HXLINE(  88)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::floor(by);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter3 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  88)								if ((by > dy)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((ay > dy)) {
HXLINE(  88)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::ceil(ay);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter3 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(ay);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter3 = this1;
            								}
            							}
HXDLIN(  88)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  88)							if (hasUndo) {
HXLINE(  88)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  88)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  88)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  88)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  88)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  88)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  88)								undoImage = this3;
HXDLIN(  88)								{
HXLINE(  88)									int rectLeft = xIter3->start;
HXDLIN(  88)									int rectTop = yIter3->start;
HXDLIN(  88)									int rectRight = xIter3->max;
HXDLIN(  88)									bool forceClear = false;
HXDLIN(  88)									{
HXLINE(  88)										int _g = rectTop;
HXDLIN(  88)										int _g1 = yIter3->max;
HXDLIN(  88)										while((_g < _g1)){
HXLINE(  88)											_g = (_g + 1);
HXDLIN(  88)											int dy = (_g - 1);
HXDLIN(  88)											{
HXLINE(  88)												int _g1 = rectLeft;
HXDLIN(  88)												int _g2 = rectRight;
HXDLIN(  88)												while((_g1 < _g2)){
HXLINE(  88)													_g1 = (_g1 + 1);
HXDLIN(  88)													int dx = (_g1 - 1);
HXDLIN(  88)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)													int index;
HXDLIN(  88)													if (pixelImage->useVirtualPos) {
HXLINE(  88)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            													}
            													else {
HXLINE(  88)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            													}
HXDLIN(  88)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int col;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  88)														col = c;
            													}
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if (pixelImage->useMask) {
HXLINE(  88)														_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  88)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  88)														int index;
HXDLIN(  88)														if (this1->useVirtualPos) {
HXLINE(  88)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  88)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  88)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  88)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  88)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)														int v;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  88)															v = c;
            														}
HXDLIN(  88)														int this3 = v;
HXDLIN(  88)														int maskPixel = this3;
HXDLIN(  88)														int this4 = col;
HXDLIN(  88)														int this5 = this4;
HXDLIN(  88)														if ((maskPixel == 0)) {
HXLINE(  88)															int this1 = this5;
HXDLIN(  88)															col = this1;
            														}
            														else {
HXLINE(  88)															Float m0;
HXDLIN(  88)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  88)															if ((this1 == 0)) {
HXLINE(  88)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m1;
HXDLIN(  88)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  88)															if ((this2 == 0)) {
HXLINE(  88)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m2;
HXDLIN(  88)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  88)															if ((this3 == 0)) {
HXLINE(  88)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m3;
HXDLIN(  88)															int this4 = (maskPixel & 255);
HXDLIN(  88)															if ((this4 == 0)) {
HXLINE(  88)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  88)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  88)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  88)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  88)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  88)													if ((col != 0)) {
HXLINE(  88)														int x = (dx - rectLeft);
HXDLIN(  88)														int y = (dy - rectTop);
HXDLIN(  88)														int this1 = col;
HXDLIN(  88)														int c = this1;
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  88)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															int location;
HXDLIN(  88)															if (undoImage->useVirtualPos) {
HXLINE(  88)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  88)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)															int this3 = this2;
HXDLIN(  88)															int this4;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  88)																this4 = this3;
            															}
HXDLIN(  88)															Float a1;
HXDLIN(  88)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  88)															if ((this5 == 0)) {
HXLINE(  88)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r1;
HXDLIN(  88)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  88)															if ((this6 == 0)) {
HXLINE(  88)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g1;
HXDLIN(  88)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  88)															if ((this7 == 0)) {
HXLINE(  88)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b1;
HXDLIN(  88)															int this8 = (this4 & 255);
HXDLIN(  88)															if ((this8 == 0)) {
HXLINE(  88)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a2;
HXDLIN(  88)															int this9 = ((col >> 24) & 255);
HXDLIN(  88)															if ((this9 == 0)) {
HXLINE(  88)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r2;
HXDLIN(  88)															int this10 = ((col >> 16) & 255);
HXDLIN(  88)															if ((this10 == 0)) {
HXLINE(  88)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g2;
HXDLIN(  88)															int this11 = ((col >> 8) & 255);
HXDLIN(  88)															if ((this11 == 0)) {
HXLINE(  88)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b2;
HXDLIN(  88)															int this12 = (col & 255);
HXDLIN(  88)															if ((this12 == 0)) {
HXLINE(  88)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)															{
HXLINE(  88)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  88)																int value;
HXDLIN(  88)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  88)																	value = blended;
            																}
HXDLIN(  88)																bool _hx_tmp;
HXDLIN(  88)																if ((location >= 0)) {
HXLINE(  88)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  88)																	_hx_tmp = false;
            																}
HXDLIN(  88)																if (_hx_tmp) {
HXLINE(  88)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  88)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  88)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  88)															int index;
HXDLIN(  88)															if (undoImage->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = c;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  88)														if (forceClear) {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  88)															int x = (dx - rectLeft);
HXDLIN(  88)															int y = (dy - rectTop);
HXDLIN(  88)															int index;
HXDLIN(  88)															if (undoImage->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  88)							bool found = false;
HXDLIN(  88)							Float min = ( (Float)(0) );
HXDLIN(  88)							Float max = ( (Float)(0) );
HXDLIN(  88)							int a1 = 0;
HXDLIN(  88)							int r = 0;
HXDLIN(  88)							int g = 0;
HXDLIN(  88)							int b = 0;
HXDLIN(  88)							{
HXLINE(  88)								int _g_min = xIter3->start;
HXDLIN(  88)								int _g_max = xIter3->max;
HXDLIN(  88)								while((_g_min < _g_max)){
HXLINE(  88)									_g_min = (_g_min + 1);
HXDLIN(  88)									int px = (_g_min - 1);
HXDLIN(  88)									Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)									found = false;
HXLINE(  88)									{
HXLINE(  88)										int _g_min1 = yIter3->start;
HXDLIN(  88)										int _g_max = yIter3->max;
HXDLIN(  88)										while((_g_min1 < _g_max)){
HXLINE(  88)											_g_min1 = (_g_min1 + 1);
HXDLIN(  88)											int py = (_g_min1 - 1);
HXDLIN(  88)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  88)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  88)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  88)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  88)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  88)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  88)											bool _hx_tmp;
HXDLIN(  88)											bool _hx_tmp1;
HXDLIN(  88)											if ((ratioA >= 0)) {
HXLINE(  88)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  88)												_hx_tmp1 = false;
            											}
HXDLIN(  88)											if (_hx_tmp1) {
HXLINE(  88)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  88)												_hx_tmp = false;
            											}
HXDLIN(  88)											if (_hx_tmp) {
HXLINE( 723)												min = ratioC;
HXLINE(  88)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  88)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  88)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  88)												int this1 = i;
HXDLIN(  88)												a1 = this1;
HXDLIN(  88)												int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  88)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  88)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  88)												int this2 = i1;
HXLINE( 748)												r = this2;
HXLINE(  88)												int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  88)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  88)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  88)												int this3 = i2;
HXLINE( 749)												g = this3;
HXLINE(  88)												int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  88)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  88)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  88)												int this4 = i3;
HXLINE( 750)												b = this4;
HXLINE(  88)												{
HXLINE(  88)													int location;
HXDLIN(  88)													if (pixelImage->useVirtualPos) {
HXLINE(  88)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            													}
            													else {
HXLINE(  88)														location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            													}
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if (pixelImage->transparent) {
HXLINE(  88)														_hx_tmp = (a1 < 254);
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)														int this3 = this2;
HXDLIN(  88)														int old;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  88)															old = this3;
            														}
HXDLIN(  88)														int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)														Float a11;
HXDLIN(  88)														int this4 = ((old >> 24) & 255);
HXDLIN(  88)														if ((this4 == 0)) {
HXLINE(  88)															a11 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float r1;
HXDLIN(  88)														int this5 = ((old >> 16) & 255);
HXDLIN(  88)														if ((this5 == 0)) {
HXLINE(  88)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float g1;
HXDLIN(  88)														int this6 = ((old >> 8) & 255);
HXDLIN(  88)														if ((this6 == 0)) {
HXLINE(  88)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float b1;
HXDLIN(  88)														int this7 = (old & 255);
HXDLIN(  88)														if ((this7 == 0)) {
HXLINE(  88)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float a2;
HXDLIN(  88)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  88)														if ((this8 == 0)) {
HXLINE(  88)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float r2;
HXDLIN(  88)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  88)														if ((this9 == 0)) {
HXLINE(  88)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float g2;
HXDLIN(  88)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  88)														if ((this10 == 0)) {
HXLINE(  88)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float b2;
HXDLIN(  88)														int this11 = (rhs & 255);
HXDLIN(  88)														if ((this11 == 0)) {
HXLINE(  88)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  88)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)														int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  88)														{
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = blended;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((location >= 0)) {
HXLINE(  88)																_hx_tmp = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  88)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)														int value;
HXDLIN(  88)														if (pixelImage->isLittle) {
HXLINE(  88)															value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            														}
            														else {
HXLINE(  88)															value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            														}
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((location >= 0)) {
HXLINE(  88)															_hx_tmp = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 752)												found = true;
            											}
            											else {
HXLINE(  88)												if (found) {
HXLINE(  88)													goto _hx_goto_94;
            												}
            											}
            										}
            										_hx_goto_94:;
            									}
            								}
            							}
            						}
HXDLIN(  88)						{
HXLINE(  88)							bool hasUndo1 = true;
HXDLIN(  88)							int aA1 = ((color >> 24) & 255);
HXDLIN(  88)							int rA1 = ((color >> 16) & 255);
HXDLIN(  88)							int gA1 = ((color >> 8) & 255);
HXDLIN(  88)							int bA1 = (color & 255);
HXDLIN(  88)							Float bcx1 = (cx - dx);
HXDLIN(  88)							Float bcy1 = (cy - dy);
HXDLIN(  88)							Float acx1 = (bx - dx);
HXDLIN(  88)							Float acy1 = (by - dy);
HXDLIN(  88)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  88)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  88)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  88)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  88)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  88)							if ((bx > cx)) {
HXLINE(  88)								if ((bx > dx)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((cx > dx)) {
HXLINE(  88)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::floor(cx);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter31 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(cx);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  88)								if ((cx > dx)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((bx > dx)) {
HXLINE(  88)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter31 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									xIter31 = this1;
            								}
            							}
HXDLIN(  88)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  88)							if ((by > cy)) {
HXLINE(  88)								if ((by > dy)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((cy > dy)) {
HXLINE(  88)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::floor(cy);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter31 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(cy);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  88)								if ((cy > dy)) {
HXLINE(  88)									int min;
HXDLIN(  88)									if ((by > dy)) {
HXLINE(  88)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  88)										min = ::Math_obj::ceil(by);
            									}
HXDLIN(  88)									int ii_min = min;
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter31 = this1;
            								}
            								else {
HXLINE(  88)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  88)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  88)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)									yIter31 = this1;
            								}
            							}
HXDLIN(  88)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  88)							if (hasUndo1) {
HXLINE(  88)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  88)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  88)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  88)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  88)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  88)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  88)								undoImage1 = this3;
HXDLIN(  88)								{
HXLINE(  88)									int rectLeft = xIter31->start;
HXDLIN(  88)									int rectTop = yIter31->start;
HXDLIN(  88)									int rectRight = xIter31->max;
HXDLIN(  88)									bool forceClear = false;
HXDLIN(  88)									{
HXLINE(  88)										int _g = rectTop;
HXDLIN(  88)										int _g1 = yIter31->max;
HXDLIN(  88)										while((_g < _g1)){
HXLINE(  88)											_g = (_g + 1);
HXDLIN(  88)											int dy = (_g - 1);
HXDLIN(  88)											{
HXLINE(  88)												int _g1 = rectLeft;
HXDLIN(  88)												int _g2 = rectRight;
HXDLIN(  88)												while((_g1 < _g2)){
HXLINE(  88)													_g1 = (_g1 + 1);
HXDLIN(  88)													int dx = (_g1 - 1);
HXDLIN(  88)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)													int index;
HXDLIN(  88)													if (pixelImage->useVirtualPos) {
HXLINE(  88)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            													}
            													else {
HXLINE(  88)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            													}
HXDLIN(  88)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int col;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  88)														col = c;
            													}
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if (pixelImage->useMask) {
HXLINE(  88)														_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  88)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  88)														int index;
HXDLIN(  88)														if (this1->useVirtualPos) {
HXLINE(  88)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  88)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  88)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  88)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  88)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)														int v;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  88)															v = c;
            														}
HXDLIN(  88)														int this3 = v;
HXDLIN(  88)														int maskPixel = this3;
HXDLIN(  88)														int this4 = col;
HXDLIN(  88)														int this5 = this4;
HXDLIN(  88)														if ((maskPixel == 0)) {
HXLINE(  88)															int this1 = this5;
HXDLIN(  88)															col = this1;
            														}
            														else {
HXLINE(  88)															Float m0;
HXDLIN(  88)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  88)															if ((this1 == 0)) {
HXLINE(  88)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m1;
HXDLIN(  88)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  88)															if ((this2 == 0)) {
HXLINE(  88)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m2;
HXDLIN(  88)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  88)															if ((this3 == 0)) {
HXLINE(  88)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float m3;
HXDLIN(  88)															int this4 = (maskPixel & 255);
HXDLIN(  88)															if ((this4 == 0)) {
HXLINE(  88)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  88)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  88)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  88)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  88)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  88)													if ((col != 0)) {
HXLINE(  88)														int x = (dx - rectLeft);
HXDLIN(  88)														int y = (dy - rectTop);
HXDLIN(  88)														int this1 = col;
HXDLIN(  88)														int c = this1;
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  88)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															int location;
HXDLIN(  88)															if (undoImage1->useVirtualPos) {
HXLINE(  88)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  88)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)															int this3 = this2;
HXDLIN(  88)															int this4;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  88)																this4 = this3;
            															}
HXDLIN(  88)															Float a1;
HXDLIN(  88)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  88)															if ((this5 == 0)) {
HXLINE(  88)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r1;
HXDLIN(  88)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  88)															if ((this6 == 0)) {
HXLINE(  88)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g1;
HXDLIN(  88)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  88)															if ((this7 == 0)) {
HXLINE(  88)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b1;
HXDLIN(  88)															int this8 = (this4 & 255);
HXDLIN(  88)															if ((this8 == 0)) {
HXLINE(  88)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a2;
HXDLIN(  88)															int this9 = ((col >> 24) & 255);
HXDLIN(  88)															if ((this9 == 0)) {
HXLINE(  88)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float r2;
HXDLIN(  88)															int this10 = ((col >> 16) & 255);
HXDLIN(  88)															if ((this10 == 0)) {
HXLINE(  88)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float g2;
HXDLIN(  88)															int this11 = ((col >> 8) & 255);
HXDLIN(  88)															if ((this11 == 0)) {
HXLINE(  88)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float b2;
HXDLIN(  88)															int this12 = (col & 255);
HXDLIN(  88)															if ((this12 == 0)) {
HXLINE(  88)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  88)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  88)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)															{
HXLINE(  88)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  88)																int value;
HXDLIN(  88)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  88)																	value = blended;
            																}
HXDLIN(  88)																bool _hx_tmp;
HXDLIN(  88)																if ((location >= 0)) {
HXLINE(  88)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  88)																	_hx_tmp = false;
            																}
HXDLIN(  88)																if (_hx_tmp) {
HXLINE(  88)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  88)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  88)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  88)															int index;
HXDLIN(  88)															if (undoImage1->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = c;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  88)														if (forceClear) {
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  88)															int x = (dx - rectLeft);
HXDLIN(  88)															int y = (dy - rectTop);
HXDLIN(  88)															int index;
HXDLIN(  88)															if (undoImage1->useVirtualPos) {
HXLINE(  88)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  88)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((index >= 0)) {
HXLINE(  88)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  88)							bool found1 = false;
HXDLIN(  88)							Float min1 = ( (Float)(0) );
HXDLIN(  88)							Float max1 = ( (Float)(0) );
HXDLIN(  88)							int a2 = 0;
HXDLIN(  88)							int r1 = 0;
HXDLIN(  88)							int g1 = 0;
HXDLIN(  88)							int b1 = 0;
HXDLIN(  88)							{
HXLINE(  88)								int _g_min1 = xIter31->start;
HXDLIN(  88)								int _g_max1 = xIter31->max;
HXDLIN(  88)								while((_g_min1 < _g_max1)){
HXLINE(  88)									_g_min1 = (_g_min1 + 1);
HXDLIN(  88)									int px = (_g_min1 - 1);
HXDLIN(  88)									Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)									found1 = false;
HXLINE(  88)									{
HXLINE(  88)										int _g_min = yIter31->start;
HXDLIN(  88)										int _g_max = yIter31->max;
HXDLIN(  88)										while((_g_min < _g_max)){
HXLINE(  88)											_g_min = (_g_min + 1);
HXDLIN(  88)											int py = (_g_min - 1);
HXDLIN(  88)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  88)											Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  88)											Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  88)											Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  88)											Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  88)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  88)											bool _hx_tmp;
HXDLIN(  88)											bool _hx_tmp1;
HXDLIN(  88)											if ((ratioA >= 0)) {
HXLINE(  88)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  88)												_hx_tmp1 = false;
            											}
HXDLIN(  88)											if (_hx_tmp1) {
HXLINE(  88)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  88)												_hx_tmp = false;
            											}
HXDLIN(  88)											if (_hx_tmp) {
HXLINE( 713)												min1 = ratioB;
HXLINE(  88)												int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  88)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  88)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  88)												int this1 = i;
HXDLIN(  88)												a2 = this1;
HXDLIN(  88)												int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  88)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  88)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  88)												int this2 = i1;
HXLINE( 748)												r1 = this2;
HXLINE(  88)												int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  88)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  88)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  88)												int this3 = i2;
HXLINE( 749)												g1 = this3;
HXLINE(  88)												int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  88)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  88)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  88)												int this4 = i3;
HXLINE( 750)												b1 = this4;
HXLINE(  88)												{
HXLINE(  88)													int location;
HXDLIN(  88)													if (pixelImage->useVirtualPos) {
HXLINE(  88)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            													}
            													else {
HXLINE(  88)														location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            													}
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if (pixelImage->transparent) {
HXLINE(  88)														_hx_tmp = (a2 < 254);
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)														int this3 = this2;
HXDLIN(  88)														int old;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  88)															old = this3;
            														}
HXDLIN(  88)														int rhs = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  88)														Float a1;
HXDLIN(  88)														int this4 = ((old >> 24) & 255);
HXDLIN(  88)														if ((this4 == 0)) {
HXLINE(  88)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float r11;
HXDLIN(  88)														int this5 = ((old >> 16) & 255);
HXDLIN(  88)														if ((this5 == 0)) {
HXLINE(  88)															r11 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float g11;
HXDLIN(  88)														int this6 = ((old >> 8) & 255);
HXDLIN(  88)														if ((this6 == 0)) {
HXLINE(  88)															g11 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float b11;
HXDLIN(  88)														int this7 = (old & 255);
HXDLIN(  88)														if ((this7 == 0)) {
HXLINE(  88)															b11 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float a21;
HXDLIN(  88)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  88)														if ((this8 == 0)) {
HXLINE(  88)															a21 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															a21 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float r2;
HXDLIN(  88)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  88)														if ((this9 == 0)) {
HXLINE(  88)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float g2;
HXDLIN(  88)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  88)														if ((this10 == 0)) {
HXLINE(  88)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float b2;
HXDLIN(  88)														int this11 = (rhs & 255);
HXDLIN(  88)														if ((this11 == 0)) {
HXLINE(  88)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float a3 = (a1 * (( (Float)(1) ) - a21));
HXDLIN(  88)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a21))));
HXDLIN(  88)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a21))));
HXDLIN(  88)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a21))));
HXDLIN(  88)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a21)));
HXDLIN(  88)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)														{
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = blended;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((location >= 0)) {
HXLINE(  88)																_hx_tmp = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  88)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)														int value;
HXDLIN(  88)														if (pixelImage->isLittle) {
HXLINE(  88)															value = ((((a2 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            														}
            														else {
HXLINE(  88)															value = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            														}
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((location >= 0)) {
HXLINE(  88)															_hx_tmp = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 752)												found1 = true;
            											}
            											else {
HXLINE(  88)												if (found1) {
HXLINE(  88)													goto _hx_goto_98;
            												}
            											}
            										}
            										_hx_goto_98:;
            									}
            								}
            							}
            						}
HXDLIN(  88)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  88)						::pixelimage::algo::HitQuad hitQuad = v;
HXDLIN(  88)						Float cx1 = h2;
HXDLIN(  88)						Float cy1 = radius2;
HXDLIN(  88)						Float bx1 = h2;
HXDLIN(  88)						Float by1 = -(radius2);
HXDLIN(  88)						Float dx1 = hSmall;
HXDLIN(  88)						Float dy1 = radius2;
HXDLIN(  88)						Float ax1 = hSmall;
HXDLIN(  88)						Float ay1 = -(radius2);
HXLINE( 669)						temp = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE( 670)						by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE( 671)						bx1 = temp;
HXLINE( 672)						temp = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE( 673)						cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE( 674)						cx1 = temp;
HXLINE( 676)						temp = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE( 677)						ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE( 678)						ax1 = temp;
HXLINE( 680)						temp = (px + ((dx1 * cos) - (dy1 * sin)));
HXLINE( 681)						dy1 = (py + ((dy1 * cos) + (dx1 * sin)));
HXLINE( 682)						dx1 = temp;
HXLINE(  88)						Float soft3 = ( (Float)(40) );
HXDLIN(  88)						bool hasUndo2 = true;
HXDLIN(  88)						int aA2 = ((color >> 24) & 255);
HXDLIN(  88)						int rA2 = ((color >> 16) & 255);
HXDLIN(  88)						int gA2 = ((color >> 8) & 255);
HXDLIN(  88)						int bA2 = (color & 255);
HXDLIN(  88)						Float bcx2 = (bx1 - cx1);
HXDLIN(  88)						Float bcy2 = (by1 - cy1);
HXDLIN(  88)						Float acx2 = (px - cx1);
HXDLIN(  88)						Float acy2 = (py - cy1);
HXDLIN(  88)						Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  88)						Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  88)						Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  88)						Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  88)						::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  88)						if ((px > bx1)) {
HXLINE(  88)							if ((px > cx1)) {
HXLINE(  88)								int min;
HXDLIN(  88)								if ((bx1 > cx1)) {
HXLINE(  88)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  88)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN(  88)								int ii_min = min;
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(px);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								xIter32 = this1;
            							}
            							else {
HXLINE(  88)								int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								xIter32 = this1;
            							}
            						}
            						else {
HXLINE(  88)							if ((bx1 > cx1)) {
HXLINE(  88)								int min;
HXDLIN(  88)								if ((px > cx1)) {
HXLINE(  88)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  88)									min = ::Math_obj::ceil(px);
            								}
HXDLIN(  88)								int ii_min = min;
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								xIter32 = this1;
            							}
            							else {
HXLINE(  88)								int ii_min = ::Math_obj::floor(px);
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								xIter32 = this1;
            							}
            						}
HXDLIN(  88)						::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  88)						if ((py > by1)) {
HXLINE(  88)							if ((py > cy1)) {
HXLINE(  88)								int min;
HXDLIN(  88)								if ((by1 > cy1)) {
HXLINE(  88)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  88)									min = ::Math_obj::floor(by1);
            								}
HXDLIN(  88)								int ii_min = min;
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(py);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								yIter32 = this1;
            							}
            							else {
HXLINE(  88)								int ii_min = ::Math_obj::floor(by1);
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								yIter32 = this1;
            							}
            						}
            						else {
HXLINE(  88)							if ((by1 > cy1)) {
HXLINE(  88)								int min;
HXDLIN(  88)								if ((py > cy1)) {
HXLINE(  88)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  88)									min = ::Math_obj::ceil(py);
            								}
HXDLIN(  88)								int ii_min = min;
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								yIter32 = this1;
            							}
            							else {
HXLINE(  88)								int ii_min = ::Math_obj::floor(py);
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								yIter32 = this1;
            							}
            						}
HXDLIN(  88)						::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  88)						if (hasUndo2) {
HXLINE(  88)							int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  88)							int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  88)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  88)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  88)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  88)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  88)							undoImage2 = this3;
HXDLIN(  88)							{
HXLINE(  88)								int rectLeft = xIter32->start;
HXDLIN(  88)								int rectTop = yIter32->start;
HXDLIN(  88)								int rectRight = xIter32->max;
HXDLIN(  88)								bool forceClear = false;
HXDLIN(  88)								{
HXLINE(  88)									int _g = rectTop;
HXDLIN(  88)									int _g1 = yIter32->max;
HXDLIN(  88)									while((_g < _g1)){
HXLINE(  88)										_g = (_g + 1);
HXDLIN(  88)										int dy = (_g - 1);
HXDLIN(  88)										{
HXLINE(  88)											int _g1 = rectLeft;
HXDLIN(  88)											int _g2 = rectRight;
HXDLIN(  88)											while((_g1 < _g2)){
HXLINE(  88)												_g1 = (_g1 + 1);
HXDLIN(  88)												int dx = (_g1 - 1);
HXDLIN(  88)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)												int index;
HXDLIN(  88)												if (pixelImage->useVirtualPos) {
HXLINE(  88)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  88)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN(  88)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)												int col;
HXDLIN(  88)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  88)													col = c;
            												}
HXDLIN(  88)												bool _hx_tmp;
HXDLIN(  88)												if (pixelImage->useMask) {
HXLINE(  88)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE(  88)													_hx_tmp = false;
            												}
HXDLIN(  88)												if (_hx_tmp) {
HXLINE(  88)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  88)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  88)													int index;
HXDLIN(  88)													if (this1->useVirtualPos) {
HXLINE(  88)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  88)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  88)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  88)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  88)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int v;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  88)														v = c;
            													}
HXDLIN(  88)													int this3 = v;
HXDLIN(  88)													int maskPixel = this3;
HXDLIN(  88)													int this4 = col;
HXDLIN(  88)													int this5 = this4;
HXDLIN(  88)													if ((maskPixel == 0)) {
HXLINE(  88)														int this1 = this5;
HXDLIN(  88)														col = this1;
            													}
            													else {
HXLINE(  88)														Float m0;
HXDLIN(  88)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  88)														if ((this1 == 0)) {
HXLINE(  88)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float m1;
HXDLIN(  88)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  88)														if ((this2 == 0)) {
HXLINE(  88)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float m2;
HXDLIN(  88)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  88)														if ((this3 == 0)) {
HXLINE(  88)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float m3;
HXDLIN(  88)														int this4 = (maskPixel & 255);
HXDLIN(  88)														if ((this4 == 0)) {
HXLINE(  88)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  88)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  88)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  88)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  88)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  88)												if ((col != 0)) {
HXLINE(  88)													int x = (dx - rectLeft);
HXDLIN(  88)													int y = (dy - rectTop);
HXDLIN(  88)													int this1 = col;
HXDLIN(  88)													int c = this1;
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  88)														_hx_tmp = undoImage2->transparent;
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														int location;
HXDLIN(  88)														if (undoImage2->useVirtualPos) {
HXLINE(  88)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE(  88)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN(  88)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  88)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)														int this3 = this2;
HXDLIN(  88)														int this4;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  88)															this4 = this3;
            														}
HXDLIN(  88)														Float a1;
HXDLIN(  88)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  88)														if ((this5 == 0)) {
HXLINE(  88)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float r1;
HXDLIN(  88)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  88)														if ((this6 == 0)) {
HXLINE(  88)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float g1;
HXDLIN(  88)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  88)														if ((this7 == 0)) {
HXLINE(  88)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float b1;
HXDLIN(  88)														int this8 = (this4 & 255);
HXDLIN(  88)														if ((this8 == 0)) {
HXLINE(  88)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float a2;
HXDLIN(  88)														int this9 = ((col >> 24) & 255);
HXDLIN(  88)														if ((this9 == 0)) {
HXLINE(  88)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float r2;
HXDLIN(  88)														int this10 = ((col >> 16) & 255);
HXDLIN(  88)														if ((this10 == 0)) {
HXLINE(  88)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float g2;
HXDLIN(  88)														int this11 = ((col >> 8) & 255);
HXDLIN(  88)														if ((this11 == 0)) {
HXLINE(  88)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float b2;
HXDLIN(  88)														int this12 = (col & 255);
HXDLIN(  88)														if ((this12 == 0)) {
HXLINE(  88)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)														{
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = blended;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((location >= 0)) {
HXLINE(  88)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  88)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  88)														int index;
HXDLIN(  88)														if (undoImage2->useVirtualPos) {
HXLINE(  88)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE(  88)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN(  88)														int value;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  88)															value = c;
            														}
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((index >= 0)) {
HXLINE(  88)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  88)													if (forceClear) {
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  88)														int x = (dx - rectLeft);
HXDLIN(  88)														int y = (dy - rectTop);
HXDLIN(  88)														int index;
HXDLIN(  88)														if (undoImage2->useVirtualPos) {
HXLINE(  88)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE(  88)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((index >= 0)) {
HXLINE(  88)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  88)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  88)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  88)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  88)						bool found2 = false;
HXDLIN(  88)						Float min2 = ( (Float)(0) );
HXDLIN(  88)						Float max2 = ( (Float)(0) );
HXDLIN(  88)						int a3 = 0;
HXDLIN(  88)						int r2 = 0;
HXDLIN(  88)						int g2 = 0;
HXDLIN(  88)						int b2 = 0;
HXDLIN(  88)						{
HXLINE(  88)							int _g_min2 = xIter32->start;
HXDLIN(  88)							int _g_max2 = xIter32->max;
HXDLIN(  88)							while((_g_min2 < _g_max2)){
HXLINE(  88)								_g_min2 = (_g_min2 + 1);
HXDLIN(  88)								int px = (_g_min2 - 1);
HXDLIN(  88)								Float pcx = (( (Float)(px) ) - cx1);
HXLINE( 696)								found2 = false;
HXLINE(  88)								{
HXLINE(  88)									int _g_min = yIter32->start;
HXDLIN(  88)									int _g_max = yIter32->max;
HXDLIN(  88)									while((_g_min < _g_max)){
HXLINE(  88)										_g_min = (_g_min + 1);
HXDLIN(  88)										int py = (_g_min - 1);
HXDLIN(  88)										Float pcy = (( (Float)(py) ) - cy1);
HXDLIN(  88)										Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  88)										Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  88)										Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  88)										Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  88)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  88)										bool _hx_tmp;
HXDLIN(  88)										bool _hx_tmp1;
HXDLIN(  88)										if ((ratioA >= 0)) {
HXLINE(  88)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  88)											_hx_tmp1 = false;
            										}
HXDLIN(  88)										if (_hx_tmp1) {
HXLINE(  88)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  88)											_hx_tmp = false;
            										}
HXDLIN(  88)										if (_hx_tmp) {
HXLINE(  88)											Float min;
HXDLIN(  88)											if ((ratioA < ratioB)) {
HXLINE(  88)												min = ratioA;
            											}
            											else {
HXLINE(  88)												min = ratioB;
            											}
HXDLIN(  88)											if (!((min < ratioC))) {
HXLINE(  88)												min = ratioC;
            											}
HXDLIN(  88)											Float max;
HXDLIN(  88)											if ((ratioA > ratioB)) {
HXLINE(  88)												max = ratioA;
            											}
            											else {
HXLINE(  88)												max = ratioB;
            											}
HXDLIN(  88)											if (!((max > ratioC))) {
HXLINE(  88)												max = ratioC;
            											}
HXLINE( 744)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  88)											Float min1;
HXDLIN(  88)											if ((min < max)) {
HXLINE(  88)												min1 = min;
            											}
            											else {
HXLINE(  88)												min1 = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  88)											int i = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft3) * min1));
HXDLIN(  88)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  88)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  88)											int this1 = i;
HXDLIN(  88)											a3 = this1;
HXDLIN(  88)											int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  88)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  88)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  88)											int this2 = i1;
HXLINE( 748)											r2 = this2;
HXLINE(  88)											int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  88)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  88)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  88)											int this3 = i2;
HXLINE( 749)											g2 = this3;
HXLINE(  88)											int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  88)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  88)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  88)											int this4 = i3;
HXLINE( 750)											b2 = this4;
HXLINE(  88)											{
HXLINE(  88)												int location;
HXDLIN(  88)												if (pixelImage->useVirtualPos) {
HXLINE(  88)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  88)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            												}
HXDLIN(  88)												bool _hx_tmp;
HXDLIN(  88)												if (pixelImage->transparent) {
HXLINE(  88)													_hx_tmp = (a3 < 254);
            												}
            												else {
HXLINE(  88)													_hx_tmp = false;
            												}
HXDLIN(  88)												if (_hx_tmp) {
HXLINE(  88)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int this3 = this2;
HXDLIN(  88)													int old;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  88)														old = this3;
            													}
HXDLIN(  88)													int rhs = ((((a3 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
HXDLIN(  88)													Float a1;
HXDLIN(  88)													int this4 = ((old >> 24) & 255);
HXDLIN(  88)													if ((this4 == 0)) {
HXLINE(  88)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float r1;
HXDLIN(  88)													int this5 = ((old >> 16) & 255);
HXDLIN(  88)													if ((this5 == 0)) {
HXLINE(  88)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float g1;
HXDLIN(  88)													int this6 = ((old >> 8) & 255);
HXDLIN(  88)													if ((this6 == 0)) {
HXLINE(  88)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float b1;
HXDLIN(  88)													int this7 = (old & 255);
HXDLIN(  88)													if ((this7 == 0)) {
HXLINE(  88)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float a2;
HXDLIN(  88)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  88)													if ((this8 == 0)) {
HXLINE(  88)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float r21;
HXDLIN(  88)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  88)													if ((this9 == 0)) {
HXLINE(  88)														r21 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														r21 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float g21;
HXDLIN(  88)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  88)													if ((this10 == 0)) {
HXLINE(  88)														g21 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														g21 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float b21;
HXDLIN(  88)													int this11 = (rhs & 255);
HXDLIN(  88)													if ((this11 == 0)) {
HXLINE(  88)														b21 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														b21 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float a31 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a31) + (r21 * a2))));
HXDLIN(  88)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a31) + (g21 * a2))));
HXDLIN(  88)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a31) + (b21 * a2))));
HXDLIN(  88)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a2)));
HXDLIN(  88)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)													{
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  88)														int value;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  88)															value = blended;
            														}
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((location >= 0)) {
HXLINE(  88)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  88)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  88)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)													int value;
HXDLIN(  88)													if (pixelImage->isLittle) {
HXLINE(  88)														value = ((((a3 << 24) | (b2 << 16)) | (g2 << 8)) | r2);
            													}
            													else {
HXLINE(  88)														value = ((((a3 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
            													}
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if ((location >= 0)) {
HXLINE(  88)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 752)											found2 = true;
            										}
            										else {
HXLINE(  88)											if (found2) {
HXLINE(  88)												goto _hx_goto_102;
            											}
            										}
            									}
            									_hx_goto_102:;
            								}
            							}
            						}
HXDLIN(  88)						::pixelimage::algo::HitTri hitTriTop;
HXDLIN(  88)						if ((hasHit == false)) {
HXLINE(  88)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx1,by1,cx1,cy1,true);
HXDLIN(  88)							if (hasUndo2) {
HXLINE(  88)								v->undoImage = undoImage2;
HXDLIN(  88)								v->undoX = xIter32->start;
HXDLIN(  88)								v->undoY = yIter32->start;
            							}
HXDLIN(  88)							hitTriTop = v;
            						}
            						else {
HXLINE(  88)							hitTriTop = null();
            						}
HXDLIN(  88)						Float soft31 = ( (Float)(40) );
HXDLIN(  88)						bool hasUndo3 = true;
HXDLIN(  88)						int aA3 = ((color >> 24) & 255);
HXDLIN(  88)						int rA3 = ((color >> 16) & 255);
HXDLIN(  88)						int gA3 = ((color >> 8) & 255);
HXDLIN(  88)						int bA3 = (color & 255);
HXDLIN(  88)						Float bcx3 = (ax1 - dx1);
HXDLIN(  88)						Float bcy3 = (ay1 - dy1);
HXDLIN(  88)						Float acx3 = (px - dx1);
HXDLIN(  88)						Float acy3 = (py - dy1);
HXDLIN(  88)						Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  88)						Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  88)						Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  88)						Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  88)						::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  88)						if ((px > ax1)) {
HXLINE(  88)							if ((px > dx1)) {
HXLINE(  88)								int min;
HXDLIN(  88)								if ((ax1 > dx1)) {
HXLINE(  88)									min = ::Math_obj::floor(dx1);
            								}
            								else {
HXLINE(  88)									min = ::Math_obj::floor(ax1);
            								}
HXDLIN(  88)								int ii_min = min;
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(px);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								xIter33 = this1;
            							}
            							else {
HXLINE(  88)								int ii_min = ::Math_obj::floor(ax1);
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(dx1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								xIter33 = this1;
            							}
            						}
            						else {
HXLINE(  88)							if ((ax1 > dx1)) {
HXLINE(  88)								int min;
HXDLIN(  88)								if ((px > dx1)) {
HXLINE(  88)									min = ::Math_obj::floor(dx1);
            								}
            								else {
HXLINE(  88)									min = ::Math_obj::ceil(px);
            								}
HXDLIN(  88)								int ii_min = min;
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(ax1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								xIter33 = this1;
            							}
            							else {
HXLINE(  88)								int ii_min = ::Math_obj::floor(px);
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(dx1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								xIter33 = this1;
            							}
            						}
HXDLIN(  88)						::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  88)						if ((py > ay1)) {
HXLINE(  88)							if ((py > dy1)) {
HXLINE(  88)								int min;
HXDLIN(  88)								if ((ay1 > dy1)) {
HXLINE(  88)									min = ::Math_obj::floor(dy1);
            								}
            								else {
HXLINE(  88)									min = ::Math_obj::floor(ay1);
            								}
HXDLIN(  88)								int ii_min = min;
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(py);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								yIter33 = this1;
            							}
            							else {
HXLINE(  88)								int ii_min = ::Math_obj::floor(ay1);
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(dy1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								yIter33 = this1;
            							}
            						}
            						else {
HXLINE(  88)							if ((ay1 > dy1)) {
HXLINE(  88)								int min;
HXDLIN(  88)								if ((py > dy1)) {
HXLINE(  88)									min = ::Math_obj::floor(dy1);
            								}
            								else {
HXLINE(  88)									min = ::Math_obj::ceil(py);
            								}
HXDLIN(  88)								int ii_min = min;
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(ay1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								yIter33 = this1;
            							}
            							else {
HXLINE(  88)								int ii_min = ::Math_obj::floor(py);
HXDLIN(  88)								int ii_max = ::Math_obj::ceil(dy1);
HXDLIN(  88)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  88)								yIter33 = this1;
            							}
            						}
HXDLIN(  88)						::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  88)						if (hasUndo3) {
HXLINE(  88)							int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  88)							int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  88)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  88)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  88)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  88)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  88)							undoImage3 = this3;
HXDLIN(  88)							{
HXLINE(  88)								int rectLeft = xIter33->start;
HXDLIN(  88)								int rectTop = yIter33->start;
HXDLIN(  88)								int rectRight = xIter33->max;
HXDLIN(  88)								bool forceClear = false;
HXDLIN(  88)								{
HXLINE(  88)									int _g = rectTop;
HXDLIN(  88)									int _g1 = yIter33->max;
HXDLIN(  88)									while((_g < _g1)){
HXLINE(  88)										_g = (_g + 1);
HXDLIN(  88)										int dy = (_g - 1);
HXDLIN(  88)										{
HXLINE(  88)											int _g1 = rectLeft;
HXDLIN(  88)											int _g2 = rectRight;
HXDLIN(  88)											while((_g1 < _g2)){
HXLINE(  88)												_g1 = (_g1 + 1);
HXDLIN(  88)												int dx = (_g1 - 1);
HXDLIN(  88)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)												int index;
HXDLIN(  88)												if (pixelImage->useVirtualPos) {
HXLINE(  88)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  88)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN(  88)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)												int col;
HXDLIN(  88)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  88)													col = c;
            												}
HXDLIN(  88)												bool _hx_tmp;
HXDLIN(  88)												if (pixelImage->useMask) {
HXLINE(  88)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE(  88)													_hx_tmp = false;
            												}
HXDLIN(  88)												if (_hx_tmp) {
HXLINE(  88)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  88)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  88)													int index;
HXDLIN(  88)													if (this1->useVirtualPos) {
HXLINE(  88)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  88)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  88)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  88)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  88)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int v;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  88)														v = c;
            													}
HXDLIN(  88)													int this3 = v;
HXDLIN(  88)													int maskPixel = this3;
HXDLIN(  88)													int this4 = col;
HXDLIN(  88)													int this5 = this4;
HXDLIN(  88)													if ((maskPixel == 0)) {
HXLINE(  88)														int this1 = this5;
HXDLIN(  88)														col = this1;
            													}
            													else {
HXLINE(  88)														Float m0;
HXDLIN(  88)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  88)														if ((this1 == 0)) {
HXLINE(  88)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float m1;
HXDLIN(  88)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  88)														if ((this2 == 0)) {
HXLINE(  88)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float m2;
HXDLIN(  88)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  88)														if ((this3 == 0)) {
HXLINE(  88)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float m3;
HXDLIN(  88)														int this4 = (maskPixel & 255);
HXDLIN(  88)														if ((this4 == 0)) {
HXLINE(  88)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  88)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  88)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  88)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  88)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  88)												if ((col != 0)) {
HXLINE(  88)													int x = (dx - rectLeft);
HXDLIN(  88)													int y = (dy - rectTop);
HXDLIN(  88)													int this1 = col;
HXDLIN(  88)													int c = this1;
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  88)														_hx_tmp = undoImage3->transparent;
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														int location;
HXDLIN(  88)														if (undoImage3->useVirtualPos) {
HXLINE(  88)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  88)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN(  88)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  88)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)														int this3 = this2;
HXDLIN(  88)														int this4;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  88)															this4 = this3;
            														}
HXDLIN(  88)														Float a1;
HXDLIN(  88)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  88)														if ((this5 == 0)) {
HXLINE(  88)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float r1;
HXDLIN(  88)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  88)														if ((this6 == 0)) {
HXLINE(  88)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float g1;
HXDLIN(  88)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  88)														if ((this7 == 0)) {
HXLINE(  88)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float b1;
HXDLIN(  88)														int this8 = (this4 & 255);
HXDLIN(  88)														if ((this8 == 0)) {
HXLINE(  88)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float a2;
HXDLIN(  88)														int this9 = ((col >> 24) & 255);
HXDLIN(  88)														if ((this9 == 0)) {
HXLINE(  88)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float r2;
HXDLIN(  88)														int this10 = ((col >> 16) & 255);
HXDLIN(  88)														if ((this10 == 0)) {
HXLINE(  88)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float g2;
HXDLIN(  88)														int this11 = ((col >> 8) & 255);
HXDLIN(  88)														if ((this11 == 0)) {
HXLINE(  88)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float b2;
HXDLIN(  88)														int this12 = (col & 255);
HXDLIN(  88)														if ((this12 == 0)) {
HXLINE(  88)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  88)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  88)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)														{
HXLINE(  88)															::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  88)															int value;
HXDLIN(  88)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  88)																value = blended;
            															}
HXDLIN(  88)															bool _hx_tmp;
HXDLIN(  88)															if ((location >= 0)) {
HXLINE(  88)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  88)																_hx_tmp = false;
            															}
HXDLIN(  88)															if (_hx_tmp) {
HXLINE(  88)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  88)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  88)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  88)														int index;
HXDLIN(  88)														if (undoImage3->useVirtualPos) {
HXLINE(  88)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  88)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN(  88)														int value;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  88)															value = c;
            														}
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((index >= 0)) {
HXLINE(  88)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  88)													if (forceClear) {
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  88)														int x = (dx - rectLeft);
HXDLIN(  88)														int y = (dy - rectTop);
HXDLIN(  88)														int index;
HXDLIN(  88)														if (undoImage3->useVirtualPos) {
HXLINE(  88)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  88)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((index >= 0)) {
HXLINE(  88)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  88)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  88)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  88)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  88)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  88)						bool found3 = false;
HXDLIN(  88)						Float min3 = ( (Float)(0) );
HXDLIN(  88)						Float max3 = ( (Float)(0) );
HXDLIN(  88)						int a4 = 0;
HXDLIN(  88)						int r3 = 0;
HXDLIN(  88)						int g3 = 0;
HXDLIN(  88)						int b3 = 0;
HXDLIN(  88)						{
HXLINE(  88)							int _g_min3 = xIter33->start;
HXDLIN(  88)							int _g_max3 = xIter33->max;
HXDLIN(  88)							while((_g_min3 < _g_max3)){
HXLINE(  88)								_g_min3 = (_g_min3 + 1);
HXDLIN(  88)								int px = (_g_min3 - 1);
HXDLIN(  88)								Float pcx = (( (Float)(px) ) - dx1);
HXLINE( 696)								found3 = false;
HXLINE(  88)								{
HXLINE(  88)									int _g_min = yIter33->start;
HXDLIN(  88)									int _g_max = yIter33->max;
HXDLIN(  88)									while((_g_min < _g_max)){
HXLINE(  88)										_g_min = (_g_min + 1);
HXDLIN(  88)										int py = (_g_min - 1);
HXDLIN(  88)										Float pcy = (( (Float)(py) ) - dy1);
HXDLIN(  88)										Float dot31 = ((pcx * bcx3) + (pcy * bcy3));
HXDLIN(  88)										Float dot32 = ((pcx * acx3) + (pcy * acy3));
HXDLIN(  88)										Float ratioA = (((dot223 * dot31) - (dot123 * dot32)) * denom13);
HXDLIN(  88)										Float ratioB = (((dot113 * dot32) - (dot123 * dot31)) * denom13);
HXDLIN(  88)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  88)										bool _hx_tmp;
HXDLIN(  88)										bool _hx_tmp1;
HXDLIN(  88)										if ((ratioA >= 0)) {
HXLINE(  88)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  88)											_hx_tmp1 = false;
            										}
HXDLIN(  88)										if (_hx_tmp1) {
HXLINE(  88)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  88)											_hx_tmp = false;
            										}
HXDLIN(  88)										if (_hx_tmp) {
HXLINE(  88)											Float min;
HXDLIN(  88)											if ((ratioA < ratioB)) {
HXLINE(  88)												min = ratioA;
            											}
            											else {
HXLINE(  88)												min = ratioB;
            											}
HXDLIN(  88)											if (!((min < ratioC))) {
HXLINE(  88)												min = ratioC;
            											}
HXDLIN(  88)											Float max;
HXDLIN(  88)											if ((ratioA > ratioB)) {
HXLINE(  88)												max = ratioA;
            											}
            											else {
HXLINE(  88)												max = ratioB;
            											}
HXDLIN(  88)											if (!((max > ratioC))) {
HXLINE(  88)												max = ratioC;
            											}
HXLINE( 744)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  88)											Float min1;
HXDLIN(  88)											if ((min < max)) {
HXLINE(  88)												min1 = min;
            											}
            											else {
HXLINE(  88)												min1 = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  88)											int i = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft31) * min1));
HXDLIN(  88)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  88)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  88)											int this1 = i;
HXDLIN(  88)											a4 = this1;
HXDLIN(  88)											int i1 = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN(  88)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  88)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  88)											int this2 = i1;
HXLINE( 748)											r3 = this2;
HXLINE(  88)											int i2 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN(  88)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  88)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  88)											int this3 = i2;
HXLINE( 749)											g3 = this3;
HXLINE(  88)											int i3 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN(  88)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  88)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  88)											int this4 = i3;
HXLINE( 750)											b3 = this4;
HXLINE(  88)											{
HXLINE(  88)												int location;
HXDLIN(  88)												if (pixelImage->useVirtualPos) {
HXLINE(  88)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  88)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            												}
HXDLIN(  88)												bool _hx_tmp;
HXDLIN(  88)												if (pixelImage->transparent) {
HXLINE(  88)													_hx_tmp = (a4 < 254);
            												}
            												else {
HXLINE(  88)													_hx_tmp = false;
            												}
HXDLIN(  88)												if (_hx_tmp) {
HXLINE(  88)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  88)													int this3 = this2;
HXDLIN(  88)													int old;
HXDLIN(  88)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  88)														old = this3;
            													}
HXDLIN(  88)													int rhs = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  88)													Float a1;
HXDLIN(  88)													int this4 = ((old >> 24) & 255);
HXDLIN(  88)													if ((this4 == 0)) {
HXLINE(  88)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float r1;
HXDLIN(  88)													int this5 = ((old >> 16) & 255);
HXDLIN(  88)													if ((this5 == 0)) {
HXLINE(  88)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float g1;
HXDLIN(  88)													int this6 = ((old >> 8) & 255);
HXDLIN(  88)													if ((this6 == 0)) {
HXLINE(  88)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float b1;
HXDLIN(  88)													int this7 = (old & 255);
HXDLIN(  88)													if ((this7 == 0)) {
HXLINE(  88)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float a2;
HXDLIN(  88)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  88)													if ((this8 == 0)) {
HXLINE(  88)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float r2;
HXDLIN(  88)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  88)													if ((this9 == 0)) {
HXLINE(  88)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float g2;
HXDLIN(  88)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  88)													if ((this10 == 0)) {
HXLINE(  88)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float b2;
HXDLIN(  88)													int this11 = (rhs & 255);
HXDLIN(  88)													if ((this11 == 0)) {
HXLINE(  88)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  88)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  88)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  88)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  88)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)													{
HXLINE(  88)														::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  88)														int value;
HXDLIN(  88)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  88)															value = blended;
            														}
HXDLIN(  88)														bool _hx_tmp;
HXDLIN(  88)														if ((location >= 0)) {
HXLINE(  88)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  88)															_hx_tmp = false;
            														}
HXDLIN(  88)														if (_hx_tmp) {
HXLINE(  88)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  88)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  88)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  88)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  88)													int value;
HXDLIN(  88)													if (pixelImage->isLittle) {
HXLINE(  88)														value = ((((a4 << 24) | (b3 << 16)) | (g3 << 8)) | r3);
            													}
            													else {
HXLINE(  88)														value = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
            													}
HXDLIN(  88)													bool _hx_tmp;
HXDLIN(  88)													if ((location >= 0)) {
HXLINE(  88)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  88)														_hx_tmp = false;
            													}
HXDLIN(  88)													if (_hx_tmp) {
HXLINE(  88)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  88)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  88)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  88)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  88)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  88)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 752)											found3 = true;
            										}
            										else {
HXLINE(  88)											if (found3) {
HXLINE(  88)												goto _hx_goto_106;
            											}
            										}
            									}
            									_hx_goto_106:;
            								}
            							}
            						}
HXDLIN(  88)						::pixelimage::algo::HitTri hitTriBottom;
HXDLIN(  88)						if ((hasHit == false)) {
HXLINE(  88)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,ax1,ay1,dx1,dy1,true);
HXDLIN(  88)							if (hasUndo3) {
HXLINE(  88)								v->undoImage = undoImage3;
HXDLIN(  88)								v->undoX = xIter33->start;
HXDLIN(  88)								v->undoY = yIter33->start;
            							}
HXDLIN(  88)							hitTriBottom = v;
            						}
            						else {
HXLINE(  88)							hitTriBottom = null();
            						}
HXDLIN(  88)						if (hasHit) {
HXLINE(  88)							::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN(  88)							if (::hx::IsNotNull( hitQuad )) {
HXLINE(  88)								hitArr->triArr->push(hitQuad->triABD);
            							}
HXDLIN(  88)							hitArr->triArr->push(hitQuad->triBCD);
            						}
            					}
            				}
            				else {
HXLINE(  90)					Float thick = this->strokeWidth;
HXDLIN(  90)					int color = this->strokeColor;
HXDLIN(  90)					Float soft = this->soft;
HXDLIN(  90)					bool hasHit = true;
HXDLIN(  90)					{
HXLINE(  90)						Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  90)						Float o = (py - py);
HXDLIN(  90)						Float a = (px - px);
HXDLIN(  90)						Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  90)						Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  90)						Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN(  90)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  90)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  90)						Float radius = (thick / ( (Float)(2) ));
HXDLIN(  90)						Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  90)						Float h2 = (h / goldenRatio);
HXDLIN(  90)						Float hSmall = (h - h2);
HXDLIN(  90)						Float px_ = hSmall;
HXDLIN(  90)						Float py_ = ((Float)0.);
HXDLIN(  90)						Float temp = ((Float)0.);
HXLINE( 254)						temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 255)						py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 256)						px_ = temp;
HXLINE(  90)						Float h1 = (h2 - hSmall);
HXDLIN(  90)						Float sin1 = ::Math_obj::sin(theta);
HXDLIN(  90)						Float cos1 = ::Math_obj::cos(theta);
HXDLIN(  90)						Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  90)						Float dx = ((Float)0.1);
HXDLIN(  90)						Float dy = radius1;
HXDLIN(  90)						Float cx = h1;
HXDLIN(  90)						Float cy = radius1;
HXDLIN(  90)						Float bx = h1;
HXDLIN(  90)						Float by = -(radius1);
HXDLIN(  90)						Float ax = ((Float)0.1);
HXDLIN(  90)						Float ay = -(radius1);
HXDLIN(  90)						Float temp1 = ((Float)0.);
HXLINE(  82)						temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE(  83)						ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE(  84)						ax = temp1;
HXLINE(  86)						temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE(  87)						by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE(  88)						bx = temp1;
HXLINE(  90)						temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE(  91)						cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE(  92)						cx = temp1;
HXLINE(  94)						temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE(  95)						dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE(  96)						dx = temp1;
HXLINE(  90)						{
HXLINE(  90)							bool hasUndo = true;
HXDLIN(  90)							int aA = ((color >> 24) & 255);
HXDLIN(  90)							int rA = ((color >> 16) & 255);
HXDLIN(  90)							int gA = ((color >> 8) & 255);
HXDLIN(  90)							int bA = (color & 255);
HXDLIN(  90)							Float bcx = (bx - dx);
HXDLIN(  90)							Float bcy = (by - dy);
HXDLIN(  90)							Float acx = (ax - dx);
HXDLIN(  90)							Float acy = (ay - dy);
HXDLIN(  90)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  90)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  90)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  90)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  90)							::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  90)							if ((ax > bx)) {
HXLINE(  90)								if ((ax > dx)) {
HXLINE(  90)									int min;
HXDLIN(  90)									if ((bx > dx)) {
HXLINE(  90)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  90)										min = ::Math_obj::floor(bx);
            									}
HXDLIN(  90)									int ii_min = min;
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									xIter3 = this1;
            								}
            								else {
HXLINE(  90)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									xIter3 = this1;
            								}
            							}
            							else {
HXLINE(  90)								if ((bx > dx)) {
HXLINE(  90)									int min;
HXDLIN(  90)									if ((ax > dx)) {
HXLINE(  90)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  90)										min = ::Math_obj::ceil(ax);
            									}
HXDLIN(  90)									int ii_min = min;
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									xIter3 = this1;
            								}
            								else {
HXLINE(  90)									int ii_min = ::Math_obj::floor(ax);
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									xIter3 = this1;
            								}
            							}
HXDLIN(  90)							::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  90)							if ((ay > by)) {
HXLINE(  90)								if ((ay > dy)) {
HXLINE(  90)									int min;
HXDLIN(  90)									if ((by > dy)) {
HXLINE(  90)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  90)										min = ::Math_obj::floor(by);
            									}
HXDLIN(  90)									int ii_min = min;
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									yIter3 = this1;
            								}
            								else {
HXLINE(  90)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									yIter3 = this1;
            								}
            							}
            							else {
HXLINE(  90)								if ((by > dy)) {
HXLINE(  90)									int min;
HXDLIN(  90)									if ((ay > dy)) {
HXLINE(  90)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  90)										min = ::Math_obj::ceil(ay);
            									}
HXDLIN(  90)									int ii_min = min;
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									yIter3 = this1;
            								}
            								else {
HXLINE(  90)									int ii_min = ::Math_obj::floor(ay);
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									yIter3 = this1;
            								}
            							}
HXDLIN(  90)							::pixelimage::ImageStruct undoImage = null();
HXDLIN(  90)							if (hasUndo) {
HXLINE(  90)								int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  90)								int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  90)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  90)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  90)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  90)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  90)								undoImage = this3;
HXDLIN(  90)								{
HXLINE(  90)									int rectLeft = xIter3->start;
HXDLIN(  90)									int rectTop = yIter3->start;
HXDLIN(  90)									int rectRight = xIter3->max;
HXDLIN(  90)									bool forceClear = false;
HXDLIN(  90)									{
HXLINE(  90)										int _g = rectTop;
HXDLIN(  90)										int _g1 = yIter3->max;
HXDLIN(  90)										while((_g < _g1)){
HXLINE(  90)											_g = (_g + 1);
HXDLIN(  90)											int dy = (_g - 1);
HXDLIN(  90)											{
HXLINE(  90)												int _g1 = rectLeft;
HXDLIN(  90)												int _g2 = rectRight;
HXDLIN(  90)												while((_g1 < _g2)){
HXLINE(  90)													_g1 = (_g1 + 1);
HXDLIN(  90)													int dx = (_g1 - 1);
HXDLIN(  90)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)													int index;
HXDLIN(  90)													if (pixelImage->useVirtualPos) {
HXLINE(  90)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            													}
            													else {
HXLINE(  90)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            													}
HXDLIN(  90)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)													int col;
HXDLIN(  90)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  90)														col = c;
            													}
HXDLIN(  90)													bool _hx_tmp;
HXDLIN(  90)													if (pixelImage->useMask) {
HXLINE(  90)														_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            													}
            													else {
HXLINE(  90)														_hx_tmp = false;
            													}
HXDLIN(  90)													if (_hx_tmp) {
HXLINE(  90)														::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  90)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  90)														int index;
HXDLIN(  90)														if (this1->useVirtualPos) {
HXLINE(  90)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  90)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  90)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  90)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  90)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)														int v;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  90)															v = c;
            														}
HXDLIN(  90)														int this3 = v;
HXDLIN(  90)														int maskPixel = this3;
HXDLIN(  90)														int this4 = col;
HXDLIN(  90)														int this5 = this4;
HXDLIN(  90)														if ((maskPixel == 0)) {
HXLINE(  90)															int this1 = this5;
HXDLIN(  90)															col = this1;
            														}
            														else {
HXLINE(  90)															Float m0;
HXDLIN(  90)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  90)															if ((this1 == 0)) {
HXLINE(  90)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float m1;
HXDLIN(  90)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  90)															if ((this2 == 0)) {
HXLINE(  90)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float m2;
HXDLIN(  90)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  90)															if ((this3 == 0)) {
HXLINE(  90)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float m3;
HXDLIN(  90)															int this4 = (maskPixel & 255);
HXDLIN(  90)															if ((this4 == 0)) {
HXLINE(  90)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  90)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  90)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  90)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  90)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  90)													if ((col != 0)) {
HXLINE(  90)														int x = (dx - rectLeft);
HXDLIN(  90)														int y = (dy - rectTop);
HXDLIN(  90)														int this1 = col;
HXDLIN(  90)														int c = this1;
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  90)															_hx_tmp = undoImage->transparent;
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															int location;
HXDLIN(  90)															if (undoImage->useVirtualPos) {
HXLINE(  90)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  90)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  90)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  90)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)															int this3 = this2;
HXDLIN(  90)															int this4;
HXDLIN(  90)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  90)																this4 = this3;
            															}
HXDLIN(  90)															Float a1;
HXDLIN(  90)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  90)															if ((this5 == 0)) {
HXLINE(  90)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float r1;
HXDLIN(  90)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  90)															if ((this6 == 0)) {
HXLINE(  90)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float g1;
HXDLIN(  90)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  90)															if ((this7 == 0)) {
HXLINE(  90)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float b1;
HXDLIN(  90)															int this8 = (this4 & 255);
HXDLIN(  90)															if ((this8 == 0)) {
HXLINE(  90)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float a2;
HXDLIN(  90)															int this9 = ((col >> 24) & 255);
HXDLIN(  90)															if ((this9 == 0)) {
HXLINE(  90)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float r2;
HXDLIN(  90)															int this10 = ((col >> 16) & 255);
HXDLIN(  90)															if ((this10 == 0)) {
HXLINE(  90)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float g2;
HXDLIN(  90)															int this11 = ((col >> 8) & 255);
HXDLIN(  90)															if ((this11 == 0)) {
HXLINE(  90)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float b2;
HXDLIN(  90)															int this12 = (col & 255);
HXDLIN(  90)															if ((this12 == 0)) {
HXLINE(  90)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  90)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  90)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  90)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  90)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  90)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  90)															{
HXLINE(  90)																::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  90)																int value;
HXDLIN(  90)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  90)																	value = blended;
            																}
HXDLIN(  90)																bool _hx_tmp;
HXDLIN(  90)																if ((location >= 0)) {
HXLINE(  90)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  90)																	_hx_tmp = false;
            																}
HXDLIN(  90)																if (_hx_tmp) {
HXLINE(  90)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  90)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  90)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  90)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  90)															int index;
HXDLIN(  90)															if (undoImage->useVirtualPos) {
HXLINE(  90)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  90)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  90)															int value;
HXDLIN(  90)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  90)																value = c;
            															}
HXDLIN(  90)															bool _hx_tmp;
HXDLIN(  90)															if ((index >= 0)) {
HXLINE(  90)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  90)																_hx_tmp = false;
            															}
HXDLIN(  90)															if (_hx_tmp) {
HXLINE(  90)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  90)														if (forceClear) {
HXLINE(  90)															::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  90)															int x = (dx - rectLeft);
HXDLIN(  90)															int y = (dy - rectTop);
HXDLIN(  90)															int index;
HXDLIN(  90)															if (undoImage->useVirtualPos) {
HXLINE(  90)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            															}
            															else {
HXLINE(  90)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            															}
HXDLIN(  90)															bool _hx_tmp;
HXDLIN(  90)															if ((index >= 0)) {
HXLINE(  90)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  90)																_hx_tmp = false;
            															}
HXDLIN(  90)															if (_hx_tmp) {
HXLINE(  90)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  90)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  90)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  90)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  90)							bool found = false;
HXDLIN(  90)							Float min = ( (Float)(0) );
HXDLIN(  90)							Float max = ( (Float)(0) );
HXDLIN(  90)							int a1 = 0;
HXDLIN(  90)							int r = 0;
HXDLIN(  90)							int g = 0;
HXDLIN(  90)							int b = 0;
HXDLIN(  90)							{
HXLINE(  90)								int _g_min = xIter3->start;
HXDLIN(  90)								int _g_max = xIter3->max;
HXDLIN(  90)								while((_g_min < _g_max)){
HXLINE(  90)									_g_min = (_g_min + 1);
HXDLIN(  90)									int px = (_g_min - 1);
HXDLIN(  90)									Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)									found = false;
HXLINE(  90)									{
HXLINE(  90)										int _g_min1 = yIter3->start;
HXDLIN(  90)										int _g_max = yIter3->max;
HXDLIN(  90)										while((_g_min1 < _g_max)){
HXLINE(  90)											_g_min1 = (_g_min1 + 1);
HXDLIN(  90)											int py = (_g_min1 - 1);
HXDLIN(  90)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  90)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  90)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  90)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  90)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  90)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  90)											bool _hx_tmp;
HXDLIN(  90)											bool _hx_tmp1;
HXDLIN(  90)											if ((ratioA >= 0)) {
HXLINE(  90)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  90)												_hx_tmp1 = false;
            											}
HXDLIN(  90)											if (_hx_tmp1) {
HXLINE(  90)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  90)												_hx_tmp = false;
            											}
HXDLIN(  90)											if (_hx_tmp) {
HXLINE( 710)												min = ratioA;
HXLINE(  90)												int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  90)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  90)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  90)												int this1 = i;
HXDLIN(  90)												a1 = this1;
HXDLIN(  90)												int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  90)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  90)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  90)												int this2 = i1;
HXLINE( 748)												r = this2;
HXLINE(  90)												int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  90)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  90)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  90)												int this3 = i2;
HXLINE( 749)												g = this3;
HXLINE(  90)												int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  90)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  90)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  90)												int this4 = i3;
HXLINE( 750)												b = this4;
HXLINE(  90)												{
HXLINE(  90)													int location;
HXDLIN(  90)													if (pixelImage->useVirtualPos) {
HXLINE(  90)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            													}
            													else {
HXLINE(  90)														location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            													}
HXDLIN(  90)													bool _hx_tmp;
HXDLIN(  90)													if (pixelImage->transparent) {
HXLINE(  90)														_hx_tmp = (a1 < 254);
            													}
            													else {
HXLINE(  90)														_hx_tmp = false;
            													}
HXDLIN(  90)													if (_hx_tmp) {
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)														int this3 = this2;
HXDLIN(  90)														int old;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  90)															old = this3;
            														}
HXDLIN(  90)														int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  90)														Float a11;
HXDLIN(  90)														int this4 = ((old >> 24) & 255);
HXDLIN(  90)														if ((this4 == 0)) {
HXLINE(  90)															a11 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float r1;
HXDLIN(  90)														int this5 = ((old >> 16) & 255);
HXDLIN(  90)														if ((this5 == 0)) {
HXLINE(  90)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float g1;
HXDLIN(  90)														int this6 = ((old >> 8) & 255);
HXDLIN(  90)														if ((this6 == 0)) {
HXLINE(  90)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float b1;
HXDLIN(  90)														int this7 = (old & 255);
HXDLIN(  90)														if ((this7 == 0)) {
HXLINE(  90)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float a2;
HXDLIN(  90)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  90)														if ((this8 == 0)) {
HXLINE(  90)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float r2;
HXDLIN(  90)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  90)														if ((this9 == 0)) {
HXLINE(  90)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float g2;
HXDLIN(  90)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  90)														if ((this10 == 0)) {
HXLINE(  90)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float b2;
HXDLIN(  90)														int this11 = (rhs & 255);
HXDLIN(  90)														if ((this11 == 0)) {
HXLINE(  90)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  90)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  90)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  90)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  90)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  90)														int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  90)														{
HXLINE(  90)															::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  90)															int value;
HXDLIN(  90)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  90)																value = blended;
            															}
HXDLIN(  90)															bool _hx_tmp;
HXDLIN(  90)															if ((location >= 0)) {
HXLINE(  90)																_hx_tmp = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  90)																_hx_tmp = false;
            															}
HXDLIN(  90)															if (_hx_tmp) {
HXLINE(  90)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  90)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  90)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)														int value;
HXDLIN(  90)														if (pixelImage->isLittle) {
HXLINE(  90)															value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            														}
            														else {
HXLINE(  90)															value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            														}
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((location >= 0)) {
HXLINE(  90)															_hx_tmp = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 752)												found = true;
            											}
            											else {
HXLINE(  90)												if (found) {
HXLINE(  90)													goto _hx_goto_110;
            												}
            											}
            										}
            										_hx_goto_110:;
            									}
            								}
            							}
            						}
HXDLIN(  90)						{
HXLINE(  90)							bool hasUndo1 = true;
HXDLIN(  90)							int aA1 = ((color >> 24) & 255);
HXDLIN(  90)							int rA1 = ((color >> 16) & 255);
HXDLIN(  90)							int gA1 = ((color >> 8) & 255);
HXDLIN(  90)							int bA1 = (color & 255);
HXDLIN(  90)							Float bcx1 = (cx - dx);
HXDLIN(  90)							Float bcy1 = (cy - dy);
HXDLIN(  90)							Float acx1 = (bx - dx);
HXDLIN(  90)							Float acy1 = (by - dy);
HXDLIN(  90)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  90)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  90)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  90)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  90)							::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  90)							if ((bx > cx)) {
HXLINE(  90)								if ((bx > dx)) {
HXLINE(  90)									int min;
HXDLIN(  90)									if ((cx > dx)) {
HXLINE(  90)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  90)										min = ::Math_obj::floor(cx);
            									}
HXDLIN(  90)									int ii_min = min;
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									xIter31 = this1;
            								}
            								else {
HXLINE(  90)									int ii_min = ::Math_obj::floor(cx);
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									xIter31 = this1;
            								}
            							}
            							else {
HXLINE(  90)								if ((cx > dx)) {
HXLINE(  90)									int min;
HXDLIN(  90)									if ((bx > dx)) {
HXLINE(  90)										min = ::Math_obj::floor(dx);
            									}
            									else {
HXLINE(  90)										min = ::Math_obj::ceil(bx);
            									}
HXDLIN(  90)									int ii_min = min;
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									xIter31 = this1;
            								}
            								else {
HXLINE(  90)									int ii_min = ::Math_obj::floor(bx);
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									xIter31 = this1;
            								}
            							}
HXDLIN(  90)							::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  90)							if ((by > cy)) {
HXLINE(  90)								if ((by > dy)) {
HXLINE(  90)									int min;
HXDLIN(  90)									if ((cy > dy)) {
HXLINE(  90)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  90)										min = ::Math_obj::floor(cy);
            									}
HXDLIN(  90)									int ii_min = min;
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(by);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									yIter31 = this1;
            								}
            								else {
HXLINE(  90)									int ii_min = ::Math_obj::floor(cy);
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									yIter31 = this1;
            								}
            							}
            							else {
HXLINE(  90)								if ((cy > dy)) {
HXLINE(  90)									int min;
HXDLIN(  90)									if ((by > dy)) {
HXLINE(  90)										min = ::Math_obj::floor(dy);
            									}
            									else {
HXLINE(  90)										min = ::Math_obj::ceil(by);
            									}
HXDLIN(  90)									int ii_min = min;
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									yIter31 = this1;
            								}
            								else {
HXLINE(  90)									int ii_min = ::Math_obj::floor(by);
HXDLIN(  90)									int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  90)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)									yIter31 = this1;
            								}
            							}
HXDLIN(  90)							::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  90)							if (hasUndo1) {
HXLINE(  90)								int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  90)								int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  90)								int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  90)								::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  90)								::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  90)								::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  90)								undoImage1 = this3;
HXDLIN(  90)								{
HXLINE(  90)									int rectLeft = xIter31->start;
HXDLIN(  90)									int rectTop = yIter31->start;
HXDLIN(  90)									int rectRight = xIter31->max;
HXDLIN(  90)									bool forceClear = false;
HXDLIN(  90)									{
HXLINE(  90)										int _g = rectTop;
HXDLIN(  90)										int _g1 = yIter31->max;
HXDLIN(  90)										while((_g < _g1)){
HXLINE(  90)											_g = (_g + 1);
HXDLIN(  90)											int dy = (_g - 1);
HXDLIN(  90)											{
HXLINE(  90)												int _g1 = rectLeft;
HXDLIN(  90)												int _g2 = rectRight;
HXDLIN(  90)												while((_g1 < _g2)){
HXLINE(  90)													_g1 = (_g1 + 1);
HXDLIN(  90)													int dx = (_g1 - 1);
HXDLIN(  90)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)													int index;
HXDLIN(  90)													if (pixelImage->useVirtualPos) {
HXLINE(  90)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            													}
            													else {
HXLINE(  90)														index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            													}
HXDLIN(  90)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)													int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)													int col;
HXDLIN(  90)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  90)														col = c;
            													}
HXDLIN(  90)													bool _hx_tmp;
HXDLIN(  90)													if (pixelImage->useMask) {
HXLINE(  90)														_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            													}
            													else {
HXLINE(  90)														_hx_tmp = false;
            													}
HXDLIN(  90)													if (_hx_tmp) {
HXLINE(  90)														::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  90)														::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  90)														int index;
HXDLIN(  90)														if (this1->useVirtualPos) {
HXLINE(  90)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  90)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  90)														::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  90)														int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  90)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)														int v;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  90)															v = c;
            														}
HXDLIN(  90)														int this3 = v;
HXDLIN(  90)														int maskPixel = this3;
HXDLIN(  90)														int this4 = col;
HXDLIN(  90)														int this5 = this4;
HXDLIN(  90)														if ((maskPixel == 0)) {
HXLINE(  90)															int this1 = this5;
HXDLIN(  90)															col = this1;
            														}
            														else {
HXLINE(  90)															Float m0;
HXDLIN(  90)															int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  90)															if ((this1 == 0)) {
HXLINE(  90)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float m1;
HXDLIN(  90)															int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  90)															if ((this2 == 0)) {
HXLINE(  90)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float m2;
HXDLIN(  90)															int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  90)															if ((this3 == 0)) {
HXLINE(  90)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float m3;
HXDLIN(  90)															int this4 = (maskPixel & 255);
HXDLIN(  90)															if ((this4 == 0)) {
HXLINE(  90)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  90)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  90)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  90)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  90)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  90)													if ((col != 0)) {
HXLINE(  90)														int x = (dx - rectLeft);
HXDLIN(  90)														int y = (dy - rectTop);
HXDLIN(  90)														int this1 = col;
HXDLIN(  90)														int c = this1;
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((((c >> 24) & 255) < 254)) {
HXLINE(  90)															_hx_tmp = undoImage1->transparent;
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															int location;
HXDLIN(  90)															if (undoImage1->useVirtualPos) {
HXLINE(  90)																location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  90)																location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  90)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  90)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)															int this3 = this2;
HXDLIN(  90)															int this4;
HXDLIN(  90)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  90)																this4 = this3;
            															}
HXDLIN(  90)															Float a1;
HXDLIN(  90)															int this5 = ((this4 >> 24) & 255);
HXDLIN(  90)															if ((this5 == 0)) {
HXLINE(  90)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float r1;
HXDLIN(  90)															int this6 = ((this4 >> 16) & 255);
HXDLIN(  90)															if ((this6 == 0)) {
HXLINE(  90)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float g1;
HXDLIN(  90)															int this7 = ((this4 >> 8) & 255);
HXDLIN(  90)															if ((this7 == 0)) {
HXLINE(  90)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float b1;
HXDLIN(  90)															int this8 = (this4 & 255);
HXDLIN(  90)															if ((this8 == 0)) {
HXLINE(  90)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float a2;
HXDLIN(  90)															int this9 = ((col >> 24) & 255);
HXDLIN(  90)															if ((this9 == 0)) {
HXLINE(  90)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float r2;
HXDLIN(  90)															int this10 = ((col >> 16) & 255);
HXDLIN(  90)															if ((this10 == 0)) {
HXLINE(  90)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float g2;
HXDLIN(  90)															int this11 = ((col >> 8) & 255);
HXDLIN(  90)															if ((this11 == 0)) {
HXLINE(  90)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float b2;
HXDLIN(  90)															int this12 = (col & 255);
HXDLIN(  90)															if ((this12 == 0)) {
HXLINE(  90)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  90)																b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  90)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  90)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  90)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  90)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  90)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  90)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  90)															{
HXLINE(  90)																::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  90)																int value;
HXDLIN(  90)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  90)																	value = blended;
            																}
HXDLIN(  90)																bool _hx_tmp;
HXDLIN(  90)																if ((location >= 0)) {
HXLINE(  90)																	_hx_tmp = (location < (this13->byteLength >> 2));
            																}
            																else {
HXLINE(  90)																	_hx_tmp = false;
            																}
HXDLIN(  90)																if (_hx_tmp) {
HXLINE(  90)																	::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  90)																	int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  90)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  90)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  90)															int index;
HXDLIN(  90)															if (undoImage1->useVirtualPos) {
HXLINE(  90)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  90)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  90)															int value;
HXDLIN(  90)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  90)																value = c;
            															}
HXDLIN(  90)															bool _hx_tmp;
HXDLIN(  90)															if ((index >= 0)) {
HXLINE(  90)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  90)																_hx_tmp = false;
            															}
HXDLIN(  90)															if (_hx_tmp) {
HXLINE(  90)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  90)														if (forceClear) {
HXLINE(  90)															::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  90)															int x = (dx - rectLeft);
HXDLIN(  90)															int y = (dy - rectTop);
HXDLIN(  90)															int index;
HXDLIN(  90)															if (undoImage1->useVirtualPos) {
HXLINE(  90)																index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            															}
            															else {
HXLINE(  90)																index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            															}
HXDLIN(  90)															bool _hx_tmp;
HXDLIN(  90)															if ((index >= 0)) {
HXLINE(  90)																_hx_tmp = (index < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  90)																_hx_tmp = false;
            															}
HXDLIN(  90)															if (_hx_tmp) {
HXLINE(  90)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  90)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  90)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  90)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  90)							bool found1 = false;
HXDLIN(  90)							Float min1 = ( (Float)(0) );
HXDLIN(  90)							Float max1 = ( (Float)(0) );
HXDLIN(  90)							int a2 = 0;
HXDLIN(  90)							int r1 = 0;
HXDLIN(  90)							int g1 = 0;
HXDLIN(  90)							int b1 = 0;
HXDLIN(  90)							{
HXLINE(  90)								int _g_min1 = xIter31->start;
HXDLIN(  90)								int _g_max1 = xIter31->max;
HXDLIN(  90)								while((_g_min1 < _g_max1)){
HXLINE(  90)									_g_min1 = (_g_min1 + 1);
HXDLIN(  90)									int px = (_g_min1 - 1);
HXDLIN(  90)									Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)									found1 = false;
HXLINE(  90)									{
HXLINE(  90)										int _g_min = yIter31->start;
HXDLIN(  90)										int _g_max = yIter31->max;
HXDLIN(  90)										while((_g_min < _g_max)){
HXLINE(  90)											_g_min = (_g_min + 1);
HXDLIN(  90)											int py = (_g_min - 1);
HXDLIN(  90)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  90)											Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  90)											Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  90)											Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  90)											Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  90)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  90)											bool _hx_tmp;
HXDLIN(  90)											bool _hx_tmp1;
HXDLIN(  90)											if ((ratioA >= 0)) {
HXLINE(  90)												_hx_tmp1 = (ratioB >= 0);
            											}
            											else {
HXLINE(  90)												_hx_tmp1 = false;
            											}
HXDLIN(  90)											if (_hx_tmp1) {
HXLINE(  90)												_hx_tmp = (ratioC >= 0);
            											}
            											else {
HXLINE(  90)												_hx_tmp = false;
            											}
HXDLIN(  90)											if (_hx_tmp) {
HXLINE( 723)												min1 = ratioC;
HXLINE(  90)												int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  90)												if ((i > 255)) {
HXLINE(  24)													i = 255;
            												}
HXLINE(  90)												if ((i < 0)) {
HXLINE(  25)													i = 0;
            												}
HXLINE(  90)												int this1 = i;
HXDLIN(  90)												a2 = this1;
HXDLIN(  90)												int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  90)												if ((i1 > 255)) {
HXLINE(  24)													i1 = 255;
            												}
HXLINE(  90)												if ((i1 < 0)) {
HXLINE(  25)													i1 = 0;
            												}
HXLINE(  90)												int this2 = i1;
HXLINE( 748)												r1 = this2;
HXLINE(  90)												int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  90)												if ((i2 > 255)) {
HXLINE(  24)													i2 = 255;
            												}
HXLINE(  90)												if ((i2 < 0)) {
HXLINE(  25)													i2 = 0;
            												}
HXLINE(  90)												int this3 = i2;
HXLINE( 749)												g1 = this3;
HXLINE(  90)												int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  90)												if ((i3 > 255)) {
HXLINE(  24)													i3 = 255;
            												}
HXLINE(  90)												if ((i3 < 0)) {
HXLINE(  25)													i3 = 0;
            												}
HXLINE(  90)												int this4 = i3;
HXLINE( 750)												b1 = this4;
HXLINE(  90)												{
HXLINE(  90)													int location;
HXDLIN(  90)													if (pixelImage->useVirtualPos) {
HXLINE(  90)														location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            													}
            													else {
HXLINE(  90)														location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            													}
HXDLIN(  90)													bool _hx_tmp;
HXDLIN(  90)													if (pixelImage->transparent) {
HXLINE(  90)														_hx_tmp = (a2 < 254);
            													}
            													else {
HXLINE(  90)														_hx_tmp = false;
            													}
HXDLIN(  90)													if (_hx_tmp) {
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)														int this3 = this2;
HXDLIN(  90)														int old;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  90)															old = this3;
            														}
HXDLIN(  90)														int rhs = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  90)														Float a1;
HXDLIN(  90)														int this4 = ((old >> 24) & 255);
HXDLIN(  90)														if ((this4 == 0)) {
HXLINE(  90)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float r11;
HXDLIN(  90)														int this5 = ((old >> 16) & 255);
HXDLIN(  90)														if ((this5 == 0)) {
HXLINE(  90)															r11 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float g11;
HXDLIN(  90)														int this6 = ((old >> 8) & 255);
HXDLIN(  90)														if ((this6 == 0)) {
HXLINE(  90)															g11 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float b11;
HXDLIN(  90)														int this7 = (old & 255);
HXDLIN(  90)														if ((this7 == 0)) {
HXLINE(  90)															b11 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float a21;
HXDLIN(  90)														int this8 = ((rhs >> 24) & 255);
HXDLIN(  90)														if ((this8 == 0)) {
HXLINE(  90)															a21 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															a21 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float r2;
HXDLIN(  90)														int this9 = ((rhs >> 16) & 255);
HXDLIN(  90)														if ((this9 == 0)) {
HXLINE(  90)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float g2;
HXDLIN(  90)														int this10 = ((rhs >> 8) & 255);
HXDLIN(  90)														if ((this10 == 0)) {
HXLINE(  90)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float b2;
HXDLIN(  90)														int this11 = (rhs & 255);
HXDLIN(  90)														if ((this11 == 0)) {
HXLINE(  90)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float a3 = (a1 * (( (Float)(1) ) - a21));
HXDLIN(  90)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a21))));
HXDLIN(  90)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a21))));
HXDLIN(  90)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a21))));
HXDLIN(  90)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a21)));
HXDLIN(  90)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  90)														{
HXLINE(  90)															::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  90)															int value;
HXDLIN(  90)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  90)																value = blended;
            															}
HXDLIN(  90)															bool _hx_tmp;
HXDLIN(  90)															if ((location >= 0)) {
HXLINE(  90)																_hx_tmp = (location < (this12->byteLength >> 2));
            															}
            															else {
HXLINE(  90)																_hx_tmp = false;
            															}
HXDLIN(  90)															if (_hx_tmp) {
HXLINE(  90)																::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  90)																int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  90)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)														int value;
HXDLIN(  90)														if (pixelImage->isLittle) {
HXLINE(  90)															value = ((((a2 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            														}
            														else {
HXLINE(  90)															value = ((((a2 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            														}
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((location >= 0)) {
HXLINE(  90)															_hx_tmp = (location < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE( 752)												found1 = true;
            											}
            											else {
HXLINE(  90)												if (found1) {
HXLINE(  90)													goto _hx_goto_114;
            												}
            											}
            										}
            										_hx_goto_114:;
            									}
            								}
            							}
            						}
HXDLIN(  90)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  90)						::pixelimage::algo::HitQuad hitQuad = v;
HXDLIN(  90)						Float cx1 = h2;
HXDLIN(  90)						Float cy1 = radius2;
HXDLIN(  90)						Float bx1 = h2;
HXDLIN(  90)						Float by1 = -(radius2);
HXDLIN(  90)						Float dx1 = hSmall;
HXDLIN(  90)						Float dy1 = radius2;
HXDLIN(  90)						Float ax1 = hSmall;
HXDLIN(  90)						Float ay1 = -(radius2);
HXLINE( 269)						temp = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE( 270)						by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE( 271)						bx1 = temp;
HXLINE( 272)						temp = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE( 273)						cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE( 274)						cx1 = temp;
HXLINE( 276)						temp = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE( 277)						ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE( 278)						ax1 = temp;
HXLINE( 280)						temp = (px + ((dx1 * cos) - (dy1 * sin)));
HXLINE( 281)						dy1 = (py + ((dy1 * cos) + (dx1 * sin)));
HXLINE( 282)						dx1 = temp;
HXLINE(  90)						bool hasUndo2 = true;
HXDLIN(  90)						int aA2 = ((color >> 24) & 255);
HXDLIN(  90)						int rA2 = ((color >> 16) & 255);
HXDLIN(  90)						int gA2 = ((color >> 8) & 255);
HXDLIN(  90)						int bA2 = (color & 255);
HXDLIN(  90)						Float bcx2 = (bx1 - cx1);
HXDLIN(  90)						Float bcy2 = (by1 - cy1);
HXDLIN(  90)						Float acx2 = (px - cx1);
HXDLIN(  90)						Float acy2 = (py - cy1);
HXDLIN(  90)						Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  90)						Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  90)						Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  90)						Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  90)						::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  90)						if ((px > bx1)) {
HXLINE(  90)							if ((px > cx1)) {
HXLINE(  90)								int min;
HXDLIN(  90)								if ((bx1 > cx1)) {
HXLINE(  90)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  90)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN(  90)								int ii_min = min;
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(px);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								xIter32 = this1;
            							}
            							else {
HXLINE(  90)								int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								xIter32 = this1;
            							}
            						}
            						else {
HXLINE(  90)							if ((bx1 > cx1)) {
HXLINE(  90)								int min;
HXDLIN(  90)								if ((px > cx1)) {
HXLINE(  90)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  90)									min = ::Math_obj::ceil(px);
            								}
HXDLIN(  90)								int ii_min = min;
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								xIter32 = this1;
            							}
            							else {
HXLINE(  90)								int ii_min = ::Math_obj::floor(px);
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								xIter32 = this1;
            							}
            						}
HXDLIN(  90)						::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  90)						if ((py > by1)) {
HXLINE(  90)							if ((py > cy1)) {
HXLINE(  90)								int min;
HXDLIN(  90)								if ((by1 > cy1)) {
HXLINE(  90)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  90)									min = ::Math_obj::floor(by1);
            								}
HXDLIN(  90)								int ii_min = min;
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(py);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								yIter32 = this1;
            							}
            							else {
HXLINE(  90)								int ii_min = ::Math_obj::floor(by1);
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								yIter32 = this1;
            							}
            						}
            						else {
HXLINE(  90)							if ((by1 > cy1)) {
HXLINE(  90)								int min;
HXDLIN(  90)								if ((py > cy1)) {
HXLINE(  90)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  90)									min = ::Math_obj::ceil(py);
            								}
HXDLIN(  90)								int ii_min = min;
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								yIter32 = this1;
            							}
            							else {
HXLINE(  90)								int ii_min = ::Math_obj::floor(py);
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								yIter32 = this1;
            							}
            						}
HXDLIN(  90)						::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  90)						if (hasUndo2) {
HXLINE(  90)							int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  90)							int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  90)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  90)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  90)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  90)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  90)							undoImage2 = this3;
HXDLIN(  90)							{
HXLINE(  90)								int rectLeft = xIter32->start;
HXDLIN(  90)								int rectTop = yIter32->start;
HXDLIN(  90)								int rectRight = xIter32->max;
HXDLIN(  90)								bool forceClear = false;
HXDLIN(  90)								{
HXLINE(  90)									int _g = rectTop;
HXDLIN(  90)									int _g1 = yIter32->max;
HXDLIN(  90)									while((_g < _g1)){
HXLINE(  90)										_g = (_g + 1);
HXDLIN(  90)										int dy = (_g - 1);
HXDLIN(  90)										{
HXLINE(  90)											int _g1 = rectLeft;
HXDLIN(  90)											int _g2 = rectRight;
HXDLIN(  90)											while((_g1 < _g2)){
HXLINE(  90)												_g1 = (_g1 + 1);
HXDLIN(  90)												int dx = (_g1 - 1);
HXDLIN(  90)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)												int index;
HXDLIN(  90)												if (pixelImage->useVirtualPos) {
HXLINE(  90)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  90)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN(  90)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)												int col;
HXDLIN(  90)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  90)													col = c;
            												}
HXDLIN(  90)												bool _hx_tmp;
HXDLIN(  90)												if (pixelImage->useMask) {
HXLINE(  90)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE(  90)													_hx_tmp = false;
            												}
HXDLIN(  90)												if (_hx_tmp) {
HXLINE(  90)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  90)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  90)													int index;
HXDLIN(  90)													if (this1->useVirtualPos) {
HXLINE(  90)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  90)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  90)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  90)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  90)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)													int v;
HXDLIN(  90)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  90)														v = c;
            													}
HXDLIN(  90)													int this3 = v;
HXDLIN(  90)													int maskPixel = this3;
HXDLIN(  90)													int this4 = col;
HXDLIN(  90)													int this5 = this4;
HXDLIN(  90)													if ((maskPixel == 0)) {
HXLINE(  90)														int this1 = this5;
HXDLIN(  90)														col = this1;
            													}
            													else {
HXLINE(  90)														Float m0;
HXDLIN(  90)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  90)														if ((this1 == 0)) {
HXLINE(  90)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float m1;
HXDLIN(  90)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  90)														if ((this2 == 0)) {
HXLINE(  90)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float m2;
HXDLIN(  90)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  90)														if ((this3 == 0)) {
HXLINE(  90)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float m3;
HXDLIN(  90)														int this4 = (maskPixel & 255);
HXDLIN(  90)														if ((this4 == 0)) {
HXLINE(  90)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  90)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  90)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  90)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  90)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  90)												if ((col != 0)) {
HXLINE(  90)													int x = (dx - rectLeft);
HXDLIN(  90)													int y = (dy - rectTop);
HXDLIN(  90)													int this1 = col;
HXDLIN(  90)													int c = this1;
HXDLIN(  90)													bool _hx_tmp;
HXDLIN(  90)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  90)														_hx_tmp = undoImage2->transparent;
            													}
            													else {
HXLINE(  90)														_hx_tmp = false;
            													}
HXDLIN(  90)													if (_hx_tmp) {
HXLINE(  90)														int location;
HXDLIN(  90)														if (undoImage2->useVirtualPos) {
HXLINE(  90)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE(  90)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN(  90)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  90)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)														int this3 = this2;
HXDLIN(  90)														int this4;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  90)															this4 = this3;
            														}
HXDLIN(  90)														Float a1;
HXDLIN(  90)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  90)														if ((this5 == 0)) {
HXLINE(  90)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float r1;
HXDLIN(  90)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  90)														if ((this6 == 0)) {
HXLINE(  90)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float g1;
HXDLIN(  90)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  90)														if ((this7 == 0)) {
HXLINE(  90)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float b1;
HXDLIN(  90)														int this8 = (this4 & 255);
HXDLIN(  90)														if ((this8 == 0)) {
HXLINE(  90)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float a2;
HXDLIN(  90)														int this9 = ((col >> 24) & 255);
HXDLIN(  90)														if ((this9 == 0)) {
HXLINE(  90)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float r2;
HXDLIN(  90)														int this10 = ((col >> 16) & 255);
HXDLIN(  90)														if ((this10 == 0)) {
HXLINE(  90)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float g2;
HXDLIN(  90)														int this11 = ((col >> 8) & 255);
HXDLIN(  90)														if ((this11 == 0)) {
HXLINE(  90)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float b2;
HXDLIN(  90)														int this12 = (col & 255);
HXDLIN(  90)														if ((this12 == 0)) {
HXLINE(  90)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  90)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  90)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  90)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  90)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  90)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  90)														{
HXLINE(  90)															::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  90)															int value;
HXDLIN(  90)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  90)																value = blended;
            															}
HXDLIN(  90)															bool _hx_tmp;
HXDLIN(  90)															if ((location >= 0)) {
HXLINE(  90)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  90)																_hx_tmp = false;
            															}
HXDLIN(  90)															if (_hx_tmp) {
HXLINE(  90)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  90)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  90)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  90)														int index;
HXDLIN(  90)														if (undoImage2->useVirtualPos) {
HXLINE(  90)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE(  90)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN(  90)														int value;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  90)															value = c;
            														}
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((index >= 0)) {
HXLINE(  90)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  90)													if (forceClear) {
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  90)														int x = (dx - rectLeft);
HXDLIN(  90)														int y = (dy - rectTop);
HXDLIN(  90)														int index;
HXDLIN(  90)														if (undoImage2->useVirtualPos) {
HXLINE(  90)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE(  90)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((index >= 0)) {
HXLINE(  90)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  90)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  90)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  90)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  90)						bool found2 = false;
HXDLIN(  90)						Float min2 = ( (Float)(0) );
HXDLIN(  90)						Float max2 = ( (Float)(0) );
HXDLIN(  90)						int a3 = 0;
HXDLIN(  90)						int r2 = 0;
HXDLIN(  90)						int g2 = 0;
HXDLIN(  90)						int b2 = 0;
HXDLIN(  90)						{
HXLINE(  90)							int _g_min2 = xIter32->start;
HXDLIN(  90)							int _g_max2 = xIter32->max;
HXDLIN(  90)							while((_g_min2 < _g_max2)){
HXLINE(  90)								_g_min2 = (_g_min2 + 1);
HXDLIN(  90)								int px = (_g_min2 - 1);
HXDLIN(  90)								Float pcx = (( (Float)(px) ) - cx1);
HXLINE( 696)								found2 = false;
HXLINE(  90)								{
HXLINE(  90)									int _g_min = yIter32->start;
HXDLIN(  90)									int _g_max = yIter32->max;
HXDLIN(  90)									while((_g_min < _g_max)){
HXLINE(  90)										_g_min = (_g_min + 1);
HXDLIN(  90)										int py = (_g_min - 1);
HXDLIN(  90)										Float pcy = (( (Float)(py) ) - cy1);
HXDLIN(  90)										Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  90)										Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  90)										Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  90)										Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  90)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  90)										bool _hx_tmp;
HXDLIN(  90)										bool _hx_tmp1;
HXDLIN(  90)										if ((ratioA >= 0)) {
HXLINE(  90)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  90)											_hx_tmp1 = false;
            										}
HXDLIN(  90)										if (_hx_tmp1) {
HXLINE(  90)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  90)											_hx_tmp = false;
            										}
HXDLIN(  90)										if (_hx_tmp) {
HXLINE(  90)											Float min;
HXDLIN(  90)											if ((ratioA < ratioB)) {
HXLINE(  90)												min = ratioA;
            											}
            											else {
HXLINE(  90)												min = ratioB;
            											}
HXDLIN(  90)											if (!((min < ratioC))) {
HXLINE(  90)												min = ratioC;
            											}
HXDLIN(  90)											Float max;
HXDLIN(  90)											if ((ratioA > ratioB)) {
HXLINE(  90)												max = ratioA;
            											}
            											else {
HXLINE(  90)												max = ratioB;
            											}
HXDLIN(  90)											if (!((max > ratioC))) {
HXLINE(  90)												max = ratioC;
            											}
HXLINE( 744)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  90)											Float min1;
HXDLIN(  90)											if ((min < max)) {
HXLINE(  90)												min1 = min;
            											}
            											else {
HXLINE(  90)												min1 = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  90)											int i = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min1));
HXDLIN(  90)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  90)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  90)											int this1 = i;
HXDLIN(  90)											a3 = this1;
HXDLIN(  90)											int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  90)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  90)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  90)											int this2 = i1;
HXLINE( 748)											r2 = this2;
HXLINE(  90)											int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  90)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  90)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  90)											int this3 = i2;
HXLINE( 749)											g2 = this3;
HXLINE(  90)											int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  90)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  90)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  90)											int this4 = i3;
HXLINE( 750)											b2 = this4;
HXLINE(  90)											{
HXLINE(  90)												int location;
HXDLIN(  90)												if (pixelImage->useVirtualPos) {
HXLINE(  90)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  90)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            												}
HXDLIN(  90)												bool _hx_tmp;
HXDLIN(  90)												if (pixelImage->transparent) {
HXLINE(  90)													_hx_tmp = (a3 < 254);
            												}
            												else {
HXLINE(  90)													_hx_tmp = false;
            												}
HXDLIN(  90)												if (_hx_tmp) {
HXLINE(  90)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)													int this3 = this2;
HXDLIN(  90)													int old;
HXDLIN(  90)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  90)														old = this3;
            													}
HXDLIN(  90)													int rhs = ((((a3 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
HXDLIN(  90)													Float a1;
HXDLIN(  90)													int this4 = ((old >> 24) & 255);
HXDLIN(  90)													if ((this4 == 0)) {
HXLINE(  90)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float r1;
HXDLIN(  90)													int this5 = ((old >> 16) & 255);
HXDLIN(  90)													if ((this5 == 0)) {
HXLINE(  90)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float g1;
HXDLIN(  90)													int this6 = ((old >> 8) & 255);
HXDLIN(  90)													if ((this6 == 0)) {
HXLINE(  90)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float b1;
HXDLIN(  90)													int this7 = (old & 255);
HXDLIN(  90)													if ((this7 == 0)) {
HXLINE(  90)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float a2;
HXDLIN(  90)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  90)													if ((this8 == 0)) {
HXLINE(  90)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float r21;
HXDLIN(  90)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  90)													if ((this9 == 0)) {
HXLINE(  90)														r21 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														r21 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float g21;
HXDLIN(  90)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  90)													if ((this10 == 0)) {
HXLINE(  90)														g21 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														g21 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float b21;
HXDLIN(  90)													int this11 = (rhs & 255);
HXDLIN(  90)													if ((this11 == 0)) {
HXLINE(  90)														b21 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														b21 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float a31 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  90)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a31) + (r21 * a2))));
HXDLIN(  90)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a31) + (g21 * a2))));
HXDLIN(  90)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a31) + (b21 * a2))));
HXDLIN(  90)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a2)));
HXDLIN(  90)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  90)													{
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  90)														int value;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  90)															value = blended;
            														}
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((location >= 0)) {
HXLINE(  90)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  90)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  90)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  90)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)													int value;
HXDLIN(  90)													if (pixelImage->isLittle) {
HXLINE(  90)														value = ((((a3 << 24) | (b2 << 16)) | (g2 << 8)) | r2);
            													}
            													else {
HXLINE(  90)														value = ((((a3 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
            													}
HXDLIN(  90)													bool _hx_tmp;
HXDLIN(  90)													if ((location >= 0)) {
HXLINE(  90)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  90)														_hx_tmp = false;
            													}
HXDLIN(  90)													if (_hx_tmp) {
HXLINE(  90)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 752)											found2 = true;
            										}
            										else {
HXLINE(  90)											if (found2) {
HXLINE(  90)												goto _hx_goto_118;
            											}
            										}
            									}
            									_hx_goto_118:;
            								}
            							}
            						}
HXDLIN(  90)						::pixelimage::algo::HitTri hitTriTop;
HXDLIN(  90)						if ((hasHit == false)) {
HXLINE(  90)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx1,by1,cx1,cy1,true);
HXDLIN(  90)							if (hasUndo2) {
HXLINE(  90)								v->undoImage = undoImage2;
HXDLIN(  90)								v->undoX = xIter32->start;
HXDLIN(  90)								v->undoY = yIter32->start;
            							}
HXDLIN(  90)							hitTriTop = v;
            						}
            						else {
HXLINE(  90)							hitTriTop = null();
            						}
HXDLIN(  90)						Float soft3 = ( (Float)(40) );
HXDLIN(  90)						bool hasUndo3 = true;
HXDLIN(  90)						int aA3 = ((color >> 24) & 255);
HXDLIN(  90)						int rA3 = ((color >> 16) & 255);
HXDLIN(  90)						int gA3 = ((color >> 8) & 255);
HXDLIN(  90)						int bA3 = (color & 255);
HXDLIN(  90)						Float bcx3 = (ax1 - dx1);
HXDLIN(  90)						Float bcy3 = (ay1 - dy1);
HXDLIN(  90)						Float acx3 = (px - dx1);
HXDLIN(  90)						Float acy3 = (py - dy1);
HXDLIN(  90)						Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  90)						Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  90)						Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  90)						Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  90)						::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  90)						if ((px > ax1)) {
HXLINE(  90)							if ((px > dx1)) {
HXLINE(  90)								int min;
HXDLIN(  90)								if ((ax1 > dx1)) {
HXLINE(  90)									min = ::Math_obj::floor(dx1);
            								}
            								else {
HXLINE(  90)									min = ::Math_obj::floor(ax1);
            								}
HXDLIN(  90)								int ii_min = min;
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(px);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								xIter33 = this1;
            							}
            							else {
HXLINE(  90)								int ii_min = ::Math_obj::floor(ax1);
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(dx1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								xIter33 = this1;
            							}
            						}
            						else {
HXLINE(  90)							if ((ax1 > dx1)) {
HXLINE(  90)								int min;
HXDLIN(  90)								if ((px > dx1)) {
HXLINE(  90)									min = ::Math_obj::floor(dx1);
            								}
            								else {
HXLINE(  90)									min = ::Math_obj::ceil(px);
            								}
HXDLIN(  90)								int ii_min = min;
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(ax1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								xIter33 = this1;
            							}
            							else {
HXLINE(  90)								int ii_min = ::Math_obj::floor(px);
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(dx1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								xIter33 = this1;
            							}
            						}
HXDLIN(  90)						::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  90)						if ((py > ay1)) {
HXLINE(  90)							if ((py > dy1)) {
HXLINE(  90)								int min;
HXDLIN(  90)								if ((ay1 > dy1)) {
HXLINE(  90)									min = ::Math_obj::floor(dy1);
            								}
            								else {
HXLINE(  90)									min = ::Math_obj::floor(ay1);
            								}
HXDLIN(  90)								int ii_min = min;
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(py);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								yIter33 = this1;
            							}
            							else {
HXLINE(  90)								int ii_min = ::Math_obj::floor(ay1);
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(dy1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								yIter33 = this1;
            							}
            						}
            						else {
HXLINE(  90)							if ((ay1 > dy1)) {
HXLINE(  90)								int min;
HXDLIN(  90)								if ((py > dy1)) {
HXLINE(  90)									min = ::Math_obj::floor(dy1);
            								}
            								else {
HXLINE(  90)									min = ::Math_obj::ceil(py);
            								}
HXDLIN(  90)								int ii_min = min;
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(ay1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								yIter33 = this1;
            							}
            							else {
HXLINE(  90)								int ii_min = ::Math_obj::floor(py);
HXDLIN(  90)								int ii_max = ::Math_obj::ceil(dy1);
HXDLIN(  90)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  90)								yIter33 = this1;
            							}
            						}
HXDLIN(  90)						::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  90)						if (hasUndo3) {
HXLINE(  90)							int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  90)							int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  90)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  90)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  90)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  90)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  90)							undoImage3 = this3;
HXDLIN(  90)							{
HXLINE(  90)								int rectLeft = xIter33->start;
HXDLIN(  90)								int rectTop = yIter33->start;
HXDLIN(  90)								int rectRight = xIter33->max;
HXDLIN(  90)								bool forceClear = false;
HXDLIN(  90)								{
HXLINE(  90)									int _g = rectTop;
HXDLIN(  90)									int _g1 = yIter33->max;
HXDLIN(  90)									while((_g < _g1)){
HXLINE(  90)										_g = (_g + 1);
HXDLIN(  90)										int dy = (_g - 1);
HXDLIN(  90)										{
HXLINE(  90)											int _g1 = rectLeft;
HXDLIN(  90)											int _g2 = rectRight;
HXDLIN(  90)											while((_g1 < _g2)){
HXLINE(  90)												_g1 = (_g1 + 1);
HXDLIN(  90)												int dx = (_g1 - 1);
HXDLIN(  90)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)												int index;
HXDLIN(  90)												if (pixelImage->useVirtualPos) {
HXLINE(  90)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  90)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN(  90)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)												int col;
HXDLIN(  90)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  90)													col = c;
            												}
HXDLIN(  90)												bool _hx_tmp;
HXDLIN(  90)												if (pixelImage->useMask) {
HXLINE(  90)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE(  90)													_hx_tmp = false;
            												}
HXDLIN(  90)												if (_hx_tmp) {
HXLINE(  90)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  90)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  90)													int index;
HXDLIN(  90)													if (this1->useVirtualPos) {
HXLINE(  90)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  90)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  90)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  90)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  90)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)													int v;
HXDLIN(  90)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  90)														v = c;
            													}
HXDLIN(  90)													int this3 = v;
HXDLIN(  90)													int maskPixel = this3;
HXDLIN(  90)													int this4 = col;
HXDLIN(  90)													int this5 = this4;
HXDLIN(  90)													if ((maskPixel == 0)) {
HXLINE(  90)														int this1 = this5;
HXDLIN(  90)														col = this1;
            													}
            													else {
HXLINE(  90)														Float m0;
HXDLIN(  90)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  90)														if ((this1 == 0)) {
HXLINE(  90)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float m1;
HXDLIN(  90)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  90)														if ((this2 == 0)) {
HXLINE(  90)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float m2;
HXDLIN(  90)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  90)														if ((this3 == 0)) {
HXLINE(  90)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float m3;
HXDLIN(  90)														int this4 = (maskPixel & 255);
HXDLIN(  90)														if ((this4 == 0)) {
HXLINE(  90)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  90)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  90)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  90)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  90)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  90)												if ((col != 0)) {
HXLINE(  90)													int x = (dx - rectLeft);
HXDLIN(  90)													int y = (dy - rectTop);
HXDLIN(  90)													int this1 = col;
HXDLIN(  90)													int c = this1;
HXDLIN(  90)													bool _hx_tmp;
HXDLIN(  90)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  90)														_hx_tmp = undoImage3->transparent;
            													}
            													else {
HXLINE(  90)														_hx_tmp = false;
            													}
HXDLIN(  90)													if (_hx_tmp) {
HXLINE(  90)														int location;
HXDLIN(  90)														if (undoImage3->useVirtualPos) {
HXLINE(  90)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  90)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN(  90)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  90)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)														int this3 = this2;
HXDLIN(  90)														int this4;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  90)															this4 = this3;
            														}
HXDLIN(  90)														Float a1;
HXDLIN(  90)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  90)														if ((this5 == 0)) {
HXLINE(  90)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float r1;
HXDLIN(  90)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  90)														if ((this6 == 0)) {
HXLINE(  90)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float g1;
HXDLIN(  90)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  90)														if ((this7 == 0)) {
HXLINE(  90)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float b1;
HXDLIN(  90)														int this8 = (this4 & 255);
HXDLIN(  90)														if ((this8 == 0)) {
HXLINE(  90)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float a2;
HXDLIN(  90)														int this9 = ((col >> 24) & 255);
HXDLIN(  90)														if ((this9 == 0)) {
HXLINE(  90)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float r2;
HXDLIN(  90)														int this10 = ((col >> 16) & 255);
HXDLIN(  90)														if ((this10 == 0)) {
HXLINE(  90)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float g2;
HXDLIN(  90)														int this11 = ((col >> 8) & 255);
HXDLIN(  90)														if ((this11 == 0)) {
HXLINE(  90)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float b2;
HXDLIN(  90)														int this12 = (col & 255);
HXDLIN(  90)														if ((this12 == 0)) {
HXLINE(  90)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  90)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  90)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  90)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  90)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  90)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  90)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  90)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  90)														{
HXLINE(  90)															::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  90)															int value;
HXDLIN(  90)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  90)																value = blended;
            															}
HXDLIN(  90)															bool _hx_tmp;
HXDLIN(  90)															if ((location >= 0)) {
HXLINE(  90)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  90)																_hx_tmp = false;
            															}
HXDLIN(  90)															if (_hx_tmp) {
HXLINE(  90)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  90)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  90)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  90)														int index;
HXDLIN(  90)														if (undoImage3->useVirtualPos) {
HXLINE(  90)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  90)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN(  90)														int value;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  90)															value = c;
            														}
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((index >= 0)) {
HXLINE(  90)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  90)													if (forceClear) {
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  90)														int x = (dx - rectLeft);
HXDLIN(  90)														int y = (dy - rectTop);
HXDLIN(  90)														int index;
HXDLIN(  90)														if (undoImage3->useVirtualPos) {
HXLINE(  90)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  90)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((index >= 0)) {
HXLINE(  90)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  90)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  90)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  90)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  90)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  90)						bool found3 = false;
HXDLIN(  90)						Float min3 = ( (Float)(0) );
HXDLIN(  90)						Float max3 = ( (Float)(0) );
HXDLIN(  90)						int a4 = 0;
HXDLIN(  90)						int r3 = 0;
HXDLIN(  90)						int g3 = 0;
HXDLIN(  90)						int b3 = 0;
HXDLIN(  90)						{
HXLINE(  90)							int _g_min3 = xIter33->start;
HXDLIN(  90)							int _g_max3 = xIter33->max;
HXDLIN(  90)							while((_g_min3 < _g_max3)){
HXLINE(  90)								_g_min3 = (_g_min3 + 1);
HXDLIN(  90)								int px = (_g_min3 - 1);
HXDLIN(  90)								Float pcx = (( (Float)(px) ) - dx1);
HXLINE( 696)								found3 = false;
HXLINE(  90)								{
HXLINE(  90)									int _g_min = yIter33->start;
HXDLIN(  90)									int _g_max = yIter33->max;
HXDLIN(  90)									while((_g_min < _g_max)){
HXLINE(  90)										_g_min = (_g_min + 1);
HXDLIN(  90)										int py = (_g_min - 1);
HXDLIN(  90)										Float pcy = (( (Float)(py) ) - dy1);
HXDLIN(  90)										Float dot31 = ((pcx * bcx3) + (pcy * bcy3));
HXDLIN(  90)										Float dot32 = ((pcx * acx3) + (pcy * acy3));
HXDLIN(  90)										Float ratioA = (((dot223 * dot31) - (dot123 * dot32)) * denom13);
HXDLIN(  90)										Float ratioB = (((dot113 * dot32) - (dot123 * dot31)) * denom13);
HXDLIN(  90)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  90)										bool _hx_tmp;
HXDLIN(  90)										bool _hx_tmp1;
HXDLIN(  90)										if ((ratioA >= 0)) {
HXLINE(  90)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  90)											_hx_tmp1 = false;
            										}
HXDLIN(  90)										if (_hx_tmp1) {
HXLINE(  90)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  90)											_hx_tmp = false;
            										}
HXDLIN(  90)										if (_hx_tmp) {
HXLINE(  90)											Float min;
HXDLIN(  90)											if ((ratioA < ratioB)) {
HXLINE(  90)												min = ratioA;
            											}
            											else {
HXLINE(  90)												min = ratioB;
            											}
HXDLIN(  90)											if (!((min < ratioC))) {
HXLINE(  90)												min = ratioC;
            											}
HXDLIN(  90)											Float max;
HXDLIN(  90)											if ((ratioA > ratioB)) {
HXLINE(  90)												max = ratioA;
            											}
            											else {
HXLINE(  90)												max = ratioB;
            											}
HXDLIN(  90)											if (!((max > ratioC))) {
HXLINE(  90)												max = ratioC;
            											}
HXLINE( 744)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  90)											Float min1;
HXDLIN(  90)											if ((min < max)) {
HXLINE(  90)												min1 = min;
            											}
            											else {
HXLINE(  90)												min1 = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  90)											int i = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft3) * min1));
HXDLIN(  90)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  90)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  90)											int this1 = i;
HXDLIN(  90)											a4 = this1;
HXDLIN(  90)											int i1 = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN(  90)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  90)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  90)											int this2 = i1;
HXLINE( 748)											r3 = this2;
HXLINE(  90)											int i2 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN(  90)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  90)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  90)											int this3 = i2;
HXLINE( 749)											g3 = this3;
HXLINE(  90)											int i3 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN(  90)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  90)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  90)											int this4 = i3;
HXLINE( 750)											b3 = this4;
HXLINE(  90)											{
HXLINE(  90)												int location;
HXDLIN(  90)												if (pixelImage->useVirtualPos) {
HXLINE(  90)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  90)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            												}
HXDLIN(  90)												bool _hx_tmp;
HXDLIN(  90)												if (pixelImage->transparent) {
HXLINE(  90)													_hx_tmp = (a4 < 254);
            												}
            												else {
HXLINE(  90)													_hx_tmp = false;
            												}
HXDLIN(  90)												if (_hx_tmp) {
HXLINE(  90)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  90)													int this3 = this2;
HXDLIN(  90)													int old;
HXDLIN(  90)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  90)														old = this3;
            													}
HXDLIN(  90)													int rhs = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  90)													Float a1;
HXDLIN(  90)													int this4 = ((old >> 24) & 255);
HXDLIN(  90)													if ((this4 == 0)) {
HXLINE(  90)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float r1;
HXDLIN(  90)													int this5 = ((old >> 16) & 255);
HXDLIN(  90)													if ((this5 == 0)) {
HXLINE(  90)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float g1;
HXDLIN(  90)													int this6 = ((old >> 8) & 255);
HXDLIN(  90)													if ((this6 == 0)) {
HXLINE(  90)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float b1;
HXDLIN(  90)													int this7 = (old & 255);
HXDLIN(  90)													if ((this7 == 0)) {
HXLINE(  90)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float a2;
HXDLIN(  90)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  90)													if ((this8 == 0)) {
HXLINE(  90)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float r2;
HXDLIN(  90)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  90)													if ((this9 == 0)) {
HXLINE(  90)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float g2;
HXDLIN(  90)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  90)													if ((this10 == 0)) {
HXLINE(  90)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float b2;
HXDLIN(  90)													int this11 = (rhs & 255);
HXDLIN(  90)													if ((this11 == 0)) {
HXLINE(  90)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  90)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  90)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  90)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  90)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  90)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  90)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  90)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  90)													{
HXLINE(  90)														::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  90)														int value;
HXDLIN(  90)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  90)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  90)															value = blended;
            														}
HXDLIN(  90)														bool _hx_tmp;
HXDLIN(  90)														if ((location >= 0)) {
HXLINE(  90)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  90)															_hx_tmp = false;
            														}
HXDLIN(  90)														if (_hx_tmp) {
HXLINE(  90)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  90)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  90)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  90)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  90)													int value;
HXDLIN(  90)													if (pixelImage->isLittle) {
HXLINE(  90)														value = ((((a4 << 24) | (b3 << 16)) | (g3 << 8)) | r3);
            													}
            													else {
HXLINE(  90)														value = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
            													}
HXDLIN(  90)													bool _hx_tmp;
HXDLIN(  90)													if ((location >= 0)) {
HXLINE(  90)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  90)														_hx_tmp = false;
            													}
HXDLIN(  90)													if (_hx_tmp) {
HXLINE(  90)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  90)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  90)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  90)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  90)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  90)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 752)											found3 = true;
            										}
            										else {
HXLINE(  90)											if (found3) {
HXLINE(  90)												goto _hx_goto_122;
            											}
            										}
            									}
            									_hx_goto_122:;
            								}
            							}
            						}
HXDLIN(  90)						::pixelimage::algo::HitTri hitTriBottom;
HXDLIN(  90)						if ((hasHit == false)) {
HXLINE(  90)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,ax1,ay1,dx1,dy1,true);
HXDLIN(  90)							if (hasUndo3) {
HXLINE(  90)								v->undoImage = undoImage3;
HXDLIN(  90)								v->undoX = xIter33->start;
HXDLIN(  90)								v->undoY = yIter33->start;
            							}
HXDLIN(  90)							hitTriBottom = v;
            						}
            						else {
HXLINE(  90)							hitTriBottom = null();
            						}
HXDLIN(  90)						if (hasHit) {
HXLINE(  90)							::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN(  90)							if (::hx::IsNotNull( hitQuad )) {
HXLINE(  90)								hitArr->triArr->push(hitQuad->triABD);
            							}
HXDLIN(  90)							hitArr->triArr->push(hitQuad->triBCD);
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE(  94)			if ((this->both == false)) {
HXLINE(  95)				bool _hx_tmp;
HXDLIN(  95)				if (!((this->arrowHeight > ((Float)0.)))) {
HXLINE(  95)					_hx_tmp = (this->arrowWidth > ((Float)0.));
            				}
            				else {
HXLINE(  95)					_hx_tmp = true;
            				}
HXDLIN(  95)				if (_hx_tmp) {
HXLINE(  96)					Float arrowWidth = this->arrowWidth;
HXDLIN(  96)					Float arrowHeight = this->arrowHeight;
HXDLIN(  96)					Float thick = this->strokeWidth;
HXDLIN(  96)					int color = this->strokeColor;
HXDLIN(  96)					Float soft = this->soft;
HXDLIN(  96)					bool hasHit = true;
HXDLIN(  96)					{
HXLINE(  96)						Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  96)						Float o = (py - py);
HXDLIN(  96)						Float a = (px - px);
HXDLIN(  96)						Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  96)						Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  96)						Float thicker;
HXDLIN(  96)						if ((arrowWidth > (thick * ((Float)1.1)))) {
HXLINE(  96)							thicker = arrowWidth;
            						}
            						else {
HXLINE(  96)							thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            						}
HXDLIN(  96)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  96)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  96)						Float radius = (thick / ( (Float)(2) ));
HXDLIN(  96)						Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  96)						Float h2;
HXDLIN(  96)						if ((arrowHeight < (h * ((Float)1.1)))) {
HXLINE(  96)							h2 = (h - arrowHeight);
            						}
            						else {
HXLINE(  96)							h2 = (h / goldenRatio);
            						}
HXDLIN(  96)						::pixelimage::algo::HitQuad hitQuad;
HXDLIN(  96)						if (this->flare) {
HXLINE(  96)							if (this->reverseFlare) {
HXLINE(  96)								Float sin = ::Math_obj::sin(theta);
HXDLIN(  96)								Float cos = ::Math_obj::cos(theta);
HXDLIN(  96)								Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  96)								Float radius2 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  96)								Float dx = ((Float)0.1);
HXDLIN(  96)								Float dy = radius1;
HXDLIN(  96)								Float cx = h2;
HXDLIN(  96)								Float cy = radius2;
HXDLIN(  96)								Float bx = h2;
HXDLIN(  96)								Float by = -(radius2);
HXDLIN(  96)								Float ax = ((Float)0.1);
HXDLIN(  96)								Float ay = -(radius1);
HXDLIN(  96)								Float temp = ((Float)0.);
HXLINE( 288)								temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)								ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)								ax = temp;
HXLINE( 292)								temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)								by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)								bx = temp;
HXLINE( 296)								temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)								cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)								cx = temp;
HXLINE( 300)								temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)								dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)								dx = temp;
HXLINE(  96)								Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN(  96)								Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN(  96)								bool hasUndo = false;
HXDLIN(  96)								int aA = ((color >> 24) & 255);
HXDLIN(  96)								int rA = ((color >> 16) & 255);
HXDLIN(  96)								int gA = ((color >> 8) & 255);
HXDLIN(  96)								int bA = (color & 255);
HXDLIN(  96)								Float bcx = (ax - bx);
HXDLIN(  96)								Float bcy = (ay - by);
HXDLIN(  96)								Float acx = (ex - bx);
HXDLIN(  96)								Float acy = (ey - by);
HXDLIN(  96)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  96)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  96)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  96)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  96)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  96)								if ((ex > ax)) {
HXLINE(  96)									if ((ex > bx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ax > bx)) {
HXLINE(  96)											min = ::Math_obj::floor(bx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(ax);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((ax > bx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ex > bx)) {
HXLINE(  96)											min = ::Math_obj::floor(bx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  96)								if ((ey > ay)) {
HXLINE(  96)									if ((ey > by)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ay > by)) {
HXLINE(  96)											min = ::Math_obj::floor(by);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(ay);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((ay > by)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ey > by)) {
HXLINE(  96)											min = ::Math_obj::floor(by);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  96)								if (hasUndo) {
HXLINE(  96)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  96)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  96)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)									undoImage = this3;
HXDLIN(  96)									{
HXLINE(  96)										int rectLeft = xIter3->start;
HXDLIN(  96)										int rectTop = yIter3->start;
HXDLIN(  96)										int rectRight = xIter3->max;
HXDLIN(  96)										bool forceClear = false;
HXDLIN(  96)										{
HXLINE(  96)											int _g = rectTop;
HXDLIN(  96)											int _g1 = yIter3->max;
HXDLIN(  96)											while((_g < _g1)){
HXLINE(  96)												_g = (_g + 1);
HXDLIN(  96)												int dy = (_g - 1);
HXDLIN(  96)												{
HXLINE(  96)													int _g1 = rectLeft;
HXDLIN(  96)													int _g2 = rectRight;
HXDLIN(  96)													while((_g1 < _g2)){
HXLINE(  96)														_g1 = (_g1 + 1);
HXDLIN(  96)														int dx = (_g1 - 1);
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int col;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															col = c;
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->useMask) {
HXLINE(  96)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)															int index;
HXDLIN(  96)															if (this1->useVirtualPos) {
HXLINE(  96)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  96)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  96)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int v;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  96)																v = c;
            															}
HXDLIN(  96)															int this3 = v;
HXDLIN(  96)															int maskPixel = this3;
HXDLIN(  96)															int this4 = col;
HXDLIN(  96)															int this5 = this4;
HXDLIN(  96)															if ((maskPixel == 0)) {
HXLINE(  96)																int this1 = this5;
HXDLIN(  96)																col = this1;
            															}
            															else {
HXLINE(  96)																Float m0;
HXDLIN(  96)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																if ((this1 == 0)) {
HXLINE(  96)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m1;
HXDLIN(  96)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																if ((this2 == 0)) {
HXLINE(  96)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m2;
HXDLIN(  96)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																if ((this3 == 0)) {
HXLINE(  96)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m3;
HXDLIN(  96)																int this4 = (maskPixel & 255);
HXDLIN(  96)																if ((this4 == 0)) {
HXLINE(  96)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  96)														if ((col != 0)) {
HXLINE(  96)															int x = (dx - rectLeft);
HXDLIN(  96)															int y = (dy - rectTop);
HXDLIN(  96)															int this1 = col;
HXDLIN(  96)															int c = this1;
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																int location;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int this3 = this2;
HXDLIN(  96)																int this4;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	this4 = this3;
            																}
HXDLIN(  96)																Float a1;
HXDLIN(  96)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																if ((this5 == 0)) {
HXLINE(  96)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r1;
HXDLIN(  96)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																if ((this6 == 0)) {
HXLINE(  96)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g1;
HXDLIN(  96)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																if ((this7 == 0)) {
HXLINE(  96)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b1;
HXDLIN(  96)																int this8 = (this4 & 255);
HXDLIN(  96)																if ((this8 == 0)) {
HXLINE(  96)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a2;
HXDLIN(  96)																int this9 = ((col >> 24) & 255);
HXDLIN(  96)																if ((this9 == 0)) {
HXLINE(  96)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r2;
HXDLIN(  96)																int this10 = ((col >> 16) & 255);
HXDLIN(  96)																if ((this10 == 0)) {
HXLINE(  96)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g2;
HXDLIN(  96)																int this11 = ((col >> 8) & 255);
HXDLIN(  96)																if ((this11 == 0)) {
HXLINE(  96)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b2;
HXDLIN(  96)																int this12 = (col & 255);
HXDLIN(  96)																if ((this12 == 0)) {
HXLINE(  96)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																{
HXLINE(  96)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  96)																	int value;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		value = blended;
            																	}
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((location >= 0)) {
HXLINE(  96)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															if (forceClear) {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																int x = (dx - rectLeft);
HXDLIN(  96)																int y = (dy - rectTop);
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool found = false;
HXDLIN(  96)								{
HXLINE(  96)									int _g_min = xIter3->start;
HXDLIN(  96)									int _g_max = xIter3->max;
HXDLIN(  96)									while((_g_min < _g_max)){
HXLINE(  96)										_g_min = (_g_min + 1);
HXDLIN(  96)										int px = (_g_min - 1);
HXDLIN(  96)										Float pcx = (( (Float)(px) ) - bx);
HXLINE( 620)										found = false;
HXLINE(  96)										{
HXLINE(  96)											int _g_min1 = yIter3->start;
HXDLIN(  96)											int _g_max = yIter3->max;
HXDLIN(  96)											while((_g_min1 < _g_max)){
HXLINE(  96)												_g_min1 = (_g_min1 + 1);
HXDLIN(  96)												int py = (_g_min1 - 1);
HXDLIN(  96)												Float pcy = (( (Float)(py) ) - by);
HXDLIN(  96)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  96)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  96)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  96)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  96)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)												bool hitQuad;
HXDLIN(  96)												bool hitQuad1;
HXDLIN(  96)												if ((ratioA >= 0)) {
HXLINE(  96)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad1 = false;
            												}
HXDLIN(  96)												if (hitQuad1) {
HXLINE(  96)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad = false;
            												}
HXDLIN(  96)												if (hitQuad) {
HXLINE(  96)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (soft * ratioB)));
HXDLIN(  96)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  96)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  96)													int this1 = i;
HXDLIN(  96)													int a = this1;
HXDLIN(  96)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  96)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  96)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  96)													int this2 = i1;
HXDLIN(  96)													int r = this2;
HXDLIN(  96)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  96)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  96)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  96)													int this3 = i2;
HXDLIN(  96)													int g = this3;
HXDLIN(  96)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  96)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  96)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  96)													int this4 = i3;
HXDLIN(  96)													int b = this4;
HXDLIN(  96)													{
HXLINE(  96)														int location;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->transparent) {
HXLINE(  96)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int this3 = this2;
HXDLIN(  96)															int old;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  96)																old = this3;
            															}
HXDLIN(  96)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)															Float a1;
HXDLIN(  96)															int this4 = ((old >> 24) & 255);
HXDLIN(  96)															if ((this4 == 0)) {
HXLINE(  96)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r1;
HXDLIN(  96)															int this5 = ((old >> 16) & 255);
HXDLIN(  96)															if ((this5 == 0)) {
HXLINE(  96)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g1;
HXDLIN(  96)															int this6 = ((old >> 8) & 255);
HXDLIN(  96)															if ((this6 == 0)) {
HXLINE(  96)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b1;
HXDLIN(  96)															int this7 = (old & 255);
HXDLIN(  96)															if ((this7 == 0)) {
HXLINE(  96)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a2;
HXDLIN(  96)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)															if ((this8 == 0)) {
HXLINE(  96)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r2;
HXDLIN(  96)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)															if ((this9 == 0)) {
HXLINE(  96)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g2;
HXDLIN(  96)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)															if ((this10 == 0)) {
HXLINE(  96)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b2;
HXDLIN(  96)															int this11 = (rhs & 255);
HXDLIN(  96)															if ((this11 == 0)) {
HXLINE(  96)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  96)															{
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = blended;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((location >= 0)) {
HXLINE(  96)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (pixelImage->isLittle) {
HXLINE(  96)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  96)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found = true;
            												}
            												else {
HXLINE(  96)													if (found) {
HXLINE(  96)														goto _hx_goto_126;
            													}
            												}
            											}
            											_hx_goto_126:;
            										}
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  96)								int v_undoY;
HXDLIN(  96)								int v_undoX;
HXDLIN(  96)								Float v_ty;
HXDLIN(  96)								Float v_tx;
HXDLIN(  96)								Float v_t0;
HXDLIN(  96)								Float v_sy;
HXDLIN(  96)								Float v_sx;
HXDLIN(  96)								Float v_s0;
HXDLIN(  96)								Float v_A;
HXDLIN(  96)								Float ax1 = ex;
HXDLIN(  96)								Float ay1 = ey;
HXDLIN(  96)								Float bx1 = ax;
HXDLIN(  96)								Float by1 = ay;
HXDLIN(  96)								Float cx1 = bx;
HXDLIN(  96)								Float cy1 = by;
HXDLIN(  96)								::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  96)								bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN(  96)								if (!(adjustWinding)) {
HXLINE(  96)									Float bx_ = bx1;
HXDLIN(  96)									Float by_ = by1;
HXLINE(  35)									bx1 = cx1;
HXLINE(  36)									by1 = cy1;
HXLINE(  37)									cx1 = bx_;
HXLINE(  38)									cy1 = by_;
            								}
HXLINE(  96)								Float v_ax = ax1;
HXDLIN(  96)								Float v_ay = ay1;
HXDLIN(  96)								Float v_bx = bx1;
HXDLIN(  96)								Float v_by = by1;
HXDLIN(  96)								Float v_cx = cx1;
HXDLIN(  96)								Float v_cy = cy1;
HXDLIN(  96)								bool v_preCalculated = true;
HXDLIN(  96)								{
HXLINE(  96)									v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  96)									v_sx = (v_cy - v_ay);
HXDLIN(  96)									v_sy = (v_ax - v_cx);
HXDLIN(  96)									v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  96)									v_tx = (v_ay - v_by);
HXDLIN(  96)									v_ty = (v_bx - v_ax);
HXDLIN(  96)									v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  96)									Float a = v_ax;
HXDLIN(  96)									Float b = v_bx;
HXDLIN(  96)									Float c = v_cx;
HXDLIN(  96)									if ((a > b)) {
HXLINE(  96)										if ((a > c)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b > c)) {
HXLINE(  96)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b > c)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a > c)) {
HXLINE(  96)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter3 = this1;
            										}
            									}
HXDLIN(  96)									Float a1 = v_ay;
HXDLIN(  96)									Float b1 = v_by;
HXDLIN(  96)									Float c1 = v_cy;
HXDLIN(  96)									if ((a1 > b1)) {
HXLINE(  96)										if ((a1 > c1)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b1 > c1)) {
HXLINE(  96)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b1);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b1);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b1 > c1)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a1 > c1)) {
HXLINE(  96)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a1);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a1);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter3 = this1;
            										}
            									}
            								}
HXDLIN(  96)								if (hasUndo) {
HXLINE(  96)									v_undoImage = undoImage;
HXDLIN(  96)									v_undoX = xIter3->start;
HXDLIN(  96)									v_undoY = yIter3->start;
            								}
HXDLIN(  96)								{
HXLINE(  96)									Float bx2 = bx;
HXDLIN(  96)									Float by2 = by;
HXDLIN(  96)									Float cx2 = cx;
HXDLIN(  96)									Float cy2 = cy;
HXDLIN(  96)									bool hasUndo1 = false;
HXDLIN(  96)									bool adjustWinding1 = (((((ex * by2) - (bx2 * ey)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ey) - (ex * cy2))) > 0);
HXDLIN(  96)									if (!(adjustWinding1)) {
HXLINE(  96)										Float bx_ = bx2;
HXDLIN(  96)										Float by_ = by2;
HXLINE(  26)										bx2 = cx2;
HXLINE(  27)										by2 = cy2;
HXLINE(  28)										cx2 = bx_;
HXLINE(  29)										cy2 = by_;
            									}
HXLINE(  96)									{
HXLINE(  96)										Float s0 = ((ey * cx2) - (ex * cy2));
HXDLIN(  96)										Float sx = (cy2 - ey);
HXDLIN(  96)										Float sy = (ex - cx2);
HXDLIN(  96)										Float t0 = ((ex * by2) - (ey * bx2));
HXDLIN(  96)										Float tx = (ey - by2);
HXDLIN(  96)										Float ty = (bx2 - ex);
HXDLIN(  96)										Float A = ((((-(by2) * cx2) + (ey * (-(bx2) + cx2))) + (ex * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  96)										::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  96)										if ((ex > bx2)) {
HXLINE(  96)											if ((ex > cx2)) {
HXLINE(  96)												int min;
HXDLIN(  96)												if ((bx2 > cx2)) {
HXLINE(  96)													min = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  96)													min = ::Math_obj::floor(bx2);
            												}
HXDLIN(  96)												int ii_min = min;
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												xIter31 = this1;
            											}
            											else {
HXLINE(  96)												int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												xIter31 = this1;
            											}
            										}
            										else {
HXLINE(  96)											if ((bx2 > cx2)) {
HXLINE(  96)												int min;
HXDLIN(  96)												if ((ex > cx2)) {
HXLINE(  96)													min = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  96)													min = ::Math_obj::ceil(ex);
            												}
HXDLIN(  96)												int ii_min = min;
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												xIter31 = this1;
            											}
            											else {
HXLINE(  96)												int ii_min = ::Math_obj::floor(ex);
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												xIter31 = this1;
            											}
            										}
HXDLIN(  96)										::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  96)										if ((ey > by2)) {
HXLINE(  96)											if ((ey > cy2)) {
HXLINE(  96)												int min;
HXDLIN(  96)												if ((by2 > cy2)) {
HXLINE(  96)													min = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  96)													min = ::Math_obj::floor(by2);
            												}
HXDLIN(  96)												int ii_min = min;
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												yIter31 = this1;
            											}
            											else {
HXLINE(  96)												int ii_min = ::Math_obj::floor(by2);
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												yIter31 = this1;
            											}
            										}
            										else {
HXLINE(  96)											if ((by2 > cy2)) {
HXLINE(  96)												int min;
HXDLIN(  96)												if ((ey > cy2)) {
HXLINE(  96)													min = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  96)													min = ::Math_obj::ceil(ey);
            												}
HXDLIN(  96)												int ii_min = min;
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												yIter31 = this1;
            											}
            											else {
HXLINE(  96)												int ii_min = ::Math_obj::floor(ey);
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												yIter31 = this1;
            											}
            										}
HXDLIN(  96)										::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  96)										if (hasUndo1) {
HXLINE(  96)											int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  96)											int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  96)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)											undoImage1 = this3;
HXDLIN(  96)											{
HXLINE(  96)												int rectLeft = xIter31->start;
HXDLIN(  96)												int rectTop = yIter31->start;
HXDLIN(  96)												int rectRight = xIter31->max;
HXDLIN(  96)												bool forceClear = false;
HXDLIN(  96)												{
HXLINE(  96)													int _g = rectTop;
HXDLIN(  96)													int _g1 = yIter31->max;
HXDLIN(  96)													while((_g < _g1)){
HXLINE(  96)														_g = (_g + 1);
HXDLIN(  96)														int dy = (_g - 1);
HXDLIN(  96)														{
HXLINE(  96)															int _g1 = rectLeft;
HXDLIN(  96)															int _g2 = rectRight;
HXDLIN(  96)															while((_g1 < _g2)){
HXLINE(  96)																_g1 = (_g1 + 1);
HXDLIN(  96)																int dx = (_g1 - 1);
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (pixelImage->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            																}
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int col;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	col = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if (pixelImage->useMask) {
HXLINE(  96)																	hitQuad = ::hx::IsNotNull( pixelImage->mask );
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)																	int index;
HXDLIN(  96)																	if (this1->useVirtualPos) {
HXLINE(  96)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  96)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  96)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																	int v;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		v = c;
            																	}
HXDLIN(  96)																	int this3 = v;
HXDLIN(  96)																	int maskPixel = this3;
HXDLIN(  96)																	int this4 = col;
HXDLIN(  96)																	int this5 = this4;
HXDLIN(  96)																	if ((maskPixel == 0)) {
HXLINE(  96)																		int this1 = this5;
HXDLIN(  96)																		col = this1;
            																	}
            																	else {
HXLINE(  96)																		Float m0;
HXDLIN(  96)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																		if ((this1 == 0)) {
HXLINE(  96)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float m1;
HXDLIN(  96)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																		if ((this2 == 0)) {
HXLINE(  96)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float m2;
HXDLIN(  96)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																		if ((this3 == 0)) {
HXLINE(  96)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float m3;
HXDLIN(  96)																		int this4 = (maskPixel & 255);
HXDLIN(  96)																		if ((this4 == 0)) {
HXLINE(  96)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  96)																if ((col != 0)) {
HXLINE(  96)																	int x = (dx - rectLeft);
HXDLIN(  96)																	int y = (dy - rectTop);
HXDLIN(  96)																	int this1 = col;
HXDLIN(  96)																	int c = this1;
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																		hitQuad = undoImage1->transparent;
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		int location;
HXDLIN(  96)																		if (undoImage1->useVirtualPos) {
HXLINE(  96)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  96)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  96)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																		int this3 = this2;
HXDLIN(  96)																		int this4;
HXDLIN(  96)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  96)																			this4 = this3;
            																		}
HXDLIN(  96)																		Float a1;
HXDLIN(  96)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																		if ((this5 == 0)) {
HXLINE(  96)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float r1;
HXDLIN(  96)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																		if ((this6 == 0)) {
HXLINE(  96)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float g1;
HXDLIN(  96)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																		if ((this7 == 0)) {
HXLINE(  96)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float b1;
HXDLIN(  96)																		int this8 = (this4 & 255);
HXDLIN(  96)																		if ((this8 == 0)) {
HXLINE(  96)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float a2;
HXDLIN(  96)																		int this9 = ((col >> 24) & 255);
HXDLIN(  96)																		if ((this9 == 0)) {
HXLINE(  96)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float r2;
HXDLIN(  96)																		int this10 = ((col >> 16) & 255);
HXDLIN(  96)																		if ((this10 == 0)) {
HXLINE(  96)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float g2;
HXDLIN(  96)																		int this11 = ((col >> 8) & 255);
HXDLIN(  96)																		if ((this11 == 0)) {
HXLINE(  96)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float b2;
HXDLIN(  96)																		int this12 = (col & 255);
HXDLIN(  96)																		if ((this12 == 0)) {
HXLINE(  96)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																		{
HXLINE(  96)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  96)																			int value;
HXDLIN(  96)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  96)																				value = blended;
            																			}
HXDLIN(  96)																			bool hitQuad;
HXDLIN(  96)																			if ((location >= 0)) {
HXLINE(  96)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  96)																				hitQuad = false;
            																			}
HXDLIN(  96)																			if (hitQuad) {
HXLINE(  96)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  96)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																		int index;
HXDLIN(  96)																		if (undoImage1->useVirtualPos) {
HXLINE(  96)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  96)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  96)																		int value;
HXDLIN(  96)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  96)																			value = c;
            																		}
HXDLIN(  96)																		bool hitQuad;
HXDLIN(  96)																		if ((index >= 0)) {
HXLINE(  96)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  96)																			hitQuad = false;
            																		}
HXDLIN(  96)																		if (hitQuad) {
HXLINE(  96)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  96)																	if (forceClear) {
HXLINE(  96)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																		int x = (dx - rectLeft);
HXDLIN(  96)																		int y = (dy - rectTop);
HXDLIN(  96)																		int index;
HXDLIN(  96)																		if (undoImage1->useVirtualPos) {
HXLINE(  96)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  96)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  96)																		bool hitQuad;
HXDLIN(  96)																		if ((index >= 0)) {
HXLINE(  96)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  96)																			hitQuad = false;
            																		}
HXDLIN(  96)																		if (hitQuad) {
HXLINE(  96)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  96)										bool found1 = false;
HXDLIN(  96)										Float s = ((Float)0.);
HXDLIN(  96)										Float t = ((Float)0.);
HXDLIN(  96)										Float sxx = ((Float)0.);
HXDLIN(  96)										Float txx = ((Float)0.);
HXDLIN(  96)										{
HXLINE(  96)											int _g_min1 = xIter31->start;
HXDLIN(  96)											int _g_max1 = xIter31->max;
HXDLIN(  96)											while((_g_min1 < _g_max1)){
HXLINE(  96)												_g_min1 = (_g_min1 + 1);
HXDLIN(  96)												int x = (_g_min1 - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found1 = false;
HXLINE(  96)												{
HXLINE(  96)													int _g_min = yIter31->start;
HXDLIN(  96)													int _g_max = yIter31->max;
HXDLIN(  96)													while((_g_min < _g_max)){
HXLINE(  96)														_g_min = (_g_min + 1);
HXDLIN(  96)														int y = (_g_min - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  96)														bool hitQuad;
HXDLIN(  96)														if (!((s <= 0))) {
HXLINE(  96)															hitQuad = (t <= 0);
            														}
            														else {
HXLINE(  96)															hitQuad = true;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															if (found1) {
HXLINE(  96)																goto _hx_goto_130;
            															}
            														}
            														else {
HXLINE(  96)															if (((s + t) < A)) {
HXLINE(  96)																{
HXLINE(  96)																	int this1 = color;
HXDLIN(  96)																	int c = this1;
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																		hitQuad = pixelImage->transparent;
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		int location;
HXDLIN(  96)																		if (pixelImage->useVirtualPos) {
HXLINE(  96)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  96)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  96)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																		int this3 = this2;
HXDLIN(  96)																		int this4;
HXDLIN(  96)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  96)																			this4 = this3;
            																		}
HXDLIN(  96)																		Float a1;
HXDLIN(  96)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																		if ((this5 == 0)) {
HXLINE(  96)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float r1;
HXDLIN(  96)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																		if ((this6 == 0)) {
HXLINE(  96)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float g1;
HXDLIN(  96)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																		if ((this7 == 0)) {
HXLINE(  96)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float b1;
HXDLIN(  96)																		int this8 = (this4 & 255);
HXDLIN(  96)																		if ((this8 == 0)) {
HXLINE(  96)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float a2;
HXDLIN(  96)																		int this9 = ((color >> 24) & 255);
HXDLIN(  96)																		if ((this9 == 0)) {
HXLINE(  96)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float r2;
HXDLIN(  96)																		int this10 = ((color >> 16) & 255);
HXDLIN(  96)																		if ((this10 == 0)) {
HXLINE(  96)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float g2;
HXDLIN(  96)																		int this11 = ((color >> 8) & 255);
HXDLIN(  96)																		if ((this11 == 0)) {
HXLINE(  96)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float b2;
HXDLIN(  96)																		int this12 = (color & 255);
HXDLIN(  96)																		if ((this12 == 0)) {
HXLINE(  96)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																		{
HXLINE(  96)																			::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN(  96)																			int value;
HXDLIN(  96)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  96)																				value = blended;
            																			}
HXDLIN(  96)																			bool hitQuad;
HXDLIN(  96)																			if ((location >= 0)) {
HXLINE(  96)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  96)																				hitQuad = false;
            																			}
HXDLIN(  96)																			if (hitQuad) {
HXLINE(  96)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  96)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)																		int index;
HXDLIN(  96)																		if (pixelImage->useVirtualPos) {
HXLINE(  96)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  96)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  96)																		int value;
HXDLIN(  96)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  96)																			value = c;
            																		}
HXDLIN(  96)																		bool hitQuad;
HXDLIN(  96)																		if ((index >= 0)) {
HXLINE(  96)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  96)																			hitQuad = false;
            																		}
HXDLIN(  96)																		if (hitQuad) {
HXLINE(  96)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found1 = true;
            															}
            															else {
HXLINE(  96)																if (found1) {
HXLINE(  96)																	goto _hx_goto_130;
            																}
            															}
            														}
            													}
            													_hx_goto_130:;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool hasUndo2 = false;
HXDLIN(  96)								int aA1 = ((color >> 24) & 255);
HXDLIN(  96)								int rA1 = ((color >> 16) & 255);
HXDLIN(  96)								int gA1 = ((color >> 8) & 255);
HXDLIN(  96)								int bA1 = (color & 255);
HXDLIN(  96)								Float bcx1 = (cx - dx);
HXDLIN(  96)								Float bcy1 = (cy - dy);
HXDLIN(  96)								Float acx1 = (ex - dx);
HXDLIN(  96)								Float acy1 = (ey - dy);
HXDLIN(  96)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  96)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  96)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  96)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  96)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  96)								if ((ex > cx)) {
HXLINE(  96)									if ((ex > dx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((cx > dx)) {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter32 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((cx > dx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ex > dx)) {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter32 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter32 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  96)								if ((ey > cy)) {
HXLINE(  96)									if ((ey > dy)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((cy > dy)) {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter32 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((cy > dy)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ey > dy)) {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter32 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter32 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  96)								if (hasUndo2) {
HXLINE(  96)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  96)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  96)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)									undoImage2 = this3;
HXDLIN(  96)									{
HXLINE(  96)										int rectLeft = xIter32->start;
HXDLIN(  96)										int rectTop = yIter32->start;
HXDLIN(  96)										int rectRight = xIter32->max;
HXDLIN(  96)										bool forceClear = false;
HXDLIN(  96)										{
HXLINE(  96)											int _g = rectTop;
HXDLIN(  96)											int _g1 = yIter32->max;
HXDLIN(  96)											while((_g < _g1)){
HXLINE(  96)												_g = (_g + 1);
HXDLIN(  96)												int dy = (_g - 1);
HXDLIN(  96)												{
HXLINE(  96)													int _g1 = rectLeft;
HXDLIN(  96)													int _g2 = rectRight;
HXDLIN(  96)													while((_g1 < _g2)){
HXLINE(  96)														_g1 = (_g1 + 1);
HXDLIN(  96)														int dx = (_g1 - 1);
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int col;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															col = c;
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->useMask) {
HXLINE(  96)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)															int index;
HXDLIN(  96)															if (this1->useVirtualPos) {
HXLINE(  96)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  96)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  96)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int v;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  96)																v = c;
            															}
HXDLIN(  96)															int this3 = v;
HXDLIN(  96)															int maskPixel = this3;
HXDLIN(  96)															int this4 = col;
HXDLIN(  96)															int this5 = this4;
HXDLIN(  96)															if ((maskPixel == 0)) {
HXLINE(  96)																int this1 = this5;
HXDLIN(  96)																col = this1;
            															}
            															else {
HXLINE(  96)																Float m0;
HXDLIN(  96)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																if ((this1 == 0)) {
HXLINE(  96)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m1;
HXDLIN(  96)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																if ((this2 == 0)) {
HXLINE(  96)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m2;
HXDLIN(  96)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																if ((this3 == 0)) {
HXLINE(  96)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m3;
HXDLIN(  96)																int this4 = (maskPixel & 255);
HXDLIN(  96)																if ((this4 == 0)) {
HXLINE(  96)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  96)														if ((col != 0)) {
HXLINE(  96)															int x = (dx - rectLeft);
HXDLIN(  96)															int y = (dy - rectTop);
HXDLIN(  96)															int this1 = col;
HXDLIN(  96)															int c = this1;
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																hitQuad = undoImage2->transparent;
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																int location;
HXDLIN(  96)																if (undoImage2->useVirtualPos) {
HXLINE(  96)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  96)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int this3 = this2;
HXDLIN(  96)																int this4;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	this4 = this3;
            																}
HXDLIN(  96)																Float a1;
HXDLIN(  96)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																if ((this5 == 0)) {
HXLINE(  96)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r1;
HXDLIN(  96)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																if ((this6 == 0)) {
HXLINE(  96)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g1;
HXDLIN(  96)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																if ((this7 == 0)) {
HXLINE(  96)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b1;
HXDLIN(  96)																int this8 = (this4 & 255);
HXDLIN(  96)																if ((this8 == 0)) {
HXLINE(  96)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a2;
HXDLIN(  96)																int this9 = ((col >> 24) & 255);
HXDLIN(  96)																if ((this9 == 0)) {
HXLINE(  96)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r2;
HXDLIN(  96)																int this10 = ((col >> 16) & 255);
HXDLIN(  96)																if ((this10 == 0)) {
HXLINE(  96)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g2;
HXDLIN(  96)																int this11 = ((col >> 8) & 255);
HXDLIN(  96)																if ((this11 == 0)) {
HXLINE(  96)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b2;
HXDLIN(  96)																int this12 = (col & 255);
HXDLIN(  96)																if ((this12 == 0)) {
HXLINE(  96)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																{
HXLINE(  96)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  96)																	int value;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		value = blended;
            																	}
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((location >= 0)) {
HXLINE(  96)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage2->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															if (forceClear) {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  96)																int x = (dx - rectLeft);
HXDLIN(  96)																int y = (dy - rectTop);
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage2->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool found2 = false;
HXDLIN(  96)								{
HXLINE(  96)									int _g_min2 = xIter32->start;
HXDLIN(  96)									int _g_max2 = xIter32->max;
HXDLIN(  96)									while((_g_min2 < _g_max2)){
HXLINE(  96)										_g_min2 = (_g_min2 + 1);
HXDLIN(  96)										int px = (_g_min2 - 1);
HXDLIN(  96)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 620)										found2 = false;
HXLINE(  96)										{
HXLINE(  96)											int _g_min = yIter32->start;
HXDLIN(  96)											int _g_max = yIter32->max;
HXDLIN(  96)											while((_g_min < _g_max)){
HXLINE(  96)												_g_min = (_g_min + 1);
HXDLIN(  96)												int py = (_g_min - 1);
HXDLIN(  96)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  96)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  96)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  96)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  96)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  96)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)												bool hitQuad;
HXDLIN(  96)												bool hitQuad1;
HXDLIN(  96)												if ((ratioA >= 0)) {
HXLINE(  96)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad1 = false;
            												}
HXDLIN(  96)												if (hitQuad1) {
HXLINE(  96)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad = false;
            												}
HXDLIN(  96)												if (hitQuad) {
HXLINE(  96)													int i = ::Std_obj::_hx_int((( (Float)(aA1) ) * (soft * ratioB)));
HXDLIN(  96)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  96)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  96)													int this1 = i;
HXDLIN(  96)													int a = this1;
HXDLIN(  96)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  96)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  96)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  96)													int this2 = i1;
HXDLIN(  96)													int r = this2;
HXDLIN(  96)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  96)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  96)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  96)													int this3 = i2;
HXDLIN(  96)													int g = this3;
HXDLIN(  96)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  96)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  96)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  96)													int this4 = i3;
HXDLIN(  96)													int b = this4;
HXDLIN(  96)													{
HXLINE(  96)														int location;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->transparent) {
HXLINE(  96)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int this3 = this2;
HXDLIN(  96)															int old;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  96)																old = this3;
            															}
HXDLIN(  96)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)															Float a1;
HXDLIN(  96)															int this4 = ((old >> 24) & 255);
HXDLIN(  96)															if ((this4 == 0)) {
HXLINE(  96)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r1;
HXDLIN(  96)															int this5 = ((old >> 16) & 255);
HXDLIN(  96)															if ((this5 == 0)) {
HXLINE(  96)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g1;
HXDLIN(  96)															int this6 = ((old >> 8) & 255);
HXDLIN(  96)															if ((this6 == 0)) {
HXLINE(  96)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b1;
HXDLIN(  96)															int this7 = (old & 255);
HXDLIN(  96)															if ((this7 == 0)) {
HXLINE(  96)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a2;
HXDLIN(  96)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)															if ((this8 == 0)) {
HXLINE(  96)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r2;
HXDLIN(  96)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)															if ((this9 == 0)) {
HXLINE(  96)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g2;
HXDLIN(  96)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)															if ((this10 == 0)) {
HXLINE(  96)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b2;
HXDLIN(  96)															int this11 = (rhs & 255);
HXDLIN(  96)															if ((this11 == 0)) {
HXLINE(  96)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  96)															{
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = blended;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((location >= 0)) {
HXLINE(  96)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (pixelImage->isLittle) {
HXLINE(  96)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  96)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found2 = true;
            												}
            												else {
HXLINE(  96)													if (found2) {
HXLINE(  96)														goto _hx_goto_134;
            													}
            												}
            											}
            											_hx_goto_134:;
            										}
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  96)								int v_undoY1;
HXDLIN(  96)								int v_undoX1;
HXDLIN(  96)								Float v_ty1;
HXDLIN(  96)								Float v_tx1;
HXDLIN(  96)								Float v_t01;
HXDLIN(  96)								Float v_sy1;
HXDLIN(  96)								Float v_sx1;
HXDLIN(  96)								Float v_s01;
HXDLIN(  96)								Float v_A1;
HXDLIN(  96)								Float ax2 = ex;
HXDLIN(  96)								Float ay2 = ey;
HXDLIN(  96)								Float bx3 = cx;
HXDLIN(  96)								Float by3 = cy;
HXDLIN(  96)								Float cx3 = dx;
HXDLIN(  96)								Float cy3 = dy;
HXDLIN(  96)								::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  96)								bool adjustWinding2 = (((((ax2 * by3) - (bx3 * ay2)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay2) - (ax2 * cy3))) > 0);
HXDLIN(  96)								if (!(adjustWinding2)) {
HXLINE(  96)									Float bx_ = bx3;
HXDLIN(  96)									Float by_ = by3;
HXLINE(  35)									bx3 = cx3;
HXLINE(  36)									by3 = cy3;
HXLINE(  37)									cx3 = bx_;
HXLINE(  38)									cy3 = by_;
            								}
HXLINE(  96)								Float v_ax1 = ax2;
HXDLIN(  96)								Float v_ay1 = ay2;
HXDLIN(  96)								Float v_bx1 = bx3;
HXDLIN(  96)								Float v_by1 = by3;
HXDLIN(  96)								Float v_cx1 = cx3;
HXDLIN(  96)								Float v_cy1 = cy3;
HXDLIN(  96)								bool v_preCalculated1 = true;
HXDLIN(  96)								{
HXLINE(  96)									v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  96)									v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  96)									v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  96)									v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  96)									v_tx1 = (v_ay1 - v_by1);
HXDLIN(  96)									v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  96)									v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  96)									Float a2 = v_ax1;
HXDLIN(  96)									Float b2 = v_bx1;
HXDLIN(  96)									Float c2 = v_cx1;
HXDLIN(  96)									if ((a2 > b2)) {
HXLINE(  96)										if ((a2 > c2)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b2 > c2)) {
HXLINE(  96)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b2);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b2);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter31 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b2 > c2)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a2 > c2)) {
HXLINE(  96)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a2);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a2);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter31 = this1;
            										}
            									}
HXDLIN(  96)									Float a3 = v_ay1;
HXDLIN(  96)									Float b3 = v_by1;
HXDLIN(  96)									Float c3 = v_cy1;
HXDLIN(  96)									if ((a3 > b3)) {
HXLINE(  96)										if ((a3 > c3)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b3 > c3)) {
HXLINE(  96)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b3);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b3);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter31 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b3 > c3)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a3 > c3)) {
HXLINE(  96)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a3);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a3);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter31 = this1;
            										}
            									}
            								}
HXDLIN(  96)								if (hasUndo2) {
HXLINE(  96)									v_undoImage1 = undoImage2;
HXDLIN(  96)									v_undoX1 = xIter32->start;
HXDLIN(  96)									v_undoY1 = yIter32->start;
            								}
HXDLIN(  96)								bool hasUndo3 = false;
HXDLIN(  96)								int aA2 = ((color >> 24) & 255);
HXDLIN(  96)								int rA2 = ((color >> 16) & 255);
HXDLIN(  96)								int gA2 = ((color >> 8) & 255);
HXDLIN(  96)								int bA2 = (color & 255);
HXDLIN(  96)								Float bcx2 = (dx - ax);
HXDLIN(  96)								Float bcy2 = (dy - ay);
HXDLIN(  96)								Float acx2 = (ex - ax);
HXDLIN(  96)								Float acy2 = (ey - ay);
HXDLIN(  96)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  96)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  96)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  96)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  96)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  96)								if ((ex > dx)) {
HXLINE(  96)									if ((ex > ax)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((dx > ax)) {
HXLINE(  96)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter33 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(dx);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((dx > ax)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ex > ax)) {
HXLINE(  96)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter33 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter33 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  96)								if ((ey > dy)) {
HXLINE(  96)									if ((ey > ay)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((dy > ay)) {
HXLINE(  96)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter33 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(dy);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((dy > ay)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ey > ay)) {
HXLINE(  96)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter33 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter33 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  96)								if (hasUndo3) {
HXLINE(  96)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  96)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  96)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)									undoImage3 = this3;
HXDLIN(  96)									{
HXLINE(  96)										int rectLeft = xIter33->start;
HXDLIN(  96)										int rectTop = yIter33->start;
HXDLIN(  96)										int rectRight = xIter33->max;
HXDLIN(  96)										bool forceClear = false;
HXDLIN(  96)										{
HXLINE(  96)											int _g = rectTop;
HXDLIN(  96)											int _g1 = yIter33->max;
HXDLIN(  96)											while((_g < _g1)){
HXLINE(  96)												_g = (_g + 1);
HXDLIN(  96)												int dy = (_g - 1);
HXDLIN(  96)												{
HXLINE(  96)													int _g1 = rectLeft;
HXDLIN(  96)													int _g2 = rectRight;
HXDLIN(  96)													while((_g1 < _g2)){
HXLINE(  96)														_g1 = (_g1 + 1);
HXDLIN(  96)														int dx = (_g1 - 1);
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int col;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															col = c;
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->useMask) {
HXLINE(  96)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)															int index;
HXDLIN(  96)															if (this1->useVirtualPos) {
HXLINE(  96)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  96)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  96)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int v;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  96)																v = c;
            															}
HXDLIN(  96)															int this3 = v;
HXDLIN(  96)															int maskPixel = this3;
HXDLIN(  96)															int this4 = col;
HXDLIN(  96)															int this5 = this4;
HXDLIN(  96)															if ((maskPixel == 0)) {
HXLINE(  96)																int this1 = this5;
HXDLIN(  96)																col = this1;
            															}
            															else {
HXLINE(  96)																Float m0;
HXDLIN(  96)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																if ((this1 == 0)) {
HXLINE(  96)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m1;
HXDLIN(  96)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																if ((this2 == 0)) {
HXLINE(  96)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m2;
HXDLIN(  96)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																if ((this3 == 0)) {
HXLINE(  96)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m3;
HXDLIN(  96)																int this4 = (maskPixel & 255);
HXDLIN(  96)																if ((this4 == 0)) {
HXLINE(  96)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  96)														if ((col != 0)) {
HXLINE(  96)															int x = (dx - rectLeft);
HXDLIN(  96)															int y = (dy - rectTop);
HXDLIN(  96)															int this1 = col;
HXDLIN(  96)															int c = this1;
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																hitQuad = undoImage3->transparent;
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																int location;
HXDLIN(  96)																if (undoImage3->useVirtualPos) {
HXLINE(  96)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  96)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int this3 = this2;
HXDLIN(  96)																int this4;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	this4 = this3;
            																}
HXDLIN(  96)																Float a1;
HXDLIN(  96)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																if ((this5 == 0)) {
HXLINE(  96)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r1;
HXDLIN(  96)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																if ((this6 == 0)) {
HXLINE(  96)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g1;
HXDLIN(  96)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																if ((this7 == 0)) {
HXLINE(  96)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b1;
HXDLIN(  96)																int this8 = (this4 & 255);
HXDLIN(  96)																if ((this8 == 0)) {
HXLINE(  96)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a2;
HXDLIN(  96)																int this9 = ((col >> 24) & 255);
HXDLIN(  96)																if ((this9 == 0)) {
HXLINE(  96)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r2;
HXDLIN(  96)																int this10 = ((col >> 16) & 255);
HXDLIN(  96)																if ((this10 == 0)) {
HXLINE(  96)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g2;
HXDLIN(  96)																int this11 = ((col >> 8) & 255);
HXDLIN(  96)																if ((this11 == 0)) {
HXLINE(  96)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b2;
HXDLIN(  96)																int this12 = (col & 255);
HXDLIN(  96)																if ((this12 == 0)) {
HXLINE(  96)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																{
HXLINE(  96)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  96)																	int value;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		value = blended;
            																	}
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((location >= 0)) {
HXLINE(  96)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage3->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															if (forceClear) {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  96)																int x = (dx - rectLeft);
HXDLIN(  96)																int y = (dy - rectTop);
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage3->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool found3 = false;
HXDLIN(  96)								{
HXLINE(  96)									int _g_min3 = xIter33->start;
HXDLIN(  96)									int _g_max3 = xIter33->max;
HXDLIN(  96)									while((_g_min3 < _g_max3)){
HXLINE(  96)										_g_min3 = (_g_min3 + 1);
HXDLIN(  96)										int px = (_g_min3 - 1);
HXDLIN(  96)										Float pcx = (( (Float)(px) ) - ax);
HXLINE( 620)										found3 = false;
HXLINE(  96)										{
HXLINE(  96)											int _g_min = yIter33->start;
HXDLIN(  96)											int _g_max = yIter33->max;
HXDLIN(  96)											while((_g_min < _g_max)){
HXLINE(  96)												_g_min = (_g_min + 1);
HXDLIN(  96)												int py = (_g_min - 1);
HXDLIN(  96)												Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  96)												Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  96)												Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  96)												Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  96)												Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  96)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)												bool hitQuad;
HXDLIN(  96)												bool hitQuad1;
HXDLIN(  96)												if ((ratioA >= 0)) {
HXLINE(  96)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad1 = false;
            												}
HXDLIN(  96)												if (hitQuad1) {
HXLINE(  96)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad = false;
            												}
HXDLIN(  96)												if (hitQuad) {
HXLINE(  96)													int i = ::Std_obj::_hx_int((( (Float)(aA2) ) * (soft * ratioB)));
HXDLIN(  96)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  96)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  96)													int this1 = i;
HXDLIN(  96)													int a = this1;
HXDLIN(  96)													int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  96)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  96)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  96)													int this2 = i1;
HXDLIN(  96)													int r = this2;
HXDLIN(  96)													int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  96)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  96)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  96)													int this3 = i2;
HXDLIN(  96)													int g = this3;
HXDLIN(  96)													int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  96)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  96)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  96)													int this4 = i3;
HXDLIN(  96)													int b = this4;
HXDLIN(  96)													{
HXLINE(  96)														int location;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->transparent) {
HXLINE(  96)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int this3 = this2;
HXDLIN(  96)															int old;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  96)																old = this3;
            															}
HXDLIN(  96)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)															Float a1;
HXDLIN(  96)															int this4 = ((old >> 24) & 255);
HXDLIN(  96)															if ((this4 == 0)) {
HXLINE(  96)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r1;
HXDLIN(  96)															int this5 = ((old >> 16) & 255);
HXDLIN(  96)															if ((this5 == 0)) {
HXLINE(  96)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g1;
HXDLIN(  96)															int this6 = ((old >> 8) & 255);
HXDLIN(  96)															if ((this6 == 0)) {
HXLINE(  96)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b1;
HXDLIN(  96)															int this7 = (old & 255);
HXDLIN(  96)															if ((this7 == 0)) {
HXLINE(  96)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a2;
HXDLIN(  96)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)															if ((this8 == 0)) {
HXLINE(  96)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r2;
HXDLIN(  96)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)															if ((this9 == 0)) {
HXLINE(  96)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g2;
HXDLIN(  96)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)															if ((this10 == 0)) {
HXLINE(  96)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b2;
HXDLIN(  96)															int this11 = (rhs & 255);
HXDLIN(  96)															if ((this11 == 0)) {
HXLINE(  96)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  96)															{
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = blended;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((location >= 0)) {
HXLINE(  96)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (pixelImage->isLittle) {
HXLINE(  96)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  96)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found3 = true;
            												}
            												else {
HXLINE(  96)													if (found3) {
HXLINE(  96)														goto _hx_goto_138;
            													}
            												}
            											}
            											_hx_goto_138:;
            										}
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_yIter32;
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_xIter32;
HXDLIN(  96)								int v_undoY2;
HXDLIN(  96)								int v_undoX2;
HXDLIN(  96)								Float v_ty2;
HXDLIN(  96)								Float v_tx2;
HXDLIN(  96)								Float v_t02;
HXDLIN(  96)								Float v_sy2;
HXDLIN(  96)								Float v_sx2;
HXDLIN(  96)								Float v_s02;
HXDLIN(  96)								Float v_A2;
HXDLIN(  96)								Float ax3 = ex;
HXDLIN(  96)								Float ay3 = ey;
HXDLIN(  96)								Float bx4 = dx;
HXDLIN(  96)								Float by4 = dy;
HXDLIN(  96)								Float cx4 = ax;
HXDLIN(  96)								Float cy4 = ay;
HXDLIN(  96)								::pixelimage::ImageStruct v_undoImage2 = null();
HXDLIN(  96)								bool adjustWinding3 = (((((ax3 * by4) - (bx4 * ay3)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay3) - (ax3 * cy4))) > 0);
HXDLIN(  96)								if (!(adjustWinding3)) {
HXLINE(  96)									Float bx_ = bx4;
HXDLIN(  96)									Float by_ = by4;
HXLINE(  35)									bx4 = cx4;
HXLINE(  36)									by4 = cy4;
HXLINE(  37)									cx4 = bx_;
HXLINE(  38)									cy4 = by_;
            								}
HXLINE(  96)								Float v_ax2 = ax3;
HXDLIN(  96)								Float v_ay2 = ay3;
HXDLIN(  96)								Float v_bx2 = bx4;
HXDLIN(  96)								Float v_by2 = by4;
HXDLIN(  96)								Float v_cx2 = cx4;
HXDLIN(  96)								Float v_cy2 = cy4;
HXDLIN(  96)								bool v_preCalculated2 = true;
HXDLIN(  96)								{
HXLINE(  96)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  96)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  96)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  96)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  96)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  96)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  96)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  96)									Float a4 = v_ax2;
HXDLIN(  96)									Float b4 = v_bx2;
HXDLIN(  96)									Float c4 = v_cx2;
HXDLIN(  96)									if ((a4 > b4)) {
HXLINE(  96)										if ((a4 > c4)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b4 > c4)) {
HXLINE(  96)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b4);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a4);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b4);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter32 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b4 > c4)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a4 > c4)) {
HXLINE(  96)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a4);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b4);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a4);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter32 = this1;
            										}
            									}
HXDLIN(  96)									Float a5 = v_ay2;
HXDLIN(  96)									Float b5 = v_by2;
HXDLIN(  96)									Float c5 = v_cy2;
HXDLIN(  96)									if ((a5 > b5)) {
HXLINE(  96)										if ((a5 > c5)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b5 > c5)) {
HXLINE(  96)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b5);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a5);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b5);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter32 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b5 > c5)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a5 > c5)) {
HXLINE(  96)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a5);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b5);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a5);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter32 = this1;
            										}
            									}
            								}
HXDLIN(  96)								if (hasUndo3) {
HXLINE(  96)									v_undoImage2 = undoImage3;
HXDLIN(  96)									v_undoX2 = xIter33->start;
HXDLIN(  96)									v_undoY2 = yIter33->start;
            								}
HXDLIN(  96)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  96)								hitQuad = v;
            							}
            							else {
HXLINE(  96)								Float sin = ::Math_obj::sin(theta);
HXDLIN(  96)								Float cos = ::Math_obj::cos(theta);
HXDLIN(  96)								Float radius1 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  96)								Float radius2 = (thick / ( (Float)(2) ));
HXDLIN(  96)								Float dx = ((Float)0.1);
HXDLIN(  96)								Float dy = radius1;
HXDLIN(  96)								Float cx = h2;
HXDLIN(  96)								Float cy = radius2;
HXDLIN(  96)								Float bx = h2;
HXDLIN(  96)								Float by = -(radius2);
HXDLIN(  96)								Float ax = ((Float)0.1);
HXDLIN(  96)								Float ay = -(radius1);
HXDLIN(  96)								Float temp = ((Float)0.);
HXLINE( 288)								temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)								ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)								ax = temp;
HXLINE( 292)								temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)								by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)								bx = temp;
HXLINE( 296)								temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)								cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)								cx = temp;
HXLINE( 300)								temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)								dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)								dx = temp;
HXLINE(  96)								Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN(  96)								Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN(  96)								bool hasUndo = false;
HXDLIN(  96)								int aA = ((color >> 24) & 255);
HXDLIN(  96)								int rA = ((color >> 16) & 255);
HXDLIN(  96)								int gA = ((color >> 8) & 255);
HXDLIN(  96)								int bA = (color & 255);
HXDLIN(  96)								Float bcx = (ax - bx);
HXDLIN(  96)								Float bcy = (ay - by);
HXDLIN(  96)								Float acx = (ex - bx);
HXDLIN(  96)								Float acy = (ey - by);
HXDLIN(  96)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  96)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  96)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  96)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  96)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  96)								if ((ex > ax)) {
HXLINE(  96)									if ((ex > bx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ax > bx)) {
HXLINE(  96)											min = ::Math_obj::floor(bx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(ax);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((ax > bx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ex > bx)) {
HXLINE(  96)											min = ::Math_obj::floor(bx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  96)								if ((ey > ay)) {
HXLINE(  96)									if ((ey > by)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ay > by)) {
HXLINE(  96)											min = ::Math_obj::floor(by);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(ay);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((ay > by)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ey > by)) {
HXLINE(  96)											min = ::Math_obj::floor(by);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  96)								if (hasUndo) {
HXLINE(  96)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  96)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  96)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)									undoImage = this3;
HXDLIN(  96)									{
HXLINE(  96)										int rectLeft = xIter3->start;
HXDLIN(  96)										int rectTop = yIter3->start;
HXDLIN(  96)										int rectRight = xIter3->max;
HXDLIN(  96)										bool forceClear = false;
HXDLIN(  96)										{
HXLINE(  96)											int _g = rectTop;
HXDLIN(  96)											int _g1 = yIter3->max;
HXDLIN(  96)											while((_g < _g1)){
HXLINE(  96)												_g = (_g + 1);
HXDLIN(  96)												int dy = (_g - 1);
HXDLIN(  96)												{
HXLINE(  96)													int _g1 = rectLeft;
HXDLIN(  96)													int _g2 = rectRight;
HXDLIN(  96)													while((_g1 < _g2)){
HXLINE(  96)														_g1 = (_g1 + 1);
HXDLIN(  96)														int dx = (_g1 - 1);
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int col;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															col = c;
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->useMask) {
HXLINE(  96)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)															int index;
HXDLIN(  96)															if (this1->useVirtualPos) {
HXLINE(  96)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  96)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  96)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int v;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  96)																v = c;
            															}
HXDLIN(  96)															int this3 = v;
HXDLIN(  96)															int maskPixel = this3;
HXDLIN(  96)															int this4 = col;
HXDLIN(  96)															int this5 = this4;
HXDLIN(  96)															if ((maskPixel == 0)) {
HXLINE(  96)																int this1 = this5;
HXDLIN(  96)																col = this1;
            															}
            															else {
HXLINE(  96)																Float m0;
HXDLIN(  96)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																if ((this1 == 0)) {
HXLINE(  96)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m1;
HXDLIN(  96)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																if ((this2 == 0)) {
HXLINE(  96)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m2;
HXDLIN(  96)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																if ((this3 == 0)) {
HXLINE(  96)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m3;
HXDLIN(  96)																int this4 = (maskPixel & 255);
HXDLIN(  96)																if ((this4 == 0)) {
HXLINE(  96)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  96)														if ((col != 0)) {
HXLINE(  96)															int x = (dx - rectLeft);
HXDLIN(  96)															int y = (dy - rectTop);
HXDLIN(  96)															int this1 = col;
HXDLIN(  96)															int c = this1;
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																int location;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int this3 = this2;
HXDLIN(  96)																int this4;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	this4 = this3;
            																}
HXDLIN(  96)																Float a1;
HXDLIN(  96)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																if ((this5 == 0)) {
HXLINE(  96)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r1;
HXDLIN(  96)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																if ((this6 == 0)) {
HXLINE(  96)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g1;
HXDLIN(  96)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																if ((this7 == 0)) {
HXLINE(  96)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b1;
HXDLIN(  96)																int this8 = (this4 & 255);
HXDLIN(  96)																if ((this8 == 0)) {
HXLINE(  96)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a2;
HXDLIN(  96)																int this9 = ((col >> 24) & 255);
HXDLIN(  96)																if ((this9 == 0)) {
HXLINE(  96)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r2;
HXDLIN(  96)																int this10 = ((col >> 16) & 255);
HXDLIN(  96)																if ((this10 == 0)) {
HXLINE(  96)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g2;
HXDLIN(  96)																int this11 = ((col >> 8) & 255);
HXDLIN(  96)																if ((this11 == 0)) {
HXLINE(  96)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b2;
HXDLIN(  96)																int this12 = (col & 255);
HXDLIN(  96)																if ((this12 == 0)) {
HXLINE(  96)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																{
HXLINE(  96)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  96)																	int value;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		value = blended;
            																	}
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((location >= 0)) {
HXLINE(  96)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															if (forceClear) {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																int x = (dx - rectLeft);
HXDLIN(  96)																int y = (dy - rectTop);
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool found = false;
HXDLIN(  96)								{
HXLINE(  96)									int _g_min = xIter3->start;
HXDLIN(  96)									int _g_max = xIter3->max;
HXDLIN(  96)									while((_g_min < _g_max)){
HXLINE(  96)										_g_min = (_g_min + 1);
HXDLIN(  96)										int px = (_g_min - 1);
HXDLIN(  96)										Float pcx = (( (Float)(px) ) - bx);
HXLINE( 620)										found = false;
HXLINE(  96)										{
HXLINE(  96)											int _g_min1 = yIter3->start;
HXDLIN(  96)											int _g_max = yIter3->max;
HXDLIN(  96)											while((_g_min1 < _g_max)){
HXLINE(  96)												_g_min1 = (_g_min1 + 1);
HXDLIN(  96)												int py = (_g_min1 - 1);
HXDLIN(  96)												Float pcy = (( (Float)(py) ) - by);
HXDLIN(  96)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  96)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  96)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  96)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  96)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)												bool hitQuad;
HXDLIN(  96)												bool hitQuad1;
HXDLIN(  96)												if ((ratioA >= 0)) {
HXLINE(  96)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad1 = false;
            												}
HXDLIN(  96)												if (hitQuad1) {
HXLINE(  96)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad = false;
            												}
HXDLIN(  96)												if (hitQuad) {
HXLINE(  96)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (soft * ratioB)));
HXDLIN(  96)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  96)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  96)													int this1 = i;
HXDLIN(  96)													int a = this1;
HXDLIN(  96)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  96)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  96)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  96)													int this2 = i1;
HXDLIN(  96)													int r = this2;
HXDLIN(  96)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  96)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  96)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  96)													int this3 = i2;
HXDLIN(  96)													int g = this3;
HXDLIN(  96)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  96)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  96)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  96)													int this4 = i3;
HXDLIN(  96)													int b = this4;
HXDLIN(  96)													{
HXLINE(  96)														int location;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->transparent) {
HXLINE(  96)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int this3 = this2;
HXDLIN(  96)															int old;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  96)																old = this3;
            															}
HXDLIN(  96)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)															Float a1;
HXDLIN(  96)															int this4 = ((old >> 24) & 255);
HXDLIN(  96)															if ((this4 == 0)) {
HXLINE(  96)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r1;
HXDLIN(  96)															int this5 = ((old >> 16) & 255);
HXDLIN(  96)															if ((this5 == 0)) {
HXLINE(  96)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g1;
HXDLIN(  96)															int this6 = ((old >> 8) & 255);
HXDLIN(  96)															if ((this6 == 0)) {
HXLINE(  96)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b1;
HXDLIN(  96)															int this7 = (old & 255);
HXDLIN(  96)															if ((this7 == 0)) {
HXLINE(  96)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a2;
HXDLIN(  96)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)															if ((this8 == 0)) {
HXLINE(  96)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r2;
HXDLIN(  96)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)															if ((this9 == 0)) {
HXLINE(  96)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g2;
HXDLIN(  96)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)															if ((this10 == 0)) {
HXLINE(  96)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b2;
HXDLIN(  96)															int this11 = (rhs & 255);
HXDLIN(  96)															if ((this11 == 0)) {
HXLINE(  96)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  96)															{
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = blended;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((location >= 0)) {
HXLINE(  96)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (pixelImage->isLittle) {
HXLINE(  96)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  96)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found = true;
            												}
            												else {
HXLINE(  96)													if (found) {
HXLINE(  96)														goto _hx_goto_142;
            													}
            												}
            											}
            											_hx_goto_142:;
            										}
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  96)								int v_undoY;
HXDLIN(  96)								int v_undoX;
HXDLIN(  96)								Float v_ty;
HXDLIN(  96)								Float v_tx;
HXDLIN(  96)								Float v_t0;
HXDLIN(  96)								Float v_sy;
HXDLIN(  96)								Float v_sx;
HXDLIN(  96)								Float v_s0;
HXDLIN(  96)								Float v_A;
HXDLIN(  96)								Float ax1 = ex;
HXDLIN(  96)								Float ay1 = ey;
HXDLIN(  96)								Float bx1 = ax;
HXDLIN(  96)								Float by1 = ay;
HXDLIN(  96)								Float cx1 = bx;
HXDLIN(  96)								Float cy1 = by;
HXDLIN(  96)								::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  96)								bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN(  96)								if (!(adjustWinding)) {
HXLINE(  96)									Float bx_ = bx1;
HXDLIN(  96)									Float by_ = by1;
HXLINE(  35)									bx1 = cx1;
HXLINE(  36)									by1 = cy1;
HXLINE(  37)									cx1 = bx_;
HXLINE(  38)									cy1 = by_;
            								}
HXLINE(  96)								Float v_ax = ax1;
HXDLIN(  96)								Float v_ay = ay1;
HXDLIN(  96)								Float v_bx = bx1;
HXDLIN(  96)								Float v_by = by1;
HXDLIN(  96)								Float v_cx = cx1;
HXDLIN(  96)								Float v_cy = cy1;
HXDLIN(  96)								bool v_preCalculated = true;
HXDLIN(  96)								{
HXLINE(  96)									v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  96)									v_sx = (v_cy - v_ay);
HXDLIN(  96)									v_sy = (v_ax - v_cx);
HXDLIN(  96)									v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  96)									v_tx = (v_ay - v_by);
HXDLIN(  96)									v_ty = (v_bx - v_ax);
HXDLIN(  96)									v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  96)									Float a = v_ax;
HXDLIN(  96)									Float b = v_bx;
HXDLIN(  96)									Float c = v_cx;
HXDLIN(  96)									if ((a > b)) {
HXLINE(  96)										if ((a > c)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b > c)) {
HXLINE(  96)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b > c)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a > c)) {
HXLINE(  96)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter3 = this1;
            										}
            									}
HXDLIN(  96)									Float a1 = v_ay;
HXDLIN(  96)									Float b1 = v_by;
HXDLIN(  96)									Float c1 = v_cy;
HXDLIN(  96)									if ((a1 > b1)) {
HXLINE(  96)										if ((a1 > c1)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b1 > c1)) {
HXLINE(  96)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b1);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b1);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b1 > c1)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a1 > c1)) {
HXLINE(  96)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a1);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a1);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter3 = this1;
            										}
            									}
            								}
HXDLIN(  96)								if (hasUndo) {
HXLINE(  96)									v_undoImage = undoImage;
HXDLIN(  96)									v_undoX = xIter3->start;
HXDLIN(  96)									v_undoY = yIter3->start;
            								}
HXDLIN(  96)								{
HXLINE(  96)									Float bx2 = bx;
HXDLIN(  96)									Float by2 = by;
HXDLIN(  96)									Float cx2 = cx;
HXDLIN(  96)									Float cy2 = cy;
HXDLIN(  96)									bool hasUndo1 = false;
HXDLIN(  96)									bool adjustWinding1 = (((((ex * by2) - (bx2 * ey)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ey) - (ex * cy2))) > 0);
HXDLIN(  96)									if (!(adjustWinding1)) {
HXLINE(  96)										Float bx_ = bx2;
HXDLIN(  96)										Float by_ = by2;
HXLINE(  26)										bx2 = cx2;
HXLINE(  27)										by2 = cy2;
HXLINE(  28)										cx2 = bx_;
HXLINE(  29)										cy2 = by_;
            									}
HXLINE(  96)									{
HXLINE(  96)										Float s0 = ((ey * cx2) - (ex * cy2));
HXDLIN(  96)										Float sx = (cy2 - ey);
HXDLIN(  96)										Float sy = (ex - cx2);
HXDLIN(  96)										Float t0 = ((ex * by2) - (ey * bx2));
HXDLIN(  96)										Float tx = (ey - by2);
HXDLIN(  96)										Float ty = (bx2 - ex);
HXDLIN(  96)										Float A = ((((-(by2) * cx2) + (ey * (-(bx2) + cx2))) + (ex * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  96)										::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  96)										if ((ex > bx2)) {
HXLINE(  96)											if ((ex > cx2)) {
HXLINE(  96)												int min;
HXDLIN(  96)												if ((bx2 > cx2)) {
HXLINE(  96)													min = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  96)													min = ::Math_obj::floor(bx2);
            												}
HXDLIN(  96)												int ii_min = min;
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												xIter31 = this1;
            											}
            											else {
HXLINE(  96)												int ii_min = ::Math_obj::floor(bx2);
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												xIter31 = this1;
            											}
            										}
            										else {
HXLINE(  96)											if ((bx2 > cx2)) {
HXLINE(  96)												int min;
HXDLIN(  96)												if ((ex > cx2)) {
HXLINE(  96)													min = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  96)													min = ::Math_obj::ceil(ex);
            												}
HXDLIN(  96)												int ii_min = min;
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(bx2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												xIter31 = this1;
            											}
            											else {
HXLINE(  96)												int ii_min = ::Math_obj::floor(ex);
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(cx2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												xIter31 = this1;
            											}
            										}
HXDLIN(  96)										::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  96)										if ((ey > by2)) {
HXLINE(  96)											if ((ey > cy2)) {
HXLINE(  96)												int min;
HXDLIN(  96)												if ((by2 > cy2)) {
HXLINE(  96)													min = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  96)													min = ::Math_obj::floor(by2);
            												}
HXDLIN(  96)												int ii_min = min;
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												yIter31 = this1;
            											}
            											else {
HXLINE(  96)												int ii_min = ::Math_obj::floor(by2);
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												yIter31 = this1;
            											}
            										}
            										else {
HXLINE(  96)											if ((by2 > cy2)) {
HXLINE(  96)												int min;
HXDLIN(  96)												if ((ey > cy2)) {
HXLINE(  96)													min = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  96)													min = ::Math_obj::ceil(ey);
            												}
HXDLIN(  96)												int ii_min = min;
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(by2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												yIter31 = this1;
            											}
            											else {
HXLINE(  96)												int ii_min = ::Math_obj::floor(ey);
HXDLIN(  96)												int ii_max = ::Math_obj::ceil(cy2);
HXDLIN(  96)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)												yIter31 = this1;
            											}
            										}
HXDLIN(  96)										::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  96)										if (hasUndo1) {
HXLINE(  96)											int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  96)											int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  96)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)											undoImage1 = this3;
HXDLIN(  96)											{
HXLINE(  96)												int rectLeft = xIter31->start;
HXDLIN(  96)												int rectTop = yIter31->start;
HXDLIN(  96)												int rectRight = xIter31->max;
HXDLIN(  96)												bool forceClear = false;
HXDLIN(  96)												{
HXLINE(  96)													int _g = rectTop;
HXDLIN(  96)													int _g1 = yIter31->max;
HXDLIN(  96)													while((_g < _g1)){
HXLINE(  96)														_g = (_g + 1);
HXDLIN(  96)														int dy = (_g - 1);
HXDLIN(  96)														{
HXLINE(  96)															int _g1 = rectLeft;
HXDLIN(  96)															int _g2 = rectRight;
HXDLIN(  96)															while((_g1 < _g2)){
HXLINE(  96)																_g1 = (_g1 + 1);
HXDLIN(  96)																int dx = (_g1 - 1);
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (pixelImage->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            																}
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int col;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	col = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if (pixelImage->useMask) {
HXLINE(  96)																	hitQuad = ::hx::IsNotNull( pixelImage->mask );
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)																	int index;
HXDLIN(  96)																	if (this1->useVirtualPos) {
HXLINE(  96)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  96)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  96)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																	int v;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		v = c;
            																	}
HXDLIN(  96)																	int this3 = v;
HXDLIN(  96)																	int maskPixel = this3;
HXDLIN(  96)																	int this4 = col;
HXDLIN(  96)																	int this5 = this4;
HXDLIN(  96)																	if ((maskPixel == 0)) {
HXLINE(  96)																		int this1 = this5;
HXDLIN(  96)																		col = this1;
            																	}
            																	else {
HXLINE(  96)																		Float m0;
HXDLIN(  96)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																		if ((this1 == 0)) {
HXLINE(  96)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float m1;
HXDLIN(  96)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																		if ((this2 == 0)) {
HXLINE(  96)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float m2;
HXDLIN(  96)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																		if ((this3 == 0)) {
HXLINE(  96)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float m3;
HXDLIN(  96)																		int this4 = (maskPixel & 255);
HXDLIN(  96)																		if ((this4 == 0)) {
HXLINE(  96)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  96)																if ((col != 0)) {
HXLINE(  96)																	int x = (dx - rectLeft);
HXDLIN(  96)																	int y = (dy - rectTop);
HXDLIN(  96)																	int this1 = col;
HXDLIN(  96)																	int c = this1;
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																		hitQuad = undoImage1->transparent;
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		int location;
HXDLIN(  96)																		if (undoImage1->useVirtualPos) {
HXLINE(  96)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  96)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  96)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																		int this3 = this2;
HXDLIN(  96)																		int this4;
HXDLIN(  96)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  96)																			this4 = this3;
            																		}
HXDLIN(  96)																		Float a1;
HXDLIN(  96)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																		if ((this5 == 0)) {
HXLINE(  96)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float r1;
HXDLIN(  96)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																		if ((this6 == 0)) {
HXLINE(  96)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float g1;
HXDLIN(  96)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																		if ((this7 == 0)) {
HXLINE(  96)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float b1;
HXDLIN(  96)																		int this8 = (this4 & 255);
HXDLIN(  96)																		if ((this8 == 0)) {
HXLINE(  96)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float a2;
HXDLIN(  96)																		int this9 = ((col >> 24) & 255);
HXDLIN(  96)																		if ((this9 == 0)) {
HXLINE(  96)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float r2;
HXDLIN(  96)																		int this10 = ((col >> 16) & 255);
HXDLIN(  96)																		if ((this10 == 0)) {
HXLINE(  96)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float g2;
HXDLIN(  96)																		int this11 = ((col >> 8) & 255);
HXDLIN(  96)																		if ((this11 == 0)) {
HXLINE(  96)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float b2;
HXDLIN(  96)																		int this12 = (col & 255);
HXDLIN(  96)																		if ((this12 == 0)) {
HXLINE(  96)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																		{
HXLINE(  96)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  96)																			int value;
HXDLIN(  96)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  96)																				value = blended;
            																			}
HXDLIN(  96)																			bool hitQuad;
HXDLIN(  96)																			if ((location >= 0)) {
HXLINE(  96)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  96)																				hitQuad = false;
            																			}
HXDLIN(  96)																			if (hitQuad) {
HXLINE(  96)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  96)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																		int index;
HXDLIN(  96)																		if (undoImage1->useVirtualPos) {
HXLINE(  96)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  96)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  96)																		int value;
HXDLIN(  96)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  96)																			value = c;
            																		}
HXDLIN(  96)																		bool hitQuad;
HXDLIN(  96)																		if ((index >= 0)) {
HXLINE(  96)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  96)																			hitQuad = false;
            																		}
HXDLIN(  96)																		if (hitQuad) {
HXLINE(  96)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  96)																	if (forceClear) {
HXLINE(  96)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																		int x = (dx - rectLeft);
HXDLIN(  96)																		int y = (dy - rectTop);
HXDLIN(  96)																		int index;
HXDLIN(  96)																		if (undoImage1->useVirtualPos) {
HXLINE(  96)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																		}
            																		else {
HXLINE(  96)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																		}
HXDLIN(  96)																		bool hitQuad;
HXDLIN(  96)																		if ((index >= 0)) {
HXLINE(  96)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  96)																			hitQuad = false;
            																		}
HXDLIN(  96)																		if (hitQuad) {
HXLINE(  96)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  96)										bool found1 = false;
HXDLIN(  96)										Float s = ((Float)0.);
HXDLIN(  96)										Float t = ((Float)0.);
HXDLIN(  96)										Float sxx = ((Float)0.);
HXDLIN(  96)										Float txx = ((Float)0.);
HXDLIN(  96)										{
HXLINE(  96)											int _g_min1 = xIter31->start;
HXDLIN(  96)											int _g_max1 = xIter31->max;
HXDLIN(  96)											while((_g_min1 < _g_max1)){
HXLINE(  96)												_g_min1 = (_g_min1 + 1);
HXDLIN(  96)												int x = (_g_min1 - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found1 = false;
HXLINE(  96)												{
HXLINE(  96)													int _g_min = yIter31->start;
HXDLIN(  96)													int _g_max = yIter31->max;
HXDLIN(  96)													while((_g_min < _g_max)){
HXLINE(  96)														_g_min = (_g_min + 1);
HXDLIN(  96)														int y = (_g_min - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  96)														bool hitQuad;
HXDLIN(  96)														if (!((s <= 0))) {
HXLINE(  96)															hitQuad = (t <= 0);
            														}
            														else {
HXLINE(  96)															hitQuad = true;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															if (found1) {
HXLINE(  96)																goto _hx_goto_146;
            															}
            														}
            														else {
HXLINE(  96)															if (((s + t) < A)) {
HXLINE(  96)																{
HXLINE(  96)																	int this1 = color;
HXDLIN(  96)																	int c = this1;
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																		hitQuad = pixelImage->transparent;
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		int location;
HXDLIN(  96)																		if (pixelImage->useVirtualPos) {
HXLINE(  96)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  96)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  96)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																		int this3 = this2;
HXDLIN(  96)																		int this4;
HXDLIN(  96)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  96)																			this4 = this3;
            																		}
HXDLIN(  96)																		Float a1;
HXDLIN(  96)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																		if ((this5 == 0)) {
HXLINE(  96)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float r1;
HXDLIN(  96)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																		if ((this6 == 0)) {
HXLINE(  96)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float g1;
HXDLIN(  96)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																		if ((this7 == 0)) {
HXLINE(  96)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float b1;
HXDLIN(  96)																		int this8 = (this4 & 255);
HXDLIN(  96)																		if ((this8 == 0)) {
HXLINE(  96)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float a2;
HXDLIN(  96)																		int this9 = ((color >> 24) & 255);
HXDLIN(  96)																		if ((this9 == 0)) {
HXLINE(  96)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float r2;
HXDLIN(  96)																		int this10 = ((color >> 16) & 255);
HXDLIN(  96)																		if ((this10 == 0)) {
HXLINE(  96)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float g2;
HXDLIN(  96)																		int this11 = ((color >> 8) & 255);
HXDLIN(  96)																		if ((this11 == 0)) {
HXLINE(  96)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float b2;
HXDLIN(  96)																		int this12 = (color & 255);
HXDLIN(  96)																		if ((this12 == 0)) {
HXLINE(  96)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  96)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  96)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																		{
HXLINE(  96)																			::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN(  96)																			int value;
HXDLIN(  96)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  96)																				value = blended;
            																			}
HXDLIN(  96)																			bool hitQuad;
HXDLIN(  96)																			if ((location >= 0)) {
HXLINE(  96)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  96)																				hitQuad = false;
            																			}
HXDLIN(  96)																			if (hitQuad) {
HXLINE(  96)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  96)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)																		int index;
HXDLIN(  96)																		if (pixelImage->useVirtualPos) {
HXLINE(  96)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  96)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  96)																		int value;
HXDLIN(  96)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  96)																			value = c;
            																		}
HXDLIN(  96)																		bool hitQuad;
HXDLIN(  96)																		if ((index >= 0)) {
HXLINE(  96)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  96)																			hitQuad = false;
            																		}
HXDLIN(  96)																		if (hitQuad) {
HXLINE(  96)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found1 = true;
            															}
            															else {
HXLINE(  96)																if (found1) {
HXLINE(  96)																	goto _hx_goto_146;
            																}
            															}
            														}
            													}
            													_hx_goto_146:;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool hasUndo2 = false;
HXDLIN(  96)								int aA1 = ((color >> 24) & 255);
HXDLIN(  96)								int rA1 = ((color >> 16) & 255);
HXDLIN(  96)								int gA1 = ((color >> 8) & 255);
HXDLIN(  96)								int bA1 = (color & 255);
HXDLIN(  96)								Float bcx1 = (cx - dx);
HXDLIN(  96)								Float bcy1 = (cy - dy);
HXDLIN(  96)								Float acx1 = (ex - dx);
HXDLIN(  96)								Float acy1 = (ey - dy);
HXDLIN(  96)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  96)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  96)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  96)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  96)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  96)								if ((ex > cx)) {
HXLINE(  96)									if ((ex > dx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((cx > dx)) {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter32 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((cx > dx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ex > dx)) {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter32 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter32 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  96)								if ((ey > cy)) {
HXLINE(  96)									if ((ey > dy)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((cy > dy)) {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter32 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((cy > dy)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ey > dy)) {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter32 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter32 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  96)								if (hasUndo2) {
HXLINE(  96)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  96)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  96)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)									undoImage2 = this3;
HXDLIN(  96)									{
HXLINE(  96)										int rectLeft = xIter32->start;
HXDLIN(  96)										int rectTop = yIter32->start;
HXDLIN(  96)										int rectRight = xIter32->max;
HXDLIN(  96)										bool forceClear = false;
HXDLIN(  96)										{
HXLINE(  96)											int _g = rectTop;
HXDLIN(  96)											int _g1 = yIter32->max;
HXDLIN(  96)											while((_g < _g1)){
HXLINE(  96)												_g = (_g + 1);
HXDLIN(  96)												int dy = (_g - 1);
HXDLIN(  96)												{
HXLINE(  96)													int _g1 = rectLeft;
HXDLIN(  96)													int _g2 = rectRight;
HXDLIN(  96)													while((_g1 < _g2)){
HXLINE(  96)														_g1 = (_g1 + 1);
HXDLIN(  96)														int dx = (_g1 - 1);
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int col;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															col = c;
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->useMask) {
HXLINE(  96)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)															int index;
HXDLIN(  96)															if (this1->useVirtualPos) {
HXLINE(  96)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  96)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  96)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int v;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  96)																v = c;
            															}
HXDLIN(  96)															int this3 = v;
HXDLIN(  96)															int maskPixel = this3;
HXDLIN(  96)															int this4 = col;
HXDLIN(  96)															int this5 = this4;
HXDLIN(  96)															if ((maskPixel == 0)) {
HXLINE(  96)																int this1 = this5;
HXDLIN(  96)																col = this1;
            															}
            															else {
HXLINE(  96)																Float m0;
HXDLIN(  96)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																if ((this1 == 0)) {
HXLINE(  96)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m1;
HXDLIN(  96)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																if ((this2 == 0)) {
HXLINE(  96)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m2;
HXDLIN(  96)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																if ((this3 == 0)) {
HXLINE(  96)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m3;
HXDLIN(  96)																int this4 = (maskPixel & 255);
HXDLIN(  96)																if ((this4 == 0)) {
HXLINE(  96)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  96)														if ((col != 0)) {
HXLINE(  96)															int x = (dx - rectLeft);
HXDLIN(  96)															int y = (dy - rectTop);
HXDLIN(  96)															int this1 = col;
HXDLIN(  96)															int c = this1;
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																hitQuad = undoImage2->transparent;
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																int location;
HXDLIN(  96)																if (undoImage2->useVirtualPos) {
HXLINE(  96)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  96)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int this3 = this2;
HXDLIN(  96)																int this4;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	this4 = this3;
            																}
HXDLIN(  96)																Float a1;
HXDLIN(  96)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																if ((this5 == 0)) {
HXLINE(  96)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r1;
HXDLIN(  96)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																if ((this6 == 0)) {
HXLINE(  96)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g1;
HXDLIN(  96)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																if ((this7 == 0)) {
HXLINE(  96)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b1;
HXDLIN(  96)																int this8 = (this4 & 255);
HXDLIN(  96)																if ((this8 == 0)) {
HXLINE(  96)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a2;
HXDLIN(  96)																int this9 = ((col >> 24) & 255);
HXDLIN(  96)																if ((this9 == 0)) {
HXLINE(  96)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r2;
HXDLIN(  96)																int this10 = ((col >> 16) & 255);
HXDLIN(  96)																if ((this10 == 0)) {
HXLINE(  96)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g2;
HXDLIN(  96)																int this11 = ((col >> 8) & 255);
HXDLIN(  96)																if ((this11 == 0)) {
HXLINE(  96)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b2;
HXDLIN(  96)																int this12 = (col & 255);
HXDLIN(  96)																if ((this12 == 0)) {
HXLINE(  96)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																{
HXLINE(  96)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  96)																	int value;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		value = blended;
            																	}
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((location >= 0)) {
HXLINE(  96)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage2->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															if (forceClear) {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  96)																int x = (dx - rectLeft);
HXDLIN(  96)																int y = (dy - rectTop);
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage2->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool found2 = false;
HXDLIN(  96)								{
HXLINE(  96)									int _g_min2 = xIter32->start;
HXDLIN(  96)									int _g_max2 = xIter32->max;
HXDLIN(  96)									while((_g_min2 < _g_max2)){
HXLINE(  96)										_g_min2 = (_g_min2 + 1);
HXDLIN(  96)										int px = (_g_min2 - 1);
HXDLIN(  96)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 620)										found2 = false;
HXLINE(  96)										{
HXLINE(  96)											int _g_min = yIter32->start;
HXDLIN(  96)											int _g_max = yIter32->max;
HXDLIN(  96)											while((_g_min < _g_max)){
HXLINE(  96)												_g_min = (_g_min + 1);
HXDLIN(  96)												int py = (_g_min - 1);
HXDLIN(  96)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  96)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  96)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  96)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  96)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  96)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)												bool hitQuad;
HXDLIN(  96)												bool hitQuad1;
HXDLIN(  96)												if ((ratioA >= 0)) {
HXLINE(  96)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad1 = false;
            												}
HXDLIN(  96)												if (hitQuad1) {
HXLINE(  96)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad = false;
            												}
HXDLIN(  96)												if (hitQuad) {
HXLINE(  96)													int i = ::Std_obj::_hx_int((( (Float)(aA1) ) * (soft * ratioB)));
HXDLIN(  96)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  96)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  96)													int this1 = i;
HXDLIN(  96)													int a = this1;
HXDLIN(  96)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  96)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  96)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  96)													int this2 = i1;
HXDLIN(  96)													int r = this2;
HXDLIN(  96)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  96)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  96)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  96)													int this3 = i2;
HXDLIN(  96)													int g = this3;
HXDLIN(  96)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  96)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  96)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  96)													int this4 = i3;
HXDLIN(  96)													int b = this4;
HXDLIN(  96)													{
HXLINE(  96)														int location;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->transparent) {
HXLINE(  96)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int this3 = this2;
HXDLIN(  96)															int old;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  96)																old = this3;
            															}
HXDLIN(  96)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)															Float a1;
HXDLIN(  96)															int this4 = ((old >> 24) & 255);
HXDLIN(  96)															if ((this4 == 0)) {
HXLINE(  96)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r1;
HXDLIN(  96)															int this5 = ((old >> 16) & 255);
HXDLIN(  96)															if ((this5 == 0)) {
HXLINE(  96)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g1;
HXDLIN(  96)															int this6 = ((old >> 8) & 255);
HXDLIN(  96)															if ((this6 == 0)) {
HXLINE(  96)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b1;
HXDLIN(  96)															int this7 = (old & 255);
HXDLIN(  96)															if ((this7 == 0)) {
HXLINE(  96)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a2;
HXDLIN(  96)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)															if ((this8 == 0)) {
HXLINE(  96)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r2;
HXDLIN(  96)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)															if ((this9 == 0)) {
HXLINE(  96)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g2;
HXDLIN(  96)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)															if ((this10 == 0)) {
HXLINE(  96)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b2;
HXDLIN(  96)															int this11 = (rhs & 255);
HXDLIN(  96)															if ((this11 == 0)) {
HXLINE(  96)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  96)															{
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = blended;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((location >= 0)) {
HXLINE(  96)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (pixelImage->isLittle) {
HXLINE(  96)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  96)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found2 = true;
            												}
            												else {
HXLINE(  96)													if (found2) {
HXLINE(  96)														goto _hx_goto_150;
            													}
            												}
            											}
            											_hx_goto_150:;
            										}
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  96)								int v_undoY1;
HXDLIN(  96)								int v_undoX1;
HXDLIN(  96)								Float v_ty1;
HXDLIN(  96)								Float v_tx1;
HXDLIN(  96)								Float v_t01;
HXDLIN(  96)								Float v_sy1;
HXDLIN(  96)								Float v_sx1;
HXDLIN(  96)								Float v_s01;
HXDLIN(  96)								Float v_A1;
HXDLIN(  96)								Float ax2 = ex;
HXDLIN(  96)								Float ay2 = ey;
HXDLIN(  96)								Float bx3 = cx;
HXDLIN(  96)								Float by3 = cy;
HXDLIN(  96)								Float cx3 = dx;
HXDLIN(  96)								Float cy3 = dy;
HXDLIN(  96)								::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  96)								bool adjustWinding2 = (((((ax2 * by3) - (bx3 * ay2)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay2) - (ax2 * cy3))) > 0);
HXDLIN(  96)								if (!(adjustWinding2)) {
HXLINE(  96)									Float bx_ = bx3;
HXDLIN(  96)									Float by_ = by3;
HXLINE(  35)									bx3 = cx3;
HXLINE(  36)									by3 = cy3;
HXLINE(  37)									cx3 = bx_;
HXLINE(  38)									cy3 = by_;
            								}
HXLINE(  96)								Float v_ax1 = ax2;
HXDLIN(  96)								Float v_ay1 = ay2;
HXDLIN(  96)								Float v_bx1 = bx3;
HXDLIN(  96)								Float v_by1 = by3;
HXDLIN(  96)								Float v_cx1 = cx3;
HXDLIN(  96)								Float v_cy1 = cy3;
HXDLIN(  96)								bool v_preCalculated1 = true;
HXDLIN(  96)								{
HXLINE(  96)									v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  96)									v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  96)									v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  96)									v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  96)									v_tx1 = (v_ay1 - v_by1);
HXDLIN(  96)									v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  96)									v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  96)									Float a2 = v_ax1;
HXDLIN(  96)									Float b2 = v_bx1;
HXDLIN(  96)									Float c2 = v_cx1;
HXDLIN(  96)									if ((a2 > b2)) {
HXLINE(  96)										if ((a2 > c2)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b2 > c2)) {
HXLINE(  96)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b2);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b2);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter31 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b2 > c2)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a2 > c2)) {
HXLINE(  96)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a2);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a2);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter31 = this1;
            										}
            									}
HXDLIN(  96)									Float a3 = v_ay1;
HXDLIN(  96)									Float b3 = v_by1;
HXDLIN(  96)									Float c3 = v_cy1;
HXDLIN(  96)									if ((a3 > b3)) {
HXLINE(  96)										if ((a3 > c3)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b3 > c3)) {
HXLINE(  96)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b3);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b3);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter31 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b3 > c3)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a3 > c3)) {
HXLINE(  96)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a3);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a3);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter31 = this1;
            										}
            									}
            								}
HXDLIN(  96)								if (hasUndo2) {
HXLINE(  96)									v_undoImage1 = undoImage2;
HXDLIN(  96)									v_undoX1 = xIter32->start;
HXDLIN(  96)									v_undoY1 = yIter32->start;
            								}
HXDLIN(  96)								bool hasUndo3 = false;
HXDLIN(  96)								int aA2 = ((color >> 24) & 255);
HXDLIN(  96)								int rA2 = ((color >> 16) & 255);
HXDLIN(  96)								int gA2 = ((color >> 8) & 255);
HXDLIN(  96)								int bA2 = (color & 255);
HXDLIN(  96)								Float bcx2 = (dx - ax);
HXDLIN(  96)								Float bcy2 = (dy - ay);
HXDLIN(  96)								Float acx2 = (ex - ax);
HXDLIN(  96)								Float acy2 = (ey - ay);
HXDLIN(  96)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  96)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  96)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  96)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  96)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  96)								if ((ex > dx)) {
HXLINE(  96)									if ((ex > ax)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((dx > ax)) {
HXLINE(  96)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter33 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(dx);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((dx > ax)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ex > ax)) {
HXLINE(  96)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter33 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter33 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  96)								if ((ey > dy)) {
HXLINE(  96)									if ((ey > ay)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((dy > ay)) {
HXLINE(  96)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter33 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(dy);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((dy > ay)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ey > ay)) {
HXLINE(  96)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter33 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter33 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  96)								if (hasUndo3) {
HXLINE(  96)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  96)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  96)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)									undoImage3 = this3;
HXDLIN(  96)									{
HXLINE(  96)										int rectLeft = xIter33->start;
HXDLIN(  96)										int rectTop = yIter33->start;
HXDLIN(  96)										int rectRight = xIter33->max;
HXDLIN(  96)										bool forceClear = false;
HXDLIN(  96)										{
HXLINE(  96)											int _g = rectTop;
HXDLIN(  96)											int _g1 = yIter33->max;
HXDLIN(  96)											while((_g < _g1)){
HXLINE(  96)												_g = (_g + 1);
HXDLIN(  96)												int dy = (_g - 1);
HXDLIN(  96)												{
HXLINE(  96)													int _g1 = rectLeft;
HXDLIN(  96)													int _g2 = rectRight;
HXDLIN(  96)													while((_g1 < _g2)){
HXLINE(  96)														_g1 = (_g1 + 1);
HXDLIN(  96)														int dx = (_g1 - 1);
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int col;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															col = c;
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->useMask) {
HXLINE(  96)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)															int index;
HXDLIN(  96)															if (this1->useVirtualPos) {
HXLINE(  96)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  96)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  96)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int v;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  96)																v = c;
            															}
HXDLIN(  96)															int this3 = v;
HXDLIN(  96)															int maskPixel = this3;
HXDLIN(  96)															int this4 = col;
HXDLIN(  96)															int this5 = this4;
HXDLIN(  96)															if ((maskPixel == 0)) {
HXLINE(  96)																int this1 = this5;
HXDLIN(  96)																col = this1;
            															}
            															else {
HXLINE(  96)																Float m0;
HXDLIN(  96)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																if ((this1 == 0)) {
HXLINE(  96)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m1;
HXDLIN(  96)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																if ((this2 == 0)) {
HXLINE(  96)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m2;
HXDLIN(  96)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																if ((this3 == 0)) {
HXLINE(  96)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m3;
HXDLIN(  96)																int this4 = (maskPixel & 255);
HXDLIN(  96)																if ((this4 == 0)) {
HXLINE(  96)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  96)														if ((col != 0)) {
HXLINE(  96)															int x = (dx - rectLeft);
HXDLIN(  96)															int y = (dy - rectTop);
HXDLIN(  96)															int this1 = col;
HXDLIN(  96)															int c = this1;
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																hitQuad = undoImage3->transparent;
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																int location;
HXDLIN(  96)																if (undoImage3->useVirtualPos) {
HXLINE(  96)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  96)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int this3 = this2;
HXDLIN(  96)																int this4;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	this4 = this3;
            																}
HXDLIN(  96)																Float a1;
HXDLIN(  96)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																if ((this5 == 0)) {
HXLINE(  96)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r1;
HXDLIN(  96)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																if ((this6 == 0)) {
HXLINE(  96)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g1;
HXDLIN(  96)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																if ((this7 == 0)) {
HXLINE(  96)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b1;
HXDLIN(  96)																int this8 = (this4 & 255);
HXDLIN(  96)																if ((this8 == 0)) {
HXLINE(  96)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a2;
HXDLIN(  96)																int this9 = ((col >> 24) & 255);
HXDLIN(  96)																if ((this9 == 0)) {
HXLINE(  96)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r2;
HXDLIN(  96)																int this10 = ((col >> 16) & 255);
HXDLIN(  96)																if ((this10 == 0)) {
HXLINE(  96)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g2;
HXDLIN(  96)																int this11 = ((col >> 8) & 255);
HXDLIN(  96)																if ((this11 == 0)) {
HXLINE(  96)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b2;
HXDLIN(  96)																int this12 = (col & 255);
HXDLIN(  96)																if ((this12 == 0)) {
HXLINE(  96)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																{
HXLINE(  96)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  96)																	int value;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		value = blended;
            																	}
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((location >= 0)) {
HXLINE(  96)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage3->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															if (forceClear) {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  96)																int x = (dx - rectLeft);
HXDLIN(  96)																int y = (dy - rectTop);
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage3->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool found3 = false;
HXDLIN(  96)								{
HXLINE(  96)									int _g_min3 = xIter33->start;
HXDLIN(  96)									int _g_max3 = xIter33->max;
HXDLIN(  96)									while((_g_min3 < _g_max3)){
HXLINE(  96)										_g_min3 = (_g_min3 + 1);
HXDLIN(  96)										int px = (_g_min3 - 1);
HXDLIN(  96)										Float pcx = (( (Float)(px) ) - ax);
HXLINE( 620)										found3 = false;
HXLINE(  96)										{
HXLINE(  96)											int _g_min = yIter33->start;
HXDLIN(  96)											int _g_max = yIter33->max;
HXDLIN(  96)											while((_g_min < _g_max)){
HXLINE(  96)												_g_min = (_g_min + 1);
HXDLIN(  96)												int py = (_g_min - 1);
HXDLIN(  96)												Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  96)												Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  96)												Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  96)												Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  96)												Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  96)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)												bool hitQuad;
HXDLIN(  96)												bool hitQuad1;
HXDLIN(  96)												if ((ratioA >= 0)) {
HXLINE(  96)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad1 = false;
            												}
HXDLIN(  96)												if (hitQuad1) {
HXLINE(  96)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad = false;
            												}
HXDLIN(  96)												if (hitQuad) {
HXLINE(  96)													int i = ::Std_obj::_hx_int((( (Float)(aA2) ) * (soft * ratioB)));
HXDLIN(  96)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  96)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  96)													int this1 = i;
HXDLIN(  96)													int a = this1;
HXDLIN(  96)													int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  96)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  96)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  96)													int this2 = i1;
HXDLIN(  96)													int r = this2;
HXDLIN(  96)													int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  96)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  96)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  96)													int this3 = i2;
HXDLIN(  96)													int g = this3;
HXDLIN(  96)													int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  96)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  96)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  96)													int this4 = i3;
HXDLIN(  96)													int b = this4;
HXDLIN(  96)													{
HXLINE(  96)														int location;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->transparent) {
HXLINE(  96)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int this3 = this2;
HXDLIN(  96)															int old;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  96)																old = this3;
            															}
HXDLIN(  96)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)															Float a1;
HXDLIN(  96)															int this4 = ((old >> 24) & 255);
HXDLIN(  96)															if ((this4 == 0)) {
HXLINE(  96)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r1;
HXDLIN(  96)															int this5 = ((old >> 16) & 255);
HXDLIN(  96)															if ((this5 == 0)) {
HXLINE(  96)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g1;
HXDLIN(  96)															int this6 = ((old >> 8) & 255);
HXDLIN(  96)															if ((this6 == 0)) {
HXLINE(  96)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b1;
HXDLIN(  96)															int this7 = (old & 255);
HXDLIN(  96)															if ((this7 == 0)) {
HXLINE(  96)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a2;
HXDLIN(  96)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)															if ((this8 == 0)) {
HXLINE(  96)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r2;
HXDLIN(  96)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)															if ((this9 == 0)) {
HXLINE(  96)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g2;
HXDLIN(  96)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)															if ((this10 == 0)) {
HXLINE(  96)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b2;
HXDLIN(  96)															int this11 = (rhs & 255);
HXDLIN(  96)															if ((this11 == 0)) {
HXLINE(  96)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  96)															{
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = blended;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((location >= 0)) {
HXLINE(  96)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (pixelImage->isLittle) {
HXLINE(  96)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  96)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found3 = true;
            												}
            												else {
HXLINE(  96)													if (found3) {
HXLINE(  96)														goto _hx_goto_154;
            													}
            												}
            											}
            											_hx_goto_154:;
            										}
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_yIter32;
HXDLIN(  96)								::pixelimage::iter::IntIterStart v_xIter32;
HXDLIN(  96)								int v_undoY2;
HXDLIN(  96)								int v_undoX2;
HXDLIN(  96)								Float v_ty2;
HXDLIN(  96)								Float v_tx2;
HXDLIN(  96)								Float v_t02;
HXDLIN(  96)								Float v_sy2;
HXDLIN(  96)								Float v_sx2;
HXDLIN(  96)								Float v_s02;
HXDLIN(  96)								Float v_A2;
HXDLIN(  96)								Float ax3 = ex;
HXDLIN(  96)								Float ay3 = ey;
HXDLIN(  96)								Float bx4 = dx;
HXDLIN(  96)								Float by4 = dy;
HXDLIN(  96)								Float cx4 = ax;
HXDLIN(  96)								Float cy4 = ay;
HXDLIN(  96)								::pixelimage::ImageStruct v_undoImage2 = null();
HXDLIN(  96)								bool adjustWinding3 = (((((ax3 * by4) - (bx4 * ay3)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay3) - (ax3 * cy4))) > 0);
HXDLIN(  96)								if (!(adjustWinding3)) {
HXLINE(  96)									Float bx_ = bx4;
HXDLIN(  96)									Float by_ = by4;
HXLINE(  35)									bx4 = cx4;
HXLINE(  36)									by4 = cy4;
HXLINE(  37)									cx4 = bx_;
HXLINE(  38)									cy4 = by_;
            								}
HXLINE(  96)								Float v_ax2 = ax3;
HXDLIN(  96)								Float v_ay2 = ay3;
HXDLIN(  96)								Float v_bx2 = bx4;
HXDLIN(  96)								Float v_by2 = by4;
HXDLIN(  96)								Float v_cx2 = cx4;
HXDLIN(  96)								Float v_cy2 = cy4;
HXDLIN(  96)								bool v_preCalculated2 = true;
HXDLIN(  96)								{
HXLINE(  96)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  96)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  96)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  96)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  96)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  96)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  96)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  96)									Float a4 = v_ax2;
HXDLIN(  96)									Float b4 = v_bx2;
HXDLIN(  96)									Float c4 = v_cx2;
HXDLIN(  96)									if ((a4 > b4)) {
HXLINE(  96)										if ((a4 > c4)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b4 > c4)) {
HXLINE(  96)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b4);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a4);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b4);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter32 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b4 > c4)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a4 > c4)) {
HXLINE(  96)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a4);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b4);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a4);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_xIter32 = this1;
            										}
            									}
HXDLIN(  96)									Float a5 = v_ay2;
HXDLIN(  96)									Float b5 = v_by2;
HXDLIN(  96)									Float c5 = v_cy2;
HXDLIN(  96)									if ((a5 > b5)) {
HXLINE(  96)										if ((a5 > c5)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((b5 > c5)) {
HXLINE(  96)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::floor(b5);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(a5);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(b5);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter32 = this1;
            										}
            									}
            									else {
HXLINE(  96)										if ((b5 > c5)) {
HXLINE(  96)											int min;
HXDLIN(  96)											if ((a5 > c5)) {
HXLINE(  96)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  96)												min = ::Math_obj::ceil(a5);
            											}
HXDLIN(  96)											int ii_min = min;
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(b5);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  96)											int ii_min = ::Math_obj::floor(a5);
HXDLIN(  96)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  96)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)											v_yIter32 = this1;
            										}
            									}
            								}
HXDLIN(  96)								if (hasUndo3) {
HXLINE(  96)									v_undoImage2 = undoImage3;
HXDLIN(  96)									v_undoX2 = xIter33->start;
HXDLIN(  96)									v_undoY2 = yIter33->start;
            								}
HXDLIN(  96)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  96)								hitQuad = v;
            							}
            						}
            						else {
HXLINE(  96)							Float sin = ::Math_obj::sin(theta);
HXDLIN(  96)							Float cos = ::Math_obj::cos(theta);
HXDLIN(  96)							Float radius = (thick / ( (Float)(2) ));
HXDLIN(  96)							Float dx = ((Float)0.1);
HXDLIN(  96)							Float dy = radius;
HXDLIN(  96)							Float cx = h2;
HXDLIN(  96)							Float cy = radius;
HXDLIN(  96)							Float bx = h2;
HXDLIN(  96)							Float by = -(radius);
HXDLIN(  96)							Float ax = ((Float)0.1);
HXDLIN(  96)							Float ay = -(radius);
HXDLIN(  96)							Float temp = ((Float)0.);
HXLINE(  82)							temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  83)							ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  84)							ax = temp;
HXLINE(  86)							temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  87)							by = (py + ((by * cos) + (bx * sin)));
HXLINE(  88)							bx = temp;
HXLINE(  90)							temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  91)							cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  92)							cx = temp;
HXLINE(  94)							temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  95)							dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  96)							dx = temp;
HXDLIN(  96)							{
HXLINE(  96)								bool hasUndo = true;
HXDLIN(  96)								int aA = ((color >> 24) & 255);
HXDLIN(  96)								int rA = ((color >> 16) & 255);
HXDLIN(  96)								int gA = ((color >> 8) & 255);
HXDLIN(  96)								int bA = (color & 255);
HXDLIN(  96)								Float bcx = (bx - dx);
HXDLIN(  96)								Float bcy = (by - dy);
HXDLIN(  96)								Float acx = (ax - dx);
HXDLIN(  96)								Float acy = (ay - dy);
HXDLIN(  96)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  96)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  96)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  96)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  96)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  96)								if ((ax > bx)) {
HXLINE(  96)									if ((ax > dx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((bx > dx)) {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((bx > dx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ax > dx)) {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter3 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  96)								if ((ay > by)) {
HXLINE(  96)									if ((ay > dy)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((by > dy)) {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((by > dy)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((ay > dy)) {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter3 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  96)								if (hasUndo) {
HXLINE(  96)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  96)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  96)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)									undoImage = this3;
HXDLIN(  96)									{
HXLINE(  96)										int rectLeft = xIter3->start;
HXDLIN(  96)										int rectTop = yIter3->start;
HXDLIN(  96)										int rectRight = xIter3->max;
HXDLIN(  96)										bool forceClear = false;
HXDLIN(  96)										{
HXLINE(  96)											int _g = rectTop;
HXDLIN(  96)											int _g1 = yIter3->max;
HXDLIN(  96)											while((_g < _g1)){
HXLINE(  96)												_g = (_g + 1);
HXDLIN(  96)												int dy = (_g - 1);
HXDLIN(  96)												{
HXLINE(  96)													int _g1 = rectLeft;
HXDLIN(  96)													int _g2 = rectRight;
HXDLIN(  96)													while((_g1 < _g2)){
HXLINE(  96)														_g1 = (_g1 + 1);
HXDLIN(  96)														int dx = (_g1 - 1);
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int col;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															col = c;
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->useMask) {
HXLINE(  96)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)															int index;
HXDLIN(  96)															if (this1->useVirtualPos) {
HXLINE(  96)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  96)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  96)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int v;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  96)																v = c;
            															}
HXDLIN(  96)															int this3 = v;
HXDLIN(  96)															int maskPixel = this3;
HXDLIN(  96)															int this4 = col;
HXDLIN(  96)															int this5 = this4;
HXDLIN(  96)															if ((maskPixel == 0)) {
HXLINE(  96)																int this1 = this5;
HXDLIN(  96)																col = this1;
            															}
            															else {
HXLINE(  96)																Float m0;
HXDLIN(  96)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																if ((this1 == 0)) {
HXLINE(  96)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m1;
HXDLIN(  96)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																if ((this2 == 0)) {
HXLINE(  96)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m2;
HXDLIN(  96)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																if ((this3 == 0)) {
HXLINE(  96)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m3;
HXDLIN(  96)																int this4 = (maskPixel & 255);
HXDLIN(  96)																if ((this4 == 0)) {
HXLINE(  96)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  96)														if ((col != 0)) {
HXLINE(  96)															int x = (dx - rectLeft);
HXDLIN(  96)															int y = (dy - rectTop);
HXDLIN(  96)															int this1 = col;
HXDLIN(  96)															int c = this1;
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																int location;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int this3 = this2;
HXDLIN(  96)																int this4;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	this4 = this3;
            																}
HXDLIN(  96)																Float a1;
HXDLIN(  96)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																if ((this5 == 0)) {
HXLINE(  96)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r1;
HXDLIN(  96)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																if ((this6 == 0)) {
HXLINE(  96)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g1;
HXDLIN(  96)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																if ((this7 == 0)) {
HXLINE(  96)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b1;
HXDLIN(  96)																int this8 = (this4 & 255);
HXDLIN(  96)																if ((this8 == 0)) {
HXLINE(  96)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a2;
HXDLIN(  96)																int this9 = ((col >> 24) & 255);
HXDLIN(  96)																if ((this9 == 0)) {
HXLINE(  96)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r2;
HXDLIN(  96)																int this10 = ((col >> 16) & 255);
HXDLIN(  96)																if ((this10 == 0)) {
HXLINE(  96)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g2;
HXDLIN(  96)																int this11 = ((col >> 8) & 255);
HXDLIN(  96)																if ((this11 == 0)) {
HXLINE(  96)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b2;
HXDLIN(  96)																int this12 = (col & 255);
HXDLIN(  96)																if ((this12 == 0)) {
HXLINE(  96)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																{
HXLINE(  96)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  96)																	int value;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		value = blended;
            																	}
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((location >= 0)) {
HXLINE(  96)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															if (forceClear) {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)																int x = (dx - rectLeft);
HXDLIN(  96)																int y = (dy - rectTop);
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool found = false;
HXDLIN(  96)								Float min = ( (Float)(0) );
HXDLIN(  96)								Float max = ( (Float)(0) );
HXDLIN(  96)								int a = 0;
HXDLIN(  96)								int r = 0;
HXDLIN(  96)								int g = 0;
HXDLIN(  96)								int b = 0;
HXDLIN(  96)								{
HXLINE(  96)									int _g_min = xIter3->start;
HXDLIN(  96)									int _g_max = xIter3->max;
HXDLIN(  96)									while((_g_min < _g_max)){
HXLINE(  96)										_g_min = (_g_min + 1);
HXDLIN(  96)										int px = (_g_min - 1);
HXDLIN(  96)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found = false;
HXLINE(  96)										{
HXLINE(  96)											int _g_min1 = yIter3->start;
HXDLIN(  96)											int _g_max = yIter3->max;
HXDLIN(  96)											while((_g_min1 < _g_max)){
HXLINE(  96)												_g_min1 = (_g_min1 + 1);
HXDLIN(  96)												int py = (_g_min1 - 1);
HXDLIN(  96)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  96)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  96)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  96)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  96)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  96)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)												bool hitQuad;
HXDLIN(  96)												bool hitQuad1;
HXDLIN(  96)												if ((ratioA >= 0)) {
HXLINE(  96)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad1 = false;
            												}
HXDLIN(  96)												if (hitQuad1) {
HXLINE(  96)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad = false;
            												}
HXDLIN(  96)												if (hitQuad) {
HXLINE(  96)													if ((ratioA < ratioC)) {
HXLINE(  96)														min = ratioA;
            													}
            													else {
HXLINE(  96)														min = ratioC;
            													}
HXDLIN(  96)													if ((ratioA > ratioB)) {
HXLINE(  96)														max = ratioA;
            													}
            													else {
HXLINE(  96)														max = ratioB;
            													}
HXDLIN(  96)													if (!((max > ratioC))) {
HXLINE(  96)														max = ratioC;
            													}
HXLINE( 729)													max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  96)													if (!((min < max))) {
HXLINE(  96)														min = ((max + min) / ( (Float)(2) ));
            													}
HXDLIN(  96)													int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  96)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  96)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  96)													int this1 = i;
HXDLIN(  96)													a = this1;
HXDLIN(  96)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  96)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  96)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  96)													int this2 = i1;
HXLINE( 748)													r = this2;
HXLINE(  96)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  96)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  96)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  96)													int this3 = i2;
HXLINE( 749)													g = this3;
HXLINE(  96)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  96)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  96)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  96)													int this4 = i3;
HXLINE( 750)													b = this4;
HXLINE(  96)													{
HXLINE(  96)														int location;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->transparent) {
HXLINE(  96)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int this3 = this2;
HXDLIN(  96)															int old;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  96)																old = this3;
            															}
HXDLIN(  96)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)															Float a1;
HXDLIN(  96)															int this4 = ((old >> 24) & 255);
HXDLIN(  96)															if ((this4 == 0)) {
HXLINE(  96)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r1;
HXDLIN(  96)															int this5 = ((old >> 16) & 255);
HXDLIN(  96)															if ((this5 == 0)) {
HXLINE(  96)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g1;
HXDLIN(  96)															int this6 = ((old >> 8) & 255);
HXDLIN(  96)															if ((this6 == 0)) {
HXLINE(  96)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b1;
HXDLIN(  96)															int this7 = (old & 255);
HXDLIN(  96)															if ((this7 == 0)) {
HXLINE(  96)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a2;
HXDLIN(  96)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)															if ((this8 == 0)) {
HXLINE(  96)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r2;
HXDLIN(  96)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)															if ((this9 == 0)) {
HXLINE(  96)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g2;
HXDLIN(  96)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)															if ((this10 == 0)) {
HXLINE(  96)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b2;
HXDLIN(  96)															int this11 = (rhs & 255);
HXDLIN(  96)															if ((this11 == 0)) {
HXLINE(  96)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  96)															{
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = blended;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((location >= 0)) {
HXLINE(  96)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (pixelImage->isLittle) {
HXLINE(  96)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  96)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found = true;
            												}
            												else {
HXLINE(  96)													if (found) {
HXLINE(  96)														goto _hx_goto_158;
            													}
            												}
            											}
            											_hx_goto_158:;
            										}
            									}
            								}
            							}
HXDLIN(  96)							{
HXLINE(  96)								bool hasUndo1 = true;
HXDLIN(  96)								int aA1 = ((color >> 24) & 255);
HXDLIN(  96)								int rA1 = ((color >> 16) & 255);
HXDLIN(  96)								int gA1 = ((color >> 8) & 255);
HXDLIN(  96)								int bA1 = (color & 255);
HXDLIN(  96)								Float bcx1 = (cx - dx);
HXDLIN(  96)								Float bcy1 = (cy - dy);
HXDLIN(  96)								Float acx1 = (bx - dx);
HXDLIN(  96)								Float acy1 = (by - dy);
HXDLIN(  96)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  96)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  96)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  96)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  96)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  96)								if ((bx > cx)) {
HXLINE(  96)									if ((bx > dx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((cx > dx)) {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter31 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((cx > dx)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((bx > dx)) {
HXLINE(  96)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter31 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										xIter31 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  96)								if ((by > cy)) {
HXLINE(  96)									if ((by > dy)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((cy > dy)) {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter31 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  96)									if ((cy > dy)) {
HXLINE(  96)										int min;
HXDLIN(  96)										if ((by > dy)) {
HXLINE(  96)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  96)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  96)										int ii_min = min;
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter31 = this1;
            									}
            									else {
HXLINE(  96)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  96)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  96)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)										yIter31 = this1;
            									}
            								}
HXDLIN(  96)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  96)								if (hasUndo1) {
HXLINE(  96)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  96)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  96)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)									undoImage1 = this3;
HXDLIN(  96)									{
HXLINE(  96)										int rectLeft = xIter31->start;
HXDLIN(  96)										int rectTop = yIter31->start;
HXDLIN(  96)										int rectRight = xIter31->max;
HXDLIN(  96)										bool forceClear = false;
HXDLIN(  96)										{
HXLINE(  96)											int _g = rectTop;
HXDLIN(  96)											int _g1 = yIter31->max;
HXDLIN(  96)											while((_g < _g1)){
HXLINE(  96)												_g = (_g + 1);
HXDLIN(  96)												int dy = (_g - 1);
HXDLIN(  96)												{
HXLINE(  96)													int _g1 = rectLeft;
HXDLIN(  96)													int _g2 = rectRight;
HXDLIN(  96)													while((_g1 < _g2)){
HXLINE(  96)														_g1 = (_g1 + 1);
HXDLIN(  96)														int dx = (_g1 - 1);
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int col;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															col = c;
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->useMask) {
HXLINE(  96)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)															int index;
HXDLIN(  96)															if (this1->useVirtualPos) {
HXLINE(  96)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  96)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  96)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int v;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  96)																v = c;
            															}
HXDLIN(  96)															int this3 = v;
HXDLIN(  96)															int maskPixel = this3;
HXDLIN(  96)															int this4 = col;
HXDLIN(  96)															int this5 = this4;
HXDLIN(  96)															if ((maskPixel == 0)) {
HXLINE(  96)																int this1 = this5;
HXDLIN(  96)																col = this1;
            															}
            															else {
HXLINE(  96)																Float m0;
HXDLIN(  96)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)																if ((this1 == 0)) {
HXLINE(  96)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m1;
HXDLIN(  96)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)																if ((this2 == 0)) {
HXLINE(  96)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m2;
HXDLIN(  96)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)																if ((this3 == 0)) {
HXLINE(  96)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float m3;
HXDLIN(  96)																int this4 = (maskPixel & 255);
HXDLIN(  96)																if ((this4 == 0)) {
HXLINE(  96)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  96)														if ((col != 0)) {
HXLINE(  96)															int x = (dx - rectLeft);
HXDLIN(  96)															int y = (dy - rectTop);
HXDLIN(  96)															int this1 = col;
HXDLIN(  96)															int c = this1;
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																int location;
HXDLIN(  96)																if (undoImage1->useVirtualPos) {
HXLINE(  96)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  96)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)																int this3 = this2;
HXDLIN(  96)																int this4;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	this4 = this3;
            																}
HXDLIN(  96)																Float a1;
HXDLIN(  96)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)																if ((this5 == 0)) {
HXLINE(  96)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r1;
HXDLIN(  96)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)																if ((this6 == 0)) {
HXLINE(  96)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g1;
HXDLIN(  96)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)																if ((this7 == 0)) {
HXLINE(  96)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b1;
HXDLIN(  96)																int this8 = (this4 & 255);
HXDLIN(  96)																if ((this8 == 0)) {
HXLINE(  96)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a2;
HXDLIN(  96)																int this9 = ((col >> 24) & 255);
HXDLIN(  96)																if ((this9 == 0)) {
HXLINE(  96)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float r2;
HXDLIN(  96)																int this10 = ((col >> 16) & 255);
HXDLIN(  96)																if ((this10 == 0)) {
HXLINE(  96)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float g2;
HXDLIN(  96)																int this11 = ((col >> 8) & 255);
HXDLIN(  96)																if ((this11 == 0)) {
HXLINE(  96)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float b2;
HXDLIN(  96)																int this12 = (col & 255);
HXDLIN(  96)																if ((this12 == 0)) {
HXLINE(  96)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  96)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  96)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)																{
HXLINE(  96)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  96)																	int value;
HXDLIN(  96)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  96)																		value = blended;
            																	}
HXDLIN(  96)																	bool hitQuad;
HXDLIN(  96)																	if ((location >= 0)) {
HXLINE(  96)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  96)																		hitQuad = false;
            																	}
HXDLIN(  96)																	if (hitQuad) {
HXLINE(  96)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage1->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = c;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															if (forceClear) {
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  96)																int x = (dx - rectLeft);
HXDLIN(  96)																int y = (dy - rectTop);
HXDLIN(  96)																int index;
HXDLIN(  96)																if (undoImage1->useVirtualPos) {
HXLINE(  96)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  96)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((index >= 0)) {
HXLINE(  96)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  96)								bool found1 = false;
HXDLIN(  96)								Float min1 = ( (Float)(0) );
HXDLIN(  96)								Float max1 = ( (Float)(0) );
HXDLIN(  96)								int a1 = 0;
HXDLIN(  96)								int r1 = 0;
HXDLIN(  96)								int g1 = 0;
HXDLIN(  96)								int b1 = 0;
HXDLIN(  96)								{
HXLINE(  96)									int _g_min1 = xIter31->start;
HXDLIN(  96)									int _g_max1 = xIter31->max;
HXDLIN(  96)									while((_g_min1 < _g_max1)){
HXLINE(  96)										_g_min1 = (_g_min1 + 1);
HXDLIN(  96)										int px = (_g_min1 - 1);
HXDLIN(  96)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found1 = false;
HXLINE(  96)										{
HXLINE(  96)											int _g_min = yIter31->start;
HXDLIN(  96)											int _g_max = yIter31->max;
HXDLIN(  96)											while((_g_min < _g_max)){
HXLINE(  96)												_g_min = (_g_min + 1);
HXDLIN(  96)												int py = (_g_min - 1);
HXDLIN(  96)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  96)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  96)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  96)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  96)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  96)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)												bool hitQuad;
HXDLIN(  96)												bool hitQuad1;
HXDLIN(  96)												if ((ratioA >= 0)) {
HXLINE(  96)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad1 = false;
            												}
HXDLIN(  96)												if (hitQuad1) {
HXLINE(  96)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  96)													hitQuad = false;
            												}
HXDLIN(  96)												if (hitQuad) {
HXLINE( 713)													min1 = ratioB;
HXLINE(  96)													int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  96)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  96)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  96)													int this1 = i;
HXDLIN(  96)													a1 = this1;
HXDLIN(  96)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  96)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  96)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  96)													int this2 = i1;
HXLINE( 748)													r1 = this2;
HXLINE(  96)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  96)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  96)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  96)													int this3 = i2;
HXLINE( 749)													g1 = this3;
HXLINE(  96)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  96)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  96)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  96)													int this4 = i3;
HXLINE( 750)													b1 = this4;
HXLINE(  96)													{
HXLINE(  96)														int location;
HXDLIN(  96)														if (pixelImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  96)														bool hitQuad;
HXDLIN(  96)														if (pixelImage->transparent) {
HXLINE(  96)															hitQuad = (a1 < 254);
            														}
            														else {
HXLINE(  96)															hitQuad = false;
            														}
HXDLIN(  96)														if (hitQuad) {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)															int this3 = this2;
HXDLIN(  96)															int old;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  96)																old = this3;
            															}
HXDLIN(  96)															int rhs = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  96)															Float a11;
HXDLIN(  96)															int this4 = ((old >> 24) & 255);
HXDLIN(  96)															if ((this4 == 0)) {
HXLINE(  96)																a11 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r11;
HXDLIN(  96)															int this5 = ((old >> 16) & 255);
HXDLIN(  96)															if ((this5 == 0)) {
HXLINE(  96)																r11 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g11;
HXDLIN(  96)															int this6 = ((old >> 8) & 255);
HXDLIN(  96)															if ((this6 == 0)) {
HXLINE(  96)																g11 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b11;
HXDLIN(  96)															int this7 = (old & 255);
HXDLIN(  96)															if ((this7 == 0)) {
HXLINE(  96)																b11 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a2;
HXDLIN(  96)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)															if ((this8 == 0)) {
HXLINE(  96)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float r2;
HXDLIN(  96)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)															if ((this9 == 0)) {
HXLINE(  96)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float g2;
HXDLIN(  96)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)															if ((this10 == 0)) {
HXLINE(  96)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float b2;
HXDLIN(  96)															int this11 = (rhs & 255);
HXDLIN(  96)															if ((this11 == 0)) {
HXLINE(  96)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  96)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  96)															Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  96)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a2))));
HXDLIN(  96)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a2))));
HXDLIN(  96)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a2))));
HXDLIN(  96)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)															{
HXLINE(  96)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)																int value;
HXDLIN(  96)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  96)																	value = blended;
            																}
HXDLIN(  96)																bool hitQuad;
HXDLIN(  96)																if ((location >= 0)) {
HXLINE(  96)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  96)																	hitQuad = false;
            																}
HXDLIN(  96)																if (hitQuad) {
HXLINE(  96)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (pixelImage->isLittle) {
HXLINE(  96)																value = ((((a1 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            															}
            															else {
HXLINE(  96)																value = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            															}
HXDLIN(  96)															bool hitQuad;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																hitQuad = false;
            															}
HXDLIN(  96)															if (hitQuad) {
HXLINE(  96)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found1 = true;
            												}
            												else {
HXLINE(  96)													if (found1) {
HXLINE(  96)														goto _hx_goto_162;
            													}
            												}
            											}
            											_hx_goto_162:;
            										}
            									}
            								}
            							}
HXDLIN(  96)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  96)							hitQuad = v;
            						}
HXDLIN(  96)						Float cx = h2;
HXDLIN(  96)						Float cy = radius2;
HXDLIN(  96)						Float bx = h2;
HXDLIN(  96)						Float by = -(radius2);
HXDLIN(  96)						Float temp = ((Float)0.);
HXLINE( 468)						temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 469)						by = (py + ((by * cos) + (bx * sin)));
HXLINE( 470)						bx = temp;
HXLINE( 471)						temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 472)						cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 473)						cx = temp;
HXLINE(  96)						bool hasUndo = true;
HXDLIN(  96)						int aA = ((color >> 24) & 255);
HXDLIN(  96)						int rA = ((color >> 16) & 255);
HXDLIN(  96)						int gA = ((color >> 8) & 255);
HXDLIN(  96)						int bA = (color & 255);
HXDLIN(  96)						Float bcx = (bx - cx);
HXDLIN(  96)						Float bcy = (by - cy);
HXDLIN(  96)						Float acx = (px - cx);
HXDLIN(  96)						Float acy = (py - cy);
HXDLIN(  96)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  96)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  96)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  96)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  96)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  96)						if ((px > bx)) {
HXLINE(  96)							if ((px > cx)) {
HXLINE(  96)								int min;
HXDLIN(  96)								if ((bx > cx)) {
HXLINE(  96)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE(  96)									min = ::Math_obj::floor(bx);
            								}
HXDLIN(  96)								int ii_min = min;
HXDLIN(  96)								int ii_max = ::Math_obj::ceil(px);
HXDLIN(  96)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)								xIter3 = this1;
            							}
            							else {
HXLINE(  96)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  96)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  96)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  96)							if ((bx > cx)) {
HXLINE(  96)								int min;
HXDLIN(  96)								if ((px > cx)) {
HXLINE(  96)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE(  96)									min = ::Math_obj::ceil(px);
            								}
HXDLIN(  96)								int ii_min = min;
HXDLIN(  96)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  96)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)								xIter3 = this1;
            							}
            							else {
HXLINE(  96)								int ii_min = ::Math_obj::floor(px);
HXDLIN(  96)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  96)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)								xIter3 = this1;
            							}
            						}
HXDLIN(  96)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  96)						if ((py > by)) {
HXLINE(  96)							if ((py > cy)) {
HXLINE(  96)								int min;
HXDLIN(  96)								if ((by > cy)) {
HXLINE(  96)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE(  96)									min = ::Math_obj::floor(by);
            								}
HXDLIN(  96)								int ii_min = min;
HXDLIN(  96)								int ii_max = ::Math_obj::ceil(py);
HXDLIN(  96)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)								yIter3 = this1;
            							}
            							else {
HXLINE(  96)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  96)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  96)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  96)							if ((by > cy)) {
HXLINE(  96)								int min;
HXDLIN(  96)								if ((py > cy)) {
HXLINE(  96)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE(  96)									min = ::Math_obj::ceil(py);
            								}
HXDLIN(  96)								int ii_min = min;
HXDLIN(  96)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  96)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)								yIter3 = this1;
            							}
            							else {
HXLINE(  96)								int ii_min = ::Math_obj::floor(py);
HXDLIN(  96)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  96)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  96)								yIter3 = this1;
            							}
            						}
HXDLIN(  96)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  96)						if (hasUndo) {
HXLINE(  96)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  96)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  96)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  96)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  96)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  96)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  96)							undoImage = this3;
HXDLIN(  96)							{
HXLINE(  96)								int rectLeft = xIter3->start;
HXDLIN(  96)								int rectTop = yIter3->start;
HXDLIN(  96)								int rectRight = xIter3->max;
HXDLIN(  96)								bool forceClear = false;
HXDLIN(  96)								{
HXLINE(  96)									int _g = rectTop;
HXDLIN(  96)									int _g1 = yIter3->max;
HXDLIN(  96)									while((_g < _g1)){
HXLINE(  96)										_g = (_g + 1);
HXDLIN(  96)										int dy = (_g - 1);
HXDLIN(  96)										{
HXLINE(  96)											int _g1 = rectLeft;
HXDLIN(  96)											int _g2 = rectRight;
HXDLIN(  96)											while((_g1 < _g2)){
HXLINE(  96)												_g1 = (_g1 + 1);
HXDLIN(  96)												int dx = (_g1 - 1);
HXDLIN(  96)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)												int index;
HXDLIN(  96)												if (pixelImage->useVirtualPos) {
HXLINE(  96)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  96)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN(  96)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)												int col;
HXDLIN(  96)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  96)													col = c;
            												}
HXDLIN(  96)												bool _hx_tmp;
HXDLIN(  96)												if (pixelImage->useMask) {
HXLINE(  96)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE(  96)													_hx_tmp = false;
            												}
HXDLIN(  96)												if (_hx_tmp) {
HXLINE(  96)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  96)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  96)													int index;
HXDLIN(  96)													if (this1->useVirtualPos) {
HXLINE(  96)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  96)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  96)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  96)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  96)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)													int v;
HXDLIN(  96)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  96)														v = c;
            													}
HXDLIN(  96)													int this3 = v;
HXDLIN(  96)													int maskPixel = this3;
HXDLIN(  96)													int this4 = col;
HXDLIN(  96)													int this5 = this4;
HXDLIN(  96)													if ((maskPixel == 0)) {
HXLINE(  96)														int this1 = this5;
HXDLIN(  96)														col = this1;
            													}
            													else {
HXLINE(  96)														Float m0;
HXDLIN(  96)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  96)														if ((this1 == 0)) {
HXLINE(  96)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float m1;
HXDLIN(  96)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  96)														if ((this2 == 0)) {
HXLINE(  96)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float m2;
HXDLIN(  96)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  96)														if ((this3 == 0)) {
HXLINE(  96)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float m3;
HXDLIN(  96)														int this4 = (maskPixel & 255);
HXDLIN(  96)														if ((this4 == 0)) {
HXLINE(  96)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  96)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  96)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  96)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  96)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  96)												if ((col != 0)) {
HXLINE(  96)													int x = (dx - rectLeft);
HXDLIN(  96)													int y = (dy - rectTop);
HXDLIN(  96)													int this1 = col;
HXDLIN(  96)													int c = this1;
HXDLIN(  96)													bool _hx_tmp;
HXDLIN(  96)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  96)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  96)														_hx_tmp = false;
            													}
HXDLIN(  96)													if (_hx_tmp) {
HXLINE(  96)														int location;
HXDLIN(  96)														if (undoImage->useVirtualPos) {
HXLINE(  96)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  96)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  96)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)														int this3 = this2;
HXDLIN(  96)														int this4;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  96)															this4 = this3;
            														}
HXDLIN(  96)														Float a1;
HXDLIN(  96)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  96)														if ((this5 == 0)) {
HXLINE(  96)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float r1;
HXDLIN(  96)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  96)														if ((this6 == 0)) {
HXLINE(  96)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float g1;
HXDLIN(  96)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  96)														if ((this7 == 0)) {
HXLINE(  96)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float b1;
HXDLIN(  96)														int this8 = (this4 & 255);
HXDLIN(  96)														if ((this8 == 0)) {
HXLINE(  96)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float a2;
HXDLIN(  96)														int this9 = ((col >> 24) & 255);
HXDLIN(  96)														if ((this9 == 0)) {
HXLINE(  96)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float r2;
HXDLIN(  96)														int this10 = ((col >> 16) & 255);
HXDLIN(  96)														if ((this10 == 0)) {
HXLINE(  96)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float g2;
HXDLIN(  96)														int this11 = ((col >> 8) & 255);
HXDLIN(  96)														if ((this11 == 0)) {
HXLINE(  96)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float b2;
HXDLIN(  96)														int this12 = (col & 255);
HXDLIN(  96)														if ((this12 == 0)) {
HXLINE(  96)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  96)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  96)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  96)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)														{
HXLINE(  96)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  96)															int value;
HXDLIN(  96)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  96)																value = blended;
            															}
HXDLIN(  96)															bool _hx_tmp;
HXDLIN(  96)															if ((location >= 0)) {
HXLINE(  96)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  96)																_hx_tmp = false;
            															}
HXDLIN(  96)															if (_hx_tmp) {
HXLINE(  96)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  96)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  96)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  96)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)														int index;
HXDLIN(  96)														if (undoImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  96)														int value;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  96)															value = c;
            														}
HXDLIN(  96)														bool _hx_tmp;
HXDLIN(  96)														if ((index >= 0)) {
HXLINE(  96)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  96)															_hx_tmp = false;
            														}
HXDLIN(  96)														if (_hx_tmp) {
HXLINE(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  96)													if (forceClear) {
HXLINE(  96)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  96)														int x = (dx - rectLeft);
HXDLIN(  96)														int y = (dy - rectTop);
HXDLIN(  96)														int index;
HXDLIN(  96)														if (undoImage->useVirtualPos) {
HXLINE(  96)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  96)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  96)														bool _hx_tmp;
HXDLIN(  96)														if ((index >= 0)) {
HXLINE(  96)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  96)															_hx_tmp = false;
            														}
HXDLIN(  96)														if (_hx_tmp) {
HXLINE(  96)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  96)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  96)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  96)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  96)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  96)						bool found = false;
HXDLIN(  96)						Float min = ( (Float)(0) );
HXDLIN(  96)						Float max = ( (Float)(0) );
HXDLIN(  96)						int a1 = 0;
HXDLIN(  96)						int r = 0;
HXDLIN(  96)						int g = 0;
HXDLIN(  96)						int b = 0;
HXDLIN(  96)						{
HXLINE(  96)							int _g_min = xIter3->start;
HXDLIN(  96)							int _g_max = xIter3->max;
HXDLIN(  96)							while((_g_min < _g_max)){
HXLINE(  96)								_g_min = (_g_min + 1);
HXDLIN(  96)								int px = (_g_min - 1);
HXDLIN(  96)								Float pcx = (( (Float)(px) ) - cx);
HXLINE( 696)								found = false;
HXLINE(  96)								{
HXLINE(  96)									int _g_min1 = yIter3->start;
HXDLIN(  96)									int _g_max = yIter3->max;
HXDLIN(  96)									while((_g_min1 < _g_max)){
HXLINE(  96)										_g_min1 = (_g_min1 + 1);
HXDLIN(  96)										int py = (_g_min1 - 1);
HXDLIN(  96)										Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  96)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  96)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  96)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  96)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  96)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  96)										bool _hx_tmp;
HXDLIN(  96)										bool _hx_tmp1;
HXDLIN(  96)										if ((ratioA >= 0)) {
HXLINE(  96)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  96)											_hx_tmp1 = false;
            										}
HXDLIN(  96)										if (_hx_tmp1) {
HXLINE(  96)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  96)											_hx_tmp = false;
            										}
HXDLIN(  96)										if (_hx_tmp) {
HXLINE(  96)											Float min;
HXDLIN(  96)											if ((ratioA < ratioB)) {
HXLINE(  96)												min = ratioA;
            											}
            											else {
HXLINE(  96)												min = ratioB;
            											}
HXDLIN(  96)											if (!((min < ratioC))) {
HXLINE(  96)												min = ratioC;
            											}
HXDLIN(  96)											Float max;
HXDLIN(  96)											if ((ratioA > ratioB)) {
HXLINE(  96)												max = ratioA;
            											}
            											else {
HXLINE(  96)												max = ratioB;
            											}
HXDLIN(  96)											if (!((max > ratioC))) {
HXLINE(  96)												max = ratioC;
            											}
HXLINE( 744)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  96)											Float min1;
HXDLIN(  96)											if ((min < max)) {
HXLINE(  96)												min1 = min;
            											}
            											else {
HXLINE(  96)												min1 = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  96)											int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min1));
HXDLIN(  96)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  96)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  96)											int this1 = i;
HXDLIN(  96)											a1 = this1;
HXDLIN(  96)											int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  96)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  96)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  96)											int this2 = i1;
HXLINE( 748)											r = this2;
HXLINE(  96)											int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  96)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  96)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  96)											int this3 = i2;
HXLINE( 749)											g = this3;
HXLINE(  96)											int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  96)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  96)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  96)											int this4 = i3;
HXLINE( 750)											b = this4;
HXLINE(  96)											{
HXLINE(  96)												int location;
HXDLIN(  96)												if (pixelImage->useVirtualPos) {
HXLINE(  96)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  96)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            												}
HXDLIN(  96)												bool _hx_tmp;
HXDLIN(  96)												if (pixelImage->transparent) {
HXLINE(  96)													_hx_tmp = (a1 < 254);
            												}
            												else {
HXLINE(  96)													_hx_tmp = false;
            												}
HXDLIN(  96)												if (_hx_tmp) {
HXLINE(  96)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  96)													int this3 = this2;
HXDLIN(  96)													int old;
HXDLIN(  96)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  96)														old = this3;
            													}
HXDLIN(  96)													int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  96)													Float a11;
HXDLIN(  96)													int this4 = ((old >> 24) & 255);
HXDLIN(  96)													if ((this4 == 0)) {
HXLINE(  96)														a11 = ((Float)0.);
            													}
            													else {
HXLINE(  96)														a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  96)													Float r1;
HXDLIN(  96)													int this5 = ((old >> 16) & 255);
HXDLIN(  96)													if ((this5 == 0)) {
HXLINE(  96)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  96)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  96)													Float g1;
HXDLIN(  96)													int this6 = ((old >> 8) & 255);
HXDLIN(  96)													if ((this6 == 0)) {
HXLINE(  96)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  96)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  96)													Float b1;
HXDLIN(  96)													int this7 = (old & 255);
HXDLIN(  96)													if ((this7 == 0)) {
HXLINE(  96)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  96)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  96)													Float a2;
HXDLIN(  96)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  96)													if ((this8 == 0)) {
HXLINE(  96)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  96)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  96)													Float r2;
HXDLIN(  96)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  96)													if ((this9 == 0)) {
HXLINE(  96)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  96)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  96)													Float g2;
HXDLIN(  96)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  96)													if ((this10 == 0)) {
HXLINE(  96)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  96)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  96)													Float b2;
HXDLIN(  96)													int this11 = (rhs & 255);
HXDLIN(  96)													if ((this11 == 0)) {
HXLINE(  96)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  96)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  96)													Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  96)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  96)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  96)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  96)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  96)													int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  96)													{
HXLINE(  96)														::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  96)														int value;
HXDLIN(  96)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  96)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  96)															value = blended;
            														}
HXDLIN(  96)														bool _hx_tmp;
HXDLIN(  96)														if ((location >= 0)) {
HXLINE(  96)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  96)															_hx_tmp = false;
            														}
HXDLIN(  96)														if (_hx_tmp) {
HXLINE(  96)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  96)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  96)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  96)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  96)													int value;
HXDLIN(  96)													if (pixelImage->isLittle) {
HXLINE(  96)														value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  96)														value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  96)													bool _hx_tmp;
HXDLIN(  96)													if ((location >= 0)) {
HXLINE(  96)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  96)														_hx_tmp = false;
            													}
HXDLIN(  96)													if (_hx_tmp) {
HXLINE(  96)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  96)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  96)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  96)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  96)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  96)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 752)											found = true;
            										}
            										else {
HXLINE(  96)											if (found) {
HXLINE(  96)												goto _hx_goto_166;
            											}
            										}
            									}
            									_hx_goto_166:;
            								}
            							}
            						}
HXDLIN(  96)						::pixelimage::algo::HitTri hitTri;
HXDLIN(  96)						if ((hasHit == false)) {
HXLINE(  96)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx,by,cx,cy,true);
HXDLIN(  96)							if (hasUndo) {
HXLINE(  96)								v->undoImage = undoImage;
HXDLIN(  96)								v->undoX = xIter3->start;
HXDLIN(  96)								v->undoY = yIter3->start;
            							}
HXDLIN(  96)							hitTri = v;
            						}
            						else {
HXLINE(  96)							hitTri = null();
            						}
HXDLIN(  96)						if (hasHit) {
HXLINE(  96)							::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN(  96)							if (::hx::IsNotNull( hitQuad )) {
HXLINE(  96)								hitArr->triArr->push(hitQuad->triABD);
            							}
HXDLIN(  96)							hitArr->triArr->push(hitQuad->triBCD);
            						}
            					}
            				}
            				else {
HXLINE(  98)					Float thick = this->strokeWidth;
HXDLIN(  98)					int color = this->strokeColor;
HXDLIN(  98)					Float soft = this->soft;
HXDLIN(  98)					bool hasHit = true;
HXDLIN(  98)					{
HXLINE(  98)						Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  98)						Float o = (py - py);
HXDLIN(  98)						Float a = (px - px);
HXDLIN(  98)						Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  98)						Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  98)						Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN(  98)						Float sin = ::Math_obj::sin(theta);
HXDLIN(  98)						Float cos = ::Math_obj::cos(theta);
HXDLIN(  98)						Float radius = (thick / ( (Float)(2) ));
HXDLIN(  98)						Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  98)						Float h2 = (h / goldenRatio);
HXDLIN(  98)						::pixelimage::algo::HitQuad hitQuad;
HXDLIN(  98)						if (this->flare) {
HXLINE(  98)							if (this->reverseFlare) {
HXLINE(  98)								Float sin = ::Math_obj::sin(theta);
HXDLIN(  98)								Float cos = ::Math_obj::cos(theta);
HXDLIN(  98)								Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  98)								Float radius2 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  98)								Float dx = ((Float)0.1);
HXDLIN(  98)								Float dy = radius1;
HXDLIN(  98)								Float cx = h2;
HXDLIN(  98)								Float cy = radius2;
HXDLIN(  98)								Float bx = h2;
HXDLIN(  98)								Float by = -(radius2);
HXDLIN(  98)								Float ax = ((Float)0.1);
HXDLIN(  98)								Float ay = -(radius1);
HXDLIN(  98)								Float temp = ((Float)0.);
HXLINE( 288)								temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)								ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)								ax = temp;
HXLINE( 292)								temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)								by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)								bx = temp;
HXLINE( 296)								temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)								cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)								cx = temp;
HXLINE( 300)								temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)								dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)								dx = temp;
HXLINE(  98)								Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN(  98)								Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN(  98)								{
HXLINE(  98)									Float bx1 = ax;
HXDLIN(  98)									Float by1 = ay;
HXDLIN(  98)									Float cx1 = bx;
HXDLIN(  98)									Float cy1 = by;
HXDLIN(  98)									bool hasUndo = false;
HXDLIN(  98)									bool adjustWinding = (((((ex * by1) - (bx1 * ey)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ey) - (ex * cy1))) > 0);
HXDLIN(  98)									if (!(adjustWinding)) {
HXLINE(  98)										Float bx_ = bx1;
HXDLIN(  98)										Float by_ = by1;
HXLINE(  26)										bx1 = cx1;
HXLINE(  27)										by1 = cy1;
HXLINE(  28)										cx1 = bx_;
HXLINE(  29)										cy1 = by_;
            									}
HXLINE(  98)									{
HXLINE(  98)										Float s0 = ((ey * cx1) - (ex * cy1));
HXDLIN(  98)										Float sx = (cy1 - ey);
HXDLIN(  98)										Float sy = (ex - cx1);
HXDLIN(  98)										Float t0 = ((ex * by1) - (ey * bx1));
HXDLIN(  98)										Float tx = (ey - by1);
HXDLIN(  98)										Float ty = (bx1 - ex);
HXDLIN(  98)										Float A = ((((-(by1) * cx1) + (ey * (-(bx1) + cx1))) + (ex * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  98)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  98)										if ((ex > bx1)) {
HXLINE(  98)											if ((ex > cx1)) {
HXLINE(  98)												int min;
HXDLIN(  98)												if ((bx1 > cx1)) {
HXLINE(  98)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  98)													min = ::Math_obj::floor(bx1);
            												}
HXDLIN(  98)												int ii_min = min;
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												xIter3 = this1;
            											}
            											else {
HXLINE(  98)												int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  98)											if ((bx1 > cx1)) {
HXLINE(  98)												int min;
HXDLIN(  98)												if ((ex > cx1)) {
HXLINE(  98)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  98)													min = ::Math_obj::ceil(ex);
            												}
HXDLIN(  98)												int ii_min = min;
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												xIter3 = this1;
            											}
            											else {
HXLINE(  98)												int ii_min = ::Math_obj::floor(ex);
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												xIter3 = this1;
            											}
            										}
HXDLIN(  98)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  98)										if ((ey > by1)) {
HXLINE(  98)											if ((ey > cy1)) {
HXLINE(  98)												int min;
HXDLIN(  98)												if ((by1 > cy1)) {
HXLINE(  98)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  98)													min = ::Math_obj::floor(by1);
            												}
HXDLIN(  98)												int ii_min = min;
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												yIter3 = this1;
            											}
            											else {
HXLINE(  98)												int ii_min = ::Math_obj::floor(by1);
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  98)											if ((by1 > cy1)) {
HXLINE(  98)												int min;
HXDLIN(  98)												if ((ey > cy1)) {
HXLINE(  98)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  98)													min = ::Math_obj::ceil(ey);
            												}
HXDLIN(  98)												int ii_min = min;
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												yIter3 = this1;
            											}
            											else {
HXLINE(  98)												int ii_min = ::Math_obj::floor(ey);
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												yIter3 = this1;
            											}
            										}
HXDLIN(  98)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  98)										if (hasUndo) {
HXLINE(  98)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  98)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  98)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)											undoImage = this3;
HXDLIN(  98)											{
HXLINE(  98)												int rectLeft = xIter3->start;
HXDLIN(  98)												int rectTop = yIter3->start;
HXDLIN(  98)												int rectRight = xIter3->max;
HXDLIN(  98)												bool forceClear = false;
HXDLIN(  98)												{
HXLINE(  98)													int _g = rectTop;
HXDLIN(  98)													int _g1 = yIter3->max;
HXDLIN(  98)													while((_g < _g1)){
HXLINE(  98)														_g = (_g + 1);
HXDLIN(  98)														int dy = (_g - 1);
HXDLIN(  98)														{
HXLINE(  98)															int _g1 = rectLeft;
HXDLIN(  98)															int _g2 = rectRight;
HXDLIN(  98)															while((_g1 < _g2)){
HXLINE(  98)																_g1 = (_g1 + 1);
HXDLIN(  98)																int dx = (_g1 - 1);
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (pixelImage->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            																}
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int col;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	col = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if (pixelImage->useMask) {
HXLINE(  98)																	hitQuad = ::hx::IsNotNull( pixelImage->mask );
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)																	int index;
HXDLIN(  98)																	if (this1->useVirtualPos) {
HXLINE(  98)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  98)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  98)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																	int v;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		v = c;
            																	}
HXDLIN(  98)																	int this3 = v;
HXDLIN(  98)																	int maskPixel = this3;
HXDLIN(  98)																	int this4 = col;
HXDLIN(  98)																	int this5 = this4;
HXDLIN(  98)																	if ((maskPixel == 0)) {
HXLINE(  98)																		int this1 = this5;
HXDLIN(  98)																		col = this1;
            																	}
            																	else {
HXLINE(  98)																		Float m0;
HXDLIN(  98)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																		if ((this1 == 0)) {
HXLINE(  98)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float m1;
HXDLIN(  98)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																		if ((this2 == 0)) {
HXLINE(  98)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float m2;
HXDLIN(  98)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																		if ((this3 == 0)) {
HXLINE(  98)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float m3;
HXDLIN(  98)																		int this4 = (maskPixel & 255);
HXDLIN(  98)																		if ((this4 == 0)) {
HXLINE(  98)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  98)																if ((col != 0)) {
HXLINE(  98)																	int x = (dx - rectLeft);
HXDLIN(  98)																	int y = (dy - rectTop);
HXDLIN(  98)																	int this1 = col;
HXDLIN(  98)																	int c = this1;
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																		hitQuad = undoImage->transparent;
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		int location;
HXDLIN(  98)																		if (undoImage->useVirtualPos) {
HXLINE(  98)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  98)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																		int this3 = this2;
HXDLIN(  98)																		int this4;
HXDLIN(  98)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  98)																			this4 = this3;
            																		}
HXDLIN(  98)																		Float a1;
HXDLIN(  98)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																		if ((this5 == 0)) {
HXLINE(  98)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float r1;
HXDLIN(  98)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																		if ((this6 == 0)) {
HXLINE(  98)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float g1;
HXDLIN(  98)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																		if ((this7 == 0)) {
HXLINE(  98)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float b1;
HXDLIN(  98)																		int this8 = (this4 & 255);
HXDLIN(  98)																		if ((this8 == 0)) {
HXLINE(  98)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float a2;
HXDLIN(  98)																		int this9 = ((col >> 24) & 255);
HXDLIN(  98)																		if ((this9 == 0)) {
HXLINE(  98)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float r2;
HXDLIN(  98)																		int this10 = ((col >> 16) & 255);
HXDLIN(  98)																		if ((this10 == 0)) {
HXLINE(  98)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float g2;
HXDLIN(  98)																		int this11 = ((col >> 8) & 255);
HXDLIN(  98)																		if ((this11 == 0)) {
HXLINE(  98)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float b2;
HXDLIN(  98)																		int this12 = (col & 255);
HXDLIN(  98)																		if ((this12 == 0)) {
HXLINE(  98)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																		{
HXLINE(  98)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  98)																			int value;
HXDLIN(  98)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  98)																				value = blended;
            																			}
HXDLIN(  98)																			bool hitQuad;
HXDLIN(  98)																			if ((location >= 0)) {
HXLINE(  98)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  98)																				hitQuad = false;
            																			}
HXDLIN(  98)																			if (hitQuad) {
HXLINE(  98)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  98)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																		int index;
HXDLIN(  98)																		if (undoImage->useVirtualPos) {
HXLINE(  98)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  98)																		int value;
HXDLIN(  98)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  98)																			value = c;
            																		}
HXDLIN(  98)																		bool hitQuad;
HXDLIN(  98)																		if ((index >= 0)) {
HXLINE(  98)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  98)																			hitQuad = false;
            																		}
HXDLIN(  98)																		if (hitQuad) {
HXLINE(  98)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  98)																	if (forceClear) {
HXLINE(  98)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																		int x = (dx - rectLeft);
HXDLIN(  98)																		int y = (dy - rectTop);
HXDLIN(  98)																		int index;
HXDLIN(  98)																		if (undoImage->useVirtualPos) {
HXLINE(  98)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  98)																		bool hitQuad;
HXDLIN(  98)																		if ((index >= 0)) {
HXLINE(  98)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  98)																			hitQuad = false;
            																		}
HXDLIN(  98)																		if (hitQuad) {
HXLINE(  98)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  98)										bool found = false;
HXDLIN(  98)										Float s = ((Float)0.);
HXDLIN(  98)										Float t = ((Float)0.);
HXDLIN(  98)										Float sxx = ((Float)0.);
HXDLIN(  98)										Float txx = ((Float)0.);
HXDLIN(  98)										{
HXLINE(  98)											int _g_min = xIter3->start;
HXDLIN(  98)											int _g_max = xIter3->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int x = (_g_min - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found = false;
HXLINE(  98)												{
HXLINE(  98)													int _g_min1 = yIter3->start;
HXDLIN(  98)													int _g_max = yIter3->max;
HXDLIN(  98)													while((_g_min1 < _g_max)){
HXLINE(  98)														_g_min1 = (_g_min1 + 1);
HXDLIN(  98)														int y = (_g_min1 - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  98)														bool hitQuad;
HXDLIN(  98)														if (!((s <= 0))) {
HXLINE(  98)															hitQuad = (t <= 0);
            														}
            														else {
HXLINE(  98)															hitQuad = true;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															if (found) {
HXLINE(  98)																goto _hx_goto_170;
            															}
            														}
            														else {
HXLINE(  98)															if (((s + t) < A)) {
HXLINE(  98)																{
HXLINE(  98)																	int this1 = color;
HXDLIN(  98)																	int c = this1;
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																		hitQuad = pixelImage->transparent;
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		int location;
HXDLIN(  98)																		if (pixelImage->useVirtualPos) {
HXLINE(  98)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  98)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																		int this3 = this2;
HXDLIN(  98)																		int this4;
HXDLIN(  98)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  98)																			this4 = this3;
            																		}
HXDLIN(  98)																		Float a1;
HXDLIN(  98)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																		if ((this5 == 0)) {
HXLINE(  98)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float r1;
HXDLIN(  98)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																		if ((this6 == 0)) {
HXLINE(  98)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float g1;
HXDLIN(  98)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																		if ((this7 == 0)) {
HXLINE(  98)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float b1;
HXDLIN(  98)																		int this8 = (this4 & 255);
HXDLIN(  98)																		if ((this8 == 0)) {
HXLINE(  98)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float a2;
HXDLIN(  98)																		int this9 = ((color >> 24) & 255);
HXDLIN(  98)																		if ((this9 == 0)) {
HXLINE(  98)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float r2;
HXDLIN(  98)																		int this10 = ((color >> 16) & 255);
HXDLIN(  98)																		if ((this10 == 0)) {
HXLINE(  98)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float g2;
HXDLIN(  98)																		int this11 = ((color >> 8) & 255);
HXDLIN(  98)																		if ((this11 == 0)) {
HXLINE(  98)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float b2;
HXDLIN(  98)																		int this12 = (color & 255);
HXDLIN(  98)																		if ((this12 == 0)) {
HXLINE(  98)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																		{
HXLINE(  98)																			::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN(  98)																			int value;
HXDLIN(  98)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  98)																				value = blended;
            																			}
HXDLIN(  98)																			bool hitQuad;
HXDLIN(  98)																			if ((location >= 0)) {
HXLINE(  98)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  98)																				hitQuad = false;
            																			}
HXDLIN(  98)																			if (hitQuad) {
HXLINE(  98)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  98)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)																		int index;
HXDLIN(  98)																		if (pixelImage->useVirtualPos) {
HXLINE(  98)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  98)																		int value;
HXDLIN(  98)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  98)																			value = c;
            																		}
HXDLIN(  98)																		bool hitQuad;
HXDLIN(  98)																		if ((index >= 0)) {
HXLINE(  98)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  98)																			hitQuad = false;
            																		}
HXDLIN(  98)																		if (hitQuad) {
HXLINE(  98)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found = true;
            															}
            															else {
HXLINE(  98)																if (found) {
HXLINE(  98)																	goto _hx_goto_170;
            																}
            															}
            														}
            													}
            													_hx_goto_170:;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool hasUndo1 = false;
HXDLIN(  98)								int aA = ((color >> 24) & 255);
HXDLIN(  98)								int rA = ((color >> 16) & 255);
HXDLIN(  98)								int gA = ((color >> 8) & 255);
HXDLIN(  98)								int bA = (color & 255);
HXDLIN(  98)								Float bcx = (bx - cx);
HXDLIN(  98)								Float bcy = (by - cy);
HXDLIN(  98)								Float acx = (ex - cx);
HXDLIN(  98)								Float acy = (ey - cy);
HXDLIN(  98)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  98)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  98)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  98)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  98)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  98)								if ((ex > bx)) {
HXLINE(  98)									if ((ex > cx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((bx > cx)) {
HXLINE(  98)											min = ::Math_obj::floor(cx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((bx > cx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ex > cx)) {
HXLINE(  98)											min = ::Math_obj::floor(cx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  98)								if ((ey > by)) {
HXLINE(  98)									if ((ey > cy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((by > cy)) {
HXLINE(  98)											min = ::Math_obj::floor(cy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((by > cy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ey > cy)) {
HXLINE(  98)											min = ::Math_obj::floor(cy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  98)								if (hasUndo1) {
HXLINE(  98)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  98)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  98)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)									undoImage1 = this3;
HXDLIN(  98)									{
HXLINE(  98)										int rectLeft = xIter31->start;
HXDLIN(  98)										int rectTop = yIter31->start;
HXDLIN(  98)										int rectRight = xIter31->max;
HXDLIN(  98)										bool forceClear = false;
HXDLIN(  98)										{
HXLINE(  98)											int _g = rectTop;
HXDLIN(  98)											int _g1 = yIter31->max;
HXDLIN(  98)											while((_g < _g1)){
HXLINE(  98)												_g = (_g + 1);
HXDLIN(  98)												int dy = (_g - 1);
HXDLIN(  98)												{
HXLINE(  98)													int _g1 = rectLeft;
HXDLIN(  98)													int _g2 = rectRight;
HXDLIN(  98)													while((_g1 < _g2)){
HXLINE(  98)														_g1 = (_g1 + 1);
HXDLIN(  98)														int dx = (_g1 - 1);
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int col;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															col = c;
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->useMask) {
HXLINE(  98)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)															int index;
HXDLIN(  98)															if (this1->useVirtualPos) {
HXLINE(  98)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  98)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  98)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int v;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  98)																v = c;
            															}
HXDLIN(  98)															int this3 = v;
HXDLIN(  98)															int maskPixel = this3;
HXDLIN(  98)															int this4 = col;
HXDLIN(  98)															int this5 = this4;
HXDLIN(  98)															if ((maskPixel == 0)) {
HXLINE(  98)																int this1 = this5;
HXDLIN(  98)																col = this1;
            															}
            															else {
HXLINE(  98)																Float m0;
HXDLIN(  98)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																if ((this1 == 0)) {
HXLINE(  98)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m1;
HXDLIN(  98)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																if ((this2 == 0)) {
HXLINE(  98)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m2;
HXDLIN(  98)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																if ((this3 == 0)) {
HXLINE(  98)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m3;
HXDLIN(  98)																int this4 = (maskPixel & 255);
HXDLIN(  98)																if ((this4 == 0)) {
HXLINE(  98)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  98)														if ((col != 0)) {
HXLINE(  98)															int x = (dx - rectLeft);
HXDLIN(  98)															int y = (dy - rectTop);
HXDLIN(  98)															int this1 = col;
HXDLIN(  98)															int c = this1;
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																int location;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int this3 = this2;
HXDLIN(  98)																int this4;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	this4 = this3;
            																}
HXDLIN(  98)																Float a1;
HXDLIN(  98)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																if ((this5 == 0)) {
HXLINE(  98)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r1;
HXDLIN(  98)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																if ((this6 == 0)) {
HXLINE(  98)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g1;
HXDLIN(  98)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																if ((this7 == 0)) {
HXLINE(  98)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b1;
HXDLIN(  98)																int this8 = (this4 & 255);
HXDLIN(  98)																if ((this8 == 0)) {
HXLINE(  98)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a2;
HXDLIN(  98)																int this9 = ((col >> 24) & 255);
HXDLIN(  98)																if ((this9 == 0)) {
HXLINE(  98)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r2;
HXDLIN(  98)																int this10 = ((col >> 16) & 255);
HXDLIN(  98)																if ((this10 == 0)) {
HXLINE(  98)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g2;
HXDLIN(  98)																int this11 = ((col >> 8) & 255);
HXDLIN(  98)																if ((this11 == 0)) {
HXLINE(  98)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b2;
HXDLIN(  98)																int this12 = (col & 255);
HXDLIN(  98)																if ((this12 == 0)) {
HXLINE(  98)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																{
HXLINE(  98)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  98)																	int value;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		value = blended;
            																	}
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((location >= 0)) {
HXLINE(  98)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															if (forceClear) {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																int x = (dx - rectLeft);
HXDLIN(  98)																int y = (dy - rectTop);
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool found1 = false;
HXDLIN(  98)								{
HXLINE(  98)									int _g_min1 = xIter31->start;
HXDLIN(  98)									int _g_max1 = xIter31->max;
HXDLIN(  98)									while((_g_min1 < _g_max1)){
HXLINE(  98)										_g_min1 = (_g_min1 + 1);
HXDLIN(  98)										int px = (_g_min1 - 1);
HXDLIN(  98)										Float pcx = (( (Float)(px) ) - cx);
HXLINE( 620)										found1 = false;
HXLINE(  98)										{
HXLINE(  98)											int _g_min = yIter31->start;
HXDLIN(  98)											int _g_max = yIter31->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int py = (_g_min - 1);
HXDLIN(  98)												Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  98)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  98)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  98)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  98)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  98)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)												bool hitQuad;
HXDLIN(  98)												bool hitQuad1;
HXDLIN(  98)												if ((ratioA >= 0)) {
HXLINE(  98)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad1 = false;
            												}
HXDLIN(  98)												if (hitQuad1) {
HXLINE(  98)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad = false;
            												}
HXDLIN(  98)												if (hitQuad) {
HXLINE(  98)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (soft * ratioB)));
HXDLIN(  98)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  98)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  98)													int this1 = i;
HXDLIN(  98)													int a = this1;
HXDLIN(  98)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  98)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  98)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  98)													int this2 = i1;
HXDLIN(  98)													int r = this2;
HXDLIN(  98)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  98)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  98)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  98)													int this3 = i2;
HXDLIN(  98)													int g = this3;
HXDLIN(  98)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  98)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  98)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  98)													int this4 = i3;
HXDLIN(  98)													int b = this4;
HXDLIN(  98)													{
HXLINE(  98)														int location;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->transparent) {
HXLINE(  98)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int this3 = this2;
HXDLIN(  98)															int old;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  98)																old = this3;
            															}
HXDLIN(  98)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)															Float a1;
HXDLIN(  98)															int this4 = ((old >> 24) & 255);
HXDLIN(  98)															if ((this4 == 0)) {
HXLINE(  98)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r1;
HXDLIN(  98)															int this5 = ((old >> 16) & 255);
HXDLIN(  98)															if ((this5 == 0)) {
HXLINE(  98)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g1;
HXDLIN(  98)															int this6 = ((old >> 8) & 255);
HXDLIN(  98)															if ((this6 == 0)) {
HXLINE(  98)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b1;
HXDLIN(  98)															int this7 = (old & 255);
HXDLIN(  98)															if ((this7 == 0)) {
HXLINE(  98)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a2;
HXDLIN(  98)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)															if ((this8 == 0)) {
HXLINE(  98)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r2;
HXDLIN(  98)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)															if ((this9 == 0)) {
HXLINE(  98)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g2;
HXDLIN(  98)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)															if ((this10 == 0)) {
HXLINE(  98)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b2;
HXDLIN(  98)															int this11 = (rhs & 255);
HXDLIN(  98)															if ((this11 == 0)) {
HXLINE(  98)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  98)															{
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = blended;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((location >= 0)) {
HXLINE(  98)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (pixelImage->isLittle) {
HXLINE(  98)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  98)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found1 = true;
            												}
            												else {
HXLINE(  98)													if (found1) {
HXLINE(  98)														goto _hx_goto_174;
            													}
            												}
            											}
            											_hx_goto_174:;
            										}
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  98)								int v_undoY;
HXDLIN(  98)								int v_undoX;
HXDLIN(  98)								Float v_ty;
HXDLIN(  98)								Float v_tx;
HXDLIN(  98)								Float v_t0;
HXDLIN(  98)								Float v_sy;
HXDLIN(  98)								Float v_sx;
HXDLIN(  98)								Float v_s0;
HXDLIN(  98)								Float v_A;
HXDLIN(  98)								Float ax1 = ex;
HXDLIN(  98)								Float ay1 = ey;
HXDLIN(  98)								Float bx2 = bx;
HXDLIN(  98)								Float by2 = by;
HXDLIN(  98)								Float cx2 = cx;
HXDLIN(  98)								Float cy2 = cy;
HXDLIN(  98)								::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  98)								bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  98)								if (!(adjustWinding1)) {
HXLINE(  98)									Float bx_ = bx2;
HXDLIN(  98)									Float by_ = by2;
HXLINE(  35)									bx2 = cx2;
HXLINE(  36)									by2 = cy2;
HXLINE(  37)									cx2 = bx_;
HXLINE(  38)									cy2 = by_;
            								}
HXLINE(  98)								Float v_ax = ax1;
HXDLIN(  98)								Float v_ay = ay1;
HXDLIN(  98)								Float v_bx = bx2;
HXDLIN(  98)								Float v_by = by2;
HXDLIN(  98)								Float v_cx = cx2;
HXDLIN(  98)								Float v_cy = cy2;
HXDLIN(  98)								bool v_preCalculated = true;
HXDLIN(  98)								{
HXLINE(  98)									v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  98)									v_sx = (v_cy - v_ay);
HXDLIN(  98)									v_sy = (v_ax - v_cx);
HXDLIN(  98)									v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  98)									v_tx = (v_ay - v_by);
HXDLIN(  98)									v_ty = (v_bx - v_ax);
HXDLIN(  98)									v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  98)									Float a = v_ax;
HXDLIN(  98)									Float b = v_bx;
HXDLIN(  98)									Float c = v_cx;
HXDLIN(  98)									if ((a > b)) {
HXLINE(  98)										if ((a > c)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b > c)) {
HXLINE(  98)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b > c)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a > c)) {
HXLINE(  98)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter3 = this1;
            										}
            									}
HXDLIN(  98)									Float a1 = v_ay;
HXDLIN(  98)									Float b1 = v_by;
HXDLIN(  98)									Float c1 = v_cy;
HXDLIN(  98)									if ((a1 > b1)) {
HXLINE(  98)										if ((a1 > c1)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b1 > c1)) {
HXLINE(  98)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b1);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b1);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b1 > c1)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a1 > c1)) {
HXLINE(  98)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a1);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a1);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter3 = this1;
            										}
            									}
            								}
HXDLIN(  98)								if (hasUndo1) {
HXLINE(  98)									v_undoImage = undoImage1;
HXDLIN(  98)									v_undoX = xIter31->start;
HXDLIN(  98)									v_undoY = yIter31->start;
            								}
HXDLIN(  98)								bool hasUndo2 = false;
HXDLIN(  98)								int aA1 = ((color >> 24) & 255);
HXDLIN(  98)								int rA1 = ((color >> 16) & 255);
HXDLIN(  98)								int gA1 = ((color >> 8) & 255);
HXDLIN(  98)								int bA1 = (color & 255);
HXDLIN(  98)								Float bcx1 = (cx - dx);
HXDLIN(  98)								Float bcy1 = (cy - dy);
HXDLIN(  98)								Float acx1 = (ex - dx);
HXDLIN(  98)								Float acy1 = (ey - dy);
HXDLIN(  98)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  98)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  98)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  98)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  98)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  98)								if ((ex > cx)) {
HXLINE(  98)									if ((ex > dx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((cx > dx)) {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter32 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((cx > dx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ex > dx)) {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter32 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter32 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  98)								if ((ey > cy)) {
HXLINE(  98)									if ((ey > dy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((cy > dy)) {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter32 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((cy > dy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ey > dy)) {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter32 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter32 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  98)								if (hasUndo2) {
HXLINE(  98)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  98)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  98)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)									undoImage2 = this3;
HXDLIN(  98)									{
HXLINE(  98)										int rectLeft = xIter32->start;
HXDLIN(  98)										int rectTop = yIter32->start;
HXDLIN(  98)										int rectRight = xIter32->max;
HXDLIN(  98)										bool forceClear = false;
HXDLIN(  98)										{
HXLINE(  98)											int _g = rectTop;
HXDLIN(  98)											int _g1 = yIter32->max;
HXDLIN(  98)											while((_g < _g1)){
HXLINE(  98)												_g = (_g + 1);
HXDLIN(  98)												int dy = (_g - 1);
HXDLIN(  98)												{
HXLINE(  98)													int _g1 = rectLeft;
HXDLIN(  98)													int _g2 = rectRight;
HXDLIN(  98)													while((_g1 < _g2)){
HXLINE(  98)														_g1 = (_g1 + 1);
HXDLIN(  98)														int dx = (_g1 - 1);
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int col;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															col = c;
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->useMask) {
HXLINE(  98)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)															int index;
HXDLIN(  98)															if (this1->useVirtualPos) {
HXLINE(  98)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  98)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  98)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int v;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  98)																v = c;
            															}
HXDLIN(  98)															int this3 = v;
HXDLIN(  98)															int maskPixel = this3;
HXDLIN(  98)															int this4 = col;
HXDLIN(  98)															int this5 = this4;
HXDLIN(  98)															if ((maskPixel == 0)) {
HXLINE(  98)																int this1 = this5;
HXDLIN(  98)																col = this1;
            															}
            															else {
HXLINE(  98)																Float m0;
HXDLIN(  98)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																if ((this1 == 0)) {
HXLINE(  98)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m1;
HXDLIN(  98)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																if ((this2 == 0)) {
HXLINE(  98)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m2;
HXDLIN(  98)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																if ((this3 == 0)) {
HXLINE(  98)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m3;
HXDLIN(  98)																int this4 = (maskPixel & 255);
HXDLIN(  98)																if ((this4 == 0)) {
HXLINE(  98)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  98)														if ((col != 0)) {
HXLINE(  98)															int x = (dx - rectLeft);
HXDLIN(  98)															int y = (dy - rectTop);
HXDLIN(  98)															int this1 = col;
HXDLIN(  98)															int c = this1;
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																hitQuad = undoImage2->transparent;
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																int location;
HXDLIN(  98)																if (undoImage2->useVirtualPos) {
HXLINE(  98)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  98)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int this3 = this2;
HXDLIN(  98)																int this4;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	this4 = this3;
            																}
HXDLIN(  98)																Float a1;
HXDLIN(  98)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																if ((this5 == 0)) {
HXLINE(  98)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r1;
HXDLIN(  98)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																if ((this6 == 0)) {
HXLINE(  98)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g1;
HXDLIN(  98)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																if ((this7 == 0)) {
HXLINE(  98)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b1;
HXDLIN(  98)																int this8 = (this4 & 255);
HXDLIN(  98)																if ((this8 == 0)) {
HXLINE(  98)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a2;
HXDLIN(  98)																int this9 = ((col >> 24) & 255);
HXDLIN(  98)																if ((this9 == 0)) {
HXLINE(  98)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r2;
HXDLIN(  98)																int this10 = ((col >> 16) & 255);
HXDLIN(  98)																if ((this10 == 0)) {
HXLINE(  98)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g2;
HXDLIN(  98)																int this11 = ((col >> 8) & 255);
HXDLIN(  98)																if ((this11 == 0)) {
HXLINE(  98)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b2;
HXDLIN(  98)																int this12 = (col & 255);
HXDLIN(  98)																if ((this12 == 0)) {
HXLINE(  98)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																{
HXLINE(  98)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  98)																	int value;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		value = blended;
            																	}
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((location >= 0)) {
HXLINE(  98)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage2->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															if (forceClear) {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  98)																int x = (dx - rectLeft);
HXDLIN(  98)																int y = (dy - rectTop);
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage2->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool found2 = false;
HXDLIN(  98)								{
HXLINE(  98)									int _g_min2 = xIter32->start;
HXDLIN(  98)									int _g_max2 = xIter32->max;
HXDLIN(  98)									while((_g_min2 < _g_max2)){
HXLINE(  98)										_g_min2 = (_g_min2 + 1);
HXDLIN(  98)										int px = (_g_min2 - 1);
HXDLIN(  98)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 620)										found2 = false;
HXLINE(  98)										{
HXLINE(  98)											int _g_min = yIter32->start;
HXDLIN(  98)											int _g_max = yIter32->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int py = (_g_min - 1);
HXDLIN(  98)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  98)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  98)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  98)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  98)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  98)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)												bool hitQuad;
HXDLIN(  98)												bool hitQuad1;
HXDLIN(  98)												if ((ratioA >= 0)) {
HXLINE(  98)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad1 = false;
            												}
HXDLIN(  98)												if (hitQuad1) {
HXLINE(  98)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad = false;
            												}
HXDLIN(  98)												if (hitQuad) {
HXLINE(  98)													int i = ::Std_obj::_hx_int((( (Float)(aA1) ) * (soft * ratioB)));
HXDLIN(  98)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  98)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  98)													int this1 = i;
HXDLIN(  98)													int a = this1;
HXDLIN(  98)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  98)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  98)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  98)													int this2 = i1;
HXDLIN(  98)													int r = this2;
HXDLIN(  98)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  98)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  98)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  98)													int this3 = i2;
HXDLIN(  98)													int g = this3;
HXDLIN(  98)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  98)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  98)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  98)													int this4 = i3;
HXDLIN(  98)													int b = this4;
HXDLIN(  98)													{
HXLINE(  98)														int location;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->transparent) {
HXLINE(  98)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int this3 = this2;
HXDLIN(  98)															int old;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  98)																old = this3;
            															}
HXDLIN(  98)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)															Float a1;
HXDLIN(  98)															int this4 = ((old >> 24) & 255);
HXDLIN(  98)															if ((this4 == 0)) {
HXLINE(  98)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r1;
HXDLIN(  98)															int this5 = ((old >> 16) & 255);
HXDLIN(  98)															if ((this5 == 0)) {
HXLINE(  98)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g1;
HXDLIN(  98)															int this6 = ((old >> 8) & 255);
HXDLIN(  98)															if ((this6 == 0)) {
HXLINE(  98)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b1;
HXDLIN(  98)															int this7 = (old & 255);
HXDLIN(  98)															if ((this7 == 0)) {
HXLINE(  98)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a2;
HXDLIN(  98)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)															if ((this8 == 0)) {
HXLINE(  98)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r2;
HXDLIN(  98)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)															if ((this9 == 0)) {
HXLINE(  98)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g2;
HXDLIN(  98)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)															if ((this10 == 0)) {
HXLINE(  98)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b2;
HXDLIN(  98)															int this11 = (rhs & 255);
HXDLIN(  98)															if ((this11 == 0)) {
HXLINE(  98)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  98)															{
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = blended;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((location >= 0)) {
HXLINE(  98)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (pixelImage->isLittle) {
HXLINE(  98)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  98)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found2 = true;
            												}
            												else {
HXLINE(  98)													if (found2) {
HXLINE(  98)														goto _hx_goto_178;
            													}
            												}
            											}
            											_hx_goto_178:;
            										}
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  98)								int v_undoY1;
HXDLIN(  98)								int v_undoX1;
HXDLIN(  98)								Float v_ty1;
HXDLIN(  98)								Float v_tx1;
HXDLIN(  98)								Float v_t01;
HXDLIN(  98)								Float v_sy1;
HXDLIN(  98)								Float v_sx1;
HXDLIN(  98)								Float v_s01;
HXDLIN(  98)								Float v_A1;
HXDLIN(  98)								Float ax2 = ex;
HXDLIN(  98)								Float ay2 = ey;
HXDLIN(  98)								Float bx3 = cx;
HXDLIN(  98)								Float by3 = cy;
HXDLIN(  98)								Float cx3 = dx;
HXDLIN(  98)								Float cy3 = dy;
HXDLIN(  98)								::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  98)								bool adjustWinding2 = (((((ax2 * by3) - (bx3 * ay2)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay2) - (ax2 * cy3))) > 0);
HXDLIN(  98)								if (!(adjustWinding2)) {
HXLINE(  98)									Float bx_ = bx3;
HXDLIN(  98)									Float by_ = by3;
HXLINE(  35)									bx3 = cx3;
HXLINE(  36)									by3 = cy3;
HXLINE(  37)									cx3 = bx_;
HXLINE(  38)									cy3 = by_;
            								}
HXLINE(  98)								Float v_ax1 = ax2;
HXDLIN(  98)								Float v_ay1 = ay2;
HXDLIN(  98)								Float v_bx1 = bx3;
HXDLIN(  98)								Float v_by1 = by3;
HXDLIN(  98)								Float v_cx1 = cx3;
HXDLIN(  98)								Float v_cy1 = cy3;
HXDLIN(  98)								bool v_preCalculated1 = true;
HXDLIN(  98)								{
HXLINE(  98)									v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  98)									v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  98)									v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  98)									v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  98)									v_tx1 = (v_ay1 - v_by1);
HXDLIN(  98)									v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  98)									v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  98)									Float a2 = v_ax1;
HXDLIN(  98)									Float b2 = v_bx1;
HXDLIN(  98)									Float c2 = v_cx1;
HXDLIN(  98)									if ((a2 > b2)) {
HXLINE(  98)										if ((a2 > c2)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b2 > c2)) {
HXLINE(  98)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b2);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b2);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter31 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b2 > c2)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a2 > c2)) {
HXLINE(  98)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a2);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a2);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter31 = this1;
            										}
            									}
HXDLIN(  98)									Float a3 = v_ay1;
HXDLIN(  98)									Float b3 = v_by1;
HXDLIN(  98)									Float c3 = v_cy1;
HXDLIN(  98)									if ((a3 > b3)) {
HXLINE(  98)										if ((a3 > c3)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b3 > c3)) {
HXLINE(  98)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b3);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b3);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter31 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b3 > c3)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a3 > c3)) {
HXLINE(  98)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a3);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a3);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter31 = this1;
            										}
            									}
            								}
HXDLIN(  98)								if (hasUndo2) {
HXLINE(  98)									v_undoImage1 = undoImage2;
HXDLIN(  98)									v_undoX1 = xIter32->start;
HXDLIN(  98)									v_undoY1 = yIter32->start;
            								}
HXDLIN(  98)								bool hasUndo3 = false;
HXDLIN(  98)								int aA2 = ((color >> 24) & 255);
HXDLIN(  98)								int rA2 = ((color >> 16) & 255);
HXDLIN(  98)								int gA2 = ((color >> 8) & 255);
HXDLIN(  98)								int bA2 = (color & 255);
HXDLIN(  98)								Float bcx2 = (dx - ax);
HXDLIN(  98)								Float bcy2 = (dy - ay);
HXDLIN(  98)								Float acx2 = (ex - ax);
HXDLIN(  98)								Float acy2 = (ey - ay);
HXDLIN(  98)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  98)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  98)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  98)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  98)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  98)								if ((ex > dx)) {
HXLINE(  98)									if ((ex > ax)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((dx > ax)) {
HXLINE(  98)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter33 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(dx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((dx > ax)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ex > ax)) {
HXLINE(  98)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter33 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter33 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  98)								if ((ey > dy)) {
HXLINE(  98)									if ((ey > ay)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((dy > ay)) {
HXLINE(  98)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter33 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(dy);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((dy > ay)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ey > ay)) {
HXLINE(  98)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter33 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter33 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  98)								if (hasUndo3) {
HXLINE(  98)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  98)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  98)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)									undoImage3 = this3;
HXDLIN(  98)									{
HXLINE(  98)										int rectLeft = xIter33->start;
HXDLIN(  98)										int rectTop = yIter33->start;
HXDLIN(  98)										int rectRight = xIter33->max;
HXDLIN(  98)										bool forceClear = false;
HXDLIN(  98)										{
HXLINE(  98)											int _g = rectTop;
HXDLIN(  98)											int _g1 = yIter33->max;
HXDLIN(  98)											while((_g < _g1)){
HXLINE(  98)												_g = (_g + 1);
HXDLIN(  98)												int dy = (_g - 1);
HXDLIN(  98)												{
HXLINE(  98)													int _g1 = rectLeft;
HXDLIN(  98)													int _g2 = rectRight;
HXDLIN(  98)													while((_g1 < _g2)){
HXLINE(  98)														_g1 = (_g1 + 1);
HXDLIN(  98)														int dx = (_g1 - 1);
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int col;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															col = c;
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->useMask) {
HXLINE(  98)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)															int index;
HXDLIN(  98)															if (this1->useVirtualPos) {
HXLINE(  98)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  98)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  98)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int v;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  98)																v = c;
            															}
HXDLIN(  98)															int this3 = v;
HXDLIN(  98)															int maskPixel = this3;
HXDLIN(  98)															int this4 = col;
HXDLIN(  98)															int this5 = this4;
HXDLIN(  98)															if ((maskPixel == 0)) {
HXLINE(  98)																int this1 = this5;
HXDLIN(  98)																col = this1;
            															}
            															else {
HXLINE(  98)																Float m0;
HXDLIN(  98)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																if ((this1 == 0)) {
HXLINE(  98)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m1;
HXDLIN(  98)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																if ((this2 == 0)) {
HXLINE(  98)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m2;
HXDLIN(  98)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																if ((this3 == 0)) {
HXLINE(  98)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m3;
HXDLIN(  98)																int this4 = (maskPixel & 255);
HXDLIN(  98)																if ((this4 == 0)) {
HXLINE(  98)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  98)														if ((col != 0)) {
HXLINE(  98)															int x = (dx - rectLeft);
HXDLIN(  98)															int y = (dy - rectTop);
HXDLIN(  98)															int this1 = col;
HXDLIN(  98)															int c = this1;
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																hitQuad = undoImage3->transparent;
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																int location;
HXDLIN(  98)																if (undoImage3->useVirtualPos) {
HXLINE(  98)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  98)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int this3 = this2;
HXDLIN(  98)																int this4;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	this4 = this3;
            																}
HXDLIN(  98)																Float a1;
HXDLIN(  98)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																if ((this5 == 0)) {
HXLINE(  98)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r1;
HXDLIN(  98)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																if ((this6 == 0)) {
HXLINE(  98)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g1;
HXDLIN(  98)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																if ((this7 == 0)) {
HXLINE(  98)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b1;
HXDLIN(  98)																int this8 = (this4 & 255);
HXDLIN(  98)																if ((this8 == 0)) {
HXLINE(  98)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a2;
HXDLIN(  98)																int this9 = ((col >> 24) & 255);
HXDLIN(  98)																if ((this9 == 0)) {
HXLINE(  98)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r2;
HXDLIN(  98)																int this10 = ((col >> 16) & 255);
HXDLIN(  98)																if ((this10 == 0)) {
HXLINE(  98)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g2;
HXDLIN(  98)																int this11 = ((col >> 8) & 255);
HXDLIN(  98)																if ((this11 == 0)) {
HXLINE(  98)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b2;
HXDLIN(  98)																int this12 = (col & 255);
HXDLIN(  98)																if ((this12 == 0)) {
HXLINE(  98)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																{
HXLINE(  98)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  98)																	int value;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		value = blended;
            																	}
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((location >= 0)) {
HXLINE(  98)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage3->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															if (forceClear) {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  98)																int x = (dx - rectLeft);
HXDLIN(  98)																int y = (dy - rectTop);
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage3->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool found3 = false;
HXDLIN(  98)								{
HXLINE(  98)									int _g_min3 = xIter33->start;
HXDLIN(  98)									int _g_max3 = xIter33->max;
HXDLIN(  98)									while((_g_min3 < _g_max3)){
HXLINE(  98)										_g_min3 = (_g_min3 + 1);
HXDLIN(  98)										int px = (_g_min3 - 1);
HXDLIN(  98)										Float pcx = (( (Float)(px) ) - ax);
HXLINE( 620)										found3 = false;
HXLINE(  98)										{
HXLINE(  98)											int _g_min = yIter33->start;
HXDLIN(  98)											int _g_max = yIter33->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int py = (_g_min - 1);
HXDLIN(  98)												Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  98)												Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  98)												Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  98)												Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  98)												Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  98)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)												bool hitQuad;
HXDLIN(  98)												bool hitQuad1;
HXDLIN(  98)												if ((ratioA >= 0)) {
HXLINE(  98)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad1 = false;
            												}
HXDLIN(  98)												if (hitQuad1) {
HXLINE(  98)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad = false;
            												}
HXDLIN(  98)												if (hitQuad) {
HXLINE(  98)													int i = ::Std_obj::_hx_int((( (Float)(aA2) ) * (soft * ratioB)));
HXDLIN(  98)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  98)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  98)													int this1 = i;
HXDLIN(  98)													int a = this1;
HXDLIN(  98)													int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  98)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  98)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  98)													int this2 = i1;
HXDLIN(  98)													int r = this2;
HXDLIN(  98)													int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  98)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  98)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  98)													int this3 = i2;
HXDLIN(  98)													int g = this3;
HXDLIN(  98)													int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  98)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  98)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  98)													int this4 = i3;
HXDLIN(  98)													int b = this4;
HXDLIN(  98)													{
HXLINE(  98)														int location;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->transparent) {
HXLINE(  98)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int this3 = this2;
HXDLIN(  98)															int old;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  98)																old = this3;
            															}
HXDLIN(  98)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)															Float a1;
HXDLIN(  98)															int this4 = ((old >> 24) & 255);
HXDLIN(  98)															if ((this4 == 0)) {
HXLINE(  98)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r1;
HXDLIN(  98)															int this5 = ((old >> 16) & 255);
HXDLIN(  98)															if ((this5 == 0)) {
HXLINE(  98)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g1;
HXDLIN(  98)															int this6 = ((old >> 8) & 255);
HXDLIN(  98)															if ((this6 == 0)) {
HXLINE(  98)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b1;
HXDLIN(  98)															int this7 = (old & 255);
HXDLIN(  98)															if ((this7 == 0)) {
HXLINE(  98)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a2;
HXDLIN(  98)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)															if ((this8 == 0)) {
HXLINE(  98)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r2;
HXDLIN(  98)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)															if ((this9 == 0)) {
HXLINE(  98)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g2;
HXDLIN(  98)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)															if ((this10 == 0)) {
HXLINE(  98)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b2;
HXDLIN(  98)															int this11 = (rhs & 255);
HXDLIN(  98)															if ((this11 == 0)) {
HXLINE(  98)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  98)															{
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = blended;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((location >= 0)) {
HXLINE(  98)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (pixelImage->isLittle) {
HXLINE(  98)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  98)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found3 = true;
            												}
            												else {
HXLINE(  98)													if (found3) {
HXLINE(  98)														goto _hx_goto_182;
            													}
            												}
            											}
            											_hx_goto_182:;
            										}
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_yIter32;
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_xIter32;
HXDLIN(  98)								int v_undoY2;
HXDLIN(  98)								int v_undoX2;
HXDLIN(  98)								Float v_ty2;
HXDLIN(  98)								Float v_tx2;
HXDLIN(  98)								Float v_t02;
HXDLIN(  98)								Float v_sy2;
HXDLIN(  98)								Float v_sx2;
HXDLIN(  98)								Float v_s02;
HXDLIN(  98)								Float v_A2;
HXDLIN(  98)								Float ax3 = ex;
HXDLIN(  98)								Float ay3 = ey;
HXDLIN(  98)								Float bx4 = dx;
HXDLIN(  98)								Float by4 = dy;
HXDLIN(  98)								Float cx4 = ax;
HXDLIN(  98)								Float cy4 = ay;
HXDLIN(  98)								::pixelimage::ImageStruct v_undoImage2 = null();
HXDLIN(  98)								bool adjustWinding3 = (((((ax3 * by4) - (bx4 * ay3)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay3) - (ax3 * cy4))) > 0);
HXDLIN(  98)								if (!(adjustWinding3)) {
HXLINE(  98)									Float bx_ = bx4;
HXDLIN(  98)									Float by_ = by4;
HXLINE(  35)									bx4 = cx4;
HXLINE(  36)									by4 = cy4;
HXLINE(  37)									cx4 = bx_;
HXLINE(  38)									cy4 = by_;
            								}
HXLINE(  98)								Float v_ax2 = ax3;
HXDLIN(  98)								Float v_ay2 = ay3;
HXDLIN(  98)								Float v_bx2 = bx4;
HXDLIN(  98)								Float v_by2 = by4;
HXDLIN(  98)								Float v_cx2 = cx4;
HXDLIN(  98)								Float v_cy2 = cy4;
HXDLIN(  98)								bool v_preCalculated2 = true;
HXDLIN(  98)								{
HXLINE(  98)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  98)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  98)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  98)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  98)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  98)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  98)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  98)									Float a4 = v_ax2;
HXDLIN(  98)									Float b4 = v_bx2;
HXDLIN(  98)									Float c4 = v_cx2;
HXDLIN(  98)									if ((a4 > b4)) {
HXLINE(  98)										if ((a4 > c4)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b4 > c4)) {
HXLINE(  98)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b4);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a4);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b4);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter32 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b4 > c4)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a4 > c4)) {
HXLINE(  98)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a4);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b4);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a4);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter32 = this1;
            										}
            									}
HXDLIN(  98)									Float a5 = v_ay2;
HXDLIN(  98)									Float b5 = v_by2;
HXDLIN(  98)									Float c5 = v_cy2;
HXDLIN(  98)									if ((a5 > b5)) {
HXLINE(  98)										if ((a5 > c5)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b5 > c5)) {
HXLINE(  98)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b5);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a5);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b5);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter32 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b5 > c5)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a5 > c5)) {
HXLINE(  98)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a5);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b5);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a5);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter32 = this1;
            										}
            									}
            								}
HXDLIN(  98)								if (hasUndo3) {
HXLINE(  98)									v_undoImage2 = undoImage3;
HXDLIN(  98)									v_undoX2 = xIter33->start;
HXDLIN(  98)									v_undoY2 = yIter33->start;
            								}
HXDLIN(  98)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  98)								hitQuad = v;
            							}
            							else {
HXLINE(  98)								Float sin = ::Math_obj::sin(theta);
HXDLIN(  98)								Float cos = ::Math_obj::cos(theta);
HXDLIN(  98)								Float radius1 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN(  98)								Float radius2 = (thick / ( (Float)(2) ));
HXDLIN(  98)								Float dx = ((Float)0.1);
HXDLIN(  98)								Float dy = radius1;
HXDLIN(  98)								Float cx = h2;
HXDLIN(  98)								Float cy = radius2;
HXDLIN(  98)								Float bx = h2;
HXDLIN(  98)								Float by = -(radius2);
HXDLIN(  98)								Float ax = ((Float)0.1);
HXDLIN(  98)								Float ay = -(radius1);
HXDLIN(  98)								Float temp = ((Float)0.);
HXLINE( 288)								temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 289)								ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 290)								ax = temp;
HXLINE( 292)								temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 293)								by = (py + ((by * cos) + (bx * sin)));
HXLINE( 294)								bx = temp;
HXLINE( 296)								temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 297)								cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 298)								cx = temp;
HXLINE( 300)								temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 301)								dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 302)								dx = temp;
HXLINE(  98)								Float ex = ((((ax + bx) + cx) + dx) / ( (Float)(4) ));
HXDLIN(  98)								Float ey = ((((ay + by) + cy) + dy) / ( (Float)(4) ));
HXDLIN(  98)								{
HXLINE(  98)									Float bx1 = ax;
HXDLIN(  98)									Float by1 = ay;
HXDLIN(  98)									Float cx1 = bx;
HXDLIN(  98)									Float cy1 = by;
HXDLIN(  98)									bool hasUndo = false;
HXDLIN(  98)									bool adjustWinding = (((((ex * by1) - (bx1 * ey)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ey) - (ex * cy1))) > 0);
HXDLIN(  98)									if (!(adjustWinding)) {
HXLINE(  98)										Float bx_ = bx1;
HXDLIN(  98)										Float by_ = by1;
HXLINE(  26)										bx1 = cx1;
HXLINE(  27)										by1 = cy1;
HXLINE(  28)										cx1 = bx_;
HXLINE(  29)										cy1 = by_;
            									}
HXLINE(  98)									{
HXLINE(  98)										Float s0 = ((ey * cx1) - (ex * cy1));
HXDLIN(  98)										Float sx = (cy1 - ey);
HXDLIN(  98)										Float sy = (ex - cx1);
HXDLIN(  98)										Float t0 = ((ex * by1) - (ey * bx1));
HXDLIN(  98)										Float tx = (ey - by1);
HXDLIN(  98)										Float ty = (bx1 - ex);
HXDLIN(  98)										Float A = ((((-(by1) * cx1) + (ey * (-(bx1) + cx1))) + (ex * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  98)										::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  98)										if ((ex > bx1)) {
HXLINE(  98)											if ((ex > cx1)) {
HXLINE(  98)												int min;
HXDLIN(  98)												if ((bx1 > cx1)) {
HXLINE(  98)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  98)													min = ::Math_obj::floor(bx1);
            												}
HXDLIN(  98)												int ii_min = min;
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												xIter3 = this1;
            											}
            											else {
HXLINE(  98)												int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												xIter3 = this1;
            											}
            										}
            										else {
HXLINE(  98)											if ((bx1 > cx1)) {
HXLINE(  98)												int min;
HXDLIN(  98)												if ((ex > cx1)) {
HXLINE(  98)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE(  98)													min = ::Math_obj::ceil(ex);
            												}
HXDLIN(  98)												int ii_min = min;
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												xIter3 = this1;
            											}
            											else {
HXLINE(  98)												int ii_min = ::Math_obj::floor(ex);
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												xIter3 = this1;
            											}
            										}
HXDLIN(  98)										::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  98)										if ((ey > by1)) {
HXLINE(  98)											if ((ey > cy1)) {
HXLINE(  98)												int min;
HXDLIN(  98)												if ((by1 > cy1)) {
HXLINE(  98)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  98)													min = ::Math_obj::floor(by1);
            												}
HXDLIN(  98)												int ii_min = min;
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												yIter3 = this1;
            											}
            											else {
HXLINE(  98)												int ii_min = ::Math_obj::floor(by1);
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												yIter3 = this1;
            											}
            										}
            										else {
HXLINE(  98)											if ((by1 > cy1)) {
HXLINE(  98)												int min;
HXDLIN(  98)												if ((ey > cy1)) {
HXLINE(  98)													min = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE(  98)													min = ::Math_obj::ceil(ey);
            												}
HXDLIN(  98)												int ii_min = min;
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												yIter3 = this1;
            											}
            											else {
HXLINE(  98)												int ii_min = ::Math_obj::floor(ey);
HXDLIN(  98)												int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  98)												::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)												yIter3 = this1;
            											}
            										}
HXDLIN(  98)										::pixelimage::ImageStruct undoImage = null();
HXDLIN(  98)										if (hasUndo) {
HXLINE(  98)											int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  98)											int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  98)											int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)											::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)											::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)											::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)											undoImage = this3;
HXDLIN(  98)											{
HXLINE(  98)												int rectLeft = xIter3->start;
HXDLIN(  98)												int rectTop = yIter3->start;
HXDLIN(  98)												int rectRight = xIter3->max;
HXDLIN(  98)												bool forceClear = false;
HXDLIN(  98)												{
HXLINE(  98)													int _g = rectTop;
HXDLIN(  98)													int _g1 = yIter3->max;
HXDLIN(  98)													while((_g < _g1)){
HXLINE(  98)														_g = (_g + 1);
HXDLIN(  98)														int dy = (_g - 1);
HXDLIN(  98)														{
HXLINE(  98)															int _g1 = rectLeft;
HXDLIN(  98)															int _g2 = rectRight;
HXDLIN(  98)															while((_g1 < _g2)){
HXLINE(  98)																_g1 = (_g1 + 1);
HXDLIN(  98)																int dx = (_g1 - 1);
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (pixelImage->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            																}
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int col;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	col = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if (pixelImage->useMask) {
HXLINE(  98)																	hitQuad = ::hx::IsNotNull( pixelImage->mask );
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)																	::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)																	int index;
HXDLIN(  98)																	if (this1->useVirtualPos) {
HXLINE(  98)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            																	}
            																	else {
HXLINE(  98)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            																	}
HXDLIN(  98)																	::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)																	int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																	int v;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		v = c;
            																	}
HXDLIN(  98)																	int this3 = v;
HXDLIN(  98)																	int maskPixel = this3;
HXDLIN(  98)																	int this4 = col;
HXDLIN(  98)																	int this5 = this4;
HXDLIN(  98)																	if ((maskPixel == 0)) {
HXLINE(  98)																		int this1 = this5;
HXDLIN(  98)																		col = this1;
            																	}
            																	else {
HXLINE(  98)																		Float m0;
HXDLIN(  98)																		int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																		if ((this1 == 0)) {
HXLINE(  98)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float m1;
HXDLIN(  98)																		int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																		if ((this2 == 0)) {
HXLINE(  98)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float m2;
HXDLIN(  98)																		int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																		if ((this3 == 0)) {
HXLINE(  98)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float m3;
HXDLIN(  98)																		int this4 = (maskPixel & 255);
HXDLIN(  98)																		if ((this4 == 0)) {
HXLINE(  98)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  98)																if ((col != 0)) {
HXLINE(  98)																	int x = (dx - rectLeft);
HXDLIN(  98)																	int y = (dy - rectTop);
HXDLIN(  98)																	int this1 = col;
HXDLIN(  98)																	int c = this1;
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																		hitQuad = undoImage->transparent;
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		int location;
HXDLIN(  98)																		if (undoImage->useVirtualPos) {
HXLINE(  98)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  98)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																		int this3 = this2;
HXDLIN(  98)																		int this4;
HXDLIN(  98)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  98)																			this4 = this3;
            																		}
HXDLIN(  98)																		Float a1;
HXDLIN(  98)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																		if ((this5 == 0)) {
HXLINE(  98)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float r1;
HXDLIN(  98)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																		if ((this6 == 0)) {
HXLINE(  98)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float g1;
HXDLIN(  98)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																		if ((this7 == 0)) {
HXLINE(  98)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float b1;
HXDLIN(  98)																		int this8 = (this4 & 255);
HXDLIN(  98)																		if ((this8 == 0)) {
HXLINE(  98)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float a2;
HXDLIN(  98)																		int this9 = ((col >> 24) & 255);
HXDLIN(  98)																		if ((this9 == 0)) {
HXLINE(  98)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float r2;
HXDLIN(  98)																		int this10 = ((col >> 16) & 255);
HXDLIN(  98)																		if ((this10 == 0)) {
HXLINE(  98)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float g2;
HXDLIN(  98)																		int this11 = ((col >> 8) & 255);
HXDLIN(  98)																		if ((this11 == 0)) {
HXLINE(  98)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float b2;
HXDLIN(  98)																		int this12 = (col & 255);
HXDLIN(  98)																		if ((this12 == 0)) {
HXLINE(  98)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																		{
HXLINE(  98)																			::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  98)																			int value;
HXDLIN(  98)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  98)																				value = blended;
            																			}
HXDLIN(  98)																			bool hitQuad;
HXDLIN(  98)																			if ((location >= 0)) {
HXLINE(  98)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  98)																				hitQuad = false;
            																			}
HXDLIN(  98)																			if (hitQuad) {
HXLINE(  98)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  98)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																		int index;
HXDLIN(  98)																		if (undoImage->useVirtualPos) {
HXLINE(  98)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  98)																		int value;
HXDLIN(  98)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  98)																			value = c;
            																		}
HXDLIN(  98)																		bool hitQuad;
HXDLIN(  98)																		if ((index >= 0)) {
HXLINE(  98)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  98)																			hitQuad = false;
            																		}
HXDLIN(  98)																		if (hitQuad) {
HXLINE(  98)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
            																else {
HXLINE(  98)																	if (forceClear) {
HXLINE(  98)																		::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																		int x = (dx - rectLeft);
HXDLIN(  98)																		int y = (dy - rectTop);
HXDLIN(  98)																		int index;
HXDLIN(  98)																		if (undoImage->useVirtualPos) {
HXLINE(  98)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																		}
HXDLIN(  98)																		bool hitQuad;
HXDLIN(  98)																		if ((index >= 0)) {
HXLINE(  98)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  98)																			hitQuad = false;
            																		}
HXDLIN(  98)																		if (hitQuad) {
HXLINE(  98)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  98)										bool found = false;
HXDLIN(  98)										Float s = ((Float)0.);
HXDLIN(  98)										Float t = ((Float)0.);
HXDLIN(  98)										Float sxx = ((Float)0.);
HXDLIN(  98)										Float txx = ((Float)0.);
HXDLIN(  98)										{
HXLINE(  98)											int _g_min = xIter3->start;
HXDLIN(  98)											int _g_max = xIter3->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int x = (_g_min - 1);
HXLINE(  61)												sxx = (sx * ( (Float)(x) ));
HXLINE(  62)												txx = (tx * ( (Float)(x) ));
HXLINE(  63)												found = false;
HXLINE(  98)												{
HXLINE(  98)													int _g_min1 = yIter3->start;
HXDLIN(  98)													int _g_max = yIter3->max;
HXDLIN(  98)													while((_g_min1 < _g_max)){
HXLINE(  98)														_g_min1 = (_g_min1 + 1);
HXDLIN(  98)														int y = (_g_min1 - 1);
HXLINE(  65)														s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)														t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  98)														bool hitQuad;
HXDLIN(  98)														if (!((s <= 0))) {
HXLINE(  98)															hitQuad = (t <= 0);
            														}
            														else {
HXLINE(  98)															hitQuad = true;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															if (found) {
HXLINE(  98)																goto _hx_goto_186;
            															}
            														}
            														else {
HXLINE(  98)															if (((s + t) < A)) {
HXLINE(  98)																{
HXLINE(  98)																	int this1 = color;
HXDLIN(  98)																	int c = this1;
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																		hitQuad = pixelImage->transparent;
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		int location;
HXDLIN(  98)																		if (pixelImage->useVirtualPos) {
HXLINE(  98)																			location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  98)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)																		::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																		int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																		int this3 = this2;
HXDLIN(  98)																		int this4;
HXDLIN(  98)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																			this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																		}
            																		else {
HXLINE(  98)																			this4 = this3;
            																		}
HXDLIN(  98)																		Float a1;
HXDLIN(  98)																		int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																		if ((this5 == 0)) {
HXLINE(  98)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float r1;
HXDLIN(  98)																		int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																		if ((this6 == 0)) {
HXLINE(  98)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float g1;
HXDLIN(  98)																		int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																		if ((this7 == 0)) {
HXLINE(  98)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float b1;
HXDLIN(  98)																		int this8 = (this4 & 255);
HXDLIN(  98)																		if ((this8 == 0)) {
HXLINE(  98)																			b1 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float a2;
HXDLIN(  98)																		int this9 = ((color >> 24) & 255);
HXDLIN(  98)																		if ((this9 == 0)) {
HXLINE(  98)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float r2;
HXDLIN(  98)																		int this10 = ((color >> 16) & 255);
HXDLIN(  98)																		if ((this10 == 0)) {
HXLINE(  98)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float g2;
HXDLIN(  98)																		int this11 = ((color >> 8) & 255);
HXDLIN(  98)																		if ((this11 == 0)) {
HXLINE(  98)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float b2;
HXDLIN(  98)																		int this12 = (color & 255);
HXDLIN(  98)																		if ((this12 == 0)) {
HXLINE(  98)																			b2 = ((Float)0.);
            																		}
            																		else {
HXLINE(  98)																			b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN(  98)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																		{
HXLINE(  98)																			::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN(  98)																			int value;
HXDLIN(  98)																			if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																				value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE(  98)																				value = blended;
            																			}
HXDLIN(  98)																			bool hitQuad;
HXDLIN(  98)																			if ((location >= 0)) {
HXLINE(  98)																				hitQuad = (location < (this13->byteLength >> 2));
            																			}
            																			else {
HXLINE(  98)																				hitQuad = false;
            																			}
HXDLIN(  98)																			if (hitQuad) {
HXLINE(  98)																				::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																				int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																				_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																				_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																				_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																				_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																			}
            																		}
            																	}
            																	else {
HXLINE(  98)																		::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)																		int index;
HXDLIN(  98)																		if (pixelImage->useVirtualPos) {
HXLINE(  98)																			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            																		}
            																		else {
HXLINE(  98)																			index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            																		}
HXDLIN(  98)																		int value;
HXDLIN(  98)																		if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																			value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																		}
            																		else {
HXLINE(  98)																			value = c;
            																		}
HXDLIN(  98)																		bool hitQuad;
HXDLIN(  98)																		if ((index >= 0)) {
HXLINE(  98)																			hitQuad = (index < (this1->byteLength >> 2));
            																		}
            																		else {
HXLINE(  98)																			hitQuad = false;
            																		}
HXDLIN(  98)																		if (hitQuad) {
HXLINE(  98)																			::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																			int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																			_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																			_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																			_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																			_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																		}
            																	}
            																}
HXLINE(  74)																found = true;
            															}
            															else {
HXLINE(  98)																if (found) {
HXLINE(  98)																	goto _hx_goto_186;
            																}
            															}
            														}
            													}
            													_hx_goto_186:;
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool hasUndo1 = false;
HXDLIN(  98)								int aA = ((color >> 24) & 255);
HXDLIN(  98)								int rA = ((color >> 16) & 255);
HXDLIN(  98)								int gA = ((color >> 8) & 255);
HXDLIN(  98)								int bA = (color & 255);
HXDLIN(  98)								Float bcx = (bx - cx);
HXDLIN(  98)								Float bcy = (by - cy);
HXDLIN(  98)								Float acx = (ex - cx);
HXDLIN(  98)								Float acy = (ey - cy);
HXDLIN(  98)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  98)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  98)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  98)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  98)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  98)								if ((ex > bx)) {
HXLINE(  98)									if ((ex > cx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((bx > cx)) {
HXLINE(  98)											min = ::Math_obj::floor(cx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((bx > cx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ex > cx)) {
HXLINE(  98)											min = ::Math_obj::floor(cx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  98)								if ((ey > by)) {
HXLINE(  98)									if ((ey > cy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((by > cy)) {
HXLINE(  98)											min = ::Math_obj::floor(cy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((by > cy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ey > cy)) {
HXLINE(  98)											min = ::Math_obj::floor(cy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  98)								if (hasUndo1) {
HXLINE(  98)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  98)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  98)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)									undoImage1 = this3;
HXDLIN(  98)									{
HXLINE(  98)										int rectLeft = xIter31->start;
HXDLIN(  98)										int rectTop = yIter31->start;
HXDLIN(  98)										int rectRight = xIter31->max;
HXDLIN(  98)										bool forceClear = false;
HXDLIN(  98)										{
HXLINE(  98)											int _g = rectTop;
HXDLIN(  98)											int _g1 = yIter31->max;
HXDLIN(  98)											while((_g < _g1)){
HXLINE(  98)												_g = (_g + 1);
HXDLIN(  98)												int dy = (_g - 1);
HXDLIN(  98)												{
HXLINE(  98)													int _g1 = rectLeft;
HXDLIN(  98)													int _g2 = rectRight;
HXDLIN(  98)													while((_g1 < _g2)){
HXLINE(  98)														_g1 = (_g1 + 1);
HXDLIN(  98)														int dx = (_g1 - 1);
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int col;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															col = c;
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->useMask) {
HXLINE(  98)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)															int index;
HXDLIN(  98)															if (this1->useVirtualPos) {
HXLINE(  98)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  98)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  98)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int v;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  98)																v = c;
            															}
HXDLIN(  98)															int this3 = v;
HXDLIN(  98)															int maskPixel = this3;
HXDLIN(  98)															int this4 = col;
HXDLIN(  98)															int this5 = this4;
HXDLIN(  98)															if ((maskPixel == 0)) {
HXLINE(  98)																int this1 = this5;
HXDLIN(  98)																col = this1;
            															}
            															else {
HXLINE(  98)																Float m0;
HXDLIN(  98)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																if ((this1 == 0)) {
HXLINE(  98)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m1;
HXDLIN(  98)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																if ((this2 == 0)) {
HXLINE(  98)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m2;
HXDLIN(  98)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																if ((this3 == 0)) {
HXLINE(  98)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m3;
HXDLIN(  98)																int this4 = (maskPixel & 255);
HXDLIN(  98)																if ((this4 == 0)) {
HXLINE(  98)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  98)														if ((col != 0)) {
HXLINE(  98)															int x = (dx - rectLeft);
HXDLIN(  98)															int y = (dy - rectTop);
HXDLIN(  98)															int this1 = col;
HXDLIN(  98)															int c = this1;
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																int location;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int this3 = this2;
HXDLIN(  98)																int this4;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	this4 = this3;
            																}
HXDLIN(  98)																Float a1;
HXDLIN(  98)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																if ((this5 == 0)) {
HXLINE(  98)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r1;
HXDLIN(  98)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																if ((this6 == 0)) {
HXLINE(  98)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g1;
HXDLIN(  98)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																if ((this7 == 0)) {
HXLINE(  98)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b1;
HXDLIN(  98)																int this8 = (this4 & 255);
HXDLIN(  98)																if ((this8 == 0)) {
HXLINE(  98)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a2;
HXDLIN(  98)																int this9 = ((col >> 24) & 255);
HXDLIN(  98)																if ((this9 == 0)) {
HXLINE(  98)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r2;
HXDLIN(  98)																int this10 = ((col >> 16) & 255);
HXDLIN(  98)																if ((this10 == 0)) {
HXLINE(  98)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g2;
HXDLIN(  98)																int this11 = ((col >> 8) & 255);
HXDLIN(  98)																if ((this11 == 0)) {
HXLINE(  98)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b2;
HXDLIN(  98)																int this12 = (col & 255);
HXDLIN(  98)																if ((this12 == 0)) {
HXLINE(  98)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																{
HXLINE(  98)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  98)																	int value;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		value = blended;
            																	}
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((location >= 0)) {
HXLINE(  98)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															if (forceClear) {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																int x = (dx - rectLeft);
HXDLIN(  98)																int y = (dy - rectTop);
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool found1 = false;
HXDLIN(  98)								{
HXLINE(  98)									int _g_min1 = xIter31->start;
HXDLIN(  98)									int _g_max1 = xIter31->max;
HXDLIN(  98)									while((_g_min1 < _g_max1)){
HXLINE(  98)										_g_min1 = (_g_min1 + 1);
HXDLIN(  98)										int px = (_g_min1 - 1);
HXDLIN(  98)										Float pcx = (( (Float)(px) ) - cx);
HXLINE( 620)										found1 = false;
HXLINE(  98)										{
HXLINE(  98)											int _g_min = yIter31->start;
HXDLIN(  98)											int _g_max = yIter31->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int py = (_g_min - 1);
HXDLIN(  98)												Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  98)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  98)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  98)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  98)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  98)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)												bool hitQuad;
HXDLIN(  98)												bool hitQuad1;
HXDLIN(  98)												if ((ratioA >= 0)) {
HXLINE(  98)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad1 = false;
            												}
HXDLIN(  98)												if (hitQuad1) {
HXLINE(  98)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad = false;
            												}
HXDLIN(  98)												if (hitQuad) {
HXLINE(  98)													int i = ::Std_obj::_hx_int((( (Float)(aA) ) * (soft * ratioB)));
HXDLIN(  98)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  98)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  98)													int this1 = i;
HXDLIN(  98)													int a = this1;
HXDLIN(  98)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  98)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  98)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  98)													int this2 = i1;
HXDLIN(  98)													int r = this2;
HXDLIN(  98)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  98)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  98)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  98)													int this3 = i2;
HXDLIN(  98)													int g = this3;
HXDLIN(  98)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  98)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  98)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  98)													int this4 = i3;
HXDLIN(  98)													int b = this4;
HXDLIN(  98)													{
HXLINE(  98)														int location;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->transparent) {
HXLINE(  98)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int this3 = this2;
HXDLIN(  98)															int old;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  98)																old = this3;
            															}
HXDLIN(  98)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)															Float a1;
HXDLIN(  98)															int this4 = ((old >> 24) & 255);
HXDLIN(  98)															if ((this4 == 0)) {
HXLINE(  98)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r1;
HXDLIN(  98)															int this5 = ((old >> 16) & 255);
HXDLIN(  98)															if ((this5 == 0)) {
HXLINE(  98)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g1;
HXDLIN(  98)															int this6 = ((old >> 8) & 255);
HXDLIN(  98)															if ((this6 == 0)) {
HXLINE(  98)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b1;
HXDLIN(  98)															int this7 = (old & 255);
HXDLIN(  98)															if ((this7 == 0)) {
HXLINE(  98)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a2;
HXDLIN(  98)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)															if ((this8 == 0)) {
HXLINE(  98)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r2;
HXDLIN(  98)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)															if ((this9 == 0)) {
HXLINE(  98)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g2;
HXDLIN(  98)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)															if ((this10 == 0)) {
HXLINE(  98)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b2;
HXDLIN(  98)															int this11 = (rhs & 255);
HXDLIN(  98)															if ((this11 == 0)) {
HXLINE(  98)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  98)															{
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = blended;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((location >= 0)) {
HXLINE(  98)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (pixelImage->isLittle) {
HXLINE(  98)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  98)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found1 = true;
            												}
            												else {
HXLINE(  98)													if (found1) {
HXLINE(  98)														goto _hx_goto_190;
            													}
            												}
            											}
            											_hx_goto_190:;
            										}
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  98)								int v_undoY;
HXDLIN(  98)								int v_undoX;
HXDLIN(  98)								Float v_ty;
HXDLIN(  98)								Float v_tx;
HXDLIN(  98)								Float v_t0;
HXDLIN(  98)								Float v_sy;
HXDLIN(  98)								Float v_sx;
HXDLIN(  98)								Float v_s0;
HXDLIN(  98)								Float v_A;
HXDLIN(  98)								Float ax1 = ex;
HXDLIN(  98)								Float ay1 = ey;
HXDLIN(  98)								Float bx2 = bx;
HXDLIN(  98)								Float by2 = by;
HXDLIN(  98)								Float cx2 = cx;
HXDLIN(  98)								Float cy2 = cy;
HXDLIN(  98)								::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  98)								bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  98)								if (!(adjustWinding1)) {
HXLINE(  98)									Float bx_ = bx2;
HXDLIN(  98)									Float by_ = by2;
HXLINE(  35)									bx2 = cx2;
HXLINE(  36)									by2 = cy2;
HXLINE(  37)									cx2 = bx_;
HXLINE(  38)									cy2 = by_;
            								}
HXLINE(  98)								Float v_ax = ax1;
HXDLIN(  98)								Float v_ay = ay1;
HXDLIN(  98)								Float v_bx = bx2;
HXDLIN(  98)								Float v_by = by2;
HXDLIN(  98)								Float v_cx = cx2;
HXDLIN(  98)								Float v_cy = cy2;
HXDLIN(  98)								bool v_preCalculated = true;
HXDLIN(  98)								{
HXLINE(  98)									v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  98)									v_sx = (v_cy - v_ay);
HXDLIN(  98)									v_sy = (v_ax - v_cx);
HXDLIN(  98)									v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  98)									v_tx = (v_ay - v_by);
HXDLIN(  98)									v_ty = (v_bx - v_ax);
HXDLIN(  98)									v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  98)									Float a = v_ax;
HXDLIN(  98)									Float b = v_bx;
HXDLIN(  98)									Float c = v_cx;
HXDLIN(  98)									if ((a > b)) {
HXLINE(  98)										if ((a > c)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b > c)) {
HXLINE(  98)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter3 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b > c)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a > c)) {
HXLINE(  98)												min = ::Math_obj::floor(c);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter3 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter3 = this1;
            										}
            									}
HXDLIN(  98)									Float a1 = v_ay;
HXDLIN(  98)									Float b1 = v_by;
HXDLIN(  98)									Float c1 = v_cy;
HXDLIN(  98)									if ((a1 > b1)) {
HXLINE(  98)										if ((a1 > c1)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b1 > c1)) {
HXLINE(  98)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b1);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b1);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter3 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b1 > c1)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a1 > c1)) {
HXLINE(  98)												min = ::Math_obj::floor(c1);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a1);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter3 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a1);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter3 = this1;
            										}
            									}
            								}
HXDLIN(  98)								if (hasUndo1) {
HXLINE(  98)									v_undoImage = undoImage1;
HXDLIN(  98)									v_undoX = xIter31->start;
HXDLIN(  98)									v_undoY = yIter31->start;
            								}
HXDLIN(  98)								bool hasUndo2 = false;
HXDLIN(  98)								int aA1 = ((color >> 24) & 255);
HXDLIN(  98)								int rA1 = ((color >> 16) & 255);
HXDLIN(  98)								int gA1 = ((color >> 8) & 255);
HXDLIN(  98)								int bA1 = (color & 255);
HXDLIN(  98)								Float bcx1 = (cx - dx);
HXDLIN(  98)								Float bcy1 = (cy - dy);
HXDLIN(  98)								Float acx1 = (ex - dx);
HXDLIN(  98)								Float acy1 = (ey - dy);
HXDLIN(  98)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  98)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  98)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  98)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  98)								::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  98)								if ((ex > cx)) {
HXLINE(  98)									if ((ex > dx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((cx > dx)) {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter32 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter32 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((cx > dx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ex > dx)) {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter32 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter32 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  98)								if ((ey > cy)) {
HXLINE(  98)									if ((ey > dy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((cy > dy)) {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter32 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter32 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((cy > dy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ey > dy)) {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter32 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter32 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  98)								if (hasUndo2) {
HXLINE(  98)									int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  98)									int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  98)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)									undoImage2 = this3;
HXDLIN(  98)									{
HXLINE(  98)										int rectLeft = xIter32->start;
HXDLIN(  98)										int rectTop = yIter32->start;
HXDLIN(  98)										int rectRight = xIter32->max;
HXDLIN(  98)										bool forceClear = false;
HXDLIN(  98)										{
HXLINE(  98)											int _g = rectTop;
HXDLIN(  98)											int _g1 = yIter32->max;
HXDLIN(  98)											while((_g < _g1)){
HXLINE(  98)												_g = (_g + 1);
HXDLIN(  98)												int dy = (_g - 1);
HXDLIN(  98)												{
HXLINE(  98)													int _g1 = rectLeft;
HXDLIN(  98)													int _g2 = rectRight;
HXDLIN(  98)													while((_g1 < _g2)){
HXLINE(  98)														_g1 = (_g1 + 1);
HXDLIN(  98)														int dx = (_g1 - 1);
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int col;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															col = c;
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->useMask) {
HXLINE(  98)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)															int index;
HXDLIN(  98)															if (this1->useVirtualPos) {
HXLINE(  98)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  98)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  98)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int v;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  98)																v = c;
            															}
HXDLIN(  98)															int this3 = v;
HXDLIN(  98)															int maskPixel = this3;
HXDLIN(  98)															int this4 = col;
HXDLIN(  98)															int this5 = this4;
HXDLIN(  98)															if ((maskPixel == 0)) {
HXLINE(  98)																int this1 = this5;
HXDLIN(  98)																col = this1;
            															}
            															else {
HXLINE(  98)																Float m0;
HXDLIN(  98)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																if ((this1 == 0)) {
HXLINE(  98)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m1;
HXDLIN(  98)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																if ((this2 == 0)) {
HXLINE(  98)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m2;
HXDLIN(  98)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																if ((this3 == 0)) {
HXLINE(  98)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m3;
HXDLIN(  98)																int this4 = (maskPixel & 255);
HXDLIN(  98)																if ((this4 == 0)) {
HXLINE(  98)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  98)														if ((col != 0)) {
HXLINE(  98)															int x = (dx - rectLeft);
HXDLIN(  98)															int y = (dy - rectTop);
HXDLIN(  98)															int this1 = col;
HXDLIN(  98)															int c = this1;
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																hitQuad = undoImage2->transparent;
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																int location;
HXDLIN(  98)																if (undoImage2->useVirtualPos) {
HXLINE(  98)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  98)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int this3 = this2;
HXDLIN(  98)																int this4;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	this4 = this3;
            																}
HXDLIN(  98)																Float a1;
HXDLIN(  98)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																if ((this5 == 0)) {
HXLINE(  98)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r1;
HXDLIN(  98)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																if ((this6 == 0)) {
HXLINE(  98)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g1;
HXDLIN(  98)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																if ((this7 == 0)) {
HXLINE(  98)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b1;
HXDLIN(  98)																int this8 = (this4 & 255);
HXDLIN(  98)																if ((this8 == 0)) {
HXLINE(  98)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a2;
HXDLIN(  98)																int this9 = ((col >> 24) & 255);
HXDLIN(  98)																if ((this9 == 0)) {
HXLINE(  98)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r2;
HXDLIN(  98)																int this10 = ((col >> 16) & 255);
HXDLIN(  98)																if ((this10 == 0)) {
HXLINE(  98)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g2;
HXDLIN(  98)																int this11 = ((col >> 8) & 255);
HXDLIN(  98)																if ((this11 == 0)) {
HXLINE(  98)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b2;
HXDLIN(  98)																int this12 = (col & 255);
HXDLIN(  98)																if ((this12 == 0)) {
HXLINE(  98)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																{
HXLINE(  98)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  98)																	int value;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		value = blended;
            																	}
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((location >= 0)) {
HXLINE(  98)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage2->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															if (forceClear) {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  98)																int x = (dx - rectLeft);
HXDLIN(  98)																int y = (dy - rectTop);
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage2->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool found2 = false;
HXDLIN(  98)								{
HXLINE(  98)									int _g_min2 = xIter32->start;
HXDLIN(  98)									int _g_max2 = xIter32->max;
HXDLIN(  98)									while((_g_min2 < _g_max2)){
HXLINE(  98)										_g_min2 = (_g_min2 + 1);
HXDLIN(  98)										int px = (_g_min2 - 1);
HXDLIN(  98)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 620)										found2 = false;
HXLINE(  98)										{
HXLINE(  98)											int _g_min = yIter32->start;
HXDLIN(  98)											int _g_max = yIter32->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int py = (_g_min - 1);
HXDLIN(  98)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  98)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  98)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  98)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  98)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  98)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)												bool hitQuad;
HXDLIN(  98)												bool hitQuad1;
HXDLIN(  98)												if ((ratioA >= 0)) {
HXLINE(  98)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad1 = false;
            												}
HXDLIN(  98)												if (hitQuad1) {
HXLINE(  98)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad = false;
            												}
HXDLIN(  98)												if (hitQuad) {
HXLINE(  98)													int i = ::Std_obj::_hx_int((( (Float)(aA1) ) * (soft * ratioB)));
HXDLIN(  98)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  98)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  98)													int this1 = i;
HXDLIN(  98)													int a = this1;
HXDLIN(  98)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  98)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  98)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  98)													int this2 = i1;
HXDLIN(  98)													int r = this2;
HXDLIN(  98)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  98)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  98)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  98)													int this3 = i2;
HXDLIN(  98)													int g = this3;
HXDLIN(  98)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  98)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  98)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  98)													int this4 = i3;
HXDLIN(  98)													int b = this4;
HXDLIN(  98)													{
HXLINE(  98)														int location;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->transparent) {
HXLINE(  98)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int this3 = this2;
HXDLIN(  98)															int old;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  98)																old = this3;
            															}
HXDLIN(  98)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)															Float a1;
HXDLIN(  98)															int this4 = ((old >> 24) & 255);
HXDLIN(  98)															if ((this4 == 0)) {
HXLINE(  98)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r1;
HXDLIN(  98)															int this5 = ((old >> 16) & 255);
HXDLIN(  98)															if ((this5 == 0)) {
HXLINE(  98)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g1;
HXDLIN(  98)															int this6 = ((old >> 8) & 255);
HXDLIN(  98)															if ((this6 == 0)) {
HXLINE(  98)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b1;
HXDLIN(  98)															int this7 = (old & 255);
HXDLIN(  98)															if ((this7 == 0)) {
HXLINE(  98)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a2;
HXDLIN(  98)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)															if ((this8 == 0)) {
HXLINE(  98)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r2;
HXDLIN(  98)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)															if ((this9 == 0)) {
HXLINE(  98)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g2;
HXDLIN(  98)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)															if ((this10 == 0)) {
HXLINE(  98)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b2;
HXDLIN(  98)															int this11 = (rhs & 255);
HXDLIN(  98)															if ((this11 == 0)) {
HXLINE(  98)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  98)															{
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = blended;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((location >= 0)) {
HXLINE(  98)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (pixelImage->isLittle) {
HXLINE(  98)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  98)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found2 = true;
            												}
            												else {
HXLINE(  98)													if (found2) {
HXLINE(  98)														goto _hx_goto_194;
            													}
            												}
            											}
            											_hx_goto_194:;
            										}
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  98)								int v_undoY1;
HXDLIN(  98)								int v_undoX1;
HXDLIN(  98)								Float v_ty1;
HXDLIN(  98)								Float v_tx1;
HXDLIN(  98)								Float v_t01;
HXDLIN(  98)								Float v_sy1;
HXDLIN(  98)								Float v_sx1;
HXDLIN(  98)								Float v_s01;
HXDLIN(  98)								Float v_A1;
HXDLIN(  98)								Float ax2 = ex;
HXDLIN(  98)								Float ay2 = ey;
HXDLIN(  98)								Float bx3 = cx;
HXDLIN(  98)								Float by3 = cy;
HXDLIN(  98)								Float cx3 = dx;
HXDLIN(  98)								Float cy3 = dy;
HXDLIN(  98)								::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  98)								bool adjustWinding2 = (((((ax2 * by3) - (bx3 * ay2)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * ay2) - (ax2 * cy3))) > 0);
HXDLIN(  98)								if (!(adjustWinding2)) {
HXLINE(  98)									Float bx_ = bx3;
HXDLIN(  98)									Float by_ = by3;
HXLINE(  35)									bx3 = cx3;
HXLINE(  36)									by3 = cy3;
HXLINE(  37)									cx3 = bx_;
HXLINE(  38)									cy3 = by_;
            								}
HXLINE(  98)								Float v_ax1 = ax2;
HXDLIN(  98)								Float v_ay1 = ay2;
HXDLIN(  98)								Float v_bx1 = bx3;
HXDLIN(  98)								Float v_by1 = by3;
HXDLIN(  98)								Float v_cx1 = cx3;
HXDLIN(  98)								Float v_cy1 = cy3;
HXDLIN(  98)								bool v_preCalculated1 = true;
HXDLIN(  98)								{
HXLINE(  98)									v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  98)									v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  98)									v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  98)									v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  98)									v_tx1 = (v_ay1 - v_by1);
HXDLIN(  98)									v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  98)									v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  98)									Float a2 = v_ax1;
HXDLIN(  98)									Float b2 = v_bx1;
HXDLIN(  98)									Float c2 = v_cx1;
HXDLIN(  98)									if ((a2 > b2)) {
HXLINE(  98)										if ((a2 > c2)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b2 > c2)) {
HXLINE(  98)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b2);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b2);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter31 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b2 > c2)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a2 > c2)) {
HXLINE(  98)												min = ::Math_obj::floor(c2);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a2);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter31 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a2);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter31 = this1;
            										}
            									}
HXDLIN(  98)									Float a3 = v_ay1;
HXDLIN(  98)									Float b3 = v_by1;
HXDLIN(  98)									Float c3 = v_cy1;
HXDLIN(  98)									if ((a3 > b3)) {
HXLINE(  98)										if ((a3 > c3)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b3 > c3)) {
HXLINE(  98)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b3);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b3);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter31 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b3 > c3)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a3 > c3)) {
HXLINE(  98)												min = ::Math_obj::floor(c3);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a3);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter31 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a3);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter31 = this1;
            										}
            									}
            								}
HXDLIN(  98)								if (hasUndo2) {
HXLINE(  98)									v_undoImage1 = undoImage2;
HXDLIN(  98)									v_undoX1 = xIter32->start;
HXDLIN(  98)									v_undoY1 = yIter32->start;
            								}
HXDLIN(  98)								bool hasUndo3 = false;
HXDLIN(  98)								int aA2 = ((color >> 24) & 255);
HXDLIN(  98)								int rA2 = ((color >> 16) & 255);
HXDLIN(  98)								int gA2 = ((color >> 8) & 255);
HXDLIN(  98)								int bA2 = (color & 255);
HXDLIN(  98)								Float bcx2 = (dx - ax);
HXDLIN(  98)								Float bcy2 = (dy - ay);
HXDLIN(  98)								Float acx2 = (ex - ax);
HXDLIN(  98)								Float acy2 = (ey - ay);
HXDLIN(  98)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  98)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  98)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  98)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  98)								::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  98)								if ((ex > dx)) {
HXLINE(  98)									if ((ex > ax)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((dx > ax)) {
HXLINE(  98)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ex);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter33 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(dx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter33 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((dx > ax)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ex > ax)) {
HXLINE(  98)											min = ::Math_obj::floor(ax);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ex);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter33 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ex);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter33 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  98)								if ((ey > dy)) {
HXLINE(  98)									if ((ey > ay)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((dy > ay)) {
HXLINE(  98)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ey);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter33 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(dy);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter33 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((dy > ay)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ey > ay)) {
HXLINE(  98)											min = ::Math_obj::floor(ay);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ey);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter33 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ey);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter33 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  98)								if (hasUndo3) {
HXLINE(  98)									int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  98)									int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  98)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)									undoImage3 = this3;
HXDLIN(  98)									{
HXLINE(  98)										int rectLeft = xIter33->start;
HXDLIN(  98)										int rectTop = yIter33->start;
HXDLIN(  98)										int rectRight = xIter33->max;
HXDLIN(  98)										bool forceClear = false;
HXDLIN(  98)										{
HXLINE(  98)											int _g = rectTop;
HXDLIN(  98)											int _g1 = yIter33->max;
HXDLIN(  98)											while((_g < _g1)){
HXLINE(  98)												_g = (_g + 1);
HXDLIN(  98)												int dy = (_g - 1);
HXDLIN(  98)												{
HXLINE(  98)													int _g1 = rectLeft;
HXDLIN(  98)													int _g2 = rectRight;
HXDLIN(  98)													while((_g1 < _g2)){
HXLINE(  98)														_g1 = (_g1 + 1);
HXDLIN(  98)														int dx = (_g1 - 1);
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int col;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															col = c;
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->useMask) {
HXLINE(  98)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)															int index;
HXDLIN(  98)															if (this1->useVirtualPos) {
HXLINE(  98)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  98)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  98)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int v;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  98)																v = c;
            															}
HXDLIN(  98)															int this3 = v;
HXDLIN(  98)															int maskPixel = this3;
HXDLIN(  98)															int this4 = col;
HXDLIN(  98)															int this5 = this4;
HXDLIN(  98)															if ((maskPixel == 0)) {
HXLINE(  98)																int this1 = this5;
HXDLIN(  98)																col = this1;
            															}
            															else {
HXLINE(  98)																Float m0;
HXDLIN(  98)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																if ((this1 == 0)) {
HXLINE(  98)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m1;
HXDLIN(  98)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																if ((this2 == 0)) {
HXLINE(  98)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m2;
HXDLIN(  98)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																if ((this3 == 0)) {
HXLINE(  98)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m3;
HXDLIN(  98)																int this4 = (maskPixel & 255);
HXDLIN(  98)																if ((this4 == 0)) {
HXLINE(  98)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  98)														if ((col != 0)) {
HXLINE(  98)															int x = (dx - rectLeft);
HXDLIN(  98)															int y = (dy - rectTop);
HXDLIN(  98)															int this1 = col;
HXDLIN(  98)															int c = this1;
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																hitQuad = undoImage3->transparent;
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																int location;
HXDLIN(  98)																if (undoImage3->useVirtualPos) {
HXLINE(  98)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  98)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int this3 = this2;
HXDLIN(  98)																int this4;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	this4 = this3;
            																}
HXDLIN(  98)																Float a1;
HXDLIN(  98)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																if ((this5 == 0)) {
HXLINE(  98)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r1;
HXDLIN(  98)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																if ((this6 == 0)) {
HXLINE(  98)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g1;
HXDLIN(  98)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																if ((this7 == 0)) {
HXLINE(  98)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b1;
HXDLIN(  98)																int this8 = (this4 & 255);
HXDLIN(  98)																if ((this8 == 0)) {
HXLINE(  98)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a2;
HXDLIN(  98)																int this9 = ((col >> 24) & 255);
HXDLIN(  98)																if ((this9 == 0)) {
HXLINE(  98)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r2;
HXDLIN(  98)																int this10 = ((col >> 16) & 255);
HXDLIN(  98)																if ((this10 == 0)) {
HXLINE(  98)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g2;
HXDLIN(  98)																int this11 = ((col >> 8) & 255);
HXDLIN(  98)																if ((this11 == 0)) {
HXLINE(  98)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b2;
HXDLIN(  98)																int this12 = (col & 255);
HXDLIN(  98)																if ((this12 == 0)) {
HXLINE(  98)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																{
HXLINE(  98)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  98)																	int value;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		value = blended;
            																	}
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((location >= 0)) {
HXLINE(  98)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage3->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															if (forceClear) {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  98)																int x = (dx - rectLeft);
HXDLIN(  98)																int y = (dy - rectTop);
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage3->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool found3 = false;
HXDLIN(  98)								{
HXLINE(  98)									int _g_min3 = xIter33->start;
HXDLIN(  98)									int _g_max3 = xIter33->max;
HXDLIN(  98)									while((_g_min3 < _g_max3)){
HXLINE(  98)										_g_min3 = (_g_min3 + 1);
HXDLIN(  98)										int px = (_g_min3 - 1);
HXDLIN(  98)										Float pcx = (( (Float)(px) ) - ax);
HXLINE( 620)										found3 = false;
HXLINE(  98)										{
HXLINE(  98)											int _g_min = yIter33->start;
HXDLIN(  98)											int _g_max = yIter33->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int py = (_g_min - 1);
HXDLIN(  98)												Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  98)												Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  98)												Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  98)												Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  98)												Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  98)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)												bool hitQuad;
HXDLIN(  98)												bool hitQuad1;
HXDLIN(  98)												if ((ratioA >= 0)) {
HXLINE(  98)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad1 = false;
            												}
HXDLIN(  98)												if (hitQuad1) {
HXLINE(  98)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad = false;
            												}
HXDLIN(  98)												if (hitQuad) {
HXLINE(  98)													int i = ::Std_obj::_hx_int((( (Float)(aA2) ) * (soft * ratioB)));
HXDLIN(  98)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  98)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  98)													int this1 = i;
HXDLIN(  98)													int a = this1;
HXDLIN(  98)													int i1 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  98)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  98)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  98)													int this2 = i1;
HXDLIN(  98)													int r = this2;
HXDLIN(  98)													int i2 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  98)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  98)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  98)													int this3 = i2;
HXDLIN(  98)													int g = this3;
HXDLIN(  98)													int i3 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  98)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  98)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  98)													int this4 = i3;
HXDLIN(  98)													int b = this4;
HXDLIN(  98)													{
HXLINE(  98)														int location;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->transparent) {
HXLINE(  98)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int this3 = this2;
HXDLIN(  98)															int old;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  98)																old = this3;
            															}
HXDLIN(  98)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)															Float a1;
HXDLIN(  98)															int this4 = ((old >> 24) & 255);
HXDLIN(  98)															if ((this4 == 0)) {
HXLINE(  98)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r1;
HXDLIN(  98)															int this5 = ((old >> 16) & 255);
HXDLIN(  98)															if ((this5 == 0)) {
HXLINE(  98)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g1;
HXDLIN(  98)															int this6 = ((old >> 8) & 255);
HXDLIN(  98)															if ((this6 == 0)) {
HXLINE(  98)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b1;
HXDLIN(  98)															int this7 = (old & 255);
HXDLIN(  98)															if ((this7 == 0)) {
HXLINE(  98)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a2;
HXDLIN(  98)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)															if ((this8 == 0)) {
HXLINE(  98)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r2;
HXDLIN(  98)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)															if ((this9 == 0)) {
HXLINE(  98)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g2;
HXDLIN(  98)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)															if ((this10 == 0)) {
HXLINE(  98)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b2;
HXDLIN(  98)															int this11 = (rhs & 255);
HXDLIN(  98)															if ((this11 == 0)) {
HXLINE(  98)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  98)															{
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = blended;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((location >= 0)) {
HXLINE(  98)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (pixelImage->isLittle) {
HXLINE(  98)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  98)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 634)													found3 = true;
            												}
            												else {
HXLINE(  98)													if (found3) {
HXLINE(  98)														goto _hx_goto_198;
            													}
            												}
            											}
            											_hx_goto_198:;
            										}
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_yIter32;
HXDLIN(  98)								::pixelimage::iter::IntIterStart v_xIter32;
HXDLIN(  98)								int v_undoY2;
HXDLIN(  98)								int v_undoX2;
HXDLIN(  98)								Float v_ty2;
HXDLIN(  98)								Float v_tx2;
HXDLIN(  98)								Float v_t02;
HXDLIN(  98)								Float v_sy2;
HXDLIN(  98)								Float v_sx2;
HXDLIN(  98)								Float v_s02;
HXDLIN(  98)								Float v_A2;
HXDLIN(  98)								Float ax3 = ex;
HXDLIN(  98)								Float ay3 = ey;
HXDLIN(  98)								Float bx4 = dx;
HXDLIN(  98)								Float by4 = dy;
HXDLIN(  98)								Float cx4 = ax;
HXDLIN(  98)								Float cy4 = ay;
HXDLIN(  98)								::pixelimage::ImageStruct v_undoImage2 = null();
HXDLIN(  98)								bool adjustWinding3 = (((((ax3 * by4) - (bx4 * ay3)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay3) - (ax3 * cy4))) > 0);
HXDLIN(  98)								if (!(adjustWinding3)) {
HXLINE(  98)									Float bx_ = bx4;
HXDLIN(  98)									Float by_ = by4;
HXLINE(  35)									bx4 = cx4;
HXLINE(  36)									by4 = cy4;
HXLINE(  37)									cx4 = bx_;
HXLINE(  38)									cy4 = by_;
            								}
HXLINE(  98)								Float v_ax2 = ax3;
HXDLIN(  98)								Float v_ay2 = ay3;
HXDLIN(  98)								Float v_bx2 = bx4;
HXDLIN(  98)								Float v_by2 = by4;
HXDLIN(  98)								Float v_cx2 = cx4;
HXDLIN(  98)								Float v_cy2 = cy4;
HXDLIN(  98)								bool v_preCalculated2 = true;
HXDLIN(  98)								{
HXLINE(  98)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  98)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  98)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  98)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  98)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  98)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  98)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  98)									Float a4 = v_ax2;
HXDLIN(  98)									Float b4 = v_bx2;
HXDLIN(  98)									Float c4 = v_cx2;
HXDLIN(  98)									if ((a4 > b4)) {
HXLINE(  98)										if ((a4 > c4)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b4 > c4)) {
HXLINE(  98)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b4);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a4);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b4);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter32 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b4 > c4)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a4 > c4)) {
HXLINE(  98)												min = ::Math_obj::floor(c4);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a4);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b4);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter32 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a4);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c4);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_xIter32 = this1;
            										}
            									}
HXDLIN(  98)									Float a5 = v_ay2;
HXDLIN(  98)									Float b5 = v_by2;
HXDLIN(  98)									Float c5 = v_cy2;
HXDLIN(  98)									if ((a5 > b5)) {
HXLINE(  98)										if ((a5 > c5)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((b5 > c5)) {
HXLINE(  98)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::floor(b5);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(a5);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(b5);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter32 = this1;
            										}
            									}
            									else {
HXLINE(  98)										if ((b5 > c5)) {
HXLINE(  98)											int min;
HXDLIN(  98)											if ((a5 > c5)) {
HXLINE(  98)												min = ::Math_obj::floor(c5);
            											}
            											else {
HXLINE(  98)												min = ::Math_obj::ceil(a5);
            											}
HXDLIN(  98)											int ii_min = min;
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(b5);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter32 = this1;
            										}
            										else {
HXLINE(  98)											int ii_min = ::Math_obj::floor(a5);
HXDLIN(  98)											int ii_max = ::Math_obj::ceil(c5);
HXDLIN(  98)											::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)											v_yIter32 = this1;
            										}
            									}
            								}
HXDLIN(  98)								if (hasUndo3) {
HXLINE(  98)									v_undoImage2 = undoImage3;
HXDLIN(  98)									v_undoX2 = xIter33->start;
HXDLIN(  98)									v_undoY2 = yIter33->start;
            								}
HXDLIN(  98)								::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  98)								hitQuad = v;
            							}
            						}
            						else {
HXLINE(  98)							Float sin = ::Math_obj::sin(theta);
HXDLIN(  98)							Float cos = ::Math_obj::cos(theta);
HXDLIN(  98)							Float radius = (thick / ( (Float)(2) ));
HXDLIN(  98)							Float dx = ((Float)0.1);
HXDLIN(  98)							Float dy = radius;
HXDLIN(  98)							Float cx = h2;
HXDLIN(  98)							Float cy = radius;
HXDLIN(  98)							Float bx = h2;
HXDLIN(  98)							Float by = -(radius);
HXDLIN(  98)							Float ax = ((Float)0.1);
HXDLIN(  98)							Float ay = -(radius);
HXDLIN(  98)							Float temp = ((Float)0.);
HXLINE(  82)							temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  83)							ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  84)							ax = temp;
HXLINE(  86)							temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  87)							by = (py + ((by * cos) + (bx * sin)));
HXLINE(  88)							bx = temp;
HXLINE(  90)							temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  91)							cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  92)							cx = temp;
HXLINE(  94)							temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  95)							dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  96)							dx = temp;
HXLINE(  98)							{
HXLINE(  98)								bool hasUndo = true;
HXDLIN(  98)								int aA = ((color >> 24) & 255);
HXDLIN(  98)								int rA = ((color >> 16) & 255);
HXDLIN(  98)								int gA = ((color >> 8) & 255);
HXDLIN(  98)								int bA = (color & 255);
HXDLIN(  98)								Float bcx = (bx - dx);
HXDLIN(  98)								Float bcy = (by - dy);
HXDLIN(  98)								Float acx = (ax - dx);
HXDLIN(  98)								Float acy = (ay - dy);
HXDLIN(  98)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  98)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  98)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  98)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  98)								::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  98)								if ((ax > bx)) {
HXLINE(  98)									if ((ax > dx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((bx > dx)) {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter3 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter3 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((bx > dx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ax > dx)) {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ax);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter3 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ax);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter3 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  98)								if ((ay > by)) {
HXLINE(  98)									if ((ay > dy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((by > dy)) {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(by);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter3 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter3 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((by > dy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((ay > dy)) {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(ay);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter3 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(ay);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter3 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::ImageStruct undoImage = null();
HXDLIN(  98)								if (hasUndo) {
HXLINE(  98)									int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  98)									int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  98)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)									undoImage = this3;
HXDLIN(  98)									{
HXLINE(  98)										int rectLeft = xIter3->start;
HXDLIN(  98)										int rectTop = yIter3->start;
HXDLIN(  98)										int rectRight = xIter3->max;
HXDLIN(  98)										bool forceClear = false;
HXDLIN(  98)										{
HXLINE(  98)											int _g = rectTop;
HXDLIN(  98)											int _g1 = yIter3->max;
HXDLIN(  98)											while((_g < _g1)){
HXLINE(  98)												_g = (_g + 1);
HXDLIN(  98)												int dy = (_g - 1);
HXDLIN(  98)												{
HXLINE(  98)													int _g1 = rectLeft;
HXDLIN(  98)													int _g2 = rectRight;
HXDLIN(  98)													while((_g1 < _g2)){
HXLINE(  98)														_g1 = (_g1 + 1);
HXDLIN(  98)														int dx = (_g1 - 1);
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int col;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															col = c;
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->useMask) {
HXLINE(  98)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)															int index;
HXDLIN(  98)															if (this1->useVirtualPos) {
HXLINE(  98)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  98)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  98)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int v;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  98)																v = c;
            															}
HXDLIN(  98)															int this3 = v;
HXDLIN(  98)															int maskPixel = this3;
HXDLIN(  98)															int this4 = col;
HXDLIN(  98)															int this5 = this4;
HXDLIN(  98)															if ((maskPixel == 0)) {
HXLINE(  98)																int this1 = this5;
HXDLIN(  98)																col = this1;
            															}
            															else {
HXLINE(  98)																Float m0;
HXDLIN(  98)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																if ((this1 == 0)) {
HXLINE(  98)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m1;
HXDLIN(  98)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																if ((this2 == 0)) {
HXLINE(  98)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m2;
HXDLIN(  98)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																if ((this3 == 0)) {
HXLINE(  98)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m3;
HXDLIN(  98)																int this4 = (maskPixel & 255);
HXDLIN(  98)																if ((this4 == 0)) {
HXLINE(  98)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  98)														if ((col != 0)) {
HXLINE(  98)															int x = (dx - rectLeft);
HXDLIN(  98)															int y = (dy - rectTop);
HXDLIN(  98)															int this1 = col;
HXDLIN(  98)															int c = this1;
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																hitQuad = undoImage->transparent;
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																int location;
HXDLIN(  98)																if (undoImage->useVirtualPos) {
HXLINE(  98)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  98)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int this3 = this2;
HXDLIN(  98)																int this4;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	this4 = this3;
            																}
HXDLIN(  98)																Float a1;
HXDLIN(  98)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																if ((this5 == 0)) {
HXLINE(  98)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r1;
HXDLIN(  98)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																if ((this6 == 0)) {
HXLINE(  98)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g1;
HXDLIN(  98)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																if ((this7 == 0)) {
HXLINE(  98)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b1;
HXDLIN(  98)																int this8 = (this4 & 255);
HXDLIN(  98)																if ((this8 == 0)) {
HXLINE(  98)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a2;
HXDLIN(  98)																int this9 = ((col >> 24) & 255);
HXDLIN(  98)																if ((this9 == 0)) {
HXLINE(  98)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r2;
HXDLIN(  98)																int this10 = ((col >> 16) & 255);
HXDLIN(  98)																if ((this10 == 0)) {
HXLINE(  98)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g2;
HXDLIN(  98)																int this11 = ((col >> 8) & 255);
HXDLIN(  98)																if ((this11 == 0)) {
HXLINE(  98)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b2;
HXDLIN(  98)																int this12 = (col & 255);
HXDLIN(  98)																if ((this12 == 0)) {
HXLINE(  98)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																{
HXLINE(  98)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  98)																	int value;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		value = blended;
            																	}
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((location >= 0)) {
HXLINE(  98)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															if (forceClear) {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)																int x = (dx - rectLeft);
HXDLIN(  98)																int y = (dy - rectTop);
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool found = false;
HXDLIN(  98)								Float min = ( (Float)(0) );
HXDLIN(  98)								Float max = ( (Float)(0) );
HXDLIN(  98)								int a = 0;
HXDLIN(  98)								int r = 0;
HXDLIN(  98)								int g = 0;
HXDLIN(  98)								int b = 0;
HXDLIN(  98)								{
HXLINE(  98)									int _g_min = xIter3->start;
HXDLIN(  98)									int _g_max = xIter3->max;
HXDLIN(  98)									while((_g_min < _g_max)){
HXLINE(  98)										_g_min = (_g_min + 1);
HXDLIN(  98)										int px = (_g_min - 1);
HXDLIN(  98)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found = false;
HXLINE(  98)										{
HXLINE(  98)											int _g_min1 = yIter3->start;
HXDLIN(  98)											int _g_max = yIter3->max;
HXDLIN(  98)											while((_g_min1 < _g_max)){
HXLINE(  98)												_g_min1 = (_g_min1 + 1);
HXDLIN(  98)												int py = (_g_min1 - 1);
HXDLIN(  98)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  98)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  98)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  98)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  98)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  98)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)												bool hitQuad;
HXDLIN(  98)												bool hitQuad1;
HXDLIN(  98)												if ((ratioA >= 0)) {
HXLINE(  98)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad1 = false;
            												}
HXDLIN(  98)												if (hitQuad1) {
HXLINE(  98)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad = false;
            												}
HXDLIN(  98)												if (hitQuad) {
HXLINE( 710)													min = ratioA;
HXLINE(  98)													int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  98)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  98)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  98)													int this1 = i;
HXDLIN(  98)													a = this1;
HXDLIN(  98)													int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  98)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  98)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  98)													int this2 = i1;
HXLINE( 748)													r = this2;
HXLINE(  98)													int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  98)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  98)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  98)													int this3 = i2;
HXLINE( 749)													g = this3;
HXLINE(  98)													int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  98)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  98)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  98)													int this4 = i3;
HXLINE( 750)													b = this4;
HXLINE(  98)													{
HXLINE(  98)														int location;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->transparent) {
HXLINE(  98)															hitQuad = (a < 254);
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int this3 = this2;
HXDLIN(  98)															int old;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  98)																old = this3;
            															}
HXDLIN(  98)															int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)															Float a1;
HXDLIN(  98)															int this4 = ((old >> 24) & 255);
HXDLIN(  98)															if ((this4 == 0)) {
HXLINE(  98)																a1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r1;
HXDLIN(  98)															int this5 = ((old >> 16) & 255);
HXDLIN(  98)															if ((this5 == 0)) {
HXLINE(  98)																r1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g1;
HXDLIN(  98)															int this6 = ((old >> 8) & 255);
HXDLIN(  98)															if ((this6 == 0)) {
HXLINE(  98)																g1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b1;
HXDLIN(  98)															int this7 = (old & 255);
HXDLIN(  98)															if ((this7 == 0)) {
HXLINE(  98)																b1 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a2;
HXDLIN(  98)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)															if ((this8 == 0)) {
HXLINE(  98)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r2;
HXDLIN(  98)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)															if ((this9 == 0)) {
HXLINE(  98)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g2;
HXDLIN(  98)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)															if ((this10 == 0)) {
HXLINE(  98)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b2;
HXDLIN(  98)															int this11 = (rhs & 255);
HXDLIN(  98)															if ((this11 == 0)) {
HXLINE(  98)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)															int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)															int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)															int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  98)															{
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = blended;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((location >= 0)) {
HXLINE(  98)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (pixelImage->isLittle) {
HXLINE(  98)																value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            															}
            															else {
HXLINE(  98)																value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            															}
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found = true;
            												}
            												else {
HXLINE(  98)													if (found) {
HXLINE(  98)														goto _hx_goto_202;
            													}
            												}
            											}
            											_hx_goto_202:;
            										}
            									}
            								}
            							}
HXDLIN(  98)							{
HXLINE(  98)								bool hasUndo1 = true;
HXDLIN(  98)								int aA1 = ((color >> 24) & 255);
HXDLIN(  98)								int rA1 = ((color >> 16) & 255);
HXDLIN(  98)								int gA1 = ((color >> 8) & 255);
HXDLIN(  98)								int bA1 = (color & 255);
HXDLIN(  98)								Float bcx1 = (cx - dx);
HXDLIN(  98)								Float bcy1 = (cy - dy);
HXDLIN(  98)								Float acx1 = (bx - dx);
HXDLIN(  98)								Float acy1 = (by - dy);
HXDLIN(  98)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  98)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  98)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  98)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  98)								::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  98)								if ((bx > cx)) {
HXLINE(  98)									if ((bx > dx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((cx > dx)) {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(cx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(cx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((cx > dx)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((bx > dx)) {
HXLINE(  98)											min = ::Math_obj::floor(dx);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(bx);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(bx);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										xIter31 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  98)								if ((by > cy)) {
HXLINE(  98)									if ((by > dy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((cy > dy)) {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::floor(cy);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(by);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(cy);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            								}
            								else {
HXLINE(  98)									if ((cy > dy)) {
HXLINE(  98)										int min;
HXDLIN(  98)										if ((by > dy)) {
HXLINE(  98)											min = ::Math_obj::floor(dy);
            										}
            										else {
HXLINE(  98)											min = ::Math_obj::ceil(by);
            										}
HXDLIN(  98)										int ii_min = min;
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            									else {
HXLINE(  98)										int ii_min = ::Math_obj::floor(by);
HXDLIN(  98)										int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  98)										::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)										yIter31 = this1;
            									}
            								}
HXDLIN(  98)								::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  98)								if (hasUndo1) {
HXLINE(  98)									int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  98)									int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  98)									int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)									::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)									::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)									undoImage1 = this3;
HXDLIN(  98)									{
HXLINE(  98)										int rectLeft = xIter31->start;
HXDLIN(  98)										int rectTop = yIter31->start;
HXDLIN(  98)										int rectRight = xIter31->max;
HXDLIN(  98)										bool forceClear = false;
HXDLIN(  98)										{
HXLINE(  98)											int _g = rectTop;
HXDLIN(  98)											int _g1 = yIter31->max;
HXDLIN(  98)											while((_g < _g1)){
HXLINE(  98)												_g = (_g + 1);
HXDLIN(  98)												int dy = (_g - 1);
HXDLIN(  98)												{
HXLINE(  98)													int _g1 = rectLeft;
HXDLIN(  98)													int _g2 = rectRight;
HXDLIN(  98)													while((_g1 < _g2)){
HXLINE(  98)														_g1 = (_g1 + 1);
HXDLIN(  98)														int dx = (_g1 - 1);
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            														}
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)														int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int col;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															col = c;
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->useMask) {
HXLINE(  98)															hitQuad = ::hx::IsNotNull( pixelImage->mask );
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)															::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)															int index;
HXDLIN(  98)															if (this1->useVirtualPos) {
HXLINE(  98)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            															}
            															else {
HXLINE(  98)																index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            															}
HXDLIN(  98)															::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)															int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int v;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXLINE(  98)																v = c;
            															}
HXDLIN(  98)															int this3 = v;
HXDLIN(  98)															int maskPixel = this3;
HXDLIN(  98)															int this4 = col;
HXDLIN(  98)															int this5 = this4;
HXDLIN(  98)															if ((maskPixel == 0)) {
HXLINE(  98)																int this1 = this5;
HXDLIN(  98)																col = this1;
            															}
            															else {
HXLINE(  98)																Float m0;
HXDLIN(  98)																int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)																if ((this1 == 0)) {
HXLINE(  98)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m1;
HXDLIN(  98)																int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)																if ((this2 == 0)) {
HXLINE(  98)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m2;
HXDLIN(  98)																int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)																if ((this3 == 0)) {
HXLINE(  98)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float m3;
HXDLIN(  98)																int this4 = (maskPixel & 255);
HXDLIN(  98)																if ((this4 == 0)) {
HXLINE(  98)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  98)														if ((col != 0)) {
HXLINE(  98)															int x = (dx - rectLeft);
HXDLIN(  98)															int y = (dy - rectTop);
HXDLIN(  98)															int this1 = col;
HXDLIN(  98)															int c = this1;
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)																hitQuad = undoImage1->transparent;
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																int location;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)																int this3 = this2;
HXDLIN(  98)																int this4;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	this4 = this3;
            																}
HXDLIN(  98)																Float a1;
HXDLIN(  98)																int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)																if ((this5 == 0)) {
HXLINE(  98)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r1;
HXDLIN(  98)																int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)																if ((this6 == 0)) {
HXLINE(  98)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g1;
HXDLIN(  98)																int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)																if ((this7 == 0)) {
HXLINE(  98)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b1;
HXDLIN(  98)																int this8 = (this4 & 255);
HXDLIN(  98)																if ((this8 == 0)) {
HXLINE(  98)																	b1 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a2;
HXDLIN(  98)																int this9 = ((col >> 24) & 255);
HXDLIN(  98)																if ((this9 == 0)) {
HXLINE(  98)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float r2;
HXDLIN(  98)																int this10 = ((col >> 16) & 255);
HXDLIN(  98)																if ((this10 == 0)) {
HXLINE(  98)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float g2;
HXDLIN(  98)																int this11 = ((col >> 8) & 255);
HXDLIN(  98)																if ((this11 == 0)) {
HXLINE(  98)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float b2;
HXDLIN(  98)																int this12 = (col & 255);
HXDLIN(  98)																if ((this12 == 0)) {
HXLINE(  98)																	b2 = ((Float)0.);
            																}
            																else {
HXLINE(  98)																	b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  98)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)																int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)																int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)																int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)																{
HXLINE(  98)																	::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  98)																	int value;
HXDLIN(  98)																	if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																		value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  98)																		value = blended;
            																	}
HXDLIN(  98)																	bool hitQuad;
HXDLIN(  98)																	if ((location >= 0)) {
HXLINE(  98)																		hitQuad = (location < (this13->byteLength >> 2));
            																	}
            																	else {
HXLINE(  98)																		hitQuad = false;
            																	}
HXDLIN(  98)																	if (hitQuad) {
HXLINE(  98)																		::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																		int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																		_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																		_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																		_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																		_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																	}
            																}
            															}
            															else {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = c;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															if (forceClear) {
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  98)																int x = (dx - rectLeft);
HXDLIN(  98)																int y = (dy - rectTop);
HXDLIN(  98)																int index;
HXDLIN(  98)																if (undoImage1->useVirtualPos) {
HXLINE(  98)																	index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            																}
            																else {
HXLINE(  98)																	index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((index >= 0)) {
HXLINE(  98)																	hitQuad = (index < (this1->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																	int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  98)								bool found1 = false;
HXDLIN(  98)								Float min1 = ( (Float)(0) );
HXDLIN(  98)								Float max1 = ( (Float)(0) );
HXDLIN(  98)								int a1 = 0;
HXDLIN(  98)								int r1 = 0;
HXDLIN(  98)								int g1 = 0;
HXDLIN(  98)								int b1 = 0;
HXDLIN(  98)								{
HXLINE(  98)									int _g_min1 = xIter31->start;
HXDLIN(  98)									int _g_max1 = xIter31->max;
HXDLIN(  98)									while((_g_min1 < _g_max1)){
HXLINE(  98)										_g_min1 = (_g_min1 + 1);
HXDLIN(  98)										int px = (_g_min1 - 1);
HXDLIN(  98)										Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)										found1 = false;
HXLINE(  98)										{
HXLINE(  98)											int _g_min = yIter31->start;
HXDLIN(  98)											int _g_max = yIter31->max;
HXDLIN(  98)											while((_g_min < _g_max)){
HXLINE(  98)												_g_min = (_g_min + 1);
HXDLIN(  98)												int py = (_g_min - 1);
HXDLIN(  98)												Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  98)												Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  98)												Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  98)												Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  98)												Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  98)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)												bool hitQuad;
HXDLIN(  98)												bool hitQuad1;
HXDLIN(  98)												if ((ratioA >= 0)) {
HXLINE(  98)													hitQuad1 = (ratioB >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad1 = false;
            												}
HXDLIN(  98)												if (hitQuad1) {
HXLINE(  98)													hitQuad = (ratioC >= 0);
            												}
            												else {
HXLINE(  98)													hitQuad = false;
            												}
HXDLIN(  98)												if (hitQuad) {
HXLINE(  98)													if ((ratioB < ratioC)) {
HXLINE(  98)														min1 = ratioB;
            													}
            													else {
HXLINE(  98)														min1 = ratioC;
            													}
HXDLIN(  98)													if ((ratioA > ratioB)) {
HXLINE(  98)														max1 = ratioA;
            													}
            													else {
HXLINE(  98)														max1 = ratioB;
            													}
HXDLIN(  98)													if (!((max1 > ratioC))) {
HXLINE(  98)														max1 = ratioC;
            													}
HXLINE( 736)													max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  98)													if (!((min1 < max1))) {
HXLINE(  98)														min1 = ((max1 + min1) / ( (Float)(2) ));
            													}
HXDLIN(  98)													int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  98)													if ((i > 255)) {
HXLINE(  24)														i = 255;
            													}
HXLINE(  98)													if ((i < 0)) {
HXLINE(  25)														i = 0;
            													}
HXLINE(  98)													int this1 = i;
HXDLIN(  98)													a1 = this1;
HXDLIN(  98)													int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  98)													if ((i1 > 255)) {
HXLINE(  24)														i1 = 255;
            													}
HXLINE(  98)													if ((i1 < 0)) {
HXLINE(  25)														i1 = 0;
            													}
HXLINE(  98)													int this2 = i1;
HXLINE( 748)													r1 = this2;
HXLINE(  98)													int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  98)													if ((i2 > 255)) {
HXLINE(  24)														i2 = 255;
            													}
HXLINE(  98)													if ((i2 < 0)) {
HXLINE(  25)														i2 = 0;
            													}
HXLINE(  98)													int this3 = i2;
HXLINE( 749)													g1 = this3;
HXLINE(  98)													int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  98)													if ((i3 > 255)) {
HXLINE(  24)														i3 = 255;
            													}
HXLINE(  98)													if ((i3 < 0)) {
HXLINE(  25)														i3 = 0;
            													}
HXLINE(  98)													int this4 = i3;
HXLINE( 750)													b1 = this4;
HXLINE(  98)													{
HXLINE(  98)														int location;
HXDLIN(  98)														if (pixelImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            														}
HXDLIN(  98)														bool hitQuad;
HXDLIN(  98)														if (pixelImage->transparent) {
HXLINE(  98)															hitQuad = (a1 < 254);
            														}
            														else {
HXLINE(  98)															hitQuad = false;
            														}
HXDLIN(  98)														if (hitQuad) {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)															int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)															int this3 = this2;
HXDLIN(  98)															int old;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            															}
            															else {
HXLINE(  98)																old = this3;
            															}
HXDLIN(  98)															int rhs = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  98)															Float a11;
HXDLIN(  98)															int this4 = ((old >> 24) & 255);
HXDLIN(  98)															if ((this4 == 0)) {
HXLINE(  98)																a11 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r11;
HXDLIN(  98)															int this5 = ((old >> 16) & 255);
HXDLIN(  98)															if ((this5 == 0)) {
HXLINE(  98)																r11 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g11;
HXDLIN(  98)															int this6 = ((old >> 8) & 255);
HXDLIN(  98)															if ((this6 == 0)) {
HXLINE(  98)																g11 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b11;
HXDLIN(  98)															int this7 = (old & 255);
HXDLIN(  98)															if ((this7 == 0)) {
HXLINE(  98)																b11 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a2;
HXDLIN(  98)															int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)															if ((this8 == 0)) {
HXLINE(  98)																a2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float r2;
HXDLIN(  98)															int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)															if ((this9 == 0)) {
HXLINE(  98)																r2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float g2;
HXDLIN(  98)															int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)															if ((this10 == 0)) {
HXLINE(  98)																g2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float b2;
HXDLIN(  98)															int this11 = (rhs & 255);
HXDLIN(  98)															if ((this11 == 0)) {
HXLINE(  98)																b2 = ((Float)0.);
            															}
            															else {
HXLINE(  98)																b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  98)															Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  98)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a2))));
HXDLIN(  98)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a2))));
HXDLIN(  98)															int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a2))));
HXDLIN(  98)															int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)															int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)															{
HXLINE(  98)																::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)																int value;
HXDLIN(  98)																if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																	value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXLINE(  98)																	value = blended;
            																}
HXDLIN(  98)																bool hitQuad;
HXDLIN(  98)																if ((location >= 0)) {
HXLINE(  98)																	hitQuad = (location < (this12->byteLength >> 2));
            																}
            																else {
HXLINE(  98)																	hitQuad = false;
            																}
HXDLIN(  98)																if (hitQuad) {
HXLINE(  98)																	::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)																	int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)																	_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																	_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																	_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																	_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            																}
            															}
            														}
            														else {
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (pixelImage->isLittle) {
HXLINE(  98)																value = ((((a1 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            															}
            															else {
HXLINE(  98)																value = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            															}
HXDLIN(  98)															bool hitQuad;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																hitQuad = (location < (this1->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																hitQuad = false;
            															}
HXDLIN(  98)															if (hitQuad) {
HXLINE(  98)																::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
HXLINE( 752)													found1 = true;
            												}
            												else {
HXLINE(  98)													if (found1) {
HXLINE(  98)														goto _hx_goto_206;
            													}
            												}
            											}
            											_hx_goto_206:;
            										}
            									}
            								}
            							}
HXDLIN(  98)							::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  98)							hitQuad = v;
            						}
HXDLIN(  98)						Float cx = h2;
HXDLIN(  98)						Float cy = radius2;
HXDLIN(  98)						Float bx = h2;
HXDLIN(  98)						Float by = -(radius2);
HXDLIN(  98)						Float temp = ((Float)0.);
HXLINE(  92)						temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  93)						by = (py + ((by * cos) + (bx * sin)));
HXLINE(  94)						bx = temp;
HXLINE(  95)						temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  96)						cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  97)						cx = temp;
HXLINE(  98)						bool hasUndo = true;
HXDLIN(  98)						int aA = ((color >> 24) & 255);
HXDLIN(  98)						int rA = ((color >> 16) & 255);
HXDLIN(  98)						int gA = ((color >> 8) & 255);
HXDLIN(  98)						int bA = (color & 255);
HXDLIN(  98)						Float bcx = (bx - cx);
HXDLIN(  98)						Float bcy = (by - cy);
HXDLIN(  98)						Float acx = (px - cx);
HXDLIN(  98)						Float acy = (py - cy);
HXDLIN(  98)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  98)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  98)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  98)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  98)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  98)						if ((px > bx)) {
HXLINE(  98)							if ((px > cx)) {
HXLINE(  98)								int min;
HXDLIN(  98)								if ((bx > cx)) {
HXLINE(  98)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE(  98)									min = ::Math_obj::floor(bx);
            								}
HXDLIN(  98)								int ii_min = min;
HXDLIN(  98)								int ii_max = ::Math_obj::ceil(px);
HXDLIN(  98)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)								xIter3 = this1;
            							}
            							else {
HXLINE(  98)								int ii_min = ::Math_obj::floor(bx);
HXDLIN(  98)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE(  98)							if ((bx > cx)) {
HXLINE(  98)								int min;
HXDLIN(  98)								if ((px > cx)) {
HXLINE(  98)									min = ::Math_obj::floor(cx);
            								}
            								else {
HXLINE(  98)									min = ::Math_obj::ceil(px);
            								}
HXDLIN(  98)								int ii_min = min;
HXDLIN(  98)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  98)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)								xIter3 = this1;
            							}
            							else {
HXLINE(  98)								int ii_min = ::Math_obj::floor(px);
HXDLIN(  98)								int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  98)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)								xIter3 = this1;
            							}
            						}
HXDLIN(  98)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  98)						if ((py > by)) {
HXLINE(  98)							if ((py > cy)) {
HXLINE(  98)								int min;
HXDLIN(  98)								if ((by > cy)) {
HXLINE(  98)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE(  98)									min = ::Math_obj::floor(by);
            								}
HXDLIN(  98)								int ii_min = min;
HXDLIN(  98)								int ii_max = ::Math_obj::ceil(py);
HXDLIN(  98)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)								yIter3 = this1;
            							}
            							else {
HXLINE(  98)								int ii_min = ::Math_obj::floor(by);
HXDLIN(  98)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE(  98)							if ((by > cy)) {
HXLINE(  98)								int min;
HXDLIN(  98)								if ((py > cy)) {
HXLINE(  98)									min = ::Math_obj::floor(cy);
            								}
            								else {
HXLINE(  98)									min = ::Math_obj::ceil(py);
            								}
HXDLIN(  98)								int ii_min = min;
HXDLIN(  98)								int ii_max = ::Math_obj::ceil(by);
HXDLIN(  98)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)								yIter3 = this1;
            							}
            							else {
HXLINE(  98)								int ii_min = ::Math_obj::floor(py);
HXDLIN(  98)								int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  98)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  98)								yIter3 = this1;
            							}
            						}
HXDLIN(  98)						::pixelimage::ImageStruct undoImage = null();
HXDLIN(  98)						if (hasUndo) {
HXLINE(  98)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  98)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  98)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  98)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  98)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  98)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  98)							undoImage = this3;
HXDLIN(  98)							{
HXLINE(  98)								int rectLeft = xIter3->start;
HXDLIN(  98)								int rectTop = yIter3->start;
HXDLIN(  98)								int rectRight = xIter3->max;
HXDLIN(  98)								bool forceClear = false;
HXDLIN(  98)								{
HXLINE(  98)									int _g = rectTop;
HXDLIN(  98)									int _g1 = yIter3->max;
HXDLIN(  98)									while((_g < _g1)){
HXLINE(  98)										_g = (_g + 1);
HXDLIN(  98)										int dy = (_g - 1);
HXDLIN(  98)										{
HXLINE(  98)											int _g1 = rectLeft;
HXDLIN(  98)											int _g2 = rectRight;
HXDLIN(  98)											while((_g1 < _g2)){
HXLINE(  98)												_g1 = (_g1 + 1);
HXDLIN(  98)												int dx = (_g1 - 1);
HXDLIN(  98)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)												int index;
HXDLIN(  98)												if (pixelImage->useVirtualPos) {
HXLINE(  98)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  98)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN(  98)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)												int col;
HXDLIN(  98)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  98)													col = c;
            												}
HXDLIN(  98)												bool _hx_tmp;
HXDLIN(  98)												if (pixelImage->useMask) {
HXLINE(  98)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE(  98)													_hx_tmp = false;
            												}
HXDLIN(  98)												if (_hx_tmp) {
HXLINE(  98)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN(  98)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  98)													int index;
HXDLIN(  98)													if (this1->useVirtualPos) {
HXLINE(  98)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE(  98)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN(  98)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  98)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  98)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)													int v;
HXDLIN(  98)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  98)														v = c;
            													}
HXDLIN(  98)													int this3 = v;
HXDLIN(  98)													int maskPixel = this3;
HXDLIN(  98)													int this4 = col;
HXDLIN(  98)													int this5 = this4;
HXDLIN(  98)													if ((maskPixel == 0)) {
HXLINE(  98)														int this1 = this5;
HXDLIN(  98)														col = this1;
            													}
            													else {
HXLINE(  98)														Float m0;
HXDLIN(  98)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  98)														if ((this1 == 0)) {
HXLINE(  98)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float m1;
HXDLIN(  98)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  98)														if ((this2 == 0)) {
HXLINE(  98)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float m2;
HXDLIN(  98)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  98)														if ((this3 == 0)) {
HXLINE(  98)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float m3;
HXDLIN(  98)														int this4 = (maskPixel & 255);
HXDLIN(  98)														if ((this4 == 0)) {
HXLINE(  98)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  98)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  98)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  98)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  98)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  98)												if ((col != 0)) {
HXLINE(  98)													int x = (dx - rectLeft);
HXDLIN(  98)													int y = (dy - rectTop);
HXDLIN(  98)													int this1 = col;
HXDLIN(  98)													int c = this1;
HXDLIN(  98)													bool _hx_tmp;
HXDLIN(  98)													if ((((c >> 24) & 255) < 254)) {
HXLINE(  98)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE(  98)														_hx_tmp = false;
            													}
HXDLIN(  98)													if (_hx_tmp) {
HXLINE(  98)														int location;
HXDLIN(  98)														if (undoImage->useVirtualPos) {
HXLINE(  98)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  98)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  98)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)														int this3 = this2;
HXDLIN(  98)														int this4;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE(  98)															this4 = this3;
            														}
HXDLIN(  98)														Float a1;
HXDLIN(  98)														int this5 = ((this4 >> 24) & 255);
HXDLIN(  98)														if ((this5 == 0)) {
HXLINE(  98)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float r1;
HXDLIN(  98)														int this6 = ((this4 >> 16) & 255);
HXDLIN(  98)														if ((this6 == 0)) {
HXLINE(  98)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float g1;
HXDLIN(  98)														int this7 = ((this4 >> 8) & 255);
HXDLIN(  98)														if ((this7 == 0)) {
HXLINE(  98)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float b1;
HXDLIN(  98)														int this8 = (this4 & 255);
HXDLIN(  98)														if ((this8 == 0)) {
HXLINE(  98)															b1 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float a2;
HXDLIN(  98)														int this9 = ((col >> 24) & 255);
HXDLIN(  98)														if ((this9 == 0)) {
HXLINE(  98)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float r2;
HXDLIN(  98)														int this10 = ((col >> 16) & 255);
HXDLIN(  98)														if ((this10 == 0)) {
HXLINE(  98)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float g2;
HXDLIN(  98)														int this11 = ((col >> 8) & 255);
HXDLIN(  98)														if ((this11 == 0)) {
HXLINE(  98)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float b2;
HXDLIN(  98)														int this12 = (col & 255);
HXDLIN(  98)														if ((this12 == 0)) {
HXLINE(  98)															b2 = ((Float)0.);
            														}
            														else {
HXLINE(  98)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  98)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  98)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)														{
HXLINE(  98)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  98)															int value;
HXDLIN(  98)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  98)																value = blended;
            															}
HXDLIN(  98)															bool _hx_tmp;
HXDLIN(  98)															if ((location >= 0)) {
HXLINE(  98)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE(  98)																_hx_tmp = false;
            															}
HXDLIN(  98)															if (_hx_tmp) {
HXLINE(  98)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  98)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  98)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE(  98)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)														int index;
HXDLIN(  98)														if (undoImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  98)														int value;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  98)															value = c;
            														}
HXDLIN(  98)														bool _hx_tmp;
HXDLIN(  98)														if ((index >= 0)) {
HXLINE(  98)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  98)															_hx_tmp = false;
            														}
HXDLIN(  98)														if (_hx_tmp) {
HXLINE(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  98)													if (forceClear) {
HXLINE(  98)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  98)														int x = (dx - rectLeft);
HXDLIN(  98)														int y = (dy - rectTop);
HXDLIN(  98)														int index;
HXDLIN(  98)														if (undoImage->useVirtualPos) {
HXLINE(  98)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE(  98)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN(  98)														bool _hx_tmp;
HXDLIN(  98)														if ((index >= 0)) {
HXLINE(  98)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE(  98)															_hx_tmp = false;
            														}
HXDLIN(  98)														if (_hx_tmp) {
HXLINE(  98)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  98)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  98)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  98)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  98)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  98)						bool found = false;
HXDLIN(  98)						Float min = ( (Float)(0) );
HXDLIN(  98)						Float max = ( (Float)(0) );
HXDLIN(  98)						int a1 = 0;
HXDLIN(  98)						int r = 0;
HXDLIN(  98)						int g = 0;
HXDLIN(  98)						int b = 0;
HXDLIN(  98)						{
HXLINE(  98)							int _g_min = xIter3->start;
HXDLIN(  98)							int _g_max = xIter3->max;
HXDLIN(  98)							while((_g_min < _g_max)){
HXLINE(  98)								_g_min = (_g_min + 1);
HXDLIN(  98)								int px = (_g_min - 1);
HXDLIN(  98)								Float pcx = (( (Float)(px) ) - cx);
HXLINE( 696)								found = false;
HXLINE(  98)								{
HXLINE(  98)									int _g_min1 = yIter3->start;
HXDLIN(  98)									int _g_max = yIter3->max;
HXDLIN(  98)									while((_g_min1 < _g_max)){
HXLINE(  98)										_g_min1 = (_g_min1 + 1);
HXDLIN(  98)										int py = (_g_min1 - 1);
HXDLIN(  98)										Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  98)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  98)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  98)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  98)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  98)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  98)										bool _hx_tmp;
HXDLIN(  98)										bool _hx_tmp1;
HXDLIN(  98)										if ((ratioA >= 0)) {
HXLINE(  98)											_hx_tmp1 = (ratioB >= 0);
            										}
            										else {
HXLINE(  98)											_hx_tmp1 = false;
            										}
HXDLIN(  98)										if (_hx_tmp1) {
HXLINE(  98)											_hx_tmp = (ratioC >= 0);
            										}
            										else {
HXLINE(  98)											_hx_tmp = false;
            										}
HXDLIN(  98)										if (_hx_tmp) {
HXLINE(  98)											Float min;
HXDLIN(  98)											if ((ratioA < ratioB)) {
HXLINE(  98)												min = ratioA;
            											}
            											else {
HXLINE(  98)												min = ratioB;
            											}
HXDLIN(  98)											if (!((min < ratioC))) {
HXLINE(  98)												min = ratioC;
            											}
HXDLIN(  98)											Float max;
HXDLIN(  98)											if ((ratioA > ratioB)) {
HXLINE(  98)												max = ratioA;
            											}
            											else {
HXLINE(  98)												max = ratioB;
            											}
HXDLIN(  98)											if (!((max > ratioC))) {
HXLINE(  98)												max = ratioC;
            											}
HXLINE( 744)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  98)											Float min1;
HXDLIN(  98)											if ((min < max)) {
HXLINE(  98)												min1 = min;
            											}
            											else {
HXLINE(  98)												min1 = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  98)											int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min1));
HXDLIN(  98)											if ((i > 255)) {
HXLINE(  24)												i = 255;
            											}
HXLINE(  98)											if ((i < 0)) {
HXLINE(  25)												i = 0;
            											}
HXLINE(  98)											int this1 = i;
HXDLIN(  98)											a1 = this1;
HXDLIN(  98)											int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  98)											if ((i1 > 255)) {
HXLINE(  24)												i1 = 255;
            											}
HXLINE(  98)											if ((i1 < 0)) {
HXLINE(  25)												i1 = 0;
            											}
HXLINE(  98)											int this2 = i1;
HXLINE( 748)											r = this2;
HXLINE(  98)											int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  98)											if ((i2 > 255)) {
HXLINE(  24)												i2 = 255;
            											}
HXLINE(  98)											if ((i2 < 0)) {
HXLINE(  25)												i2 = 0;
            											}
HXLINE(  98)											int this3 = i2;
HXLINE( 749)											g = this3;
HXLINE(  98)											int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  98)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  98)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  98)											int this4 = i3;
HXLINE( 750)											b = this4;
HXLINE(  98)											{
HXLINE(  98)												int location;
HXDLIN(  98)												if (pixelImage->useVirtualPos) {
HXLINE(  98)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  98)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            												}
HXDLIN(  98)												bool _hx_tmp;
HXDLIN(  98)												if (pixelImage->transparent) {
HXLINE(  98)													_hx_tmp = (a1 < 254);
            												}
            												else {
HXLINE(  98)													_hx_tmp = false;
            												}
HXDLIN(  98)												if (_hx_tmp) {
HXLINE(  98)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  98)													int this3 = this2;
HXDLIN(  98)													int old;
HXDLIN(  98)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  98)														old = this3;
            													}
HXDLIN(  98)													int rhs = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  98)													Float a11;
HXDLIN(  98)													int this4 = ((old >> 24) & 255);
HXDLIN(  98)													if ((this4 == 0)) {
HXLINE(  98)														a11 = ((Float)0.);
            													}
            													else {
HXLINE(  98)														a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  98)													Float r1;
HXDLIN(  98)													int this5 = ((old >> 16) & 255);
HXDLIN(  98)													if ((this5 == 0)) {
HXLINE(  98)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  98)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  98)													Float g1;
HXDLIN(  98)													int this6 = ((old >> 8) & 255);
HXDLIN(  98)													if ((this6 == 0)) {
HXLINE(  98)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  98)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  98)													Float b1;
HXDLIN(  98)													int this7 = (old & 255);
HXDLIN(  98)													if ((this7 == 0)) {
HXLINE(  98)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  98)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  98)													Float a2;
HXDLIN(  98)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  98)													if ((this8 == 0)) {
HXLINE(  98)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  98)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  98)													Float r2;
HXDLIN(  98)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  98)													if ((this9 == 0)) {
HXLINE(  98)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  98)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  98)													Float g2;
HXDLIN(  98)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  98)													if ((this10 == 0)) {
HXLINE(  98)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  98)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  98)													Float b2;
HXDLIN(  98)													int this11 = (rhs & 255);
HXDLIN(  98)													if ((this11 == 0)) {
HXLINE(  98)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  98)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  98)													Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  98)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  98)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  98)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  98)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  98)													int blended = ((((a << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  98)													{
HXLINE(  98)														::haxe::io::ArrayBufferViewImpl this12 = pixelImage->image;
HXDLIN(  98)														int value;
HXDLIN(  98)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  98)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  98)															value = blended;
            														}
HXDLIN(  98)														bool _hx_tmp;
HXDLIN(  98)														if ((location >= 0)) {
HXLINE(  98)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  98)															_hx_tmp = false;
            														}
HXDLIN(  98)														if (_hx_tmp) {
HXLINE(  98)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  98)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  98)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  98)													::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN(  98)													int value;
HXDLIN(  98)													if (pixelImage->isLittle) {
HXLINE(  98)														value = ((((a1 << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  98)														value = ((((a1 << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  98)													bool _hx_tmp;
HXDLIN(  98)													if ((location >= 0)) {
HXLINE(  98)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  98)														_hx_tmp = false;
            													}
HXDLIN(  98)													if (_hx_tmp) {
HXLINE(  98)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  98)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  98)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  98)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  98)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  98)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
HXLINE( 752)											found = true;
            										}
            										else {
HXLINE(  98)											if (found) {
HXLINE(  98)												goto _hx_goto_210;
            											}
            										}
            									}
            									_hx_goto_210:;
            								}
            							}
            						}
HXDLIN(  98)						::pixelimage::algo::HitTri hitTri;
HXDLIN(  98)						if ((hasHit == false)) {
HXLINE(  98)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx,by,cx,cy,true);
HXDLIN(  98)							if (hasUndo) {
HXLINE(  98)								v->undoImage = undoImage;
HXDLIN(  98)								v->undoX = xIter3->start;
HXDLIN(  98)								v->undoY = yIter3->start;
            							}
HXDLIN(  98)							hitTri = v;
            						}
            						else {
HXLINE(  98)							hitTri = null();
            						}
HXDLIN(  98)						if (hasHit) {
HXLINE(  98)							::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN(  98)							if (::hx::IsNotNull( hitQuad )) {
HXLINE(  98)								hitArr->triArr->push(hitQuad->triABD);
            							}
HXDLIN(  98)							hitArr->triArr->push(hitQuad->triBCD);
            						}
            					}
            				}
            			}
            			else {
HXLINE( 102)				bool _hx_tmp;
HXDLIN( 102)				if (!((this->arrowHeight > ((Float)0.)))) {
HXLINE( 102)					_hx_tmp = (this->arrowWidth > ((Float)0.));
            				}
            				else {
HXLINE( 102)					_hx_tmp = true;
            				}
HXDLIN( 102)				if (_hx_tmp) {
HXLINE( 103)					Float arrowWidth = this->arrowWidth;
HXDLIN( 103)					Float arrowHeight = this->arrowHeight;
HXDLIN( 103)					Float thick = this->strokeWidth;
HXDLIN( 103)					int color = this->strokeColor;
HXDLIN( 103)					bool hasHit = true;
HXDLIN( 103)					{
HXLINE( 103)						Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 103)						Float o = (py - py);
HXDLIN( 103)						Float a = (px - px);
HXDLIN( 103)						Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 103)						Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 103)						Float thicker;
HXDLIN( 103)						if ((arrowWidth > (thick * ((Float)1.1)))) {
HXLINE( 103)							thicker = arrowWidth;
            						}
            						else {
HXLINE( 103)							thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            						}
HXDLIN( 103)						Float sin = ::Math_obj::sin(theta);
HXDLIN( 103)						Float cos = ::Math_obj::cos(theta);
HXDLIN( 103)						Float radius = (thick / ( (Float)(2) ));
HXDLIN( 103)						Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 103)						Float h2;
HXDLIN( 103)						if ((arrowHeight < (h * ((Float)1.1)))) {
HXLINE( 103)							h2 = (h - arrowHeight);
            						}
            						else {
HXLINE( 103)							h2 = (h / goldenRatio);
            						}
HXDLIN( 103)						Float hSmall = (h - h2);
HXDLIN( 103)						Float px_ = hSmall;
HXDLIN( 103)						Float py_ = ((Float)0.);
HXDLIN( 103)						Float temp = ((Float)0.);
HXLINE( 577)						temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 578)						py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 579)						px_ = temp;
HXLINE( 103)						Float h1 = (h2 - hSmall);
HXDLIN( 103)						Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 103)						Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 103)						Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 103)						Float dx = ((Float)0.1);
HXDLIN( 103)						Float dy = radius1;
HXDLIN( 103)						Float cx = h1;
HXDLIN( 103)						Float cy = radius1;
HXDLIN( 103)						Float bx = h1;
HXDLIN( 103)						Float by = -(radius1);
HXDLIN( 103)						Float ax = ((Float)0.1);
HXDLIN( 103)						Float ay = -(radius1);
HXDLIN( 103)						Float temp1 = ((Float)0.);
HXLINE(  28)						temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE(  29)						ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE(  30)						ax = temp1;
HXLINE(  32)						temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE(  33)						by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE(  34)						bx = temp1;
HXLINE(  36)						temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE(  37)						cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE(  38)						cx = temp1;
HXLINE(  40)						temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE(  41)						dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE(  42)						dx = temp1;
HXLINE( 103)						Float bx1 = bx;
HXDLIN( 103)						Float by1 = by;
HXDLIN( 103)						Float cx1 = dx;
HXDLIN( 103)						Float cy1 = dy;
HXDLIN( 103)						bool hasUndo = false;
HXDLIN( 103)						bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 103)						if (!(adjustWinding)) {
HXLINE( 103)							Float bx_ = bx1;
HXDLIN( 103)							Float by_ = by1;
HXLINE(  26)							bx1 = cx1;
HXLINE(  27)							by1 = cy1;
HXLINE(  28)							cx1 = bx_;
HXLINE(  29)							cy1 = by_;
            						}
HXLINE( 103)						Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 103)						Float sx = (cy1 - ay);
HXDLIN( 103)						Float sy = (ax - cx1);
HXDLIN( 103)						Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 103)						Float tx = (ay - by1);
HXDLIN( 103)						Float ty = (bx1 - ax);
HXDLIN( 103)						Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 103)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 103)						if ((ax > bx1)) {
HXLINE( 103)							if ((ax > cx1)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((bx1 > cx1)) {
HXLINE( 103)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter3 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(bx1);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE( 103)							if ((bx1 > cx1)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((ax > cx1)) {
HXLINE( 103)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::ceil(ax);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(bx1);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter3 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(ax);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter3 = this1;
            							}
            						}
HXDLIN( 103)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 103)						if ((ay > by1)) {
HXLINE( 103)							if ((ay > cy1)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((by1 > cy1)) {
HXLINE( 103)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::floor(by1);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(ay);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter3 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(by1);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE( 103)							if ((by1 > cy1)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((ay > cy1)) {
HXLINE( 103)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::ceil(ay);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(by1);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter3 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(ay);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter3 = this1;
            							}
            						}
HXDLIN( 103)						::pixelimage::ImageStruct undoImage = null();
HXDLIN( 103)						if (hasUndo) {
HXLINE( 103)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 103)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 103)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 103)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 103)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 103)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 103)							undoImage = this3;
HXDLIN( 103)							{
HXLINE( 103)								int rectLeft = xIter3->start;
HXDLIN( 103)								int rectTop = yIter3->start;
HXDLIN( 103)								int rectRight = xIter3->max;
HXDLIN( 103)								bool forceClear = false;
HXDLIN( 103)								{
HXLINE( 103)									int _g = rectTop;
HXDLIN( 103)									int _g1 = yIter3->max;
HXDLIN( 103)									while((_g < _g1)){
HXLINE( 103)										_g = (_g + 1);
HXDLIN( 103)										int dy = (_g - 1);
HXDLIN( 103)										{
HXLINE( 103)											int _g1 = rectLeft;
HXDLIN( 103)											int _g2 = rectRight;
HXDLIN( 103)											while((_g1 < _g2)){
HXLINE( 103)												_g1 = (_g1 + 1);
HXDLIN( 103)												int dx = (_g1 - 1);
HXDLIN( 103)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)												int index;
HXDLIN( 103)												if (pixelImage->useVirtualPos) {
HXLINE( 103)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 103)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN( 103)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)												int col;
HXDLIN( 103)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 103)													col = c;
            												}
HXDLIN( 103)												bool _hx_tmp;
HXDLIN( 103)												if (pixelImage->useMask) {
HXLINE( 103)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE( 103)													_hx_tmp = false;
            												}
HXDLIN( 103)												if (_hx_tmp) {
HXLINE( 103)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN( 103)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 103)													int index;
HXDLIN( 103)													if (this1->useVirtualPos) {
HXLINE( 103)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 103)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 103)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 103)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 103)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)													int v;
HXDLIN( 103)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 103)														v = c;
            													}
HXDLIN( 103)													int this3 = v;
HXDLIN( 103)													int maskPixel = this3;
HXDLIN( 103)													int this4 = col;
HXDLIN( 103)													int this5 = this4;
HXDLIN( 103)													if ((maskPixel == 0)) {
HXLINE( 103)														int this1 = this5;
HXDLIN( 103)														col = this1;
            													}
            													else {
HXLINE( 103)														Float m0;
HXDLIN( 103)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 103)														if ((this1 == 0)) {
HXLINE( 103)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m1;
HXDLIN( 103)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 103)														if ((this2 == 0)) {
HXLINE( 103)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m2;
HXDLIN( 103)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 103)														if ((this3 == 0)) {
HXLINE( 103)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m3;
HXDLIN( 103)														int this4 = (maskPixel & 255);
HXDLIN( 103)														if ((this4 == 0)) {
HXLINE( 103)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 103)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 103)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 103)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 103)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 103)												if ((col != 0)) {
HXLINE( 103)													int x = (dx - rectLeft);
HXDLIN( 103)													int y = (dy - rectTop);
HXDLIN( 103)													int this1 = col;
HXDLIN( 103)													int c = this1;
HXDLIN( 103)													bool _hx_tmp;
HXDLIN( 103)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 103)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE( 103)														_hx_tmp = false;
            													}
HXDLIN( 103)													if (_hx_tmp) {
HXLINE( 103)														int location;
HXDLIN( 103)														if (undoImage->useVirtualPos) {
HXLINE( 103)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 103)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 103)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 103)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)														int this3 = this2;
HXDLIN( 103)														int this4;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 103)															this4 = this3;
            														}
HXDLIN( 103)														Float a1;
HXDLIN( 103)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 103)														if ((this5 == 0)) {
HXLINE( 103)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r1;
HXDLIN( 103)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 103)														if ((this6 == 0)) {
HXLINE( 103)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g1;
HXDLIN( 103)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 103)														if ((this7 == 0)) {
HXLINE( 103)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b1;
HXDLIN( 103)														int this8 = (this4 & 255);
HXDLIN( 103)														if ((this8 == 0)) {
HXLINE( 103)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a2;
HXDLIN( 103)														int this9 = ((col >> 24) & 255);
HXDLIN( 103)														if ((this9 == 0)) {
HXLINE( 103)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r2;
HXDLIN( 103)														int this10 = ((col >> 16) & 255);
HXDLIN( 103)														if ((this10 == 0)) {
HXLINE( 103)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g2;
HXDLIN( 103)														int this11 = ((col >> 8) & 255);
HXDLIN( 103)														if ((this11 == 0)) {
HXLINE( 103)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b2;
HXDLIN( 103)														int this12 = (col & 255);
HXDLIN( 103)														if ((this12 == 0)) {
HXLINE( 103)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 103)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 103)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 103)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 103)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 103)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 103)														{
HXLINE( 103)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 103)															int value;
HXDLIN( 103)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 103)																value = blended;
            															}
HXDLIN( 103)															bool _hx_tmp;
HXDLIN( 103)															if ((location >= 0)) {
HXLINE( 103)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 103)																_hx_tmp = false;
            															}
HXDLIN( 103)															if (_hx_tmp) {
HXLINE( 103)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 103)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 103)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 103)														int index;
HXDLIN( 103)														if (undoImage->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 103)														int value;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 103)															value = c;
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 103)													if (forceClear) {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 103)														int x = (dx - rectLeft);
HXDLIN( 103)														int y = (dy - rectTop);
HXDLIN( 103)														int index;
HXDLIN( 103)														if (undoImage->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 103)						bool found = false;
HXDLIN( 103)						Float s = ((Float)0.);
HXDLIN( 103)						Float t = ((Float)0.);
HXDLIN( 103)						Float sxx = ((Float)0.);
HXDLIN( 103)						Float txx = ((Float)0.);
HXDLIN( 103)						{
HXLINE( 103)							int _g_min = xIter3->start;
HXDLIN( 103)							int _g_max = xIter3->max;
HXDLIN( 103)							while((_g_min < _g_max)){
HXLINE( 103)								_g_min = (_g_min + 1);
HXDLIN( 103)								int x = (_g_min - 1);
HXLINE(  61)								sxx = (sx * ( (Float)(x) ));
HXLINE(  62)								txx = (tx * ( (Float)(x) ));
HXLINE(  63)								found = false;
HXLINE( 103)								{
HXLINE( 103)									int _g_min1 = yIter3->start;
HXDLIN( 103)									int _g_max = yIter3->max;
HXDLIN( 103)									while((_g_min1 < _g_max)){
HXLINE( 103)										_g_min1 = (_g_min1 + 1);
HXDLIN( 103)										int y = (_g_min1 - 1);
HXLINE(  65)										s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)										t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 103)										bool _hx_tmp;
HXDLIN( 103)										if (!((s <= 0))) {
HXLINE( 103)											_hx_tmp = (t <= 0);
            										}
            										else {
HXLINE( 103)											_hx_tmp = true;
            										}
HXDLIN( 103)										if (_hx_tmp) {
HXLINE( 103)											if (found) {
HXLINE( 103)												goto _hx_goto_214;
            											}
            										}
            										else {
HXLINE( 103)											if (((s + t) < A)) {
HXLINE( 103)												{
HXLINE( 103)													int this1 = color;
HXDLIN( 103)													int c = this1;
HXDLIN( 103)													bool _hx_tmp;
HXDLIN( 103)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 103)														_hx_tmp = pixelImage->transparent;
            													}
            													else {
HXLINE( 103)														_hx_tmp = false;
            													}
HXDLIN( 103)													if (_hx_tmp) {
HXLINE( 103)														int location;
HXDLIN( 103)														if (pixelImage->useVirtualPos) {
HXLINE( 103)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 103)															location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 103)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 103)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)														int this3 = this2;
HXDLIN( 103)														int this4;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 103)															this4 = this3;
            														}
HXDLIN( 103)														Float a1;
HXDLIN( 103)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 103)														if ((this5 == 0)) {
HXLINE( 103)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r1;
HXDLIN( 103)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 103)														if ((this6 == 0)) {
HXLINE( 103)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g1;
HXDLIN( 103)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 103)														if ((this7 == 0)) {
HXLINE( 103)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b1;
HXDLIN( 103)														int this8 = (this4 & 255);
HXDLIN( 103)														if ((this8 == 0)) {
HXLINE( 103)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a2;
HXDLIN( 103)														int this9 = ((color >> 24) & 255);
HXDLIN( 103)														if ((this9 == 0)) {
HXLINE( 103)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r2;
HXDLIN( 103)														int this10 = ((color >> 16) & 255);
HXDLIN( 103)														if ((this10 == 0)) {
HXLINE( 103)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g2;
HXDLIN( 103)														int this11 = ((color >> 8) & 255);
HXDLIN( 103)														if ((this11 == 0)) {
HXLINE( 103)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b2;
HXDLIN( 103)														int this12 = (color & 255);
HXDLIN( 103)														if ((this12 == 0)) {
HXLINE( 103)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 103)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 103)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 103)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 103)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 103)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 103)														{
HXLINE( 103)															::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 103)															int value;
HXDLIN( 103)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 103)																value = blended;
            															}
HXDLIN( 103)															bool _hx_tmp;
HXDLIN( 103)															if ((location >= 0)) {
HXLINE( 103)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 103)																_hx_tmp = false;
            															}
HXDLIN( 103)															if (_hx_tmp) {
HXLINE( 103)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 103)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 103)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)														int index;
HXDLIN( 103)														if (pixelImage->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 103)														int value;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 103)															value = c;
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found = true;
            											}
            											else {
HXLINE( 103)												if (found) {
HXLINE( 103)													goto _hx_goto_214;
            												}
            											}
            										}
            									}
            									_hx_goto_214:;
            								}
            							}
            						}
HXDLIN( 103)						::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN( 103)						::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN( 103)						int v_undoY;
HXDLIN( 103)						int v_undoX;
HXDLIN( 103)						Float v_ty;
HXDLIN( 103)						Float v_tx;
HXDLIN( 103)						Float v_t0;
HXDLIN( 103)						Float v_sy;
HXDLIN( 103)						Float v_sx;
HXDLIN( 103)						Float v_s0;
HXDLIN( 103)						Float v_A;
HXDLIN( 103)						Float ax1 = ax;
HXDLIN( 103)						Float ay1 = ay;
HXDLIN( 103)						Float bx2 = bx1;
HXDLIN( 103)						Float by2 = by1;
HXDLIN( 103)						Float cx2 = cx1;
HXDLIN( 103)						Float cy2 = cy1;
HXDLIN( 103)						::pixelimage::ImageStruct v_undoImage = null();
HXDLIN( 103)						bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN( 103)						if (!(adjustWinding1)) {
HXLINE( 103)							Float bx_ = bx2;
HXDLIN( 103)							Float by_ = by2;
HXLINE(  35)							bx2 = cx2;
HXLINE(  36)							by2 = cy2;
HXLINE(  37)							cx2 = bx_;
HXLINE(  38)							cy2 = by_;
            						}
HXLINE( 103)						Float v_ax = ax1;
HXDLIN( 103)						Float v_ay = ay1;
HXDLIN( 103)						Float v_bx = bx2;
HXDLIN( 103)						Float v_by = by2;
HXDLIN( 103)						Float v_cx = cx2;
HXDLIN( 103)						Float v_cy = cy2;
HXDLIN( 103)						bool v_preCalculated = true;
HXDLIN( 103)						{
HXLINE( 103)							v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 103)							v_sx = (v_cy - v_ay);
HXDLIN( 103)							v_sy = (v_ax - v_cx);
HXDLIN( 103)							v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 103)							v_tx = (v_ay - v_by);
HXDLIN( 103)							v_ty = (v_bx - v_ax);
HXDLIN( 103)							v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 103)							Float a1 = v_ax;
HXDLIN( 103)							Float b = v_bx;
HXDLIN( 103)							Float c = v_cx;
HXDLIN( 103)							if ((a1 > b)) {
HXLINE( 103)								if ((a1 > c)) {
HXLINE( 103)									int min;
HXDLIN( 103)									if ((b > c)) {
HXLINE( 103)										min = ::Math_obj::floor(c);
            									}
            									else {
HXLINE( 103)										min = ::Math_obj::floor(b);
            									}
HXDLIN( 103)									int ii_min = min;
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(a1);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_xIter3 = this1;
            								}
            								else {
HXLINE( 103)									int ii_min = ::Math_obj::floor(b);
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(c);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_xIter3 = this1;
            								}
            							}
            							else {
HXLINE( 103)								if ((b > c)) {
HXLINE( 103)									int min;
HXDLIN( 103)									if ((a1 > c)) {
HXLINE( 103)										min = ::Math_obj::floor(c);
            									}
            									else {
HXLINE( 103)										min = ::Math_obj::ceil(a1);
            									}
HXDLIN( 103)									int ii_min = min;
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(b);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_xIter3 = this1;
            								}
            								else {
HXLINE( 103)									int ii_min = ::Math_obj::floor(a1);
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(c);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_xIter3 = this1;
            								}
            							}
HXDLIN( 103)							Float a2 = v_ay;
HXDLIN( 103)							Float b1 = v_by;
HXDLIN( 103)							Float c1 = v_cy;
HXDLIN( 103)							if ((a2 > b1)) {
HXLINE( 103)								if ((a2 > c1)) {
HXLINE( 103)									int min;
HXDLIN( 103)									if ((b1 > c1)) {
HXLINE( 103)										min = ::Math_obj::floor(c1);
            									}
            									else {
HXLINE( 103)										min = ::Math_obj::floor(b1);
            									}
HXDLIN( 103)									int ii_min = min;
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(a2);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_yIter3 = this1;
            								}
            								else {
HXLINE( 103)									int ii_min = ::Math_obj::floor(b1);
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(c1);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_yIter3 = this1;
            								}
            							}
            							else {
HXLINE( 103)								if ((b1 > c1)) {
HXLINE( 103)									int min;
HXDLIN( 103)									if ((a2 > c1)) {
HXLINE( 103)										min = ::Math_obj::floor(c1);
            									}
            									else {
HXLINE( 103)										min = ::Math_obj::ceil(a2);
            									}
HXDLIN( 103)									int ii_min = min;
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(b1);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_yIter3 = this1;
            								}
            								else {
HXLINE( 103)									int ii_min = ::Math_obj::floor(a2);
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(c1);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_yIter3 = this1;
            								}
            							}
            						}
HXDLIN( 103)						if (hasUndo) {
HXLINE( 103)							v_undoImage = undoImage;
HXDLIN( 103)							v_undoX = xIter3->start;
HXDLIN( 103)							v_undoY = yIter3->start;
            						}
HXDLIN( 103)						Float bx3 = cx;
HXDLIN( 103)						Float by3 = cy;
HXDLIN( 103)						Float cx3 = dx;
HXDLIN( 103)						Float cy3 = dy;
HXDLIN( 103)						bool hasUndo1 = false;
HXDLIN( 103)						bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN( 103)						if (!(adjustWinding2)) {
HXLINE( 103)							Float bx_ = bx3;
HXDLIN( 103)							Float by_ = by3;
HXLINE(  26)							bx3 = cx3;
HXLINE(  27)							by3 = cy3;
HXLINE(  28)							cx3 = bx_;
HXLINE(  29)							cy3 = by_;
            						}
HXLINE( 103)						Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN( 103)						Float sx1 = (cy3 - by);
HXDLIN( 103)						Float sy1 = (bx - cx3);
HXDLIN( 103)						Float t01 = ((bx * by3) - (by * bx3));
HXDLIN( 103)						Float tx1 = (by - by3);
HXDLIN( 103)						Float ty1 = (bx3 - bx);
HXDLIN( 103)						Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 103)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 103)						if ((bx > bx3)) {
HXLINE( 103)							if ((bx > cx3)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((bx3 > cx3)) {
HXLINE( 103)									min = ::Math_obj::floor(cx3);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::floor(bx3);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter31 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(bx3);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE( 103)							if ((bx3 > cx3)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((bx > cx3)) {
HXLINE( 103)									min = ::Math_obj::floor(cx3);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::ceil(bx);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(bx3);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter31 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(bx);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter31 = this1;
            							}
            						}
HXDLIN( 103)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 103)						if ((by > by3)) {
HXLINE( 103)							if ((by > cy3)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((by3 > cy3)) {
HXLINE( 103)									min = ::Math_obj::floor(cy3);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::floor(by3);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(by);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter31 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(by3);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE( 103)							if ((by3 > cy3)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((by > cy3)) {
HXLINE( 103)									min = ::Math_obj::floor(cy3);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::ceil(by);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(by3);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter31 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(by);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter31 = this1;
            							}
            						}
HXDLIN( 103)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 103)						if (hasUndo1) {
HXLINE( 103)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 103)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 103)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 103)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 103)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 103)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 103)							undoImage1 = this3;
HXDLIN( 103)							{
HXLINE( 103)								int rectLeft = xIter31->start;
HXDLIN( 103)								int rectTop = yIter31->start;
HXDLIN( 103)								int rectRight = xIter31->max;
HXDLIN( 103)								bool forceClear = false;
HXDLIN( 103)								{
HXLINE( 103)									int _g = rectTop;
HXDLIN( 103)									int _g1 = yIter31->max;
HXDLIN( 103)									while((_g < _g1)){
HXLINE( 103)										_g = (_g + 1);
HXDLIN( 103)										int dy = (_g - 1);
HXDLIN( 103)										{
HXLINE( 103)											int _g1 = rectLeft;
HXDLIN( 103)											int _g2 = rectRight;
HXDLIN( 103)											while((_g1 < _g2)){
HXLINE( 103)												_g1 = (_g1 + 1);
HXDLIN( 103)												int dx = (_g1 - 1);
HXDLIN( 103)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)												int index;
HXDLIN( 103)												if (pixelImage->useVirtualPos) {
HXLINE( 103)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 103)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN( 103)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)												int col;
HXDLIN( 103)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 103)													col = c;
            												}
HXDLIN( 103)												bool _hx_tmp;
HXDLIN( 103)												if (pixelImage->useMask) {
HXLINE( 103)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE( 103)													_hx_tmp = false;
            												}
HXDLIN( 103)												if (_hx_tmp) {
HXLINE( 103)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN( 103)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 103)													int index;
HXDLIN( 103)													if (this1->useVirtualPos) {
HXLINE( 103)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 103)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 103)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 103)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 103)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)													int v;
HXDLIN( 103)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 103)														v = c;
            													}
HXDLIN( 103)													int this3 = v;
HXDLIN( 103)													int maskPixel = this3;
HXDLIN( 103)													int this4 = col;
HXDLIN( 103)													int this5 = this4;
HXDLIN( 103)													if ((maskPixel == 0)) {
HXLINE( 103)														int this1 = this5;
HXDLIN( 103)														col = this1;
            													}
            													else {
HXLINE( 103)														Float m0;
HXDLIN( 103)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 103)														if ((this1 == 0)) {
HXLINE( 103)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m1;
HXDLIN( 103)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 103)														if ((this2 == 0)) {
HXLINE( 103)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m2;
HXDLIN( 103)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 103)														if ((this3 == 0)) {
HXLINE( 103)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m3;
HXDLIN( 103)														int this4 = (maskPixel & 255);
HXDLIN( 103)														if ((this4 == 0)) {
HXLINE( 103)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 103)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 103)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 103)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 103)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 103)												if ((col != 0)) {
HXLINE( 103)													int x = (dx - rectLeft);
HXDLIN( 103)													int y = (dy - rectTop);
HXDLIN( 103)													int this1 = col;
HXDLIN( 103)													int c = this1;
HXDLIN( 103)													bool _hx_tmp;
HXDLIN( 103)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 103)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE( 103)														_hx_tmp = false;
            													}
HXDLIN( 103)													if (_hx_tmp) {
HXLINE( 103)														int location;
HXDLIN( 103)														if (undoImage1->useVirtualPos) {
HXLINE( 103)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 103)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 103)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 103)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)														int this3 = this2;
HXDLIN( 103)														int this4;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 103)															this4 = this3;
            														}
HXDLIN( 103)														Float a1;
HXDLIN( 103)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 103)														if ((this5 == 0)) {
HXLINE( 103)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r1;
HXDLIN( 103)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 103)														if ((this6 == 0)) {
HXLINE( 103)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g1;
HXDLIN( 103)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 103)														if ((this7 == 0)) {
HXLINE( 103)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b1;
HXDLIN( 103)														int this8 = (this4 & 255);
HXDLIN( 103)														if ((this8 == 0)) {
HXLINE( 103)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a2;
HXDLIN( 103)														int this9 = ((col >> 24) & 255);
HXDLIN( 103)														if ((this9 == 0)) {
HXLINE( 103)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r2;
HXDLIN( 103)														int this10 = ((col >> 16) & 255);
HXDLIN( 103)														if ((this10 == 0)) {
HXLINE( 103)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g2;
HXDLIN( 103)														int this11 = ((col >> 8) & 255);
HXDLIN( 103)														if ((this11 == 0)) {
HXLINE( 103)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b2;
HXDLIN( 103)														int this12 = (col & 255);
HXDLIN( 103)														if ((this12 == 0)) {
HXLINE( 103)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 103)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 103)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 103)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 103)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 103)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 103)														{
HXLINE( 103)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 103)															int value;
HXDLIN( 103)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 103)																value = blended;
            															}
HXDLIN( 103)															bool _hx_tmp;
HXDLIN( 103)															if ((location >= 0)) {
HXLINE( 103)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 103)																_hx_tmp = false;
            															}
HXDLIN( 103)															if (_hx_tmp) {
HXLINE( 103)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 103)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 103)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 103)														int index;
HXDLIN( 103)														if (undoImage1->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 103)														int value;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 103)															value = c;
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 103)													if (forceClear) {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 103)														int x = (dx - rectLeft);
HXDLIN( 103)														int y = (dy - rectTop);
HXDLIN( 103)														int index;
HXDLIN( 103)														if (undoImage1->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 103)						bool found1 = false;
HXDLIN( 103)						Float s1 = ((Float)0.);
HXDLIN( 103)						Float t1 = ((Float)0.);
HXDLIN( 103)						Float sxx1 = ((Float)0.);
HXDLIN( 103)						Float txx1 = ((Float)0.);
HXDLIN( 103)						{
HXLINE( 103)							int _g_min1 = xIter31->start;
HXDLIN( 103)							int _g_max1 = xIter31->max;
HXDLIN( 103)							while((_g_min1 < _g_max1)){
HXLINE( 103)								_g_min1 = (_g_min1 + 1);
HXDLIN( 103)								int x = (_g_min1 - 1);
HXLINE(  61)								sxx1 = (sx1 * ( (Float)(x) ));
HXLINE(  62)								txx1 = (tx1 * ( (Float)(x) ));
HXLINE(  63)								found1 = false;
HXLINE( 103)								{
HXLINE( 103)									int _g_min = yIter31->start;
HXDLIN( 103)									int _g_max = yIter31->max;
HXDLIN( 103)									while((_g_min < _g_max)){
HXLINE( 103)										_g_min = (_g_min + 1);
HXDLIN( 103)										int y = (_g_min - 1);
HXLINE(  65)										s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE(  66)										t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE( 103)										bool _hx_tmp;
HXDLIN( 103)										if (!((s1 <= 0))) {
HXLINE( 103)											_hx_tmp = (t1 <= 0);
            										}
            										else {
HXLINE( 103)											_hx_tmp = true;
            										}
HXDLIN( 103)										if (_hx_tmp) {
HXLINE( 103)											if (found1) {
HXLINE( 103)												goto _hx_goto_218;
            											}
            										}
            										else {
HXLINE( 103)											if (((s1 + t1) < A1)) {
HXLINE( 103)												{
HXLINE( 103)													int this1 = color;
HXDLIN( 103)													int c = this1;
HXDLIN( 103)													bool _hx_tmp;
HXDLIN( 103)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 103)														_hx_tmp = pixelImage->transparent;
            													}
            													else {
HXLINE( 103)														_hx_tmp = false;
            													}
HXDLIN( 103)													if (_hx_tmp) {
HXLINE( 103)														int location;
HXDLIN( 103)														if (pixelImage->useVirtualPos) {
HXLINE( 103)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 103)															location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 103)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 103)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)														int this3 = this2;
HXDLIN( 103)														int this4;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 103)															this4 = this3;
            														}
HXDLIN( 103)														Float a1;
HXDLIN( 103)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 103)														if ((this5 == 0)) {
HXLINE( 103)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r1;
HXDLIN( 103)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 103)														if ((this6 == 0)) {
HXLINE( 103)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g1;
HXDLIN( 103)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 103)														if ((this7 == 0)) {
HXLINE( 103)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b1;
HXDLIN( 103)														int this8 = (this4 & 255);
HXDLIN( 103)														if ((this8 == 0)) {
HXLINE( 103)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a2;
HXDLIN( 103)														int this9 = ((color >> 24) & 255);
HXDLIN( 103)														if ((this9 == 0)) {
HXLINE( 103)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r2;
HXDLIN( 103)														int this10 = ((color >> 16) & 255);
HXDLIN( 103)														if ((this10 == 0)) {
HXLINE( 103)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g2;
HXDLIN( 103)														int this11 = ((color >> 8) & 255);
HXDLIN( 103)														if ((this11 == 0)) {
HXLINE( 103)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b2;
HXDLIN( 103)														int this12 = (color & 255);
HXDLIN( 103)														if ((this12 == 0)) {
HXLINE( 103)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 103)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 103)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 103)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 103)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 103)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 103)														{
HXLINE( 103)															::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 103)															int value;
HXDLIN( 103)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 103)																value = blended;
            															}
HXDLIN( 103)															bool _hx_tmp;
HXDLIN( 103)															if ((location >= 0)) {
HXLINE( 103)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 103)																_hx_tmp = false;
            															}
HXDLIN( 103)															if (_hx_tmp) {
HXLINE( 103)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 103)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 103)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)														int index;
HXDLIN( 103)														if (pixelImage->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 103)														int value;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 103)															value = c;
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found1 = true;
            											}
            											else {
HXLINE( 103)												if (found1) {
HXLINE( 103)													goto _hx_goto_218;
            												}
            											}
            										}
            									}
            									_hx_goto_218:;
            								}
            							}
            						}
HXDLIN( 103)						::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN( 103)						::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN( 103)						int v_undoY1;
HXDLIN( 103)						int v_undoX1;
HXDLIN( 103)						Float v_ty1;
HXDLIN( 103)						Float v_tx1;
HXDLIN( 103)						Float v_t01;
HXDLIN( 103)						Float v_sy1;
HXDLIN( 103)						Float v_sx1;
HXDLIN( 103)						Float v_s01;
HXDLIN( 103)						Float v_A1;
HXDLIN( 103)						Float ax2 = bx;
HXDLIN( 103)						Float ay2 = by;
HXDLIN( 103)						Float bx4 = bx3;
HXDLIN( 103)						Float by4 = by3;
HXDLIN( 103)						Float cx4 = cx3;
HXDLIN( 103)						Float cy4 = cy3;
HXDLIN( 103)						::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN( 103)						bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN( 103)						if (!(adjustWinding3)) {
HXLINE( 103)							Float bx_ = bx4;
HXDLIN( 103)							Float by_ = by4;
HXLINE(  35)							bx4 = cx4;
HXLINE(  36)							by4 = cy4;
HXLINE(  37)							cx4 = bx_;
HXLINE(  38)							cy4 = by_;
            						}
HXLINE( 103)						Float v_ax1 = ax2;
HXDLIN( 103)						Float v_ay1 = ay2;
HXDLIN( 103)						Float v_bx1 = bx4;
HXDLIN( 103)						Float v_by1 = by4;
HXDLIN( 103)						Float v_cx1 = cx4;
HXDLIN( 103)						Float v_cy1 = cy4;
HXDLIN( 103)						bool v_preCalculated1 = true;
HXDLIN( 103)						{
HXLINE( 103)							v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 103)							v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 103)							v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 103)							v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 103)							v_tx1 = (v_ay1 - v_by1);
HXDLIN( 103)							v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 103)							v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 103)							Float a3 = v_ax1;
HXDLIN( 103)							Float b2 = v_bx1;
HXDLIN( 103)							Float c2 = v_cx1;
HXDLIN( 103)							if ((a3 > b2)) {
HXLINE( 103)								if ((a3 > c2)) {
HXLINE( 103)									int min;
HXDLIN( 103)									if ((b2 > c2)) {
HXLINE( 103)										min = ::Math_obj::floor(c2);
            									}
            									else {
HXLINE( 103)										min = ::Math_obj::floor(b2);
            									}
HXDLIN( 103)									int ii_min = min;
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(a3);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_xIter31 = this1;
            								}
            								else {
HXLINE( 103)									int ii_min = ::Math_obj::floor(b2);
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(c2);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_xIter31 = this1;
            								}
            							}
            							else {
HXLINE( 103)								if ((b2 > c2)) {
HXLINE( 103)									int min;
HXDLIN( 103)									if ((a3 > c2)) {
HXLINE( 103)										min = ::Math_obj::floor(c2);
            									}
            									else {
HXLINE( 103)										min = ::Math_obj::ceil(a3);
            									}
HXDLIN( 103)									int ii_min = min;
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(b2);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_xIter31 = this1;
            								}
            								else {
HXLINE( 103)									int ii_min = ::Math_obj::floor(a3);
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(c2);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_xIter31 = this1;
            								}
            							}
HXDLIN( 103)							Float a4 = v_ay1;
HXDLIN( 103)							Float b3 = v_by1;
HXDLIN( 103)							Float c3 = v_cy1;
HXDLIN( 103)							if ((a4 > b3)) {
HXLINE( 103)								if ((a4 > c3)) {
HXLINE( 103)									int min;
HXDLIN( 103)									if ((b3 > c3)) {
HXLINE( 103)										min = ::Math_obj::floor(c3);
            									}
            									else {
HXLINE( 103)										min = ::Math_obj::floor(b3);
            									}
HXDLIN( 103)									int ii_min = min;
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(a4);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_yIter31 = this1;
            								}
            								else {
HXLINE( 103)									int ii_min = ::Math_obj::floor(b3);
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(c3);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_yIter31 = this1;
            								}
            							}
            							else {
HXLINE( 103)								if ((b3 > c3)) {
HXLINE( 103)									int min;
HXDLIN( 103)									if ((a4 > c3)) {
HXLINE( 103)										min = ::Math_obj::floor(c3);
            									}
            									else {
HXLINE( 103)										min = ::Math_obj::ceil(a4);
            									}
HXDLIN( 103)									int ii_min = min;
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(b3);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_yIter31 = this1;
            								}
            								else {
HXLINE( 103)									int ii_min = ::Math_obj::floor(a4);
HXDLIN( 103)									int ii_max = ::Math_obj::ceil(c3);
HXDLIN( 103)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)									v_yIter31 = this1;
            								}
            							}
            						}
HXDLIN( 103)						if (hasUndo1) {
HXLINE( 103)							v_undoImage1 = undoImage1;
HXDLIN( 103)							v_undoX1 = xIter31->start;
HXDLIN( 103)							v_undoY1 = yIter31->start;
            						}
HXDLIN( 103)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 103)						::pixelimage::algo::HitQuad hitQuad = v;
HXDLIN( 103)						Float cx5 = h2;
HXDLIN( 103)						Float cy5 = radius2;
HXDLIN( 103)						Float bx5 = h2;
HXDLIN( 103)						Float by5 = -(radius2);
HXDLIN( 103)						Float dx1 = hSmall;
HXDLIN( 103)						Float dy1 = radius2;
HXDLIN( 103)						Float ax3 = hSmall;
HXDLIN( 103)						Float ay3 = -(radius2);
HXLINE( 592)						temp = (px + ((bx5 * cos) - (by5 * sin)));
HXLINE( 593)						by5 = (py + ((by5 * cos) + (bx5 * sin)));
HXLINE( 594)						bx5 = temp;
HXLINE( 595)						temp = (px + ((cx5 * cos) - (cy5 * sin)));
HXLINE( 596)						cy5 = (py + ((cy5 * cos) + (cx5 * sin)));
HXLINE( 597)						cx5 = temp;
HXLINE( 599)						temp = (px + ((ax3 * cos) - (ay3 * sin)));
HXLINE( 600)						ay3 = (py + ((ay3 * cos) + (ax3 * sin)));
HXLINE( 601)						ax3 = temp;
HXLINE( 603)						temp = (px + ((dx1 * cos) - (dy1 * sin)));
HXLINE( 604)						dy1 = (py + ((dy1 * cos) + (dx1 * sin)));
HXLINE( 605)						dx1 = temp;
HXLINE( 103)						Float bx6 = bx5;
HXDLIN( 103)						Float by6 = by5;
HXDLIN( 103)						Float cx6 = cx5;
HXDLIN( 103)						Float cy6 = cy5;
HXDLIN( 103)						bool hasUndo2 = false;
HXDLIN( 103)						bool adjustWinding4 = (((((px * by6) - (bx6 * py)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * py) - (px * cy6))) > 0);
HXDLIN( 103)						if (!(adjustWinding4)) {
HXLINE( 103)							Float bx_ = bx6;
HXDLIN( 103)							Float by_ = by6;
HXLINE(  26)							bx6 = cx6;
HXLINE(  27)							by6 = cy6;
HXLINE(  28)							cx6 = bx_;
HXLINE(  29)							cy6 = by_;
            						}
HXLINE( 103)						Float s02 = ((py * cx6) - (px * cy6));
HXDLIN( 103)						Float sx2 = (cy6 - py);
HXDLIN( 103)						Float sy2 = (px - cx6);
HXDLIN( 103)						Float t02 = ((px * by6) - (py * bx6));
HXDLIN( 103)						Float tx2 = (py - by6);
HXDLIN( 103)						Float ty2 = (bx6 - px);
HXDLIN( 103)						Float A2 = ((((-(by6) * cx6) + (py * (-(bx6) + cx6))) + (px * (by6 - cy6))) + (bx6 * cy6));
HXDLIN( 103)						::pixelimage::iter::IntIterStart xIter32;
HXDLIN( 103)						if ((px > bx6)) {
HXLINE( 103)							if ((px > cx6)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((bx6 > cx6)) {
HXLINE( 103)									min = ::Math_obj::floor(cx6);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::floor(bx6);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(px);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter32 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(bx6);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cx6);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter32 = this1;
            							}
            						}
            						else {
HXLINE( 103)							if ((bx6 > cx6)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((px > cx6)) {
HXLINE( 103)									min = ::Math_obj::floor(cx6);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::ceil(px);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(bx6);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter32 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(px);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cx6);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter32 = this1;
            							}
            						}
HXDLIN( 103)						::pixelimage::iter::IntIterStart yIter32;
HXDLIN( 103)						if ((py > by6)) {
HXLINE( 103)							if ((py > cy6)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((by6 > cy6)) {
HXLINE( 103)									min = ::Math_obj::floor(cy6);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::floor(by6);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(py);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter32 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(by6);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cy6);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter32 = this1;
            							}
            						}
            						else {
HXLINE( 103)							if ((by6 > cy6)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((py > cy6)) {
HXLINE( 103)									min = ::Math_obj::floor(cy6);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::ceil(py);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(by6);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter32 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(py);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cy6);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter32 = this1;
            							}
            						}
HXDLIN( 103)						::pixelimage::ImageStruct undoImage2 = null();
HXDLIN( 103)						if (hasUndo2) {
HXLINE( 103)							int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 103)							int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 103)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 103)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 103)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 103)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 103)							undoImage2 = this3;
HXDLIN( 103)							{
HXLINE( 103)								int rectLeft = xIter32->start;
HXDLIN( 103)								int rectTop = yIter32->start;
HXDLIN( 103)								int rectRight = xIter32->max;
HXDLIN( 103)								bool forceClear = false;
HXDLIN( 103)								{
HXLINE( 103)									int _g = rectTop;
HXDLIN( 103)									int _g1 = yIter32->max;
HXDLIN( 103)									while((_g < _g1)){
HXLINE( 103)										_g = (_g + 1);
HXDLIN( 103)										int dy = (_g - 1);
HXDLIN( 103)										{
HXLINE( 103)											int _g1 = rectLeft;
HXDLIN( 103)											int _g2 = rectRight;
HXDLIN( 103)											while((_g1 < _g2)){
HXLINE( 103)												_g1 = (_g1 + 1);
HXDLIN( 103)												int dx = (_g1 - 1);
HXDLIN( 103)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)												int index;
HXDLIN( 103)												if (pixelImage->useVirtualPos) {
HXLINE( 103)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 103)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN( 103)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)												int col;
HXDLIN( 103)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 103)													col = c;
            												}
HXDLIN( 103)												bool _hx_tmp;
HXDLIN( 103)												if (pixelImage->useMask) {
HXLINE( 103)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE( 103)													_hx_tmp = false;
            												}
HXDLIN( 103)												if (_hx_tmp) {
HXLINE( 103)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN( 103)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 103)													int index;
HXDLIN( 103)													if (this1->useVirtualPos) {
HXLINE( 103)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 103)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 103)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 103)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 103)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)													int v;
HXDLIN( 103)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 103)														v = c;
            													}
HXDLIN( 103)													int this3 = v;
HXDLIN( 103)													int maskPixel = this3;
HXDLIN( 103)													int this4 = col;
HXDLIN( 103)													int this5 = this4;
HXDLIN( 103)													if ((maskPixel == 0)) {
HXLINE( 103)														int this1 = this5;
HXDLIN( 103)														col = this1;
            													}
            													else {
HXLINE( 103)														Float m0;
HXDLIN( 103)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 103)														if ((this1 == 0)) {
HXLINE( 103)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m1;
HXDLIN( 103)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 103)														if ((this2 == 0)) {
HXLINE( 103)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m2;
HXDLIN( 103)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 103)														if ((this3 == 0)) {
HXLINE( 103)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m3;
HXDLIN( 103)														int this4 = (maskPixel & 255);
HXDLIN( 103)														if ((this4 == 0)) {
HXLINE( 103)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 103)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 103)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 103)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 103)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 103)												if ((col != 0)) {
HXLINE( 103)													int x = (dx - rectLeft);
HXDLIN( 103)													int y = (dy - rectTop);
HXDLIN( 103)													int this1 = col;
HXDLIN( 103)													int c = this1;
HXDLIN( 103)													bool _hx_tmp;
HXDLIN( 103)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 103)														_hx_tmp = undoImage2->transparent;
            													}
            													else {
HXLINE( 103)														_hx_tmp = false;
            													}
HXDLIN( 103)													if (_hx_tmp) {
HXLINE( 103)														int location;
HXDLIN( 103)														if (undoImage2->useVirtualPos) {
HXLINE( 103)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 103)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 103)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 103)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)														int this3 = this2;
HXDLIN( 103)														int this4;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 103)															this4 = this3;
            														}
HXDLIN( 103)														Float a1;
HXDLIN( 103)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 103)														if ((this5 == 0)) {
HXLINE( 103)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r1;
HXDLIN( 103)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 103)														if ((this6 == 0)) {
HXLINE( 103)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g1;
HXDLIN( 103)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 103)														if ((this7 == 0)) {
HXLINE( 103)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b1;
HXDLIN( 103)														int this8 = (this4 & 255);
HXDLIN( 103)														if ((this8 == 0)) {
HXLINE( 103)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a2;
HXDLIN( 103)														int this9 = ((col >> 24) & 255);
HXDLIN( 103)														if ((this9 == 0)) {
HXLINE( 103)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r2;
HXDLIN( 103)														int this10 = ((col >> 16) & 255);
HXDLIN( 103)														if ((this10 == 0)) {
HXLINE( 103)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g2;
HXDLIN( 103)														int this11 = ((col >> 8) & 255);
HXDLIN( 103)														if ((this11 == 0)) {
HXLINE( 103)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b2;
HXDLIN( 103)														int this12 = (col & 255);
HXDLIN( 103)														if ((this12 == 0)) {
HXLINE( 103)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 103)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 103)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 103)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 103)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 103)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 103)														{
HXLINE( 103)															::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN( 103)															int value;
HXDLIN( 103)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 103)																value = blended;
            															}
HXDLIN( 103)															bool _hx_tmp;
HXDLIN( 103)															if ((location >= 0)) {
HXLINE( 103)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 103)																_hx_tmp = false;
            															}
HXDLIN( 103)															if (_hx_tmp) {
HXLINE( 103)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 103)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 103)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 103)														int index;
HXDLIN( 103)														if (undoImage2->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 103)														int value;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 103)															value = c;
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 103)													if (forceClear) {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 103)														int x = (dx - rectLeft);
HXDLIN( 103)														int y = (dy - rectTop);
HXDLIN( 103)														int index;
HXDLIN( 103)														if (undoImage2->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 103)						bool found2 = false;
HXDLIN( 103)						Float s2 = ((Float)0.);
HXDLIN( 103)						Float t2 = ((Float)0.);
HXDLIN( 103)						Float sxx2 = ((Float)0.);
HXDLIN( 103)						Float txx2 = ((Float)0.);
HXDLIN( 103)						{
HXLINE( 103)							int _g_min2 = xIter32->start;
HXDLIN( 103)							int _g_max2 = xIter32->max;
HXDLIN( 103)							while((_g_min2 < _g_max2)){
HXLINE( 103)								_g_min2 = (_g_min2 + 1);
HXDLIN( 103)								int x = (_g_min2 - 1);
HXLINE(  61)								sxx2 = (sx2 * ( (Float)(x) ));
HXLINE(  62)								txx2 = (tx2 * ( (Float)(x) ));
HXLINE(  63)								found2 = false;
HXLINE( 103)								{
HXLINE( 103)									int _g_min = yIter32->start;
HXDLIN( 103)									int _g_max = yIter32->max;
HXDLIN( 103)									while((_g_min < _g_max)){
HXLINE( 103)										_g_min = (_g_min + 1);
HXDLIN( 103)										int y = (_g_min - 1);
HXLINE(  65)										s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE(  66)										t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE( 103)										bool _hx_tmp;
HXDLIN( 103)										if (!((s2 <= 0))) {
HXLINE( 103)											_hx_tmp = (t2 <= 0);
            										}
            										else {
HXLINE( 103)											_hx_tmp = true;
            										}
HXDLIN( 103)										if (_hx_tmp) {
HXLINE( 103)											if (found2) {
HXLINE( 103)												goto _hx_goto_222;
            											}
            										}
            										else {
HXLINE( 103)											if (((s2 + t2) < A2)) {
HXLINE( 103)												{
HXLINE( 103)													int this1 = color;
HXDLIN( 103)													int c = this1;
HXDLIN( 103)													bool _hx_tmp;
HXDLIN( 103)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 103)														_hx_tmp = pixelImage->transparent;
            													}
            													else {
HXLINE( 103)														_hx_tmp = false;
            													}
HXDLIN( 103)													if (_hx_tmp) {
HXLINE( 103)														int location;
HXDLIN( 103)														if (pixelImage->useVirtualPos) {
HXLINE( 103)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 103)															location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 103)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 103)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)														int this3 = this2;
HXDLIN( 103)														int this4;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 103)															this4 = this3;
            														}
HXDLIN( 103)														Float a1;
HXDLIN( 103)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 103)														if ((this5 == 0)) {
HXLINE( 103)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r1;
HXDLIN( 103)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 103)														if ((this6 == 0)) {
HXLINE( 103)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g1;
HXDLIN( 103)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 103)														if ((this7 == 0)) {
HXLINE( 103)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b1;
HXDLIN( 103)														int this8 = (this4 & 255);
HXDLIN( 103)														if ((this8 == 0)) {
HXLINE( 103)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a2;
HXDLIN( 103)														int this9 = ((color >> 24) & 255);
HXDLIN( 103)														if ((this9 == 0)) {
HXLINE( 103)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r2;
HXDLIN( 103)														int this10 = ((color >> 16) & 255);
HXDLIN( 103)														if ((this10 == 0)) {
HXLINE( 103)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g2;
HXDLIN( 103)														int this11 = ((color >> 8) & 255);
HXDLIN( 103)														if ((this11 == 0)) {
HXLINE( 103)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b2;
HXDLIN( 103)														int this12 = (color & 255);
HXDLIN( 103)														if ((this12 == 0)) {
HXLINE( 103)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 103)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 103)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 103)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 103)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 103)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 103)														{
HXLINE( 103)															::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 103)															int value;
HXDLIN( 103)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 103)																value = blended;
            															}
HXDLIN( 103)															bool _hx_tmp;
HXDLIN( 103)															if ((location >= 0)) {
HXLINE( 103)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 103)																_hx_tmp = false;
            															}
HXDLIN( 103)															if (_hx_tmp) {
HXLINE( 103)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 103)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 103)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)														int index;
HXDLIN( 103)														if (pixelImage->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 103)														int value;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 103)															value = c;
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found2 = true;
            											}
            											else {
HXLINE( 103)												if (found2) {
HXLINE( 103)													goto _hx_goto_222;
            												}
            											}
            										}
            									}
            									_hx_goto_222:;
            								}
            							}
            						}
HXDLIN( 103)						::pixelimage::algo::HitTri hitTriTop;
HXDLIN( 103)						if ((hasHit == true)) {
HXLINE( 103)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx6,by6,cx6,cy6,true);
HXDLIN( 103)							if (hasUndo2) {
HXLINE( 103)								v->undoImage = undoImage2;
HXDLIN( 103)								v->undoX = xIter32->start;
HXDLIN( 103)								v->undoY = yIter32->start;
            							}
HXDLIN( 103)							hitTriTop = v;
            						}
            						else {
HXLINE( 103)							hitTriTop = null();
            						}
HXDLIN( 103)						Float bx7 = ax3;
HXDLIN( 103)						Float by7 = ay3;
HXDLIN( 103)						Float cx7 = dx1;
HXDLIN( 103)						Float cy7 = dy1;
HXDLIN( 103)						bool hasUndo3 = false;
HXDLIN( 103)						bool adjustWinding5 = (((((px * by7) - (bx7 * py)) + ((bx7 * cy7) - (cx7 * by7))) + ((cx7 * py) - (px * cy7))) > 0);
HXDLIN( 103)						if (!(adjustWinding5)) {
HXLINE( 103)							Float bx_ = bx7;
HXDLIN( 103)							Float by_ = by7;
HXLINE(  26)							bx7 = cx7;
HXLINE(  27)							by7 = cy7;
HXLINE(  28)							cx7 = bx_;
HXLINE(  29)							cy7 = by_;
            						}
HXLINE( 103)						Float s03 = ((py * cx7) - (px * cy7));
HXDLIN( 103)						Float sx3 = (cy7 - py);
HXDLIN( 103)						Float sy3 = (px - cx7);
HXDLIN( 103)						Float t03 = ((px * by7) - (py * bx7));
HXDLIN( 103)						Float tx3 = (py - by7);
HXDLIN( 103)						Float ty3 = (bx7 - px);
HXDLIN( 103)						Float A3 = ((((-(by7) * cx7) + (py * (-(bx7) + cx7))) + (px * (by7 - cy7))) + (bx7 * cy7));
HXDLIN( 103)						::pixelimage::iter::IntIterStart xIter33;
HXDLIN( 103)						if ((px > bx7)) {
HXLINE( 103)							if ((px > cx7)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((bx7 > cx7)) {
HXLINE( 103)									min = ::Math_obj::floor(cx7);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::floor(bx7);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(px);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter33 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(bx7);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cx7);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter33 = this1;
            							}
            						}
            						else {
HXLINE( 103)							if ((bx7 > cx7)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((px > cx7)) {
HXLINE( 103)									min = ::Math_obj::floor(cx7);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::ceil(px);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(bx7);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter33 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(px);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cx7);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								xIter33 = this1;
            							}
            						}
HXDLIN( 103)						::pixelimage::iter::IntIterStart yIter33;
HXDLIN( 103)						if ((py > by7)) {
HXLINE( 103)							if ((py > cy7)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((by7 > cy7)) {
HXLINE( 103)									min = ::Math_obj::floor(cy7);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::floor(by7);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(py);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter33 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(by7);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cy7);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter33 = this1;
            							}
            						}
            						else {
HXLINE( 103)							if ((by7 > cy7)) {
HXLINE( 103)								int min;
HXDLIN( 103)								if ((py > cy7)) {
HXLINE( 103)									min = ::Math_obj::floor(cy7);
            								}
            								else {
HXLINE( 103)									min = ::Math_obj::ceil(py);
            								}
HXDLIN( 103)								int ii_min = min;
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(by7);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter33 = this1;
            							}
            							else {
HXLINE( 103)								int ii_min = ::Math_obj::floor(py);
HXDLIN( 103)								int ii_max = ::Math_obj::ceil(cy7);
HXDLIN( 103)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 103)								yIter33 = this1;
            							}
            						}
HXDLIN( 103)						::pixelimage::ImageStruct undoImage3 = null();
HXDLIN( 103)						if (hasUndo3) {
HXLINE( 103)							int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 103)							int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 103)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 103)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 103)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 103)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 103)							undoImage3 = this3;
HXDLIN( 103)							{
HXLINE( 103)								int rectLeft = xIter33->start;
HXDLIN( 103)								int rectTop = yIter33->start;
HXDLIN( 103)								int rectRight = xIter33->max;
HXDLIN( 103)								bool forceClear = false;
HXDLIN( 103)								{
HXLINE( 103)									int _g = rectTop;
HXDLIN( 103)									int _g1 = yIter33->max;
HXDLIN( 103)									while((_g < _g1)){
HXLINE( 103)										_g = (_g + 1);
HXDLIN( 103)										int dy = (_g - 1);
HXDLIN( 103)										{
HXLINE( 103)											int _g1 = rectLeft;
HXDLIN( 103)											int _g2 = rectRight;
HXDLIN( 103)											while((_g1 < _g2)){
HXLINE( 103)												_g1 = (_g1 + 1);
HXDLIN( 103)												int dx = (_g1 - 1);
HXDLIN( 103)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)												int index;
HXDLIN( 103)												if (pixelImage->useVirtualPos) {
HXLINE( 103)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 103)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN( 103)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)												int col;
HXDLIN( 103)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 103)													col = c;
            												}
HXDLIN( 103)												bool _hx_tmp;
HXDLIN( 103)												if (pixelImage->useMask) {
HXLINE( 103)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE( 103)													_hx_tmp = false;
            												}
HXDLIN( 103)												if (_hx_tmp) {
HXLINE( 103)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN( 103)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 103)													int index;
HXDLIN( 103)													if (this1->useVirtualPos) {
HXLINE( 103)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 103)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 103)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 103)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 103)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)													int v;
HXDLIN( 103)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 103)														v = c;
            													}
HXDLIN( 103)													int this3 = v;
HXDLIN( 103)													int maskPixel = this3;
HXDLIN( 103)													int this4 = col;
HXDLIN( 103)													int this5 = this4;
HXDLIN( 103)													if ((maskPixel == 0)) {
HXLINE( 103)														int this1 = this5;
HXDLIN( 103)														col = this1;
            													}
            													else {
HXLINE( 103)														Float m0;
HXDLIN( 103)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 103)														if ((this1 == 0)) {
HXLINE( 103)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m1;
HXDLIN( 103)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 103)														if ((this2 == 0)) {
HXLINE( 103)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m2;
HXDLIN( 103)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 103)														if ((this3 == 0)) {
HXLINE( 103)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float m3;
HXDLIN( 103)														int this4 = (maskPixel & 255);
HXDLIN( 103)														if ((this4 == 0)) {
HXLINE( 103)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 103)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 103)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 103)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 103)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 103)												if ((col != 0)) {
HXLINE( 103)													int x = (dx - rectLeft);
HXDLIN( 103)													int y = (dy - rectTop);
HXDLIN( 103)													int this1 = col;
HXDLIN( 103)													int c = this1;
HXDLIN( 103)													bool _hx_tmp;
HXDLIN( 103)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 103)														_hx_tmp = undoImage3->transparent;
            													}
            													else {
HXLINE( 103)														_hx_tmp = false;
            													}
HXDLIN( 103)													if (_hx_tmp) {
HXLINE( 103)														int location;
HXDLIN( 103)														if (undoImage3->useVirtualPos) {
HXLINE( 103)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 103)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 103)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 103)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)														int this3 = this2;
HXDLIN( 103)														int this4;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 103)															this4 = this3;
            														}
HXDLIN( 103)														Float a1;
HXDLIN( 103)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 103)														if ((this5 == 0)) {
HXLINE( 103)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r1;
HXDLIN( 103)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 103)														if ((this6 == 0)) {
HXLINE( 103)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g1;
HXDLIN( 103)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 103)														if ((this7 == 0)) {
HXLINE( 103)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b1;
HXDLIN( 103)														int this8 = (this4 & 255);
HXDLIN( 103)														if ((this8 == 0)) {
HXLINE( 103)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a2;
HXDLIN( 103)														int this9 = ((col >> 24) & 255);
HXDLIN( 103)														if ((this9 == 0)) {
HXLINE( 103)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r2;
HXDLIN( 103)														int this10 = ((col >> 16) & 255);
HXDLIN( 103)														if ((this10 == 0)) {
HXLINE( 103)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g2;
HXDLIN( 103)														int this11 = ((col >> 8) & 255);
HXDLIN( 103)														if ((this11 == 0)) {
HXLINE( 103)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b2;
HXDLIN( 103)														int this12 = (col & 255);
HXDLIN( 103)														if ((this12 == 0)) {
HXLINE( 103)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 103)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 103)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 103)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 103)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 103)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 103)														{
HXLINE( 103)															::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN( 103)															int value;
HXDLIN( 103)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 103)																value = blended;
            															}
HXDLIN( 103)															bool _hx_tmp;
HXDLIN( 103)															if ((location >= 0)) {
HXLINE( 103)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 103)																_hx_tmp = false;
            															}
HXDLIN( 103)															if (_hx_tmp) {
HXLINE( 103)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 103)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 103)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 103)														int index;
HXDLIN( 103)														if (undoImage3->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 103)														int value;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 103)															value = c;
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 103)													if (forceClear) {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 103)														int x = (dx - rectLeft);
HXDLIN( 103)														int y = (dy - rectTop);
HXDLIN( 103)														int index;
HXDLIN( 103)														if (undoImage3->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 103)						bool found3 = false;
HXDLIN( 103)						Float s3 = ((Float)0.);
HXDLIN( 103)						Float t3 = ((Float)0.);
HXDLIN( 103)						Float sxx3 = ((Float)0.);
HXDLIN( 103)						Float txx3 = ((Float)0.);
HXDLIN( 103)						{
HXLINE( 103)							int _g_min3 = xIter33->start;
HXDLIN( 103)							int _g_max3 = xIter33->max;
HXDLIN( 103)							while((_g_min3 < _g_max3)){
HXLINE( 103)								_g_min3 = (_g_min3 + 1);
HXDLIN( 103)								int x = (_g_min3 - 1);
HXLINE(  61)								sxx3 = (sx3 * ( (Float)(x) ));
HXLINE(  62)								txx3 = (tx3 * ( (Float)(x) ));
HXLINE(  63)								found3 = false;
HXLINE( 103)								{
HXLINE( 103)									int _g_min = yIter33->start;
HXDLIN( 103)									int _g_max = yIter33->max;
HXDLIN( 103)									while((_g_min < _g_max)){
HXLINE( 103)										_g_min = (_g_min + 1);
HXDLIN( 103)										int y = (_g_min - 1);
HXLINE(  65)										s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE(  66)										t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE( 103)										bool _hx_tmp;
HXDLIN( 103)										if (!((s3 <= 0))) {
HXLINE( 103)											_hx_tmp = (t3 <= 0);
            										}
            										else {
HXLINE( 103)											_hx_tmp = true;
            										}
HXDLIN( 103)										if (_hx_tmp) {
HXLINE( 103)											if (found3) {
HXLINE( 103)												goto _hx_goto_226;
            											}
            										}
            										else {
HXLINE( 103)											if (((s3 + t3) < A3)) {
HXLINE( 103)												{
HXLINE( 103)													int this1 = color;
HXDLIN( 103)													int c = this1;
HXDLIN( 103)													bool _hx_tmp;
HXDLIN( 103)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 103)														_hx_tmp = pixelImage->transparent;
            													}
            													else {
HXLINE( 103)														_hx_tmp = false;
            													}
HXDLIN( 103)													if (_hx_tmp) {
HXLINE( 103)														int location;
HXDLIN( 103)														if (pixelImage->useVirtualPos) {
HXLINE( 103)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 103)															location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 103)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 103)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 103)														int this3 = this2;
HXDLIN( 103)														int this4;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 103)															this4 = this3;
            														}
HXDLIN( 103)														Float a1;
HXDLIN( 103)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 103)														if ((this5 == 0)) {
HXLINE( 103)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r1;
HXDLIN( 103)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 103)														if ((this6 == 0)) {
HXLINE( 103)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g1;
HXDLIN( 103)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 103)														if ((this7 == 0)) {
HXLINE( 103)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b1;
HXDLIN( 103)														int this8 = (this4 & 255);
HXDLIN( 103)														if ((this8 == 0)) {
HXLINE( 103)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a2;
HXDLIN( 103)														int this9 = ((color >> 24) & 255);
HXDLIN( 103)														if ((this9 == 0)) {
HXLINE( 103)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float r2;
HXDLIN( 103)														int this10 = ((color >> 16) & 255);
HXDLIN( 103)														if ((this10 == 0)) {
HXLINE( 103)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float g2;
HXDLIN( 103)														int this11 = ((color >> 8) & 255);
HXDLIN( 103)														if ((this11 == 0)) {
HXLINE( 103)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float b2;
HXDLIN( 103)														int this12 = (color & 255);
HXDLIN( 103)														if ((this12 == 0)) {
HXLINE( 103)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 103)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 103)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 103)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 103)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 103)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 103)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 103)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 103)														{
HXLINE( 103)															::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 103)															int value;
HXDLIN( 103)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 103)																value = blended;
            															}
HXDLIN( 103)															bool _hx_tmp;
HXDLIN( 103)															if ((location >= 0)) {
HXLINE( 103)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 103)																_hx_tmp = false;
            															}
HXDLIN( 103)															if (_hx_tmp) {
HXLINE( 103)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 103)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 103)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 103)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 103)														int index;
HXDLIN( 103)														if (pixelImage->useVirtualPos) {
HXLINE( 103)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 103)															index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 103)														int value;
HXDLIN( 103)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 103)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 103)															value = c;
            														}
HXDLIN( 103)														bool _hx_tmp;
HXDLIN( 103)														if ((index >= 0)) {
HXLINE( 103)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 103)															_hx_tmp = false;
            														}
HXDLIN( 103)														if (_hx_tmp) {
HXLINE( 103)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 103)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 103)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 103)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 103)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 103)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found3 = true;
            											}
            											else {
HXLINE( 103)												if (found3) {
HXLINE( 103)													goto _hx_goto_226;
            												}
            											}
            										}
            									}
            									_hx_goto_226:;
            								}
            							}
            						}
HXDLIN( 103)						::pixelimage::algo::HitTri hitTriBottom;
HXDLIN( 103)						if ((hasHit == true)) {
HXLINE( 103)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx7,by7,cx7,cy7,true);
HXDLIN( 103)							if (hasUndo3) {
HXLINE( 103)								v->undoImage = undoImage3;
HXDLIN( 103)								v->undoX = xIter33->start;
HXDLIN( 103)								v->undoY = yIter33->start;
            							}
HXDLIN( 103)							hitTriBottom = v;
            						}
            						else {
HXLINE( 103)							hitTriBottom = null();
            						}
HXDLIN( 103)						if (hasHit) {
HXLINE( 103)							::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN( 103)							if (::hx::IsNotNull( hitQuad )) {
HXLINE( 103)								hitArr->triArr->push(hitQuad->triABD);
            							}
HXDLIN( 103)							hitArr->triArr->push(hitQuad->triBCD);
            						}
            					}
            				}
            				else {
HXLINE( 105)					Float thick = this->strokeWidth;
HXDLIN( 105)					int color = this->strokeColor;
HXDLIN( 105)					bool hasHit = true;
HXDLIN( 105)					{
HXLINE( 105)						Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 105)						Float o = (py - py);
HXDLIN( 105)						Float a = (px - px);
HXDLIN( 105)						Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 105)						Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 105)						Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN( 105)						Float sin = ::Math_obj::sin(theta);
HXDLIN( 105)						Float cos = ::Math_obj::cos(theta);
HXDLIN( 105)						Float radius = (thick / ( (Float)(2) ));
HXDLIN( 105)						Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 105)						Float h2 = (h / goldenRatio);
HXDLIN( 105)						Float hSmall = (h - h2);
HXDLIN( 105)						Float px_ = hSmall;
HXDLIN( 105)						Float py_ = ((Float)0.);
HXDLIN( 105)						Float temp = ((Float)0.);
HXLINE( 188)						temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 189)						py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 190)						px_ = temp;
HXLINE( 105)						Float h1 = (h2 - hSmall);
HXDLIN( 105)						Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 105)						Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 105)						Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 105)						Float dx = ((Float)0.1);
HXDLIN( 105)						Float dy = radius1;
HXDLIN( 105)						Float cx = h1;
HXDLIN( 105)						Float cy = radius1;
HXDLIN( 105)						Float bx = h1;
HXDLIN( 105)						Float by = -(radius1);
HXDLIN( 105)						Float ax = ((Float)0.1);
HXDLIN( 105)						Float ay = -(radius1);
HXDLIN( 105)						Float temp1 = ((Float)0.);
HXLINE(  28)						temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE(  29)						ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE(  30)						ax = temp1;
HXLINE(  32)						temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE(  33)						by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE(  34)						bx = temp1;
HXLINE(  36)						temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE(  37)						cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE(  38)						cx = temp1;
HXLINE(  40)						temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE(  41)						dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE(  42)						dx = temp1;
HXLINE( 105)						Float bx1 = bx;
HXDLIN( 105)						Float by1 = by;
HXDLIN( 105)						Float cx1 = dx;
HXDLIN( 105)						Float cy1 = dy;
HXDLIN( 105)						bool hasUndo = false;
HXDLIN( 105)						bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 105)						if (!(adjustWinding)) {
HXLINE( 105)							Float bx_ = bx1;
HXDLIN( 105)							Float by_ = by1;
HXLINE(  26)							bx1 = cx1;
HXLINE(  27)							by1 = cy1;
HXLINE(  28)							cx1 = bx_;
HXLINE(  29)							cy1 = by_;
            						}
HXLINE( 105)						Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 105)						Float sx = (cy1 - ay);
HXDLIN( 105)						Float sy = (ax - cx1);
HXDLIN( 105)						Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 105)						Float tx = (ay - by1);
HXDLIN( 105)						Float ty = (bx1 - ax);
HXDLIN( 105)						Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 105)						::pixelimage::iter::IntIterStart xIter3;
HXDLIN( 105)						if ((ax > bx1)) {
HXLINE( 105)							if ((ax > cx1)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((bx1 > cx1)) {
HXLINE( 105)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter3 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(bx1);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter3 = this1;
            							}
            						}
            						else {
HXLINE( 105)							if ((bx1 > cx1)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((ax > cx1)) {
HXLINE( 105)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::ceil(ax);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(bx1);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter3 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(ax);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cx1);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter3 = this1;
            							}
            						}
HXDLIN( 105)						::pixelimage::iter::IntIterStart yIter3;
HXDLIN( 105)						if ((ay > by1)) {
HXLINE( 105)							if ((ay > cy1)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((by1 > cy1)) {
HXLINE( 105)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::floor(by1);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(ay);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter3 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(by1);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter3 = this1;
            							}
            						}
            						else {
HXLINE( 105)							if ((by1 > cy1)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((ay > cy1)) {
HXLINE( 105)									min = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::ceil(ay);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(by1);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter3 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(ay);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cy1);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter3 = this1;
            							}
            						}
HXDLIN( 105)						::pixelimage::ImageStruct undoImage = null();
HXDLIN( 105)						if (hasUndo) {
HXLINE( 105)							int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 105)							int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 105)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 105)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 105)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 105)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 105)							undoImage = this3;
HXDLIN( 105)							{
HXLINE( 105)								int rectLeft = xIter3->start;
HXDLIN( 105)								int rectTop = yIter3->start;
HXDLIN( 105)								int rectRight = xIter3->max;
HXDLIN( 105)								bool forceClear = false;
HXDLIN( 105)								{
HXLINE( 105)									int _g = rectTop;
HXDLIN( 105)									int _g1 = yIter3->max;
HXDLIN( 105)									while((_g < _g1)){
HXLINE( 105)										_g = (_g + 1);
HXDLIN( 105)										int dy = (_g - 1);
HXDLIN( 105)										{
HXLINE( 105)											int _g1 = rectLeft;
HXDLIN( 105)											int _g2 = rectRight;
HXDLIN( 105)											while((_g1 < _g2)){
HXLINE( 105)												_g1 = (_g1 + 1);
HXDLIN( 105)												int dx = (_g1 - 1);
HXDLIN( 105)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)												int index;
HXDLIN( 105)												if (pixelImage->useVirtualPos) {
HXLINE( 105)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 105)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN( 105)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)												int col;
HXDLIN( 105)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 105)													col = c;
            												}
HXDLIN( 105)												bool _hx_tmp;
HXDLIN( 105)												if (pixelImage->useMask) {
HXLINE( 105)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE( 105)													_hx_tmp = false;
            												}
HXDLIN( 105)												if (_hx_tmp) {
HXLINE( 105)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN( 105)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 105)													int index;
HXDLIN( 105)													if (this1->useVirtualPos) {
HXLINE( 105)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 105)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 105)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 105)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 105)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)													int v;
HXDLIN( 105)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 105)														v = c;
            													}
HXDLIN( 105)													int this3 = v;
HXDLIN( 105)													int maskPixel = this3;
HXDLIN( 105)													int this4 = col;
HXDLIN( 105)													int this5 = this4;
HXDLIN( 105)													if ((maskPixel == 0)) {
HXLINE( 105)														int this1 = this5;
HXDLIN( 105)														col = this1;
            													}
            													else {
HXLINE( 105)														Float m0;
HXDLIN( 105)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 105)														if ((this1 == 0)) {
HXLINE( 105)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m1;
HXDLIN( 105)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 105)														if ((this2 == 0)) {
HXLINE( 105)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m2;
HXDLIN( 105)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 105)														if ((this3 == 0)) {
HXLINE( 105)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m3;
HXDLIN( 105)														int this4 = (maskPixel & 255);
HXDLIN( 105)														if ((this4 == 0)) {
HXLINE( 105)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 105)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 105)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 105)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 105)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 105)												if ((col != 0)) {
HXLINE( 105)													int x = (dx - rectLeft);
HXDLIN( 105)													int y = (dy - rectTop);
HXDLIN( 105)													int this1 = col;
HXDLIN( 105)													int c = this1;
HXDLIN( 105)													bool _hx_tmp;
HXDLIN( 105)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 105)														_hx_tmp = undoImage->transparent;
            													}
            													else {
HXLINE( 105)														_hx_tmp = false;
            													}
HXDLIN( 105)													if (_hx_tmp) {
HXLINE( 105)														int location;
HXDLIN( 105)														if (undoImage->useVirtualPos) {
HXLINE( 105)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 105)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 105)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 105)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)														int this3 = this2;
HXDLIN( 105)														int this4;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 105)															this4 = this3;
            														}
HXDLIN( 105)														Float a1;
HXDLIN( 105)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 105)														if ((this5 == 0)) {
HXLINE( 105)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r1;
HXDLIN( 105)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 105)														if ((this6 == 0)) {
HXLINE( 105)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g1;
HXDLIN( 105)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 105)														if ((this7 == 0)) {
HXLINE( 105)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b1;
HXDLIN( 105)														int this8 = (this4 & 255);
HXDLIN( 105)														if ((this8 == 0)) {
HXLINE( 105)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a2;
HXDLIN( 105)														int this9 = ((col >> 24) & 255);
HXDLIN( 105)														if ((this9 == 0)) {
HXLINE( 105)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r2;
HXDLIN( 105)														int this10 = ((col >> 16) & 255);
HXDLIN( 105)														if ((this10 == 0)) {
HXLINE( 105)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g2;
HXDLIN( 105)														int this11 = ((col >> 8) & 255);
HXDLIN( 105)														if ((this11 == 0)) {
HXLINE( 105)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b2;
HXDLIN( 105)														int this12 = (col & 255);
HXDLIN( 105)														if ((this12 == 0)) {
HXLINE( 105)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 105)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 105)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 105)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 105)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 105)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 105)														{
HXLINE( 105)															::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN( 105)															int value;
HXDLIN( 105)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 105)																value = blended;
            															}
HXDLIN( 105)															bool _hx_tmp;
HXDLIN( 105)															if ((location >= 0)) {
HXLINE( 105)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 105)																_hx_tmp = false;
            															}
HXDLIN( 105)															if (_hx_tmp) {
HXLINE( 105)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 105)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 105)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 105)														int index;
HXDLIN( 105)														if (undoImage->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 105)														int value;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 105)															value = c;
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 105)													if (forceClear) {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN( 105)														int x = (dx - rectLeft);
HXDLIN( 105)														int y = (dy - rectTop);
HXDLIN( 105)														int index;
HXDLIN( 105)														if (undoImage->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 105)						bool found = false;
HXDLIN( 105)						Float s = ((Float)0.);
HXDLIN( 105)						Float t = ((Float)0.);
HXDLIN( 105)						Float sxx = ((Float)0.);
HXDLIN( 105)						Float txx = ((Float)0.);
HXDLIN( 105)						{
HXLINE( 105)							int _g_min = xIter3->start;
HXDLIN( 105)							int _g_max = xIter3->max;
HXDLIN( 105)							while((_g_min < _g_max)){
HXLINE( 105)								_g_min = (_g_min + 1);
HXDLIN( 105)								int x = (_g_min - 1);
HXLINE(  61)								sxx = (sx * ( (Float)(x) ));
HXLINE(  62)								txx = (tx * ( (Float)(x) ));
HXLINE(  63)								found = false;
HXLINE( 105)								{
HXLINE( 105)									int _g_min1 = yIter3->start;
HXDLIN( 105)									int _g_max = yIter3->max;
HXDLIN( 105)									while((_g_min1 < _g_max)){
HXLINE( 105)										_g_min1 = (_g_min1 + 1);
HXDLIN( 105)										int y = (_g_min1 - 1);
HXLINE(  65)										s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)										t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE( 105)										bool _hx_tmp;
HXDLIN( 105)										if (!((s <= 0))) {
HXLINE( 105)											_hx_tmp = (t <= 0);
            										}
            										else {
HXLINE( 105)											_hx_tmp = true;
            										}
HXDLIN( 105)										if (_hx_tmp) {
HXLINE( 105)											if (found) {
HXLINE( 105)												goto _hx_goto_230;
            											}
            										}
            										else {
HXLINE( 105)											if (((s + t) < A)) {
HXLINE( 105)												{
HXLINE( 105)													int this1 = color;
HXDLIN( 105)													int c = this1;
HXDLIN( 105)													bool _hx_tmp;
HXDLIN( 105)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 105)														_hx_tmp = pixelImage->transparent;
            													}
            													else {
HXLINE( 105)														_hx_tmp = false;
            													}
HXDLIN( 105)													if (_hx_tmp) {
HXLINE( 105)														int location;
HXDLIN( 105)														if (pixelImage->useVirtualPos) {
HXLINE( 105)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 105)															location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 105)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 105)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)														int this3 = this2;
HXDLIN( 105)														int this4;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 105)															this4 = this3;
            														}
HXDLIN( 105)														Float a1;
HXDLIN( 105)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 105)														if ((this5 == 0)) {
HXLINE( 105)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r1;
HXDLIN( 105)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 105)														if ((this6 == 0)) {
HXLINE( 105)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g1;
HXDLIN( 105)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 105)														if ((this7 == 0)) {
HXLINE( 105)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b1;
HXDLIN( 105)														int this8 = (this4 & 255);
HXDLIN( 105)														if ((this8 == 0)) {
HXLINE( 105)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a2;
HXDLIN( 105)														int this9 = ((color >> 24) & 255);
HXDLIN( 105)														if ((this9 == 0)) {
HXLINE( 105)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r2;
HXDLIN( 105)														int this10 = ((color >> 16) & 255);
HXDLIN( 105)														if ((this10 == 0)) {
HXLINE( 105)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g2;
HXDLIN( 105)														int this11 = ((color >> 8) & 255);
HXDLIN( 105)														if ((this11 == 0)) {
HXLINE( 105)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b2;
HXDLIN( 105)														int this12 = (color & 255);
HXDLIN( 105)														if ((this12 == 0)) {
HXLINE( 105)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 105)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 105)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 105)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 105)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 105)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 105)														{
HXLINE( 105)															::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 105)															int value;
HXDLIN( 105)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 105)																value = blended;
            															}
HXDLIN( 105)															bool _hx_tmp;
HXDLIN( 105)															if ((location >= 0)) {
HXLINE( 105)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 105)																_hx_tmp = false;
            															}
HXDLIN( 105)															if (_hx_tmp) {
HXLINE( 105)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 105)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 105)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)														int index;
HXDLIN( 105)														if (pixelImage->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 105)														int value;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 105)															value = c;
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found = true;
            											}
            											else {
HXLINE( 105)												if (found) {
HXLINE( 105)													goto _hx_goto_230;
            												}
            											}
            										}
            									}
            									_hx_goto_230:;
            								}
            							}
            						}
HXDLIN( 105)						::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN( 105)						::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN( 105)						int v_undoY;
HXDLIN( 105)						int v_undoX;
HXDLIN( 105)						Float v_ty;
HXDLIN( 105)						Float v_tx;
HXDLIN( 105)						Float v_t0;
HXDLIN( 105)						Float v_sy;
HXDLIN( 105)						Float v_sx;
HXDLIN( 105)						Float v_s0;
HXDLIN( 105)						Float v_A;
HXDLIN( 105)						Float ax1 = ax;
HXDLIN( 105)						Float ay1 = ay;
HXDLIN( 105)						Float bx2 = bx1;
HXDLIN( 105)						Float by2 = by1;
HXDLIN( 105)						Float cx2 = cx1;
HXDLIN( 105)						Float cy2 = cy1;
HXDLIN( 105)						::pixelimage::ImageStruct v_undoImage = null();
HXDLIN( 105)						bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN( 105)						if (!(adjustWinding1)) {
HXLINE( 105)							Float bx_ = bx2;
HXDLIN( 105)							Float by_ = by2;
HXLINE(  35)							bx2 = cx2;
HXLINE(  36)							by2 = cy2;
HXLINE(  37)							cx2 = bx_;
HXLINE(  38)							cy2 = by_;
            						}
HXLINE( 105)						Float v_ax = ax1;
HXDLIN( 105)						Float v_ay = ay1;
HXDLIN( 105)						Float v_bx = bx2;
HXDLIN( 105)						Float v_by = by2;
HXDLIN( 105)						Float v_cx = cx2;
HXDLIN( 105)						Float v_cy = cy2;
HXDLIN( 105)						bool v_preCalculated = true;
HXDLIN( 105)						{
HXLINE( 105)							v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 105)							v_sx = (v_cy - v_ay);
HXDLIN( 105)							v_sy = (v_ax - v_cx);
HXDLIN( 105)							v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 105)							v_tx = (v_ay - v_by);
HXDLIN( 105)							v_ty = (v_bx - v_ax);
HXDLIN( 105)							v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 105)							Float a1 = v_ax;
HXDLIN( 105)							Float b = v_bx;
HXDLIN( 105)							Float c = v_cx;
HXDLIN( 105)							if ((a1 > b)) {
HXLINE( 105)								if ((a1 > c)) {
HXLINE( 105)									int min;
HXDLIN( 105)									if ((b > c)) {
HXLINE( 105)										min = ::Math_obj::floor(c);
            									}
            									else {
HXLINE( 105)										min = ::Math_obj::floor(b);
            									}
HXDLIN( 105)									int ii_min = min;
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(a1);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_xIter3 = this1;
            								}
            								else {
HXLINE( 105)									int ii_min = ::Math_obj::floor(b);
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(c);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_xIter3 = this1;
            								}
            							}
            							else {
HXLINE( 105)								if ((b > c)) {
HXLINE( 105)									int min;
HXDLIN( 105)									if ((a1 > c)) {
HXLINE( 105)										min = ::Math_obj::floor(c);
            									}
            									else {
HXLINE( 105)										min = ::Math_obj::ceil(a1);
            									}
HXDLIN( 105)									int ii_min = min;
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(b);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_xIter3 = this1;
            								}
            								else {
HXLINE( 105)									int ii_min = ::Math_obj::floor(a1);
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(c);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_xIter3 = this1;
            								}
            							}
HXDLIN( 105)							Float a2 = v_ay;
HXDLIN( 105)							Float b1 = v_by;
HXDLIN( 105)							Float c1 = v_cy;
HXDLIN( 105)							if ((a2 > b1)) {
HXLINE( 105)								if ((a2 > c1)) {
HXLINE( 105)									int min;
HXDLIN( 105)									if ((b1 > c1)) {
HXLINE( 105)										min = ::Math_obj::floor(c1);
            									}
            									else {
HXLINE( 105)										min = ::Math_obj::floor(b1);
            									}
HXDLIN( 105)									int ii_min = min;
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(a2);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_yIter3 = this1;
            								}
            								else {
HXLINE( 105)									int ii_min = ::Math_obj::floor(b1);
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(c1);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_yIter3 = this1;
            								}
            							}
            							else {
HXLINE( 105)								if ((b1 > c1)) {
HXLINE( 105)									int min;
HXDLIN( 105)									if ((a2 > c1)) {
HXLINE( 105)										min = ::Math_obj::floor(c1);
            									}
            									else {
HXLINE( 105)										min = ::Math_obj::ceil(a2);
            									}
HXDLIN( 105)									int ii_min = min;
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(b1);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_yIter3 = this1;
            								}
            								else {
HXLINE( 105)									int ii_min = ::Math_obj::floor(a2);
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(c1);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_yIter3 = this1;
            								}
            							}
            						}
HXDLIN( 105)						if (hasUndo) {
HXLINE( 105)							v_undoImage = undoImage;
HXDLIN( 105)							v_undoX = xIter3->start;
HXDLIN( 105)							v_undoY = yIter3->start;
            						}
HXDLIN( 105)						Float bx3 = cx;
HXDLIN( 105)						Float by3 = cy;
HXDLIN( 105)						Float cx3 = dx;
HXDLIN( 105)						Float cy3 = dy;
HXDLIN( 105)						bool hasUndo1 = false;
HXDLIN( 105)						bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN( 105)						if (!(adjustWinding2)) {
HXLINE( 105)							Float bx_ = bx3;
HXDLIN( 105)							Float by_ = by3;
HXLINE(  26)							bx3 = cx3;
HXLINE(  27)							by3 = cy3;
HXLINE(  28)							cx3 = bx_;
HXLINE(  29)							cy3 = by_;
            						}
HXLINE( 105)						Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN( 105)						Float sx1 = (cy3 - by);
HXDLIN( 105)						Float sy1 = (bx - cx3);
HXDLIN( 105)						Float t01 = ((bx * by3) - (by * bx3));
HXDLIN( 105)						Float tx1 = (by - by3);
HXDLIN( 105)						Float ty1 = (bx3 - bx);
HXDLIN( 105)						Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 105)						::pixelimage::iter::IntIterStart xIter31;
HXDLIN( 105)						if ((bx > bx3)) {
HXLINE( 105)							if ((bx > cx3)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((bx3 > cx3)) {
HXLINE( 105)									min = ::Math_obj::floor(cx3);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::floor(bx3);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(bx);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter31 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(bx3);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter31 = this1;
            							}
            						}
            						else {
HXLINE( 105)							if ((bx3 > cx3)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((bx > cx3)) {
HXLINE( 105)									min = ::Math_obj::floor(cx3);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::ceil(bx);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(bx3);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter31 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(bx);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cx3);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter31 = this1;
            							}
            						}
HXDLIN( 105)						::pixelimage::iter::IntIterStart yIter31;
HXDLIN( 105)						if ((by > by3)) {
HXLINE( 105)							if ((by > cy3)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((by3 > cy3)) {
HXLINE( 105)									min = ::Math_obj::floor(cy3);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::floor(by3);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(by);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter31 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(by3);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter31 = this1;
            							}
            						}
            						else {
HXLINE( 105)							if ((by3 > cy3)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((by > cy3)) {
HXLINE( 105)									min = ::Math_obj::floor(cy3);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::ceil(by);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(by3);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter31 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(by);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cy3);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter31 = this1;
            							}
            						}
HXDLIN( 105)						::pixelimage::ImageStruct undoImage1 = null();
HXDLIN( 105)						if (hasUndo1) {
HXLINE( 105)							int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 105)							int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 105)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 105)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 105)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 105)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 105)							undoImage1 = this3;
HXDLIN( 105)							{
HXLINE( 105)								int rectLeft = xIter31->start;
HXDLIN( 105)								int rectTop = yIter31->start;
HXDLIN( 105)								int rectRight = xIter31->max;
HXDLIN( 105)								bool forceClear = false;
HXDLIN( 105)								{
HXLINE( 105)									int _g = rectTop;
HXDLIN( 105)									int _g1 = yIter31->max;
HXDLIN( 105)									while((_g < _g1)){
HXLINE( 105)										_g = (_g + 1);
HXDLIN( 105)										int dy = (_g - 1);
HXDLIN( 105)										{
HXLINE( 105)											int _g1 = rectLeft;
HXDLIN( 105)											int _g2 = rectRight;
HXDLIN( 105)											while((_g1 < _g2)){
HXLINE( 105)												_g1 = (_g1 + 1);
HXDLIN( 105)												int dx = (_g1 - 1);
HXDLIN( 105)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)												int index;
HXDLIN( 105)												if (pixelImage->useVirtualPos) {
HXLINE( 105)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 105)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN( 105)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)												int col;
HXDLIN( 105)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 105)													col = c;
            												}
HXDLIN( 105)												bool _hx_tmp;
HXDLIN( 105)												if (pixelImage->useMask) {
HXLINE( 105)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE( 105)													_hx_tmp = false;
            												}
HXDLIN( 105)												if (_hx_tmp) {
HXLINE( 105)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN( 105)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 105)													int index;
HXDLIN( 105)													if (this1->useVirtualPos) {
HXLINE( 105)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 105)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 105)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 105)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 105)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)													int v;
HXDLIN( 105)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 105)														v = c;
            													}
HXDLIN( 105)													int this3 = v;
HXDLIN( 105)													int maskPixel = this3;
HXDLIN( 105)													int this4 = col;
HXDLIN( 105)													int this5 = this4;
HXDLIN( 105)													if ((maskPixel == 0)) {
HXLINE( 105)														int this1 = this5;
HXDLIN( 105)														col = this1;
            													}
            													else {
HXLINE( 105)														Float m0;
HXDLIN( 105)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 105)														if ((this1 == 0)) {
HXLINE( 105)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m1;
HXDLIN( 105)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 105)														if ((this2 == 0)) {
HXLINE( 105)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m2;
HXDLIN( 105)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 105)														if ((this3 == 0)) {
HXLINE( 105)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m3;
HXDLIN( 105)														int this4 = (maskPixel & 255);
HXDLIN( 105)														if ((this4 == 0)) {
HXLINE( 105)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 105)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 105)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 105)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 105)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 105)												if ((col != 0)) {
HXLINE( 105)													int x = (dx - rectLeft);
HXDLIN( 105)													int y = (dy - rectTop);
HXDLIN( 105)													int this1 = col;
HXDLIN( 105)													int c = this1;
HXDLIN( 105)													bool _hx_tmp;
HXDLIN( 105)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 105)														_hx_tmp = undoImage1->transparent;
            													}
            													else {
HXLINE( 105)														_hx_tmp = false;
            													}
HXDLIN( 105)													if (_hx_tmp) {
HXLINE( 105)														int location;
HXDLIN( 105)														if (undoImage1->useVirtualPos) {
HXLINE( 105)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 105)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 105)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 105)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)														int this3 = this2;
HXDLIN( 105)														int this4;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 105)															this4 = this3;
            														}
HXDLIN( 105)														Float a1;
HXDLIN( 105)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 105)														if ((this5 == 0)) {
HXLINE( 105)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r1;
HXDLIN( 105)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 105)														if ((this6 == 0)) {
HXLINE( 105)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g1;
HXDLIN( 105)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 105)														if ((this7 == 0)) {
HXLINE( 105)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b1;
HXDLIN( 105)														int this8 = (this4 & 255);
HXDLIN( 105)														if ((this8 == 0)) {
HXLINE( 105)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a2;
HXDLIN( 105)														int this9 = ((col >> 24) & 255);
HXDLIN( 105)														if ((this9 == 0)) {
HXLINE( 105)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r2;
HXDLIN( 105)														int this10 = ((col >> 16) & 255);
HXDLIN( 105)														if ((this10 == 0)) {
HXLINE( 105)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g2;
HXDLIN( 105)														int this11 = ((col >> 8) & 255);
HXDLIN( 105)														if ((this11 == 0)) {
HXLINE( 105)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b2;
HXDLIN( 105)														int this12 = (col & 255);
HXDLIN( 105)														if ((this12 == 0)) {
HXLINE( 105)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 105)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 105)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 105)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 105)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 105)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 105)														{
HXLINE( 105)															::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN( 105)															int value;
HXDLIN( 105)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 105)																value = blended;
            															}
HXDLIN( 105)															bool _hx_tmp;
HXDLIN( 105)															if ((location >= 0)) {
HXLINE( 105)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 105)																_hx_tmp = false;
            															}
HXDLIN( 105)															if (_hx_tmp) {
HXLINE( 105)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 105)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 105)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 105)														int index;
HXDLIN( 105)														if (undoImage1->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 105)														int value;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 105)															value = c;
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 105)													if (forceClear) {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN( 105)														int x = (dx - rectLeft);
HXDLIN( 105)														int y = (dy - rectTop);
HXDLIN( 105)														int index;
HXDLIN( 105)														if (undoImage1->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 105)						bool found1 = false;
HXDLIN( 105)						Float s1 = ((Float)0.);
HXDLIN( 105)						Float t1 = ((Float)0.);
HXDLIN( 105)						Float sxx1 = ((Float)0.);
HXDLIN( 105)						Float txx1 = ((Float)0.);
HXDLIN( 105)						{
HXLINE( 105)							int _g_min1 = xIter31->start;
HXDLIN( 105)							int _g_max1 = xIter31->max;
HXDLIN( 105)							while((_g_min1 < _g_max1)){
HXLINE( 105)								_g_min1 = (_g_min1 + 1);
HXDLIN( 105)								int x = (_g_min1 - 1);
HXLINE(  61)								sxx1 = (sx1 * ( (Float)(x) ));
HXLINE(  62)								txx1 = (tx1 * ( (Float)(x) ));
HXLINE(  63)								found1 = false;
HXLINE( 105)								{
HXLINE( 105)									int _g_min = yIter31->start;
HXDLIN( 105)									int _g_max = yIter31->max;
HXDLIN( 105)									while((_g_min < _g_max)){
HXLINE( 105)										_g_min = (_g_min + 1);
HXDLIN( 105)										int y = (_g_min - 1);
HXLINE(  65)										s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE(  66)										t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE( 105)										bool _hx_tmp;
HXDLIN( 105)										if (!((s1 <= 0))) {
HXLINE( 105)											_hx_tmp = (t1 <= 0);
            										}
            										else {
HXLINE( 105)											_hx_tmp = true;
            										}
HXDLIN( 105)										if (_hx_tmp) {
HXLINE( 105)											if (found1) {
HXLINE( 105)												goto _hx_goto_234;
            											}
            										}
            										else {
HXLINE( 105)											if (((s1 + t1) < A1)) {
HXLINE( 105)												{
HXLINE( 105)													int this1 = color;
HXDLIN( 105)													int c = this1;
HXDLIN( 105)													bool _hx_tmp;
HXDLIN( 105)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 105)														_hx_tmp = pixelImage->transparent;
            													}
            													else {
HXLINE( 105)														_hx_tmp = false;
            													}
HXDLIN( 105)													if (_hx_tmp) {
HXLINE( 105)														int location;
HXDLIN( 105)														if (pixelImage->useVirtualPos) {
HXLINE( 105)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 105)															location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 105)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 105)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)														int this3 = this2;
HXDLIN( 105)														int this4;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 105)															this4 = this3;
            														}
HXDLIN( 105)														Float a1;
HXDLIN( 105)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 105)														if ((this5 == 0)) {
HXLINE( 105)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r1;
HXDLIN( 105)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 105)														if ((this6 == 0)) {
HXLINE( 105)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g1;
HXDLIN( 105)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 105)														if ((this7 == 0)) {
HXLINE( 105)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b1;
HXDLIN( 105)														int this8 = (this4 & 255);
HXDLIN( 105)														if ((this8 == 0)) {
HXLINE( 105)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a2;
HXDLIN( 105)														int this9 = ((color >> 24) & 255);
HXDLIN( 105)														if ((this9 == 0)) {
HXLINE( 105)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r2;
HXDLIN( 105)														int this10 = ((color >> 16) & 255);
HXDLIN( 105)														if ((this10 == 0)) {
HXLINE( 105)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g2;
HXDLIN( 105)														int this11 = ((color >> 8) & 255);
HXDLIN( 105)														if ((this11 == 0)) {
HXLINE( 105)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b2;
HXDLIN( 105)														int this12 = (color & 255);
HXDLIN( 105)														if ((this12 == 0)) {
HXLINE( 105)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 105)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 105)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 105)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 105)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 105)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 105)														{
HXLINE( 105)															::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 105)															int value;
HXDLIN( 105)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 105)																value = blended;
            															}
HXDLIN( 105)															bool _hx_tmp;
HXDLIN( 105)															if ((location >= 0)) {
HXLINE( 105)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 105)																_hx_tmp = false;
            															}
HXDLIN( 105)															if (_hx_tmp) {
HXLINE( 105)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 105)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 105)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)														int index;
HXDLIN( 105)														if (pixelImage->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 105)														int value;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 105)															value = c;
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found1 = true;
            											}
            											else {
HXLINE( 105)												if (found1) {
HXLINE( 105)													goto _hx_goto_234;
            												}
            											}
            										}
            									}
            									_hx_goto_234:;
            								}
            							}
            						}
HXDLIN( 105)						::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN( 105)						::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN( 105)						int v_undoY1;
HXDLIN( 105)						int v_undoX1;
HXDLIN( 105)						Float v_ty1;
HXDLIN( 105)						Float v_tx1;
HXDLIN( 105)						Float v_t01;
HXDLIN( 105)						Float v_sy1;
HXDLIN( 105)						Float v_sx1;
HXDLIN( 105)						Float v_s01;
HXDLIN( 105)						Float v_A1;
HXDLIN( 105)						Float ax2 = bx;
HXDLIN( 105)						Float ay2 = by;
HXDLIN( 105)						Float bx4 = bx3;
HXDLIN( 105)						Float by4 = by3;
HXDLIN( 105)						Float cx4 = cx3;
HXDLIN( 105)						Float cy4 = cy3;
HXDLIN( 105)						::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN( 105)						bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN( 105)						if (!(adjustWinding3)) {
HXLINE( 105)							Float bx_ = bx4;
HXDLIN( 105)							Float by_ = by4;
HXLINE(  35)							bx4 = cx4;
HXLINE(  36)							by4 = cy4;
HXLINE(  37)							cx4 = bx_;
HXLINE(  38)							cy4 = by_;
            						}
HXLINE( 105)						Float v_ax1 = ax2;
HXDLIN( 105)						Float v_ay1 = ay2;
HXDLIN( 105)						Float v_bx1 = bx4;
HXDLIN( 105)						Float v_by1 = by4;
HXDLIN( 105)						Float v_cx1 = cx4;
HXDLIN( 105)						Float v_cy1 = cy4;
HXDLIN( 105)						bool v_preCalculated1 = true;
HXDLIN( 105)						{
HXLINE( 105)							v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 105)							v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 105)							v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 105)							v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 105)							v_tx1 = (v_ay1 - v_by1);
HXDLIN( 105)							v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 105)							v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 105)							Float a3 = v_ax1;
HXDLIN( 105)							Float b2 = v_bx1;
HXDLIN( 105)							Float c2 = v_cx1;
HXDLIN( 105)							if ((a3 > b2)) {
HXLINE( 105)								if ((a3 > c2)) {
HXLINE( 105)									int min;
HXDLIN( 105)									if ((b2 > c2)) {
HXLINE( 105)										min = ::Math_obj::floor(c2);
            									}
            									else {
HXLINE( 105)										min = ::Math_obj::floor(b2);
            									}
HXDLIN( 105)									int ii_min = min;
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(a3);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_xIter31 = this1;
            								}
            								else {
HXLINE( 105)									int ii_min = ::Math_obj::floor(b2);
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(c2);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_xIter31 = this1;
            								}
            							}
            							else {
HXLINE( 105)								if ((b2 > c2)) {
HXLINE( 105)									int min;
HXDLIN( 105)									if ((a3 > c2)) {
HXLINE( 105)										min = ::Math_obj::floor(c2);
            									}
            									else {
HXLINE( 105)										min = ::Math_obj::ceil(a3);
            									}
HXDLIN( 105)									int ii_min = min;
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(b2);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_xIter31 = this1;
            								}
            								else {
HXLINE( 105)									int ii_min = ::Math_obj::floor(a3);
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(c2);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_xIter31 = this1;
            								}
            							}
HXDLIN( 105)							Float a4 = v_ay1;
HXDLIN( 105)							Float b3 = v_by1;
HXDLIN( 105)							Float c3 = v_cy1;
HXDLIN( 105)							if ((a4 > b3)) {
HXLINE( 105)								if ((a4 > c3)) {
HXLINE( 105)									int min;
HXDLIN( 105)									if ((b3 > c3)) {
HXLINE( 105)										min = ::Math_obj::floor(c3);
            									}
            									else {
HXLINE( 105)										min = ::Math_obj::floor(b3);
            									}
HXDLIN( 105)									int ii_min = min;
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(a4);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_yIter31 = this1;
            								}
            								else {
HXLINE( 105)									int ii_min = ::Math_obj::floor(b3);
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(c3);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_yIter31 = this1;
            								}
            							}
            							else {
HXLINE( 105)								if ((b3 > c3)) {
HXLINE( 105)									int min;
HXDLIN( 105)									if ((a4 > c3)) {
HXLINE( 105)										min = ::Math_obj::floor(c3);
            									}
            									else {
HXLINE( 105)										min = ::Math_obj::ceil(a4);
            									}
HXDLIN( 105)									int ii_min = min;
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(b3);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_yIter31 = this1;
            								}
            								else {
HXLINE( 105)									int ii_min = ::Math_obj::floor(a4);
HXDLIN( 105)									int ii_max = ::Math_obj::ceil(c3);
HXDLIN( 105)									::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)									v_yIter31 = this1;
            								}
            							}
            						}
HXDLIN( 105)						if (hasUndo1) {
HXLINE( 105)							v_undoImage1 = undoImage1;
HXDLIN( 105)							v_undoX1 = xIter31->start;
HXDLIN( 105)							v_undoY1 = yIter31->start;
            						}
HXDLIN( 105)						::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 105)						::pixelimage::algo::HitQuad hitQuad = v;
HXDLIN( 105)						Float cx5 = h2;
HXDLIN( 105)						Float cy5 = radius2;
HXDLIN( 105)						Float bx5 = h2;
HXDLIN( 105)						Float by5 = -(radius2);
HXDLIN( 105)						Float dx1 = hSmall;
HXDLIN( 105)						Float dy1 = radius2;
HXDLIN( 105)						Float ax3 = hSmall;
HXDLIN( 105)						Float ay3 = -(radius2);
HXLINE( 203)						temp = (px + ((bx5 * cos) - (by5 * sin)));
HXLINE( 204)						by5 = (py + ((by5 * cos) + (bx5 * sin)));
HXLINE( 205)						bx5 = temp;
HXLINE( 206)						temp = (px + ((cx5 * cos) - (cy5 * sin)));
HXLINE( 207)						cy5 = (py + ((cy5 * cos) + (cx5 * sin)));
HXLINE( 208)						cx5 = temp;
HXLINE( 210)						temp = (px + ((ax3 * cos) - (ay3 * sin)));
HXLINE( 211)						ay3 = (py + ((ay3 * cos) + (ax3 * sin)));
HXLINE( 212)						ax3 = temp;
HXLINE( 214)						temp = (px + ((dx1 * cos) - (dy1 * sin)));
HXLINE( 215)						dy1 = (py + ((dy1 * cos) + (dx1 * sin)));
HXLINE( 216)						dx1 = temp;
HXLINE( 105)						Float bx6 = bx5;
HXDLIN( 105)						Float by6 = by5;
HXDLIN( 105)						Float cx6 = cx5;
HXDLIN( 105)						Float cy6 = cy5;
HXDLIN( 105)						bool hasUndo2 = false;
HXDLIN( 105)						bool adjustWinding4 = (((((px * by6) - (bx6 * py)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * py) - (px * cy6))) > 0);
HXDLIN( 105)						if (!(adjustWinding4)) {
HXLINE( 105)							Float bx_ = bx6;
HXDLIN( 105)							Float by_ = by6;
HXLINE(  26)							bx6 = cx6;
HXLINE(  27)							by6 = cy6;
HXLINE(  28)							cx6 = bx_;
HXLINE(  29)							cy6 = by_;
            						}
HXLINE( 105)						Float s02 = ((py * cx6) - (px * cy6));
HXDLIN( 105)						Float sx2 = (cy6 - py);
HXDLIN( 105)						Float sy2 = (px - cx6);
HXDLIN( 105)						Float t02 = ((px * by6) - (py * bx6));
HXDLIN( 105)						Float tx2 = (py - by6);
HXDLIN( 105)						Float ty2 = (bx6 - px);
HXDLIN( 105)						Float A2 = ((((-(by6) * cx6) + (py * (-(bx6) + cx6))) + (px * (by6 - cy6))) + (bx6 * cy6));
HXDLIN( 105)						::pixelimage::iter::IntIterStart xIter32;
HXDLIN( 105)						if ((px > bx6)) {
HXLINE( 105)							if ((px > cx6)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((bx6 > cx6)) {
HXLINE( 105)									min = ::Math_obj::floor(cx6);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::floor(bx6);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(px);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter32 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(bx6);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cx6);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter32 = this1;
            							}
            						}
            						else {
HXLINE( 105)							if ((bx6 > cx6)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((px > cx6)) {
HXLINE( 105)									min = ::Math_obj::floor(cx6);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::ceil(px);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(bx6);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter32 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(px);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cx6);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter32 = this1;
            							}
            						}
HXDLIN( 105)						::pixelimage::iter::IntIterStart yIter32;
HXDLIN( 105)						if ((py > by6)) {
HXLINE( 105)							if ((py > cy6)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((by6 > cy6)) {
HXLINE( 105)									min = ::Math_obj::floor(cy6);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::floor(by6);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(py);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter32 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(by6);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cy6);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter32 = this1;
            							}
            						}
            						else {
HXLINE( 105)							if ((by6 > cy6)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((py > cy6)) {
HXLINE( 105)									min = ::Math_obj::floor(cy6);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::ceil(py);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(by6);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter32 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(py);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cy6);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter32 = this1;
            							}
            						}
HXDLIN( 105)						::pixelimage::ImageStruct undoImage2 = null();
HXDLIN( 105)						if (hasUndo2) {
HXLINE( 105)							int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 105)							int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 105)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 105)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 105)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 105)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 105)							undoImage2 = this3;
HXDLIN( 105)							{
HXLINE( 105)								int rectLeft = xIter32->start;
HXDLIN( 105)								int rectTop = yIter32->start;
HXDLIN( 105)								int rectRight = xIter32->max;
HXDLIN( 105)								bool forceClear = false;
HXDLIN( 105)								{
HXLINE( 105)									int _g = rectTop;
HXDLIN( 105)									int _g1 = yIter32->max;
HXDLIN( 105)									while((_g < _g1)){
HXLINE( 105)										_g = (_g + 1);
HXDLIN( 105)										int dy = (_g - 1);
HXDLIN( 105)										{
HXLINE( 105)											int _g1 = rectLeft;
HXDLIN( 105)											int _g2 = rectRight;
HXDLIN( 105)											while((_g1 < _g2)){
HXLINE( 105)												_g1 = (_g1 + 1);
HXDLIN( 105)												int dx = (_g1 - 1);
HXDLIN( 105)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)												int index;
HXDLIN( 105)												if (pixelImage->useVirtualPos) {
HXLINE( 105)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 105)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN( 105)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)												int col;
HXDLIN( 105)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 105)													col = c;
            												}
HXDLIN( 105)												bool _hx_tmp;
HXDLIN( 105)												if (pixelImage->useMask) {
HXLINE( 105)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE( 105)													_hx_tmp = false;
            												}
HXDLIN( 105)												if (_hx_tmp) {
HXLINE( 105)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN( 105)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 105)													int index;
HXDLIN( 105)													if (this1->useVirtualPos) {
HXLINE( 105)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 105)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 105)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 105)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 105)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)													int v;
HXDLIN( 105)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 105)														v = c;
            													}
HXDLIN( 105)													int this3 = v;
HXDLIN( 105)													int maskPixel = this3;
HXDLIN( 105)													int this4 = col;
HXDLIN( 105)													int this5 = this4;
HXDLIN( 105)													if ((maskPixel == 0)) {
HXLINE( 105)														int this1 = this5;
HXDLIN( 105)														col = this1;
            													}
            													else {
HXLINE( 105)														Float m0;
HXDLIN( 105)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 105)														if ((this1 == 0)) {
HXLINE( 105)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m1;
HXDLIN( 105)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 105)														if ((this2 == 0)) {
HXLINE( 105)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m2;
HXDLIN( 105)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 105)														if ((this3 == 0)) {
HXLINE( 105)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m3;
HXDLIN( 105)														int this4 = (maskPixel & 255);
HXDLIN( 105)														if ((this4 == 0)) {
HXLINE( 105)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 105)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 105)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 105)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 105)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 105)												if ((col != 0)) {
HXLINE( 105)													int x = (dx - rectLeft);
HXDLIN( 105)													int y = (dy - rectTop);
HXDLIN( 105)													int this1 = col;
HXDLIN( 105)													int c = this1;
HXDLIN( 105)													bool _hx_tmp;
HXDLIN( 105)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 105)														_hx_tmp = undoImage2->transparent;
            													}
            													else {
HXLINE( 105)														_hx_tmp = false;
            													}
HXDLIN( 105)													if (_hx_tmp) {
HXLINE( 105)														int location;
HXDLIN( 105)														if (undoImage2->useVirtualPos) {
HXLINE( 105)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 105)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 105)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 105)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)														int this3 = this2;
HXDLIN( 105)														int this4;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 105)															this4 = this3;
            														}
HXDLIN( 105)														Float a1;
HXDLIN( 105)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 105)														if ((this5 == 0)) {
HXLINE( 105)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r1;
HXDLIN( 105)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 105)														if ((this6 == 0)) {
HXLINE( 105)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g1;
HXDLIN( 105)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 105)														if ((this7 == 0)) {
HXLINE( 105)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b1;
HXDLIN( 105)														int this8 = (this4 & 255);
HXDLIN( 105)														if ((this8 == 0)) {
HXLINE( 105)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a2;
HXDLIN( 105)														int this9 = ((col >> 24) & 255);
HXDLIN( 105)														if ((this9 == 0)) {
HXLINE( 105)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r2;
HXDLIN( 105)														int this10 = ((col >> 16) & 255);
HXDLIN( 105)														if ((this10 == 0)) {
HXLINE( 105)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g2;
HXDLIN( 105)														int this11 = ((col >> 8) & 255);
HXDLIN( 105)														if ((this11 == 0)) {
HXLINE( 105)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b2;
HXDLIN( 105)														int this12 = (col & 255);
HXDLIN( 105)														if ((this12 == 0)) {
HXLINE( 105)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 105)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 105)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 105)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 105)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 105)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 105)														{
HXLINE( 105)															::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN( 105)															int value;
HXDLIN( 105)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 105)																value = blended;
            															}
HXDLIN( 105)															bool _hx_tmp;
HXDLIN( 105)															if ((location >= 0)) {
HXLINE( 105)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 105)																_hx_tmp = false;
            															}
HXDLIN( 105)															if (_hx_tmp) {
HXLINE( 105)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 105)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 105)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 105)														int index;
HXDLIN( 105)														if (undoImage2->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 105)														int value;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 105)															value = c;
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 105)													if (forceClear) {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN( 105)														int x = (dx - rectLeft);
HXDLIN( 105)														int y = (dy - rectTop);
HXDLIN( 105)														int index;
HXDLIN( 105)														if (undoImage2->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 105)						bool found2 = false;
HXDLIN( 105)						Float s2 = ((Float)0.);
HXDLIN( 105)						Float t2 = ((Float)0.);
HXDLIN( 105)						Float sxx2 = ((Float)0.);
HXDLIN( 105)						Float txx2 = ((Float)0.);
HXDLIN( 105)						{
HXLINE( 105)							int _g_min2 = xIter32->start;
HXDLIN( 105)							int _g_max2 = xIter32->max;
HXDLIN( 105)							while((_g_min2 < _g_max2)){
HXLINE( 105)								_g_min2 = (_g_min2 + 1);
HXDLIN( 105)								int x = (_g_min2 - 1);
HXLINE(  61)								sxx2 = (sx2 * ( (Float)(x) ));
HXLINE(  62)								txx2 = (tx2 * ( (Float)(x) ));
HXLINE(  63)								found2 = false;
HXLINE( 105)								{
HXLINE( 105)									int _g_min = yIter32->start;
HXDLIN( 105)									int _g_max = yIter32->max;
HXDLIN( 105)									while((_g_min < _g_max)){
HXLINE( 105)										_g_min = (_g_min + 1);
HXDLIN( 105)										int y = (_g_min - 1);
HXLINE(  65)										s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y) )));
HXLINE(  66)										t2 = ((t02 + txx2) + (ty2 * ( (Float)(y) )));
HXLINE( 105)										bool _hx_tmp;
HXDLIN( 105)										if (!((s2 <= 0))) {
HXLINE( 105)											_hx_tmp = (t2 <= 0);
            										}
            										else {
HXLINE( 105)											_hx_tmp = true;
            										}
HXDLIN( 105)										if (_hx_tmp) {
HXLINE( 105)											if (found2) {
HXLINE( 105)												goto _hx_goto_238;
            											}
            										}
            										else {
HXLINE( 105)											if (((s2 + t2) < A2)) {
HXLINE( 105)												{
HXLINE( 105)													int this1 = color;
HXDLIN( 105)													int c = this1;
HXDLIN( 105)													bool _hx_tmp;
HXDLIN( 105)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 105)														_hx_tmp = pixelImage->transparent;
            													}
            													else {
HXLINE( 105)														_hx_tmp = false;
            													}
HXDLIN( 105)													if (_hx_tmp) {
HXLINE( 105)														int location;
HXDLIN( 105)														if (pixelImage->useVirtualPos) {
HXLINE( 105)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 105)															location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 105)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 105)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)														int this3 = this2;
HXDLIN( 105)														int this4;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 105)															this4 = this3;
            														}
HXDLIN( 105)														Float a1;
HXDLIN( 105)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 105)														if ((this5 == 0)) {
HXLINE( 105)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r1;
HXDLIN( 105)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 105)														if ((this6 == 0)) {
HXLINE( 105)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g1;
HXDLIN( 105)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 105)														if ((this7 == 0)) {
HXLINE( 105)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b1;
HXDLIN( 105)														int this8 = (this4 & 255);
HXDLIN( 105)														if ((this8 == 0)) {
HXLINE( 105)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a2;
HXDLIN( 105)														int this9 = ((color >> 24) & 255);
HXDLIN( 105)														if ((this9 == 0)) {
HXLINE( 105)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r2;
HXDLIN( 105)														int this10 = ((color >> 16) & 255);
HXDLIN( 105)														if ((this10 == 0)) {
HXLINE( 105)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g2;
HXDLIN( 105)														int this11 = ((color >> 8) & 255);
HXDLIN( 105)														if ((this11 == 0)) {
HXLINE( 105)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b2;
HXDLIN( 105)														int this12 = (color & 255);
HXDLIN( 105)														if ((this12 == 0)) {
HXLINE( 105)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 105)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 105)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 105)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 105)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 105)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 105)														{
HXLINE( 105)															::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 105)															int value;
HXDLIN( 105)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 105)																value = blended;
            															}
HXDLIN( 105)															bool _hx_tmp;
HXDLIN( 105)															if ((location >= 0)) {
HXLINE( 105)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 105)																_hx_tmp = false;
            															}
HXDLIN( 105)															if (_hx_tmp) {
HXLINE( 105)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 105)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 105)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)														int index;
HXDLIN( 105)														if (pixelImage->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 105)														int value;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 105)															value = c;
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found2 = true;
            											}
            											else {
HXLINE( 105)												if (found2) {
HXLINE( 105)													goto _hx_goto_238;
            												}
            											}
            										}
            									}
            									_hx_goto_238:;
            								}
            							}
            						}
HXDLIN( 105)						::pixelimage::algo::HitTri hitTriTop;
HXDLIN( 105)						if ((hasHit == true)) {
HXLINE( 105)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx6,by6,cx6,cy6,true);
HXDLIN( 105)							if (hasUndo2) {
HXLINE( 105)								v->undoImage = undoImage2;
HXDLIN( 105)								v->undoX = xIter32->start;
HXDLIN( 105)								v->undoY = yIter32->start;
            							}
HXDLIN( 105)							hitTriTop = v;
            						}
            						else {
HXLINE( 105)							hitTriTop = null();
            						}
HXDLIN( 105)						Float bx7 = ax3;
HXDLIN( 105)						Float by7 = ay3;
HXDLIN( 105)						Float cx7 = dx1;
HXDLIN( 105)						Float cy7 = dy1;
HXDLIN( 105)						bool hasUndo3 = false;
HXDLIN( 105)						bool adjustWinding5 = (((((px * by7) - (bx7 * py)) + ((bx7 * cy7) - (cx7 * by7))) + ((cx7 * py) - (px * cy7))) > 0);
HXDLIN( 105)						if (!(adjustWinding5)) {
HXLINE( 105)							Float bx_ = bx7;
HXDLIN( 105)							Float by_ = by7;
HXLINE(  26)							bx7 = cx7;
HXLINE(  27)							by7 = cy7;
HXLINE(  28)							cx7 = bx_;
HXLINE(  29)							cy7 = by_;
            						}
HXLINE( 105)						Float s03 = ((py * cx7) - (px * cy7));
HXDLIN( 105)						Float sx3 = (cy7 - py);
HXDLIN( 105)						Float sy3 = (px - cx7);
HXDLIN( 105)						Float t03 = ((px * by7) - (py * bx7));
HXDLIN( 105)						Float tx3 = (py - by7);
HXDLIN( 105)						Float ty3 = (bx7 - px);
HXDLIN( 105)						Float A3 = ((((-(by7) * cx7) + (py * (-(bx7) + cx7))) + (px * (by7 - cy7))) + (bx7 * cy7));
HXDLIN( 105)						::pixelimage::iter::IntIterStart xIter33;
HXDLIN( 105)						if ((px > bx7)) {
HXLINE( 105)							if ((px > cx7)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((bx7 > cx7)) {
HXLINE( 105)									min = ::Math_obj::floor(cx7);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::floor(bx7);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(px);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter33 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(bx7);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cx7);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter33 = this1;
            							}
            						}
            						else {
HXLINE( 105)							if ((bx7 > cx7)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((px > cx7)) {
HXLINE( 105)									min = ::Math_obj::floor(cx7);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::ceil(px);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(bx7);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter33 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(px);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cx7);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								xIter33 = this1;
            							}
            						}
HXDLIN( 105)						::pixelimage::iter::IntIterStart yIter33;
HXDLIN( 105)						if ((py > by7)) {
HXLINE( 105)							if ((py > cy7)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((by7 > cy7)) {
HXLINE( 105)									min = ::Math_obj::floor(cy7);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::floor(by7);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(py);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter33 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(by7);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cy7);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter33 = this1;
            							}
            						}
            						else {
HXLINE( 105)							if ((by7 > cy7)) {
HXLINE( 105)								int min;
HXDLIN( 105)								if ((py > cy7)) {
HXLINE( 105)									min = ::Math_obj::floor(cy7);
            								}
            								else {
HXLINE( 105)									min = ::Math_obj::ceil(py);
            								}
HXDLIN( 105)								int ii_min = min;
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(by7);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter33 = this1;
            							}
            							else {
HXLINE( 105)								int ii_min = ::Math_obj::floor(py);
HXDLIN( 105)								int ii_max = ::Math_obj::ceil(cy7);
HXDLIN( 105)								::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN( 105)								yIter33 = this1;
            							}
            						}
HXDLIN( 105)						::pixelimage::ImageStruct undoImage3 = null();
HXDLIN( 105)						if (hasUndo3) {
HXLINE( 105)							int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 105)							int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 105)							int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN( 105)							::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 105)							::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN( 105)							::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN( 105)							undoImage3 = this3;
HXDLIN( 105)							{
HXLINE( 105)								int rectLeft = xIter33->start;
HXDLIN( 105)								int rectTop = yIter33->start;
HXDLIN( 105)								int rectRight = xIter33->max;
HXDLIN( 105)								bool forceClear = false;
HXDLIN( 105)								{
HXLINE( 105)									int _g = rectTop;
HXDLIN( 105)									int _g1 = yIter33->max;
HXDLIN( 105)									while((_g < _g1)){
HXLINE( 105)										_g = (_g + 1);
HXDLIN( 105)										int dy = (_g - 1);
HXDLIN( 105)										{
HXLINE( 105)											int _g1 = rectLeft;
HXDLIN( 105)											int _g2 = rectRight;
HXDLIN( 105)											while((_g1 < _g2)){
HXLINE( 105)												_g1 = (_g1 + 1);
HXDLIN( 105)												int dx = (_g1 - 1);
HXDLIN( 105)												::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)												int index;
HXDLIN( 105)												if (pixelImage->useVirtualPos) {
HXLINE( 105)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 105)													index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            												}
HXDLIN( 105)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)												int col;
HXDLIN( 105)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE( 105)													col = c;
            												}
HXDLIN( 105)												bool _hx_tmp;
HXDLIN( 105)												if (pixelImage->useMask) {
HXLINE( 105)													_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            												}
            												else {
HXLINE( 105)													_hx_tmp = false;
            												}
HXDLIN( 105)												if (_hx_tmp) {
HXLINE( 105)													::pixelimage::ImageStruct this1 = pixelImage->mask;
HXDLIN( 105)													::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN( 105)													int index;
HXDLIN( 105)													if (this1->useVirtualPos) {
HXLINE( 105)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            													}
            													else {
HXLINE( 105)														index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            													}
HXDLIN( 105)													::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 105)													int pos = ((index << 2) + this2->byteOffset);
HXDLIN( 105)													int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)													int v;
HXDLIN( 105)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)														v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE( 105)														v = c;
            													}
HXDLIN( 105)													int this3 = v;
HXDLIN( 105)													int maskPixel = this3;
HXDLIN( 105)													int this4 = col;
HXDLIN( 105)													int this5 = this4;
HXDLIN( 105)													if ((maskPixel == 0)) {
HXLINE( 105)														int this1 = this5;
HXDLIN( 105)														col = this1;
            													}
            													else {
HXLINE( 105)														Float m0;
HXDLIN( 105)														int this1 = ((maskPixel >> 24) & 255);
HXDLIN( 105)														if ((this1 == 0)) {
HXLINE( 105)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m1;
HXDLIN( 105)														int this2 = ((maskPixel >> 16) & 255);
HXDLIN( 105)														if ((this2 == 0)) {
HXLINE( 105)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m2;
HXDLIN( 105)														int this3 = ((maskPixel >> 8) & 255);
HXDLIN( 105)														if ((this3 == 0)) {
HXLINE( 105)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float m3;
HXDLIN( 105)														int this4 = (maskPixel & 255);
HXDLIN( 105)														if ((this4 == 0)) {
HXLINE( 105)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 105)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 105)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 105)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 105)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 105)												if ((col != 0)) {
HXLINE( 105)													int x = (dx - rectLeft);
HXDLIN( 105)													int y = (dy - rectTop);
HXDLIN( 105)													int this1 = col;
HXDLIN( 105)													int c = this1;
HXDLIN( 105)													bool _hx_tmp;
HXDLIN( 105)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 105)														_hx_tmp = undoImage3->transparent;
            													}
            													else {
HXLINE( 105)														_hx_tmp = false;
            													}
HXDLIN( 105)													if (_hx_tmp) {
HXLINE( 105)														int location;
HXDLIN( 105)														if (undoImage3->useVirtualPos) {
HXLINE( 105)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 105)															location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 105)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 105)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)														int this3 = this2;
HXDLIN( 105)														int this4;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 105)															this4 = this3;
            														}
HXDLIN( 105)														Float a1;
HXDLIN( 105)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 105)														if ((this5 == 0)) {
HXLINE( 105)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r1;
HXDLIN( 105)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 105)														if ((this6 == 0)) {
HXLINE( 105)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g1;
HXDLIN( 105)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 105)														if ((this7 == 0)) {
HXLINE( 105)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b1;
HXDLIN( 105)														int this8 = (this4 & 255);
HXDLIN( 105)														if ((this8 == 0)) {
HXLINE( 105)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a2;
HXDLIN( 105)														int this9 = ((col >> 24) & 255);
HXDLIN( 105)														if ((this9 == 0)) {
HXLINE( 105)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r2;
HXDLIN( 105)														int this10 = ((col >> 16) & 255);
HXDLIN( 105)														if ((this10 == 0)) {
HXLINE( 105)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g2;
HXDLIN( 105)														int this11 = ((col >> 8) & 255);
HXDLIN( 105)														if ((this11 == 0)) {
HXLINE( 105)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b2;
HXDLIN( 105)														int this12 = (col & 255);
HXDLIN( 105)														if ((this12 == 0)) {
HXLINE( 105)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 105)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 105)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 105)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 105)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 105)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 105)														{
HXLINE( 105)															::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN( 105)															int value;
HXDLIN( 105)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 105)																value = blended;
            															}
HXDLIN( 105)															bool _hx_tmp;
HXDLIN( 105)															if ((location >= 0)) {
HXLINE( 105)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 105)																_hx_tmp = false;
            															}
HXDLIN( 105)															if (_hx_tmp) {
HXLINE( 105)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 105)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 105)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 105)														int index;
HXDLIN( 105)														if (undoImage3->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 105)														int value;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 105)															value = c;
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE( 105)													if (forceClear) {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN( 105)														int x = (dx - rectLeft);
HXDLIN( 105)														int y = (dy - rectTop);
HXDLIN( 105)														int index;
HXDLIN( 105)														if (undoImage3->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 105)						bool found3 = false;
HXDLIN( 105)						Float s3 = ((Float)0.);
HXDLIN( 105)						Float t3 = ((Float)0.);
HXDLIN( 105)						Float sxx3 = ((Float)0.);
HXDLIN( 105)						Float txx3 = ((Float)0.);
HXDLIN( 105)						{
HXLINE( 105)							int _g_min3 = xIter33->start;
HXDLIN( 105)							int _g_max3 = xIter33->max;
HXDLIN( 105)							while((_g_min3 < _g_max3)){
HXLINE( 105)								_g_min3 = (_g_min3 + 1);
HXDLIN( 105)								int x = (_g_min3 - 1);
HXLINE(  61)								sxx3 = (sx3 * ( (Float)(x) ));
HXLINE(  62)								txx3 = (tx3 * ( (Float)(x) ));
HXLINE(  63)								found3 = false;
HXLINE( 105)								{
HXLINE( 105)									int _g_min = yIter33->start;
HXDLIN( 105)									int _g_max = yIter33->max;
HXDLIN( 105)									while((_g_min < _g_max)){
HXLINE( 105)										_g_min = (_g_min + 1);
HXDLIN( 105)										int y = (_g_min - 1);
HXLINE(  65)										s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y) )));
HXLINE(  66)										t3 = ((t03 + txx3) + (ty3 * ( (Float)(y) )));
HXLINE( 105)										bool _hx_tmp;
HXDLIN( 105)										if (!((s3 <= 0))) {
HXLINE( 105)											_hx_tmp = (t3 <= 0);
            										}
            										else {
HXLINE( 105)											_hx_tmp = true;
            										}
HXDLIN( 105)										if (_hx_tmp) {
HXLINE( 105)											if (found3) {
HXLINE( 105)												goto _hx_goto_242;
            											}
            										}
            										else {
HXLINE( 105)											if (((s3 + t3) < A3)) {
HXLINE( 105)												{
HXLINE( 105)													int this1 = color;
HXDLIN( 105)													int c = this1;
HXDLIN( 105)													bool _hx_tmp;
HXDLIN( 105)													if ((((c >> 24) & 255) < 254)) {
HXLINE( 105)														_hx_tmp = pixelImage->transparent;
            													}
            													else {
HXLINE( 105)														_hx_tmp = false;
            													}
HXDLIN( 105)													if (_hx_tmp) {
HXLINE( 105)														int location;
HXDLIN( 105)														if (pixelImage->useVirtualPos) {
HXLINE( 105)															location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 105)															location = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 105)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN( 105)														int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN( 105)														int this3 = this2;
HXDLIN( 105)														int this4;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            														}
            														else {
HXLINE( 105)															this4 = this3;
            														}
HXDLIN( 105)														Float a1;
HXDLIN( 105)														int this5 = ((this4 >> 24) & 255);
HXDLIN( 105)														if ((this5 == 0)) {
HXLINE( 105)															a1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r1;
HXDLIN( 105)														int this6 = ((this4 >> 16) & 255);
HXDLIN( 105)														if ((this6 == 0)) {
HXLINE( 105)															r1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g1;
HXDLIN( 105)														int this7 = ((this4 >> 8) & 255);
HXDLIN( 105)														if ((this7 == 0)) {
HXLINE( 105)															g1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b1;
HXDLIN( 105)														int this8 = (this4 & 255);
HXDLIN( 105)														if ((this8 == 0)) {
HXLINE( 105)															b1 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a2;
HXDLIN( 105)														int this9 = ((color >> 24) & 255);
HXDLIN( 105)														if ((this9 == 0)) {
HXLINE( 105)															a2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float r2;
HXDLIN( 105)														int this10 = ((color >> 16) & 255);
HXDLIN( 105)														if ((this10 == 0)) {
HXLINE( 105)															r2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float g2;
HXDLIN( 105)														int this11 = ((color >> 8) & 255);
HXDLIN( 105)														if ((this11 == 0)) {
HXLINE( 105)															g2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float b2;
HXDLIN( 105)														int this12 = (color & 255);
HXDLIN( 105)														if ((this12 == 0)) {
HXLINE( 105)															b2 = ((Float)0.);
            														}
            														else {
HXLINE( 105)															b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN( 105)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 105)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 105)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 105)														int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 105)														int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 105)														int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 105)														{
HXLINE( 105)															::haxe::io::ArrayBufferViewImpl this13 = pixelImage->image;
HXDLIN( 105)															int value;
HXDLIN( 105)															if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)																value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE( 105)																value = blended;
            															}
HXDLIN( 105)															bool _hx_tmp;
HXDLIN( 105)															if ((location >= 0)) {
HXLINE( 105)																_hx_tmp = (location < (this13->byteLength >> 2));
            															}
            															else {
HXLINE( 105)																_hx_tmp = false;
            															}
HXDLIN( 105)															if (_hx_tmp) {
HXLINE( 105)																::haxe::io::Bytes _this = this13->bytes;
HXDLIN( 105)																int pos = ((location << 2) + this13->byteOffset);
HXDLIN( 105)																_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)																_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)																_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)																_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            															}
            														}
            													}
            													else {
HXLINE( 105)														::haxe::io::ArrayBufferViewImpl this1 = pixelImage->image;
HXDLIN( 105)														int index;
HXDLIN( 105)														if (pixelImage->useVirtualPos) {
HXLINE( 105)															index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x) - pixelImage->virtualX));
            														}
            														else {
HXLINE( 105)															index = ::Std_obj::_hx_int(( (Float)(((y * pixelImage->width) + x)) ));
            														}
HXDLIN( 105)														int value;
HXDLIN( 105)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)															value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 105)															value = c;
            														}
HXDLIN( 105)														bool _hx_tmp;
HXDLIN( 105)														if ((index >= 0)) {
HXLINE( 105)															_hx_tmp = (index < (this1->byteLength >> 2));
            														}
            														else {
HXLINE( 105)															_hx_tmp = false;
            														}
HXDLIN( 105)														if (_hx_tmp) {
HXLINE( 105)															::haxe::io::Bytes _this = this1->bytes;
HXDLIN( 105)															int pos = ((index << 2) + this1->byteOffset);
HXDLIN( 105)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 105)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 105)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 105)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
HXLINE(  74)												found3 = true;
            											}
            											else {
HXLINE( 105)												if (found3) {
HXLINE( 105)													goto _hx_goto_242;
            												}
            											}
            										}
            									}
            									_hx_goto_242:;
            								}
            							}
            						}
HXDLIN( 105)						::pixelimage::algo::HitTri hitTriBottom;
HXDLIN( 105)						if ((hasHit == true)) {
HXLINE( 105)							::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx7,by7,cx7,cy7,true);
HXDLIN( 105)							if (hasUndo3) {
HXLINE( 105)								v->undoImage = undoImage3;
HXDLIN( 105)								v->undoX = xIter33->start;
HXDLIN( 105)								v->undoY = yIter33->start;
            							}
HXDLIN( 105)							hitTriBottom = v;
            						}
            						else {
HXLINE( 105)							hitTriBottom = null();
            						}
HXDLIN( 105)						if (hasHit) {
HXLINE( 105)							::pixelimage::algo::HitTriArray hitArr = ::pixelimage::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN( 105)							if (::hx::IsNotNull( hitQuad )) {
HXLINE( 105)								hitArr->triArr->push(hitQuad->triABD);
            							}
HXDLIN( 105)							hitArr->triArr->push(hitQuad->triBCD);
            						}
            					}
            				}
            			}
            		}
HXLINE( 109)		return this->super::render(pixelImage);
            	}



::hx::ObjectPtr< ArrowShape_obj > ArrowShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< bool >  __o_both,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_arrowWidth,::hx::Null< Float >  __o_arrowHeight,::hx::Null< Float >  __o_soft) {
	::hx::ObjectPtr< ArrowShape_obj > __this = new ArrowShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_both,__o_flare,__o_reverseFlare,__o_x1,__o_y1,__o_x2,__o_y2,__o_arrowWidth,__o_arrowHeight,__o_soft);
	return __this;
}

::hx::ObjectPtr< ArrowShape_obj > ArrowShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< bool >  __o_both,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< Float >  __o_x1,::hx::Null< Float >  __o_y1,::hx::Null< Float >  __o_x2,::hx::Null< Float >  __o_y2,::hx::Null< Float >  __o_arrowWidth,::hx::Null< Float >  __o_arrowHeight,::hx::Null< Float >  __o_soft) {
	ArrowShape_obj *__this = (ArrowShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ArrowShape_obj), true, "pixelimage.triangleGML.contour.ArrowShape"));
	*(void **)__this = ArrowShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_both,__o_flare,__o_reverseFlare,__o_x1,__o_y1,__o_x2,__o_y2,__o_arrowWidth,__o_arrowHeight,__o_soft);
	return __this;
}

ArrowShape_obj::ArrowShape_obj()
{
}

::hx::Val ArrowShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { return ::hx::Val( x1 ); }
		if (HX_FIELD_EQ(inName,"y1") ) { return ::hx::Val( y1 ); }
		if (HX_FIELD_EQ(inName,"x2") ) { return ::hx::Val( x2 ); }
		if (HX_FIELD_EQ(inName,"y2") ) { return ::hx::Val( y2 ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"both") ) { return ::hx::Val( both ); }
		if (HX_FIELD_EQ(inName,"soft") ) { return ::hx::Val( soft ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"flare") ) { return ::hx::Val( flare ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"arrowWidth") ) { return ::hx::Val( arrowWidth ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"arrowHeight") ) { return ::hx::Val( arrowHeight ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"reverseFlare") ) { return ::hx::Val( reverseFlare ); }
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ArrowShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"x1") ) { x1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y1") ) { y1=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"x2") ) { x2=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y2") ) { y2=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"both") ) { both=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"soft") ) { soft=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"flare") ) { flare=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"arrowWidth") ) { arrowWidth=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"arrowHeight") ) { arrowHeight=inValue.Cast< Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"reverseFlare") ) { reverseFlare=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ArrowShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x1",b9,68,00,00));
	outFields->push(HX_("y1",98,69,00,00));
	outFields->push(HX_("x2",ba,68,00,00));
	outFields->push(HX_("y2",99,69,00,00));
	outFields->push(HX_("both",81,88,1b,41));
	outFields->push(HX_("flare",ce,34,8c,02));
	outFields->push(HX_("reverseFlare",4c,10,f1,18));
	outFields->push(HX_("arrowWidth",7d,93,05,3e));
	outFields->push(HX_("arrowHeight",90,f2,2a,bd));
	outFields->push(HX_("soft",ea,1c,58,4c));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ArrowShape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(ArrowShape_obj,x1),HX_("x1",b9,68,00,00)},
	{::hx::fsFloat,(int)offsetof(ArrowShape_obj,y1),HX_("y1",98,69,00,00)},
	{::hx::fsFloat,(int)offsetof(ArrowShape_obj,x2),HX_("x2",ba,68,00,00)},
	{::hx::fsFloat,(int)offsetof(ArrowShape_obj,y2),HX_("y2",99,69,00,00)},
	{::hx::fsBool,(int)offsetof(ArrowShape_obj,both),HX_("both",81,88,1b,41)},
	{::hx::fsBool,(int)offsetof(ArrowShape_obj,flare),HX_("flare",ce,34,8c,02)},
	{::hx::fsBool,(int)offsetof(ArrowShape_obj,reverseFlare),HX_("reverseFlare",4c,10,f1,18)},
	{::hx::fsFloat,(int)offsetof(ArrowShape_obj,arrowWidth),HX_("arrowWidth",7d,93,05,3e)},
	{::hx::fsFloat,(int)offsetof(ArrowShape_obj,arrowHeight),HX_("arrowHeight",90,f2,2a,bd)},
	{::hx::fsFloat,(int)offsetof(ArrowShape_obj,soft),HX_("soft",ea,1c,58,4c)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ArrowShape_obj_sStaticStorageInfo = 0;
#endif

static ::String ArrowShape_obj_sMemberFields[] = {
	HX_("x1",b9,68,00,00),
	HX_("y1",98,69,00,00),
	HX_("x2",ba,68,00,00),
	HX_("y2",99,69,00,00),
	HX_("both",81,88,1b,41),
	HX_("flare",ce,34,8c,02),
	HX_("reverseFlare",4c,10,f1,18),
	HX_("arrowWidth",7d,93,05,3e),
	HX_("arrowHeight",90,f2,2a,bd),
	HX_("soft",ea,1c,58,4c),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class ArrowShape_obj::__mClass;

void ArrowShape_obj::__register()
{
	ArrowShape_obj _hx_dummy;
	ArrowShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.contour.ArrowShape",d5,2a,d0,d6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ArrowShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ArrowShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ArrowShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ArrowShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace contour
