// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitQuad
#include <pixelimage/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pixelimage_algo_HitTri
#include <pixelimage/algo/HitTri.h>
#endif
#ifndef INCLUDED_pixelimage_algo_IhitObj
#include <pixelimage/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pixelimage_iter_IntIterStart
#include <pixelimage/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_contour_QuadShape
#include <pixelimage/triangleGML/contour/QuadShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d65a14b6114197b6_31_new,"pixelimage.triangleGML.contour.QuadShape","new",0x5443d8af,"pixelimage.triangleGML.contour.QuadShape.new","pixelimage/triangleGML/contour/QuadShape.hx",31,0x176799a4)
HX_LOCAL_STACK_FRAME(_hx_pos_d65a14b6114197b6_45_setParameter,"pixelimage.triangleGML.contour.QuadShape","setParameter",0xc5c9eb78,"pixelimage.triangleGML.contour.QuadShape.setParameter","pixelimage/triangleGML/contour/QuadShape.hx",45,0x176799a4)
HX_LOCAL_STACK_FRAME(_hx_pos_d65a14b6114197b6_70_render,"pixelimage.triangleGML.contour.QuadShape","render",0x45263e67,"pixelimage.triangleGML.contour.QuadShape.render","pixelimage/triangleGML/contour/QuadShape.hx",70,0x176799a4)
namespace pixelimage{
namespace triangleGML{
namespace contour{

void QuadShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_aX,::hx::Null< Float >  __o_aY,::hx::Null< Float >  __o_bX,::hx::Null< Float >  __o_bY,::hx::Null< Float >  __o_cX,::hx::Null< Float >  __o_cY,::hx::Null< Float >  __o_dX,::hx::Null< Float >  __o_dY,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_luxury){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(-1048576);
            		Float aX = __o_aX.Default(((Float)0.));
            		Float aY = __o_aY.Default(((Float)0.));
            		Float bX = __o_bX.Default(((Float)1.));
            		Float bY = __o_bY.Default(((Float)0.));
            		Float cX = __o_cX.Default(((Float)1.));
            		Float cY = __o_cY.Default(((Float)1.));
            		Float dX = __o_dX.Default(((Float)0.));
            		Float dY = __o_dY.Default(((Float)1.));
            		Float soft = __o_soft.Default(((Float)0.));
            		bool luxury = __o_luxury.Default(false);
            	HX_STACKFRAME(&_hx_pos_d65a14b6114197b6_31_new)
HXLINE(  32)		super::__construct(opacity,visibility,strokeColor,((Float)0.),null());
HXLINE(  33)		this->aX = aX;
HXLINE(  34)		this->aY = aY;
HXLINE(  35)		this->bX = bX;
HXLINE(  36)		this->bY = bY;
HXLINE(  37)		this->cX = cX;
HXLINE(  38)		this->cY = cY;
HXLINE(  39)		this->dX = dX;
HXLINE(  40)		this->dY = dY;
HXLINE(  41)		this->soft = soft;
HXLINE(  42)		this->luxury = luxury;
            	}

Dynamic QuadShape_obj::__CreateEmpty() { return new QuadShape_obj; }

void *QuadShape_obj::_hx_vtable = 0;

Dynamic QuadShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< QuadShape_obj > _hx_result = new QuadShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12]);
	return _hx_result;
}

bool QuadShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x40e87ca5;
	}
}

void QuadShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_d65a14b6114197b6_45_setParameter)
HXDLIN(  45)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("aX",d7,54,00,00)) ){
HXLINE(  47)			this->aX = ::Std_obj::parseFloat(value);
HXDLIN(  47)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("aY",d8,54,00,00)) ){
HXLINE(  49)			this->aY = ::Std_obj::parseFloat(value);
HXDLIN(  49)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("bX",b6,55,00,00)) ){
HXLINE(  51)			this->bX = ::Std_obj::parseFloat(value);
HXDLIN(  51)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("bY",b7,55,00,00)) ){
HXLINE(  53)			this->bY = ::Std_obj::parseFloat(value);
HXDLIN(  53)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("cX",95,56,00,00)) ){
HXLINE(  55)			this->cX = ::Std_obj::parseFloat(value);
HXDLIN(  55)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("cY",96,56,00,00)) ){
HXLINE(  57)			this->cY = ::Std_obj::parseFloat(value);
HXDLIN(  57)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("dX",74,57,00,00)) ){
HXLINE(  59)			this->dX = ::Std_obj::parseFloat(value);
HXDLIN(  59)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("dY",75,57,00,00)) ){
HXLINE(  61)			this->dY = ::Std_obj::parseFloat(value);
HXDLIN(  61)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("luxury",0d,9d,17,dc)) ){
HXLINE(  65)			bool _hx_tmp;
HXDLIN(  65)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  65)				_hx_tmp = true;
            			}
            			else {
HXLINE(  65)				_hx_tmp = false;
            			}
HXDLIN(  65)			this->luxury = _hx_tmp;
HXDLIN(  65)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("soft",ea,1c,58,4c)) ){
HXLINE(  63)			this->soft = ::Std_obj::parseFloat(value);
HXDLIN(  63)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  67)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct QuadShape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_GC_STACKFRAME(&_hx_pos_d65a14b6114197b6_70_render)
HXLINE(  71)		::Dynamic _hx_tmp;
HXDLIN(  71)		if ((this->soft == ((Float)0.))) {
HXLINE(  72)			Float ax = (this->aX + this->offX);
HXDLIN(  72)			Float ay = (this->aY + this->offY);
HXDLIN(  72)			Float bx = (this->bX + this->offX);
HXDLIN(  72)			Float by = (this->bY + this->offY);
HXDLIN(  72)			Float cx = (this->cX + this->offX);
HXDLIN(  72)			Float cy = (this->cY + this->offY);
HXDLIN(  72)			Float dx = (this->dX + this->offX);
HXDLIN(  72)			Float dy = (this->dY + this->offY);
HXDLIN(  72)			int color = this->strokeColor;
HXDLIN(  72)			Float bx1 = bx;
HXDLIN(  72)			Float by1 = by;
HXDLIN(  72)			Float cx1 = dx;
HXDLIN(  72)			Float cy1 = dy;
HXDLIN(  72)			bool hasUndo = false;
HXDLIN(  72)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  72)			if (!(adjustWinding)) {
HXLINE(  72)				Float bx_ = bx1;
HXDLIN(  72)				Float by_ = by1;
HXLINE(  26)				bx1 = cx1;
HXLINE(  27)				by1 = cy1;
HXLINE(  28)				cx1 = bx_;
HXLINE(  29)				cy1 = by_;
            			}
HXLINE(  72)			Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  72)			Float sx = (cy1 - ay);
HXDLIN(  72)			Float sy = (ax - cx1);
HXDLIN(  72)			Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  72)			Float tx = (ay - by1);
HXDLIN(  72)			Float ty = (bx1 - ax);
HXDLIN(  72)			Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  72)			::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  72)			if ((ax > bx1)) {
HXLINE(  72)				if ((ax > cx1)) {
HXLINE(  72)					int min;
HXDLIN(  72)					if ((bx1 > cx1)) {
HXLINE(  72)						min = ::Math_obj::floor(cx1);
            					}
            					else {
HXLINE(  72)						min = ::Math_obj::floor(bx1);
            					}
HXDLIN(  72)					int ii_min = min;
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					xIter3 = this1;
            				}
            				else {
HXLINE(  72)					int ii_min = ::Math_obj::floor(bx1);
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					xIter3 = this1;
            				}
            			}
            			else {
HXLINE(  72)				if ((bx1 > cx1)) {
HXLINE(  72)					int min;
HXDLIN(  72)					if ((ax > cx1)) {
HXLINE(  72)						min = ::Math_obj::floor(cx1);
            					}
            					else {
HXLINE(  72)						min = ::Math_obj::ceil(ax);
            					}
HXDLIN(  72)					int ii_min = min;
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(bx1);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					xIter3 = this1;
            				}
            				else {
HXLINE(  72)					int ii_min = ::Math_obj::floor(ax);
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(cx1);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					xIter3 = this1;
            				}
            			}
HXDLIN(  72)			::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  72)			if ((ay > by1)) {
HXLINE(  72)				if ((ay > cy1)) {
HXLINE(  72)					int min;
HXDLIN(  72)					if ((by1 > cy1)) {
HXLINE(  72)						min = ::Math_obj::floor(cy1);
            					}
            					else {
HXLINE(  72)						min = ::Math_obj::floor(by1);
            					}
HXDLIN(  72)					int ii_min = min;
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					yIter3 = this1;
            				}
            				else {
HXLINE(  72)					int ii_min = ::Math_obj::floor(by1);
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					yIter3 = this1;
            				}
            			}
            			else {
HXLINE(  72)				if ((by1 > cy1)) {
HXLINE(  72)					int min;
HXDLIN(  72)					if ((ay > cy1)) {
HXLINE(  72)						min = ::Math_obj::floor(cy1);
            					}
            					else {
HXLINE(  72)						min = ::Math_obj::ceil(ay);
            					}
HXDLIN(  72)					int ii_min = min;
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(by1);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					yIter3 = this1;
            				}
            				else {
HXLINE(  72)					int ii_min = ::Math_obj::floor(ay);
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(cy1);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					yIter3 = this1;
            				}
            			}
HXDLIN(  72)			::pixelimage::ImageStruct undoImage = null();
HXDLIN(  72)			if (hasUndo) {
HXLINE(  72)				int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  72)				int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  72)				int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  72)				::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  72)				::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  72)				::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  72)				undoImage = this3;
HXDLIN(  72)				{
HXLINE(  72)					int rectLeft = xIter3->start;
HXDLIN(  72)					int rectTop = yIter3->start;
HXDLIN(  72)					int rectRight = xIter3->max;
HXDLIN(  72)					bool forceClear = false;
HXDLIN(  72)					{
HXLINE(  72)						int _g = rectTop;
HXDLIN(  72)						int _g1 = yIter3->max;
HXDLIN(  72)						while((_g < _g1)){
HXLINE(  72)							_g = (_g + 1);
HXDLIN(  72)							int dy = (_g - 1);
HXDLIN(  72)							{
HXLINE(  72)								int _g1 = rectLeft;
HXDLIN(  72)								int _g2 = rectRight;
HXDLIN(  72)								while((_g1 < _g2)){
HXLINE(  72)									_g1 = (_g1 + 1);
HXDLIN(  72)									int dx = (_g1 - 1);
HXDLIN(  72)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  72)									int index;
HXDLIN(  72)									if (pixelShape->useVirtualPos) {
HXLINE(  72)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  72)										index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            									}
HXDLIN(  72)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  72)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  72)									int col;
HXDLIN(  72)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  72)										col = c;
            									}
HXDLIN(  72)									bool _hx_tmp;
HXDLIN(  72)									if (pixelShape->useMask) {
HXLINE(  72)										_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            									}
            									else {
HXLINE(  72)										_hx_tmp = false;
            									}
HXDLIN(  72)									if (_hx_tmp) {
HXLINE(  72)										::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  72)										::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  72)										int index;
HXDLIN(  72)										if (this1->useVirtualPos) {
HXLINE(  72)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            										}
            										else {
HXLINE(  72)											index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            										}
HXDLIN(  72)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  72)										int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  72)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  72)										int v;
HXDLIN(  72)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)											v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  72)											v = c;
            										}
HXDLIN(  72)										int this3 = v;
HXDLIN(  72)										int maskPixel = this3;
HXDLIN(  72)										int this4 = col;
HXDLIN(  72)										int this5 = this4;
HXDLIN(  72)										if ((maskPixel == 0)) {
HXLINE(  72)											int this1 = this5;
HXDLIN(  72)											col = this1;
            										}
            										else {
HXLINE(  72)											Float m0;
HXDLIN(  72)											int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  72)											if ((this1 == 0)) {
HXLINE(  72)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float m1;
HXDLIN(  72)											int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  72)											if ((this2 == 0)) {
HXLINE(  72)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float m2;
HXDLIN(  72)											int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  72)											if ((this3 == 0)) {
HXLINE(  72)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float m3;
HXDLIN(  72)											int this4 = (maskPixel & 255);
HXDLIN(  72)											if ((this4 == 0)) {
HXLINE(  72)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  72)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  72)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  72)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  72)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  72)									if ((col != 0)) {
HXLINE(  72)										int x = (dx - rectLeft);
HXDLIN(  72)										int y = (dy - rectTop);
HXDLIN(  72)										int this1 = col;
HXDLIN(  72)										int c = this1;
HXDLIN(  72)										bool _hx_tmp;
HXDLIN(  72)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  72)											_hx_tmp = undoImage->transparent;
            										}
            										else {
HXLINE(  72)											_hx_tmp = false;
            										}
HXDLIN(  72)										if (_hx_tmp) {
HXLINE(  72)											int location;
HXDLIN(  72)											if (undoImage->useVirtualPos) {
HXLINE(  72)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  72)												location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  72)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  72)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  72)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  72)											int this3 = this2;
HXDLIN(  72)											int this4;
HXDLIN(  72)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  72)												this4 = this3;
            											}
HXDLIN(  72)											Float a1;
HXDLIN(  72)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  72)											if ((this5 == 0)) {
HXLINE(  72)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float r1;
HXDLIN(  72)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  72)											if ((this6 == 0)) {
HXLINE(  72)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float g1;
HXDLIN(  72)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  72)											if ((this7 == 0)) {
HXLINE(  72)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float b1;
HXDLIN(  72)											int this8 = (this4 & 255);
HXDLIN(  72)											if ((this8 == 0)) {
HXLINE(  72)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float a2;
HXDLIN(  72)											int this9 = ((col >> 24) & 255);
HXDLIN(  72)											if ((this9 == 0)) {
HXLINE(  72)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float r2;
HXDLIN(  72)											int this10 = ((col >> 16) & 255);
HXDLIN(  72)											if ((this10 == 0)) {
HXLINE(  72)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float g2;
HXDLIN(  72)											int this11 = ((col >> 8) & 255);
HXDLIN(  72)											if ((this11 == 0)) {
HXLINE(  72)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float b2;
HXDLIN(  72)											int this12 = (col & 255);
HXDLIN(  72)											if ((this12 == 0)) {
HXLINE(  72)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  72)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  72)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  72)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  72)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  72)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  72)											{
HXLINE(  72)												::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  72)												int value;
HXDLIN(  72)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  72)													value = blended;
            												}
HXDLIN(  72)												bool _hx_tmp;
HXDLIN(  72)												if ((location >= 0)) {
HXLINE(  72)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  72)													_hx_tmp = false;
            												}
HXDLIN(  72)												if (_hx_tmp) {
HXLINE(  72)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  72)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  72)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  72)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  72)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  72)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  72)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  72)											int index;
HXDLIN(  72)											if (undoImage->useVirtualPos) {
HXLINE(  72)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  72)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  72)											int value;
HXDLIN(  72)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  72)												value = c;
            											}
HXDLIN(  72)											bool _hx_tmp;
HXDLIN(  72)											if ((index >= 0)) {
HXLINE(  72)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  72)												_hx_tmp = false;
            											}
HXDLIN(  72)											if (_hx_tmp) {
HXLINE(  72)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  72)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  72)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  72)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  72)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  72)										if (forceClear) {
HXLINE(  72)											::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  72)											int x = (dx - rectLeft);
HXDLIN(  72)											int y = (dy - rectTop);
HXDLIN(  72)											int index;
HXDLIN(  72)											if (undoImage->useVirtualPos) {
HXLINE(  72)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            											}
            											else {
HXLINE(  72)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            											}
HXDLIN(  72)											bool _hx_tmp;
HXDLIN(  72)											if ((index >= 0)) {
HXLINE(  72)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  72)												_hx_tmp = false;
            											}
HXDLIN(  72)											if (_hx_tmp) {
HXLINE(  72)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  72)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  72)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  72)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  72)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  72)			bool found = false;
HXDLIN(  72)			Float s = ((Float)0.);
HXDLIN(  72)			Float t = ((Float)0.);
HXDLIN(  72)			Float sxx = ((Float)0.);
HXDLIN(  72)			Float txx = ((Float)0.);
HXDLIN(  72)			{
HXLINE(  72)				int _g_min = xIter3->start;
HXDLIN(  72)				int _g_max = xIter3->max;
HXDLIN(  72)				while((_g_min < _g_max)){
HXLINE(  72)					_g_min = (_g_min + 1);
HXDLIN(  72)					int x = (_g_min - 1);
HXLINE(  61)					sxx = (sx * ( (Float)(x) ));
HXLINE(  62)					txx = (tx * ( (Float)(x) ));
HXLINE(  63)					found = false;
HXLINE(  72)					{
HXLINE(  72)						int _g_min1 = yIter3->start;
HXDLIN(  72)						int _g_max = yIter3->max;
HXDLIN(  72)						while((_g_min1 < _g_max)){
HXLINE(  72)							_g_min1 = (_g_min1 + 1);
HXDLIN(  72)							int y = (_g_min1 - 1);
HXLINE(  65)							s = ((s0 + sxx) + (sy * ( (Float)(y) )));
HXLINE(  66)							t = ((t0 + txx) + (ty * ( (Float)(y) )));
HXLINE(  72)							bool _hx_tmp;
HXDLIN(  72)							if (!((s <= 0))) {
HXLINE(  72)								_hx_tmp = (t <= 0);
            							}
            							else {
HXLINE(  72)								_hx_tmp = true;
            							}
HXDLIN(  72)							if (_hx_tmp) {
HXLINE(  72)								if (found) {
HXLINE(  72)									goto _hx_goto_6;
            								}
            							}
            							else {
HXLINE(  72)								if (((s + t) < A)) {
HXLINE(  72)									{
HXLINE(  72)										int this1 = color;
HXDLIN(  72)										int c = this1;
HXDLIN(  72)										bool _hx_tmp;
HXDLIN(  72)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  72)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  72)											_hx_tmp = false;
            										}
HXDLIN(  72)										if (_hx_tmp) {
HXLINE(  72)											int location;
HXDLIN(  72)											if (pixelShape->useVirtualPos) {
HXLINE(  72)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  72)												location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            											}
HXDLIN(  72)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  72)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  72)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  72)											int this3 = this2;
HXDLIN(  72)											int this4;
HXDLIN(  72)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  72)												this4 = this3;
            											}
HXDLIN(  72)											Float a1;
HXDLIN(  72)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  72)											if ((this5 == 0)) {
HXLINE(  72)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float r1;
HXDLIN(  72)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  72)											if ((this6 == 0)) {
HXLINE(  72)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float g1;
HXDLIN(  72)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  72)											if ((this7 == 0)) {
HXLINE(  72)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float b1;
HXDLIN(  72)											int this8 = (this4 & 255);
HXDLIN(  72)											if ((this8 == 0)) {
HXLINE(  72)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float a2;
HXDLIN(  72)											int this9 = ((color >> 24) & 255);
HXDLIN(  72)											if ((this9 == 0)) {
HXLINE(  72)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float r2;
HXDLIN(  72)											int this10 = ((color >> 16) & 255);
HXDLIN(  72)											if ((this10 == 0)) {
HXLINE(  72)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float g2;
HXDLIN(  72)											int this11 = ((color >> 8) & 255);
HXDLIN(  72)											if ((this11 == 0)) {
HXLINE(  72)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float b2;
HXDLIN(  72)											int this12 = (color & 255);
HXDLIN(  72)											if ((this12 == 0)) {
HXLINE(  72)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  72)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  72)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  72)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  72)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  72)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  72)											{
HXLINE(  72)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  72)												int value;
HXDLIN(  72)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  72)													value = blended;
            												}
HXDLIN(  72)												bool _hx_tmp;
HXDLIN(  72)												if ((location >= 0)) {
HXLINE(  72)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  72)													_hx_tmp = false;
            												}
HXDLIN(  72)												if (_hx_tmp) {
HXLINE(  72)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  72)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  72)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  72)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  72)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  72)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  72)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  72)											int index;
HXDLIN(  72)											if (pixelShape->useVirtualPos) {
HXLINE(  72)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  72)												index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            											}
HXDLIN(  72)											int value;
HXDLIN(  72)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  72)												value = c;
            											}
HXDLIN(  72)											bool _hx_tmp;
HXDLIN(  72)											if ((index >= 0)) {
HXLINE(  72)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  72)												_hx_tmp = false;
            											}
HXDLIN(  72)											if (_hx_tmp) {
HXLINE(  72)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  72)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  72)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  72)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  72)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXLINE(  74)									found = true;
            								}
            								else {
HXLINE(  72)									if (found) {
HXLINE(  72)										goto _hx_goto_6;
            									}
            								}
            							}
            						}
            						_hx_goto_6:;
            					}
            				}
            			}
HXDLIN(  72)			::pixelimage::iter::IntIterStart v_yIter3;
HXDLIN(  72)			::pixelimage::iter::IntIterStart v_xIter3;
HXDLIN(  72)			int v_undoY;
HXDLIN(  72)			int v_undoX;
HXDLIN(  72)			Float v_ty;
HXDLIN(  72)			Float v_tx;
HXDLIN(  72)			Float v_t0;
HXDLIN(  72)			Float v_sy;
HXDLIN(  72)			Float v_sx;
HXDLIN(  72)			Float v_s0;
HXDLIN(  72)			Float v_A;
HXDLIN(  72)			Float ax1 = ax;
HXDLIN(  72)			Float ay1 = ay;
HXDLIN(  72)			Float bx2 = bx1;
HXDLIN(  72)			Float by2 = by1;
HXDLIN(  72)			Float cx2 = cx1;
HXDLIN(  72)			Float cy2 = cy1;
HXDLIN(  72)			::pixelimage::ImageStruct v_undoImage = null();
HXDLIN(  72)			bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  72)			if (!(adjustWinding1)) {
HXLINE(  72)				Float bx_ = bx2;
HXDLIN(  72)				Float by_ = by2;
HXLINE(  35)				bx2 = cx2;
HXLINE(  36)				by2 = cy2;
HXLINE(  37)				cx2 = bx_;
HXLINE(  38)				cy2 = by_;
            			}
HXLINE(  72)			Float v_ax = ax1;
HXDLIN(  72)			Float v_ay = ay1;
HXDLIN(  72)			Float v_bx = bx2;
HXDLIN(  72)			Float v_by = by2;
HXDLIN(  72)			Float v_cx = cx2;
HXDLIN(  72)			Float v_cy = cy2;
HXDLIN(  72)			bool v_preCalculated = true;
HXDLIN(  72)			{
HXLINE(  72)				v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  72)				v_sx = (v_cy - v_ay);
HXDLIN(  72)				v_sy = (v_ax - v_cx);
HXDLIN(  72)				v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  72)				v_tx = (v_ay - v_by);
HXDLIN(  72)				v_ty = (v_bx - v_ax);
HXDLIN(  72)				v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  72)				Float a = v_ax;
HXDLIN(  72)				Float b = v_bx;
HXDLIN(  72)				Float c = v_cx;
HXDLIN(  72)				if ((a > b)) {
HXLINE(  72)					if ((a > c)) {
HXLINE(  72)						int min;
HXDLIN(  72)						if ((b > c)) {
HXLINE(  72)							min = ::Math_obj::floor(c);
            						}
            						else {
HXLINE(  72)							min = ::Math_obj::floor(b);
            						}
HXDLIN(  72)						int ii_min = min;
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(a);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_xIter3 = this1;
            					}
            					else {
HXLINE(  72)						int ii_min = ::Math_obj::floor(b);
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(c);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_xIter3 = this1;
            					}
            				}
            				else {
HXLINE(  72)					if ((b > c)) {
HXLINE(  72)						int min;
HXDLIN(  72)						if ((a > c)) {
HXLINE(  72)							min = ::Math_obj::floor(c);
            						}
            						else {
HXLINE(  72)							min = ::Math_obj::ceil(a);
            						}
HXDLIN(  72)						int ii_min = min;
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(b);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_xIter3 = this1;
            					}
            					else {
HXLINE(  72)						int ii_min = ::Math_obj::floor(a);
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(c);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_xIter3 = this1;
            					}
            				}
HXDLIN(  72)				Float a1 = v_ay;
HXDLIN(  72)				Float b1 = v_by;
HXDLIN(  72)				Float c1 = v_cy;
HXDLIN(  72)				if ((a1 > b1)) {
HXLINE(  72)					if ((a1 > c1)) {
HXLINE(  72)						int min;
HXDLIN(  72)						if ((b1 > c1)) {
HXLINE(  72)							min = ::Math_obj::floor(c1);
            						}
            						else {
HXLINE(  72)							min = ::Math_obj::floor(b1);
            						}
HXDLIN(  72)						int ii_min = min;
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(a1);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_yIter3 = this1;
            					}
            					else {
HXLINE(  72)						int ii_min = ::Math_obj::floor(b1);
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_yIter3 = this1;
            					}
            				}
            				else {
HXLINE(  72)					if ((b1 > c1)) {
HXLINE(  72)						int min;
HXDLIN(  72)						if ((a1 > c1)) {
HXLINE(  72)							min = ::Math_obj::floor(c1);
            						}
            						else {
HXLINE(  72)							min = ::Math_obj::ceil(a1);
            						}
HXDLIN(  72)						int ii_min = min;
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(b1);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_yIter3 = this1;
            					}
            					else {
HXLINE(  72)						int ii_min = ::Math_obj::floor(a1);
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(c1);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_yIter3 = this1;
            					}
            				}
            			}
HXDLIN(  72)			if (hasUndo) {
HXLINE(  72)				v_undoImage = undoImage;
HXDLIN(  72)				v_undoX = xIter3->start;
HXDLIN(  72)				v_undoY = yIter3->start;
            			}
HXDLIN(  72)			Float bx3 = cx;
HXDLIN(  72)			Float by3 = cy;
HXDLIN(  72)			Float cx3 = dx;
HXDLIN(  72)			Float cy3 = dy;
HXDLIN(  72)			bool hasUndo1 = false;
HXDLIN(  72)			bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN(  72)			if (!(adjustWinding2)) {
HXLINE(  72)				Float bx_ = bx3;
HXDLIN(  72)				Float by_ = by3;
HXLINE(  26)				bx3 = cx3;
HXLINE(  27)				by3 = cy3;
HXLINE(  28)				cx3 = bx_;
HXLINE(  29)				cy3 = by_;
            			}
HXLINE(  72)			Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN(  72)			Float sx1 = (cy3 - by);
HXDLIN(  72)			Float sy1 = (bx - cx3);
HXDLIN(  72)			Float t01 = ((bx * by3) - (by * bx3));
HXDLIN(  72)			Float tx1 = (by - by3);
HXDLIN(  72)			Float ty1 = (bx3 - bx);
HXDLIN(  72)			Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN(  72)			::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  72)			if ((bx > bx3)) {
HXLINE(  72)				if ((bx > cx3)) {
HXLINE(  72)					int min;
HXDLIN(  72)					if ((bx3 > cx3)) {
HXLINE(  72)						min = ::Math_obj::floor(cx3);
            					}
            					else {
HXLINE(  72)						min = ::Math_obj::floor(bx3);
            					}
HXDLIN(  72)					int ii_min = min;
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					xIter31 = this1;
            				}
            				else {
HXLINE(  72)					int ii_min = ::Math_obj::floor(bx3);
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					xIter31 = this1;
            				}
            			}
            			else {
HXLINE(  72)				if ((bx3 > cx3)) {
HXLINE(  72)					int min;
HXDLIN(  72)					if ((bx > cx3)) {
HXLINE(  72)						min = ::Math_obj::floor(cx3);
            					}
            					else {
HXLINE(  72)						min = ::Math_obj::ceil(bx);
            					}
HXDLIN(  72)					int ii_min = min;
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(bx3);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					xIter31 = this1;
            				}
            				else {
HXLINE(  72)					int ii_min = ::Math_obj::floor(bx);
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(cx3);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					xIter31 = this1;
            				}
            			}
HXDLIN(  72)			::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  72)			if ((by > by3)) {
HXLINE(  72)				if ((by > cy3)) {
HXLINE(  72)					int min;
HXDLIN(  72)					if ((by3 > cy3)) {
HXLINE(  72)						min = ::Math_obj::floor(cy3);
            					}
            					else {
HXLINE(  72)						min = ::Math_obj::floor(by3);
            					}
HXDLIN(  72)					int ii_min = min;
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(by);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					yIter31 = this1;
            				}
            				else {
HXLINE(  72)					int ii_min = ::Math_obj::floor(by3);
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					yIter31 = this1;
            				}
            			}
            			else {
HXLINE(  72)				if ((by3 > cy3)) {
HXLINE(  72)					int min;
HXDLIN(  72)					if ((by > cy3)) {
HXLINE(  72)						min = ::Math_obj::floor(cy3);
            					}
            					else {
HXLINE(  72)						min = ::Math_obj::ceil(by);
            					}
HXDLIN(  72)					int ii_min = min;
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(by3);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					yIter31 = this1;
            				}
            				else {
HXLINE(  72)					int ii_min = ::Math_obj::floor(by);
HXDLIN(  72)					int ii_max = ::Math_obj::ceil(cy3);
HXDLIN(  72)					::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)					yIter31 = this1;
            				}
            			}
HXDLIN(  72)			::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  72)			if (hasUndo1) {
HXLINE(  72)				int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  72)				int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  72)				int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  72)				::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  72)				::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  72)				::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  72)				undoImage1 = this3;
HXDLIN(  72)				{
HXLINE(  72)					int rectLeft = xIter31->start;
HXDLIN(  72)					int rectTop = yIter31->start;
HXDLIN(  72)					int rectRight = xIter31->max;
HXDLIN(  72)					bool forceClear = false;
HXDLIN(  72)					{
HXLINE(  72)						int _g = rectTop;
HXDLIN(  72)						int _g1 = yIter31->max;
HXDLIN(  72)						while((_g < _g1)){
HXLINE(  72)							_g = (_g + 1);
HXDLIN(  72)							int dy = (_g - 1);
HXDLIN(  72)							{
HXLINE(  72)								int _g1 = rectLeft;
HXDLIN(  72)								int _g2 = rectRight;
HXDLIN(  72)								while((_g1 < _g2)){
HXLINE(  72)									_g1 = (_g1 + 1);
HXDLIN(  72)									int dx = (_g1 - 1);
HXDLIN(  72)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  72)									int index;
HXDLIN(  72)									if (pixelShape->useVirtualPos) {
HXLINE(  72)										index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  72)										index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            									}
HXDLIN(  72)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)									int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  72)									int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  72)									int col;
HXDLIN(  72)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  72)										col = c;
            									}
HXDLIN(  72)									bool _hx_tmp;
HXDLIN(  72)									if (pixelShape->useMask) {
HXLINE(  72)										_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            									}
            									else {
HXLINE(  72)										_hx_tmp = false;
            									}
HXDLIN(  72)									if (_hx_tmp) {
HXLINE(  72)										::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  72)										::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  72)										int index;
HXDLIN(  72)										if (this1->useVirtualPos) {
HXLINE(  72)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            										}
            										else {
HXLINE(  72)											index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            										}
HXDLIN(  72)										::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  72)										int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  72)										int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  72)										int v;
HXDLIN(  72)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)											v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  72)											v = c;
            										}
HXDLIN(  72)										int this3 = v;
HXDLIN(  72)										int maskPixel = this3;
HXDLIN(  72)										int this4 = col;
HXDLIN(  72)										int this5 = this4;
HXDLIN(  72)										if ((maskPixel == 0)) {
HXLINE(  72)											int this1 = this5;
HXDLIN(  72)											col = this1;
            										}
            										else {
HXLINE(  72)											Float m0;
HXDLIN(  72)											int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  72)											if ((this1 == 0)) {
HXLINE(  72)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float m1;
HXDLIN(  72)											int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  72)											if ((this2 == 0)) {
HXLINE(  72)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float m2;
HXDLIN(  72)											int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  72)											if ((this3 == 0)) {
HXLINE(  72)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float m3;
HXDLIN(  72)											int this4 = (maskPixel & 255);
HXDLIN(  72)											if ((this4 == 0)) {
HXLINE(  72)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  72)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  72)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  72)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  72)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  72)									if ((col != 0)) {
HXLINE(  72)										int x = (dx - rectLeft);
HXDLIN(  72)										int y = (dy - rectTop);
HXDLIN(  72)										int this1 = col;
HXDLIN(  72)										int c = this1;
HXDLIN(  72)										bool _hx_tmp;
HXDLIN(  72)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  72)											_hx_tmp = undoImage1->transparent;
            										}
            										else {
HXLINE(  72)											_hx_tmp = false;
            										}
HXDLIN(  72)										if (_hx_tmp) {
HXLINE(  72)											int location;
HXDLIN(  72)											if (undoImage1->useVirtualPos) {
HXLINE(  72)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  72)												location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  72)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  72)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  72)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  72)											int this3 = this2;
HXDLIN(  72)											int this4;
HXDLIN(  72)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  72)												this4 = this3;
            											}
HXDLIN(  72)											Float a1;
HXDLIN(  72)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  72)											if ((this5 == 0)) {
HXLINE(  72)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float r1;
HXDLIN(  72)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  72)											if ((this6 == 0)) {
HXLINE(  72)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float g1;
HXDLIN(  72)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  72)											if ((this7 == 0)) {
HXLINE(  72)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float b1;
HXDLIN(  72)											int this8 = (this4 & 255);
HXDLIN(  72)											if ((this8 == 0)) {
HXLINE(  72)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float a2;
HXDLIN(  72)											int this9 = ((col >> 24) & 255);
HXDLIN(  72)											if ((this9 == 0)) {
HXLINE(  72)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float r2;
HXDLIN(  72)											int this10 = ((col >> 16) & 255);
HXDLIN(  72)											if ((this10 == 0)) {
HXLINE(  72)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float g2;
HXDLIN(  72)											int this11 = ((col >> 8) & 255);
HXDLIN(  72)											if ((this11 == 0)) {
HXLINE(  72)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float b2;
HXDLIN(  72)											int this12 = (col & 255);
HXDLIN(  72)											if ((this12 == 0)) {
HXLINE(  72)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  72)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  72)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  72)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  72)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  72)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  72)											{
HXLINE(  72)												::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  72)												int value;
HXDLIN(  72)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  72)													value = blended;
            												}
HXDLIN(  72)												bool _hx_tmp;
HXDLIN(  72)												if ((location >= 0)) {
HXLINE(  72)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  72)													_hx_tmp = false;
            												}
HXDLIN(  72)												if (_hx_tmp) {
HXLINE(  72)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  72)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  72)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  72)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  72)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  72)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  72)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  72)											int index;
HXDLIN(  72)											if (undoImage1->useVirtualPos) {
HXLINE(  72)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  72)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  72)											int value;
HXDLIN(  72)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  72)												value = c;
            											}
HXDLIN(  72)											bool _hx_tmp;
HXDLIN(  72)											if ((index >= 0)) {
HXLINE(  72)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  72)												_hx_tmp = false;
            											}
HXDLIN(  72)											if (_hx_tmp) {
HXLINE(  72)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  72)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  72)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  72)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  72)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
            									else {
HXLINE(  72)										if (forceClear) {
HXLINE(  72)											::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  72)											int x = (dx - rectLeft);
HXDLIN(  72)											int y = (dy - rectTop);
HXDLIN(  72)											int index;
HXDLIN(  72)											if (undoImage1->useVirtualPos) {
HXLINE(  72)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            											}
            											else {
HXLINE(  72)												index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            											}
HXDLIN(  72)											bool _hx_tmp;
HXDLIN(  72)											if ((index >= 0)) {
HXLINE(  72)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  72)												_hx_tmp = false;
            											}
HXDLIN(  72)											if (_hx_tmp) {
HXLINE(  72)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  72)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  72)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  72)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  72)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  72)			bool found1 = false;
HXDLIN(  72)			Float s1 = ((Float)0.);
HXDLIN(  72)			Float t1 = ((Float)0.);
HXDLIN(  72)			Float sxx1 = ((Float)0.);
HXDLIN(  72)			Float txx1 = ((Float)0.);
HXDLIN(  72)			{
HXLINE(  72)				int _g_min1 = xIter31->start;
HXDLIN(  72)				int _g_max1 = xIter31->max;
HXDLIN(  72)				while((_g_min1 < _g_max1)){
HXLINE(  72)					_g_min1 = (_g_min1 + 1);
HXDLIN(  72)					int x = (_g_min1 - 1);
HXLINE(  61)					sxx1 = (sx1 * ( (Float)(x) ));
HXLINE(  62)					txx1 = (tx1 * ( (Float)(x) ));
HXLINE(  63)					found1 = false;
HXLINE(  72)					{
HXLINE(  72)						int _g_min = yIter31->start;
HXDLIN(  72)						int _g_max = yIter31->max;
HXDLIN(  72)						while((_g_min < _g_max)){
HXLINE(  72)							_g_min = (_g_min + 1);
HXDLIN(  72)							int y = (_g_min - 1);
HXLINE(  65)							s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y) )));
HXLINE(  66)							t1 = ((t01 + txx1) + (ty1 * ( (Float)(y) )));
HXLINE(  72)							bool _hx_tmp;
HXDLIN(  72)							if (!((s1 <= 0))) {
HXLINE(  72)								_hx_tmp = (t1 <= 0);
            							}
            							else {
HXLINE(  72)								_hx_tmp = true;
            							}
HXDLIN(  72)							if (_hx_tmp) {
HXLINE(  72)								if (found1) {
HXLINE(  72)									goto _hx_goto_10;
            								}
            							}
            							else {
HXLINE(  72)								if (((s1 + t1) < A1)) {
HXLINE(  72)									{
HXLINE(  72)										int this1 = color;
HXDLIN(  72)										int c = this1;
HXDLIN(  72)										bool _hx_tmp;
HXDLIN(  72)										if ((((c >> 24) & 255) < 254)) {
HXLINE(  72)											_hx_tmp = pixelShape->transparent;
            										}
            										else {
HXLINE(  72)											_hx_tmp = false;
            										}
HXDLIN(  72)										if (_hx_tmp) {
HXLINE(  72)											int location;
HXDLIN(  72)											if (pixelShape->useVirtualPos) {
HXLINE(  72)												location = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  72)												location = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            											}
HXDLIN(  72)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  72)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)											int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  72)											int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  72)											int this3 = this2;
HXDLIN(  72)											int this4;
HXDLIN(  72)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            											}
            											else {
HXLINE(  72)												this4 = this3;
            											}
HXDLIN(  72)											Float a1;
HXDLIN(  72)											int this5 = ((this4 >> 24) & 255);
HXDLIN(  72)											if ((this5 == 0)) {
HXLINE(  72)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float r1;
HXDLIN(  72)											int this6 = ((this4 >> 16) & 255);
HXDLIN(  72)											if ((this6 == 0)) {
HXLINE(  72)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float g1;
HXDLIN(  72)											int this7 = ((this4 >> 8) & 255);
HXDLIN(  72)											if ((this7 == 0)) {
HXLINE(  72)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float b1;
HXDLIN(  72)											int this8 = (this4 & 255);
HXDLIN(  72)											if ((this8 == 0)) {
HXLINE(  72)												b1 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float a2;
HXDLIN(  72)											int this9 = ((color >> 24) & 255);
HXDLIN(  72)											if ((this9 == 0)) {
HXLINE(  72)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float r2;
HXDLIN(  72)											int this10 = ((color >> 16) & 255);
HXDLIN(  72)											if ((this10 == 0)) {
HXLINE(  72)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float g2;
HXDLIN(  72)											int this11 = ((color >> 8) & 255);
HXDLIN(  72)											if ((this11 == 0)) {
HXLINE(  72)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float b2;
HXDLIN(  72)											int this12 = (color & 255);
HXDLIN(  72)											if ((this12 == 0)) {
HXLINE(  72)												b2 = ((Float)0.);
            											}
            											else {
HXLINE(  72)												b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            											}
HXDLIN(  72)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  72)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  72)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  72)											int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  72)											int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  72)											int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  72)											{
HXLINE(  72)												::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  72)												int value;
HXDLIN(  72)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)													value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  72)													value = blended;
            												}
HXDLIN(  72)												bool _hx_tmp;
HXDLIN(  72)												if ((location >= 0)) {
HXLINE(  72)													_hx_tmp = (location < (this13->byteLength >> 2));
            												}
            												else {
HXLINE(  72)													_hx_tmp = false;
            												}
HXDLIN(  72)												if (_hx_tmp) {
HXLINE(  72)													::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  72)													int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  72)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  72)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  72)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  72)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
            										else {
HXLINE(  72)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  72)											int index;
HXDLIN(  72)											if (pixelShape->useVirtualPos) {
HXLINE(  72)												index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  72)												index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            											}
HXDLIN(  72)											int value;
HXDLIN(  72)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  72)												value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  72)												value = c;
            											}
HXDLIN(  72)											bool _hx_tmp;
HXDLIN(  72)											if ((index >= 0)) {
HXLINE(  72)												_hx_tmp = (index < (this1->byteLength >> 2));
            											}
            											else {
HXLINE(  72)												_hx_tmp = false;
            											}
HXDLIN(  72)											if (_hx_tmp) {
HXLINE(  72)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  72)												int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  72)												_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  72)												_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  72)												_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  72)												_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            											}
            										}
            									}
HXLINE(  74)									found1 = true;
            								}
            								else {
HXLINE(  72)									if (found1) {
HXLINE(  72)										goto _hx_goto_10;
            									}
            								}
            							}
            						}
            						_hx_goto_10:;
            					}
            				}
            			}
HXDLIN(  72)			::pixelimage::iter::IntIterStart v_yIter31;
HXDLIN(  72)			::pixelimage::iter::IntIterStart v_xIter31;
HXDLIN(  72)			int v_undoY1;
HXDLIN(  72)			int v_undoX1;
HXDLIN(  72)			Float v_ty1;
HXDLIN(  72)			Float v_tx1;
HXDLIN(  72)			Float v_t01;
HXDLIN(  72)			Float v_sy1;
HXDLIN(  72)			Float v_sx1;
HXDLIN(  72)			Float v_s01;
HXDLIN(  72)			Float v_A1;
HXDLIN(  72)			Float ax2 = bx;
HXDLIN(  72)			Float ay2 = by;
HXDLIN(  72)			Float bx4 = bx3;
HXDLIN(  72)			Float by4 = by3;
HXDLIN(  72)			Float cx4 = cx3;
HXDLIN(  72)			Float cy4 = cy3;
HXDLIN(  72)			::pixelimage::ImageStruct v_undoImage1 = null();
HXDLIN(  72)			bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN(  72)			if (!(adjustWinding3)) {
HXLINE(  72)				Float bx_ = bx4;
HXDLIN(  72)				Float by_ = by4;
HXLINE(  35)				bx4 = cx4;
HXLINE(  36)				by4 = cy4;
HXLINE(  37)				cx4 = bx_;
HXLINE(  38)				cy4 = by_;
            			}
HXLINE(  72)			Float v_ax1 = ax2;
HXDLIN(  72)			Float v_ay1 = ay2;
HXDLIN(  72)			Float v_bx1 = bx4;
HXDLIN(  72)			Float v_by1 = by4;
HXDLIN(  72)			Float v_cx1 = cx4;
HXDLIN(  72)			Float v_cy1 = cy4;
HXDLIN(  72)			bool v_preCalculated1 = true;
HXDLIN(  72)			{
HXLINE(  72)				v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  72)				v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  72)				v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  72)				v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  72)				v_tx1 = (v_ay1 - v_by1);
HXDLIN(  72)				v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  72)				v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  72)				Float a2 = v_ax1;
HXDLIN(  72)				Float b2 = v_bx1;
HXDLIN(  72)				Float c2 = v_cx1;
HXDLIN(  72)				if ((a2 > b2)) {
HXLINE(  72)					if ((a2 > c2)) {
HXLINE(  72)						int min;
HXDLIN(  72)						if ((b2 > c2)) {
HXLINE(  72)							min = ::Math_obj::floor(c2);
            						}
            						else {
HXLINE(  72)							min = ::Math_obj::floor(b2);
            						}
HXDLIN(  72)						int ii_min = min;
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(a2);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_xIter31 = this1;
            					}
            					else {
HXLINE(  72)						int ii_min = ::Math_obj::floor(b2);
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_xIter31 = this1;
            					}
            				}
            				else {
HXLINE(  72)					if ((b2 > c2)) {
HXLINE(  72)						int min;
HXDLIN(  72)						if ((a2 > c2)) {
HXLINE(  72)							min = ::Math_obj::floor(c2);
            						}
            						else {
HXLINE(  72)							min = ::Math_obj::ceil(a2);
            						}
HXDLIN(  72)						int ii_min = min;
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(b2);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_xIter31 = this1;
            					}
            					else {
HXLINE(  72)						int ii_min = ::Math_obj::floor(a2);
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(c2);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_xIter31 = this1;
            					}
            				}
HXDLIN(  72)				Float a3 = v_ay1;
HXDLIN(  72)				Float b3 = v_by1;
HXDLIN(  72)				Float c3 = v_cy1;
HXDLIN(  72)				if ((a3 > b3)) {
HXLINE(  72)					if ((a3 > c3)) {
HXLINE(  72)						int min;
HXDLIN(  72)						if ((b3 > c3)) {
HXLINE(  72)							min = ::Math_obj::floor(c3);
            						}
            						else {
HXLINE(  72)							min = ::Math_obj::floor(b3);
            						}
HXDLIN(  72)						int ii_min = min;
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(a3);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_yIter31 = this1;
            					}
            					else {
HXLINE(  72)						int ii_min = ::Math_obj::floor(b3);
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_yIter31 = this1;
            					}
            				}
            				else {
HXLINE(  72)					if ((b3 > c3)) {
HXLINE(  72)						int min;
HXDLIN(  72)						if ((a3 > c3)) {
HXLINE(  72)							min = ::Math_obj::floor(c3);
            						}
            						else {
HXLINE(  72)							min = ::Math_obj::ceil(a3);
            						}
HXDLIN(  72)						int ii_min = min;
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(b3);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_yIter31 = this1;
            					}
            					else {
HXLINE(  72)						int ii_min = ::Math_obj::floor(a3);
HXDLIN(  72)						int ii_max = ::Math_obj::ceil(c3);
HXDLIN(  72)						::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  72)						v_yIter31 = this1;
            					}
            				}
            			}
HXDLIN(  72)			if (hasUndo1) {
HXLINE(  72)				v_undoImage1 = undoImage1;
HXDLIN(  72)				v_undoX1 = xIter31->start;
HXDLIN(  72)				v_undoY1 = yIter31->start;
            			}
HXDLIN(  72)			::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE(  71)			_hx_tmp = v;
            		}
            		else {
HXLINE(  74)			if (this->luxury) {
HXLINE(  75)				Float ax = (this->aX + this->offX);
HXDLIN(  75)				Float ay = (this->aY + this->offY);
HXDLIN(  75)				Float bx = (this->bX + this->offX);
HXDLIN(  75)				Float by = (this->bY + this->offY);
HXDLIN(  75)				Float cx = (this->cX + this->offX);
HXDLIN(  75)				Float cy = (this->cY + this->offY);
HXDLIN(  75)				Float dx = (this->dX + this->offX);
HXDLIN(  75)				Float dy = (this->dY + this->offY);
HXDLIN(  75)				int color = this->strokeColor;
HXDLIN(  75)				Float soft = this->soft;
HXDLIN(  75)				bool hasHit = false;
HXDLIN(  75)				{
HXLINE(  75)					bool hasUndo = true;
HXDLIN(  75)					int aA = ((color >> 24) & 255);
HXDLIN(  75)					int rA = ((color >> 16) & 255);
HXDLIN(  75)					int gA = ((color >> 8) & 255);
HXDLIN(  75)					int bA = (color & 255);
HXDLIN(  75)					Float bcx = (bx - cx);
HXDLIN(  75)					Float bcy = (by - cy);
HXDLIN(  75)					Float acx = (ax - cx);
HXDLIN(  75)					Float acy = (ay - cy);
HXDLIN(  75)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  75)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  75)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  75)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  75)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  75)					if ((ax > bx)) {
HXLINE(  75)						if ((ax > cx)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((bx > cx)) {
HXLINE(  75)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::floor(bx);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter3 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(bx);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE(  75)						if ((bx > cx)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((ax > cx)) {
HXLINE(  75)								min = ::Math_obj::floor(cx);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::ceil(ax);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter3 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(ax);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter3 = this1;
            						}
            					}
HXDLIN(  75)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  75)					if ((ay > by)) {
HXLINE(  75)						if ((ay > cy)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((by > cy)) {
HXLINE(  75)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::floor(by);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter3 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(by);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE(  75)						if ((by > cy)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((ay > cy)) {
HXLINE(  75)								min = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::ceil(ay);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(by);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter3 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(ay);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter3 = this1;
            						}
            					}
HXDLIN(  75)					::pixelimage::ImageStruct undoImage = null();
HXDLIN(  75)					if (hasUndo) {
HXLINE(  75)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  75)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  75)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  75)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  75)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  75)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  75)						undoImage = this3;
HXDLIN(  75)						{
HXLINE(  75)							int rectLeft = xIter3->start;
HXDLIN(  75)							int rectTop = yIter3->start;
HXDLIN(  75)							int rectRight = xIter3->max;
HXDLIN(  75)							bool forceClear = false;
HXDLIN(  75)							{
HXLINE(  75)								int _g = rectTop;
HXDLIN(  75)								int _g1 = yIter3->max;
HXDLIN(  75)								while((_g < _g1)){
HXLINE(  75)									_g = (_g + 1);
HXDLIN(  75)									int dy = (_g - 1);
HXDLIN(  75)									{
HXLINE(  75)										int _g1 = rectLeft;
HXDLIN(  75)										int _g2 = rectRight;
HXDLIN(  75)										while((_g1 < _g2)){
HXLINE(  75)											_g1 = (_g1 + 1);
HXDLIN(  75)											int dx = (_g1 - 1);
HXDLIN(  75)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)											int index;
HXDLIN(  75)											if (pixelShape->useVirtualPos) {
HXLINE(  75)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  75)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  75)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)											int col;
HXDLIN(  75)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  75)												col = c;
            											}
HXDLIN(  75)											bool _hx_tmp;
HXDLIN(  75)											if (pixelShape->useMask) {
HXLINE(  75)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  75)												_hx_tmp = false;
            											}
HXDLIN(  75)											if (_hx_tmp) {
HXLINE(  75)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  75)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  75)												int index;
HXDLIN(  75)												if (this1->useVirtualPos) {
HXLINE(  75)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  75)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  75)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  75)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  75)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)												int v;
HXDLIN(  75)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  75)													v = c;
            												}
HXDLIN(  75)												int this3 = v;
HXDLIN(  75)												int maskPixel = this3;
HXDLIN(  75)												int this4 = col;
HXDLIN(  75)												int this5 = this4;
HXDLIN(  75)												if ((maskPixel == 0)) {
HXLINE(  75)													int this1 = this5;
HXDLIN(  75)													col = this1;
            												}
            												else {
HXLINE(  75)													Float m0;
HXDLIN(  75)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  75)													if ((this1 == 0)) {
HXLINE(  75)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m1;
HXDLIN(  75)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  75)													if ((this2 == 0)) {
HXLINE(  75)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m2;
HXDLIN(  75)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  75)													if ((this3 == 0)) {
HXLINE(  75)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m3;
HXDLIN(  75)													int this4 = (maskPixel & 255);
HXDLIN(  75)													if ((this4 == 0)) {
HXLINE(  75)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  75)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  75)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  75)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  75)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  75)											if ((col != 0)) {
HXLINE(  75)												int x = (dx - rectLeft);
HXDLIN(  75)												int y = (dy - rectTop);
HXDLIN(  75)												int this1 = col;
HXDLIN(  75)												int c = this1;
HXDLIN(  75)												bool _hx_tmp;
HXDLIN(  75)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  75)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE(  75)													_hx_tmp = false;
            												}
HXDLIN(  75)												if (_hx_tmp) {
HXLINE(  75)													int location;
HXDLIN(  75)													if (undoImage->useVirtualPos) {
HXLINE(  75)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  75)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  75)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)													int this3 = this2;
HXDLIN(  75)													int this4;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  75)														this4 = this3;
            													}
HXDLIN(  75)													Float a1;
HXDLIN(  75)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  75)													if ((this5 == 0)) {
HXLINE(  75)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r1;
HXDLIN(  75)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  75)													if ((this6 == 0)) {
HXLINE(  75)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g1;
HXDLIN(  75)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  75)													if ((this7 == 0)) {
HXLINE(  75)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b1;
HXDLIN(  75)													int this8 = (this4 & 255);
HXDLIN(  75)													if ((this8 == 0)) {
HXLINE(  75)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a2;
HXDLIN(  75)													int this9 = ((col >> 24) & 255);
HXDLIN(  75)													if ((this9 == 0)) {
HXLINE(  75)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r2;
HXDLIN(  75)													int this10 = ((col >> 16) & 255);
HXDLIN(  75)													if ((this10 == 0)) {
HXLINE(  75)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g2;
HXDLIN(  75)													int this11 = ((col >> 8) & 255);
HXDLIN(  75)													if ((this11 == 0)) {
HXLINE(  75)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b2;
HXDLIN(  75)													int this12 = (col & 255);
HXDLIN(  75)													if ((this12 == 0)) {
HXLINE(  75)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  75)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  75)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  75)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  75)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  75)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)													{
HXLINE(  75)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  75)														int value;
HXDLIN(  75)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  75)															value = blended;
            														}
HXDLIN(  75)														bool _hx_tmp;
HXDLIN(  75)														if ((location >= 0)) {
HXLINE(  75)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  75)															_hx_tmp = false;
            														}
HXDLIN(  75)														if (_hx_tmp) {
HXLINE(  75)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  75)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  75)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  75)													int index;
HXDLIN(  75)													if (undoImage->useVirtualPos) {
HXLINE(  75)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  75)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  75)													int value;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  75)														value = c;
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((index >= 0)) {
HXLINE(  75)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  75)												if (forceClear) {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  75)													int x = (dx - rectLeft);
HXDLIN(  75)													int y = (dy - rectTop);
HXDLIN(  75)													int index;
HXDLIN(  75)													if (undoImage->useVirtualPos) {
HXLINE(  75)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  75)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((index >= 0)) {
HXLINE(  75)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  75)					bool found = false;
HXDLIN(  75)					Float min = ( (Float)(0) );
HXDLIN(  75)					Float max = ( (Float)(0) );
HXDLIN(  75)					int a = 0;
HXDLIN(  75)					int r = 0;
HXDLIN(  75)					int g = 0;
HXDLIN(  75)					int b = 0;
HXDLIN(  75)					{
HXLINE(  75)						int _g_min = xIter3->start;
HXDLIN(  75)						int _g_max = xIter3->max;
HXDLIN(  75)						while((_g_min < _g_max)){
HXLINE(  75)							_g_min = (_g_min + 1);
HXDLIN(  75)							int px = (_g_min - 1);
HXDLIN(  75)							Float pcx = (( (Float)(px) ) - cx);
HXLINE( 813)							found = false;
HXLINE(  75)							{
HXLINE(  75)								int _g_min1 = yIter3->start;
HXDLIN(  75)								int _g_max = yIter3->max;
HXDLIN(  75)								while((_g_min1 < _g_max)){
HXLINE(  75)									_g_min1 = (_g_min1 + 1);
HXDLIN(  75)									int py = (_g_min1 - 1);
HXDLIN(  75)									Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  75)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  75)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  75)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  75)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  75)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  75)									bool _hx_tmp;
HXDLIN(  75)									bool _hx_tmp1;
HXDLIN(  75)									if ((ratioA >= 0)) {
HXLINE(  75)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  75)										_hx_tmp1 = false;
            									}
HXDLIN(  75)									if (_hx_tmp1) {
HXLINE(  75)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  75)										_hx_tmp = false;
            									}
HXDLIN(  75)									if (_hx_tmp) {
HXLINE(  75)										int i = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  75)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  75)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  75)										int this1 = i;
HXLINE( 822)										r = this1;
HXLINE(  75)										int i1 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  75)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  75)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  75)										int this2 = i1;
HXLINE( 823)										g = this2;
HXLINE(  75)										int i2 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  75)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  75)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  75)										int this3 = i2;
HXLINE( 824)										b = this3;
HXLINE(  75)										{
HXLINE(  75)											if ((ratioB < ratioC)) {
HXLINE(  75)												min = ratioB;
            											}
            											else {
HXLINE(  75)												min = ratioC;
            											}
HXDLIN(  75)											if ((ratioA > ratioB)) {
HXLINE(  75)												max = ratioA;
            											}
            											else {
HXLINE(  75)												max = ratioB;
            											}
HXDLIN(  75)											if (!((max > ratioC))) {
HXLINE(  75)												max = ratioC;
            											}
HXLINE( 843)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  75)											if (!((min < max))) {
HXLINE(  75)												min = ((max + min) / ( (Float)(2) ));
            											}
HXDLIN(  75)											int i3 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  75)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  75)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  75)											int this4 = i3;
HXLINE( 846)											a = this4;
HXLINE(  75)											{
HXLINE(  75)												int location;
HXDLIN(  75)												if (pixelShape->useVirtualPos) {
HXLINE(  75)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  75)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            												}
HXDLIN(  75)												bool _hx_tmp;
HXDLIN(  75)												if (pixelShape->transparent) {
HXLINE(  75)													_hx_tmp = (a < 254);
            												}
            												else {
HXLINE(  75)													_hx_tmp = false;
            												}
HXDLIN(  75)												if (_hx_tmp) {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)													int this3 = this2;
HXDLIN(  75)													int old;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  75)														old = this3;
            													}
HXDLIN(  75)													int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)													Float a1;
HXDLIN(  75)													int this4 = ((old >> 24) & 255);
HXDLIN(  75)													if ((this4 == 0)) {
HXLINE(  75)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r1;
HXDLIN(  75)													int this5 = ((old >> 16) & 255);
HXDLIN(  75)													if ((this5 == 0)) {
HXLINE(  75)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g1;
HXDLIN(  75)													int this6 = ((old >> 8) & 255);
HXDLIN(  75)													if ((this6 == 0)) {
HXLINE(  75)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b1;
HXDLIN(  75)													int this7 = (old & 255);
HXDLIN(  75)													if ((this7 == 0)) {
HXLINE(  75)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a2;
HXDLIN(  75)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  75)													if ((this8 == 0)) {
HXLINE(  75)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r2;
HXDLIN(  75)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  75)													if ((this9 == 0)) {
HXLINE(  75)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g2;
HXDLIN(  75)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  75)													if ((this10 == 0)) {
HXLINE(  75)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b2;
HXDLIN(  75)													int this11 = (rhs & 255);
HXDLIN(  75)													if ((this11 == 0)) {
HXLINE(  75)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  75)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  75)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  75)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  75)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  75)													int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  75)													{
HXLINE(  75)														::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  75)														int value;
HXDLIN(  75)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  75)															value = blended;
            														}
HXDLIN(  75)														bool _hx_tmp;
HXDLIN(  75)														if ((location >= 0)) {
HXLINE(  75)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  75)															_hx_tmp = false;
            														}
HXDLIN(  75)														if (_hx_tmp) {
HXLINE(  75)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  75)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  75)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)													int value;
HXDLIN(  75)													if (pixelShape->isLittle) {
HXLINE(  75)														value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            													}
            													else {
HXLINE(  75)														value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((location >= 0)) {
HXLINE(  75)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
HXLINE( 851)										found = true;
            									}
            									else {
HXLINE(  75)										if (found) {
HXLINE(  75)											goto _hx_goto_14;
            										}
            									}
            								}
            								_hx_goto_14:;
            							}
            						}
            					}
HXDLIN(  75)					if ((hasHit == false)) {
HXLINE(  75)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN(  75)						if (hasUndo) {
HXLINE(  75)							v->undoImage = undoImage;
HXDLIN(  75)							v->undoX = xIter3->start;
HXDLIN(  75)							v->undoY = yIter3->start;
            						}
            					}
            				}
HXDLIN(  75)				{
HXLINE(  75)					bool hasUndo1 = true;
HXDLIN(  75)					int aA1 = ((color >> 24) & 255);
HXDLIN(  75)					int rA1 = ((color >> 16) & 255);
HXDLIN(  75)					int gA1 = ((color >> 8) & 255);
HXDLIN(  75)					int bA1 = (color & 255);
HXDLIN(  75)					Float bcx1 = (cx - ax);
HXDLIN(  75)					Float bcy1 = (cy - ay);
HXDLIN(  75)					Float acx1 = (dx - ax);
HXDLIN(  75)					Float acy1 = (dy - ay);
HXDLIN(  75)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  75)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  75)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  75)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  75)					::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  75)					if ((dx > cx)) {
HXLINE(  75)						if ((dx > ax)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((cx > ax)) {
HXLINE(  75)								min = ::Math_obj::floor(ax);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::floor(cx);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter31 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(cx);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter31 = this1;
            						}
            					}
            					else {
HXLINE(  75)						if ((cx > ax)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((dx > ax)) {
HXLINE(  75)								min = ::Math_obj::floor(ax);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::ceil(dx);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter31 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(dx);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter31 = this1;
            						}
            					}
HXDLIN(  75)					::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  75)					if ((dy > cy)) {
HXLINE(  75)						if ((dy > ay)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((cy > ay)) {
HXLINE(  75)								min = ::Math_obj::floor(ay);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::floor(cy);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter31 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(cy);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter31 = this1;
            						}
            					}
            					else {
HXLINE(  75)						if ((cy > ay)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((dy > ay)) {
HXLINE(  75)								min = ::Math_obj::floor(ay);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::ceil(dy);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter31 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(dy);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter31 = this1;
            						}
            					}
HXDLIN(  75)					::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  75)					if (hasUndo1) {
HXLINE(  75)						int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  75)						int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  75)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  75)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  75)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  75)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  75)						undoImage1 = this3;
HXDLIN(  75)						{
HXLINE(  75)							int rectLeft = xIter31->start;
HXDLIN(  75)							int rectTop = yIter31->start;
HXDLIN(  75)							int rectRight = xIter31->max;
HXDLIN(  75)							bool forceClear = false;
HXDLIN(  75)							{
HXLINE(  75)								int _g = rectTop;
HXDLIN(  75)								int _g1 = yIter31->max;
HXDLIN(  75)								while((_g < _g1)){
HXLINE(  75)									_g = (_g + 1);
HXDLIN(  75)									int dy = (_g - 1);
HXDLIN(  75)									{
HXLINE(  75)										int _g1 = rectLeft;
HXDLIN(  75)										int _g2 = rectRight;
HXDLIN(  75)										while((_g1 < _g2)){
HXLINE(  75)											_g1 = (_g1 + 1);
HXDLIN(  75)											int dx = (_g1 - 1);
HXDLIN(  75)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)											int index;
HXDLIN(  75)											if (pixelShape->useVirtualPos) {
HXLINE(  75)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  75)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  75)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)											int col;
HXDLIN(  75)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  75)												col = c;
            											}
HXDLIN(  75)											bool _hx_tmp;
HXDLIN(  75)											if (pixelShape->useMask) {
HXLINE(  75)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  75)												_hx_tmp = false;
            											}
HXDLIN(  75)											if (_hx_tmp) {
HXLINE(  75)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  75)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  75)												int index;
HXDLIN(  75)												if (this1->useVirtualPos) {
HXLINE(  75)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  75)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  75)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  75)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  75)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)												int v;
HXDLIN(  75)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  75)													v = c;
            												}
HXDLIN(  75)												int this3 = v;
HXDLIN(  75)												int maskPixel = this3;
HXDLIN(  75)												int this4 = col;
HXDLIN(  75)												int this5 = this4;
HXDLIN(  75)												if ((maskPixel == 0)) {
HXLINE(  75)													int this1 = this5;
HXDLIN(  75)													col = this1;
            												}
            												else {
HXLINE(  75)													Float m0;
HXDLIN(  75)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  75)													if ((this1 == 0)) {
HXLINE(  75)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m1;
HXDLIN(  75)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  75)													if ((this2 == 0)) {
HXLINE(  75)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m2;
HXDLIN(  75)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  75)													if ((this3 == 0)) {
HXLINE(  75)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m3;
HXDLIN(  75)													int this4 = (maskPixel & 255);
HXDLIN(  75)													if ((this4 == 0)) {
HXLINE(  75)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  75)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  75)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  75)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  75)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  75)											if ((col != 0)) {
HXLINE(  75)												int x = (dx - rectLeft);
HXDLIN(  75)												int y = (dy - rectTop);
HXDLIN(  75)												int this1 = col;
HXDLIN(  75)												int c = this1;
HXDLIN(  75)												bool _hx_tmp;
HXDLIN(  75)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  75)													_hx_tmp = undoImage1->transparent;
            												}
            												else {
HXLINE(  75)													_hx_tmp = false;
            												}
HXDLIN(  75)												if (_hx_tmp) {
HXLINE(  75)													int location;
HXDLIN(  75)													if (undoImage1->useVirtualPos) {
HXLINE(  75)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  75)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  75)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)													int this3 = this2;
HXDLIN(  75)													int this4;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  75)														this4 = this3;
            													}
HXDLIN(  75)													Float a1;
HXDLIN(  75)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  75)													if ((this5 == 0)) {
HXLINE(  75)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r1;
HXDLIN(  75)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  75)													if ((this6 == 0)) {
HXLINE(  75)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g1;
HXDLIN(  75)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  75)													if ((this7 == 0)) {
HXLINE(  75)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b1;
HXDLIN(  75)													int this8 = (this4 & 255);
HXDLIN(  75)													if ((this8 == 0)) {
HXLINE(  75)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a2;
HXDLIN(  75)													int this9 = ((col >> 24) & 255);
HXDLIN(  75)													if ((this9 == 0)) {
HXLINE(  75)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r2;
HXDLIN(  75)													int this10 = ((col >> 16) & 255);
HXDLIN(  75)													if ((this10 == 0)) {
HXLINE(  75)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g2;
HXDLIN(  75)													int this11 = ((col >> 8) & 255);
HXDLIN(  75)													if ((this11 == 0)) {
HXLINE(  75)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b2;
HXDLIN(  75)													int this12 = (col & 255);
HXDLIN(  75)													if ((this12 == 0)) {
HXLINE(  75)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  75)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  75)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  75)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  75)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  75)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)													{
HXLINE(  75)														::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  75)														int value;
HXDLIN(  75)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  75)															value = blended;
            														}
HXDLIN(  75)														bool _hx_tmp;
HXDLIN(  75)														if ((location >= 0)) {
HXLINE(  75)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  75)															_hx_tmp = false;
            														}
HXDLIN(  75)														if (_hx_tmp) {
HXLINE(  75)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  75)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  75)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  75)													int index;
HXDLIN(  75)													if (undoImage1->useVirtualPos) {
HXLINE(  75)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  75)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  75)													int value;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  75)														value = c;
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((index >= 0)) {
HXLINE(  75)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  75)												if (forceClear) {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  75)													int x = (dx - rectLeft);
HXDLIN(  75)													int y = (dy - rectTop);
HXDLIN(  75)													int index;
HXDLIN(  75)													if (undoImage1->useVirtualPos) {
HXLINE(  75)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  75)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((index >= 0)) {
HXLINE(  75)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  75)					bool found1 = false;
HXDLIN(  75)					Float min1 = ( (Float)(0) );
HXDLIN(  75)					Float max1 = ( (Float)(0) );
HXDLIN(  75)					int a1 = 0;
HXDLIN(  75)					int r1 = 0;
HXDLIN(  75)					int g1 = 0;
HXDLIN(  75)					int b1 = 0;
HXDLIN(  75)					{
HXLINE(  75)						int _g_min1 = xIter31->start;
HXDLIN(  75)						int _g_max1 = xIter31->max;
HXDLIN(  75)						while((_g_min1 < _g_max1)){
HXLINE(  75)							_g_min1 = (_g_min1 + 1);
HXDLIN(  75)							int px = (_g_min1 - 1);
HXDLIN(  75)							Float pcx = (( (Float)(px) ) - ax);
HXLINE( 813)							found1 = false;
HXLINE(  75)							{
HXLINE(  75)								int _g_min = yIter31->start;
HXDLIN(  75)								int _g_max = yIter31->max;
HXDLIN(  75)								while((_g_min < _g_max)){
HXLINE(  75)									_g_min = (_g_min + 1);
HXDLIN(  75)									int py = (_g_min - 1);
HXDLIN(  75)									Float pcy = (( (Float)(py) ) - ay);
HXDLIN(  75)									Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  75)									Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  75)									Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  75)									Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  75)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  75)									bool _hx_tmp;
HXDLIN(  75)									bool _hx_tmp1;
HXDLIN(  75)									if ((ratioA >= 0)) {
HXLINE(  75)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  75)										_hx_tmp1 = false;
            									}
HXDLIN(  75)									if (_hx_tmp1) {
HXLINE(  75)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  75)										_hx_tmp = false;
            									}
HXDLIN(  75)									if (_hx_tmp) {
HXLINE(  75)										int i = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  75)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  75)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  75)										int this1 = i;
HXLINE( 822)										r1 = this1;
HXLINE(  75)										int i1 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  75)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  75)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  75)										int this2 = i1;
HXLINE( 823)										g1 = this2;
HXLINE(  75)										int i2 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  75)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  75)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  75)										int this3 = i2;
HXLINE( 824)										b1 = this3;
HXLINE(  75)										{
HXLINE(  75)											if ((ratioA < ratioC)) {
HXLINE(  75)												min1 = ratioA;
            											}
            											else {
HXLINE(  75)												min1 = ratioC;
            											}
HXDLIN(  75)											if ((ratioA > ratioB)) {
HXLINE(  75)												max1 = ratioA;
            											}
            											else {
HXLINE(  75)												max1 = ratioB;
            											}
HXDLIN(  75)											if (!((max1 > ratioC))) {
HXLINE(  75)												max1 = ratioC;
            											}
HXLINE( 830)											max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  75)											if (!((min1 < max1))) {
HXLINE(  75)												min1 = ((max1 + min1) / ( (Float)(2) ));
            											}
HXDLIN(  75)											int i3 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  75)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  75)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  75)											int this4 = i3;
HXLINE( 833)											a1 = this4;
HXLINE(  75)											{
HXLINE(  75)												int location;
HXDLIN(  75)												if (pixelShape->useVirtualPos) {
HXLINE(  75)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  75)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            												}
HXDLIN(  75)												bool _hx_tmp;
HXDLIN(  75)												if (pixelShape->transparent) {
HXLINE(  75)													_hx_tmp = (a1 < 254);
            												}
            												else {
HXLINE(  75)													_hx_tmp = false;
            												}
HXDLIN(  75)												if (_hx_tmp) {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)													int this3 = this2;
HXDLIN(  75)													int old;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  75)														old = this3;
            													}
HXDLIN(  75)													int rhs = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  75)													Float a11;
HXDLIN(  75)													int this4 = ((old >> 24) & 255);
HXDLIN(  75)													if ((this4 == 0)) {
HXLINE(  75)														a11 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r11;
HXDLIN(  75)													int this5 = ((old >> 16) & 255);
HXDLIN(  75)													if ((this5 == 0)) {
HXLINE(  75)														r11 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g11;
HXDLIN(  75)													int this6 = ((old >> 8) & 255);
HXDLIN(  75)													if ((this6 == 0)) {
HXLINE(  75)														g11 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b11;
HXDLIN(  75)													int this7 = (old & 255);
HXDLIN(  75)													if ((this7 == 0)) {
HXLINE(  75)														b11 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a2;
HXDLIN(  75)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  75)													if ((this8 == 0)) {
HXLINE(  75)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r2;
HXDLIN(  75)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  75)													if ((this9 == 0)) {
HXLINE(  75)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g2;
HXDLIN(  75)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  75)													if ((this10 == 0)) {
HXLINE(  75)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b2;
HXDLIN(  75)													int this11 = (rhs & 255);
HXDLIN(  75)													if ((this11 == 0)) {
HXLINE(  75)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  75)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a2))));
HXDLIN(  75)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a2))));
HXDLIN(  75)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a2))));
HXDLIN(  75)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  75)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)													{
HXLINE(  75)														::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  75)														int value;
HXDLIN(  75)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  75)															value = blended;
            														}
HXDLIN(  75)														bool _hx_tmp;
HXDLIN(  75)														if ((location >= 0)) {
HXLINE(  75)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  75)															_hx_tmp = false;
            														}
HXDLIN(  75)														if (_hx_tmp) {
HXLINE(  75)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  75)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  75)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)													int value;
HXDLIN(  75)													if (pixelShape->isLittle) {
HXLINE(  75)														value = ((((a1 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            													}
            													else {
HXLINE(  75)														value = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((location >= 0)) {
HXLINE(  75)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
HXLINE( 851)										found1 = true;
            									}
            									else {
HXLINE(  75)										if (found1) {
HXLINE(  75)											goto _hx_goto_18;
            										}
            									}
            								}
            								_hx_goto_18:;
            							}
            						}
            					}
HXDLIN(  75)					if ((hasHit == false)) {
HXLINE(  75)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,dx,dy,cx,cy,ax,ay,true);
HXDLIN(  75)						if (hasUndo1) {
HXLINE(  75)							v->undoImage = undoImage1;
HXDLIN(  75)							v->undoX = xIter31->start;
HXDLIN(  75)							v->undoY = yIter31->start;
            						}
            					}
            				}
HXDLIN(  75)				{
HXLINE(  75)					bool hasUndo2 = true;
HXDLIN(  75)					int aA2 = ((color >> 24) & 255);
HXDLIN(  75)					int rA2 = ((color >> 16) & 255);
HXDLIN(  75)					int gA2 = ((color >> 8) & 255);
HXDLIN(  75)					int bA2 = (color & 255);
HXDLIN(  75)					Float bcx2 = (bx - dx);
HXDLIN(  75)					Float bcy2 = (by - dy);
HXDLIN(  75)					Float acx2 = (ax - dx);
HXDLIN(  75)					Float acy2 = (ay - dy);
HXDLIN(  75)					Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  75)					Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  75)					Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  75)					Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  75)					::pixelimage::iter::IntIterStart xIter32;
HXDLIN(  75)					if ((ax > bx)) {
HXLINE(  75)						if ((ax > dx)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((bx > dx)) {
HXLINE(  75)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::floor(bx);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter32 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(bx);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter32 = this1;
            						}
            					}
            					else {
HXLINE(  75)						if ((bx > dx)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((ax > dx)) {
HXLINE(  75)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::ceil(ax);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter32 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(ax);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter32 = this1;
            						}
            					}
HXDLIN(  75)					::pixelimage::iter::IntIterStart yIter32;
HXDLIN(  75)					if ((ay > by)) {
HXLINE(  75)						if ((ay > dy)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((by > dy)) {
HXLINE(  75)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::floor(by);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter32 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(by);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter32 = this1;
            						}
            					}
            					else {
HXLINE(  75)						if ((by > dy)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((ay > dy)) {
HXLINE(  75)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::ceil(ay);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(by);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter32 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(ay);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter32 = this1;
            						}
            					}
HXDLIN(  75)					::pixelimage::ImageStruct undoImage2 = null();
HXDLIN(  75)					if (hasUndo2) {
HXLINE(  75)						int w = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  75)						int h = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  75)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  75)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  75)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  75)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  75)						undoImage2 = this3;
HXDLIN(  75)						{
HXLINE(  75)							int rectLeft = xIter32->start;
HXDLIN(  75)							int rectTop = yIter32->start;
HXDLIN(  75)							int rectRight = xIter32->max;
HXDLIN(  75)							bool forceClear = false;
HXDLIN(  75)							{
HXLINE(  75)								int _g = rectTop;
HXDLIN(  75)								int _g1 = yIter32->max;
HXDLIN(  75)								while((_g < _g1)){
HXLINE(  75)									_g = (_g + 1);
HXDLIN(  75)									int dy = (_g - 1);
HXDLIN(  75)									{
HXLINE(  75)										int _g1 = rectLeft;
HXDLIN(  75)										int _g2 = rectRight;
HXDLIN(  75)										while((_g1 < _g2)){
HXLINE(  75)											_g1 = (_g1 + 1);
HXDLIN(  75)											int dx = (_g1 - 1);
HXDLIN(  75)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)											int index;
HXDLIN(  75)											if (pixelShape->useVirtualPos) {
HXLINE(  75)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  75)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  75)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)											int col;
HXDLIN(  75)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  75)												col = c;
            											}
HXDLIN(  75)											bool _hx_tmp;
HXDLIN(  75)											if (pixelShape->useMask) {
HXLINE(  75)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  75)												_hx_tmp = false;
            											}
HXDLIN(  75)											if (_hx_tmp) {
HXLINE(  75)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  75)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  75)												int index;
HXDLIN(  75)												if (this1->useVirtualPos) {
HXLINE(  75)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  75)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  75)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  75)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  75)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)												int v;
HXDLIN(  75)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  75)													v = c;
            												}
HXDLIN(  75)												int this3 = v;
HXDLIN(  75)												int maskPixel = this3;
HXDLIN(  75)												int this4 = col;
HXDLIN(  75)												int this5 = this4;
HXDLIN(  75)												if ((maskPixel == 0)) {
HXLINE(  75)													int this1 = this5;
HXDLIN(  75)													col = this1;
            												}
            												else {
HXLINE(  75)													Float m0;
HXDLIN(  75)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  75)													if ((this1 == 0)) {
HXLINE(  75)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m1;
HXDLIN(  75)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  75)													if ((this2 == 0)) {
HXLINE(  75)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m2;
HXDLIN(  75)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  75)													if ((this3 == 0)) {
HXLINE(  75)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m3;
HXDLIN(  75)													int this4 = (maskPixel & 255);
HXDLIN(  75)													if ((this4 == 0)) {
HXLINE(  75)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  75)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  75)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  75)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  75)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  75)											if ((col != 0)) {
HXLINE(  75)												int x = (dx - rectLeft);
HXDLIN(  75)												int y = (dy - rectTop);
HXDLIN(  75)												int this1 = col;
HXDLIN(  75)												int c = this1;
HXDLIN(  75)												bool _hx_tmp;
HXDLIN(  75)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  75)													_hx_tmp = undoImage2->transparent;
            												}
            												else {
HXLINE(  75)													_hx_tmp = false;
            												}
HXDLIN(  75)												if (_hx_tmp) {
HXLINE(  75)													int location;
HXDLIN(  75)													if (undoImage2->useVirtualPos) {
HXLINE(  75)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  75)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  75)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)													int this3 = this2;
HXDLIN(  75)													int this4;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  75)														this4 = this3;
            													}
HXDLIN(  75)													Float a1;
HXDLIN(  75)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  75)													if ((this5 == 0)) {
HXLINE(  75)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r1;
HXDLIN(  75)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  75)													if ((this6 == 0)) {
HXLINE(  75)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g1;
HXDLIN(  75)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  75)													if ((this7 == 0)) {
HXLINE(  75)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b1;
HXDLIN(  75)													int this8 = (this4 & 255);
HXDLIN(  75)													if ((this8 == 0)) {
HXLINE(  75)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a2;
HXDLIN(  75)													int this9 = ((col >> 24) & 255);
HXDLIN(  75)													if ((this9 == 0)) {
HXLINE(  75)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r2;
HXDLIN(  75)													int this10 = ((col >> 16) & 255);
HXDLIN(  75)													if ((this10 == 0)) {
HXLINE(  75)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g2;
HXDLIN(  75)													int this11 = ((col >> 8) & 255);
HXDLIN(  75)													if ((this11 == 0)) {
HXLINE(  75)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b2;
HXDLIN(  75)													int this12 = (col & 255);
HXDLIN(  75)													if ((this12 == 0)) {
HXLINE(  75)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  75)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  75)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  75)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  75)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  75)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)													{
HXLINE(  75)														::haxe::io::ArrayBufferViewImpl this13 = undoImage2->image;
HXDLIN(  75)														int value;
HXDLIN(  75)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  75)															value = blended;
            														}
HXDLIN(  75)														bool _hx_tmp;
HXDLIN(  75)														if ((location >= 0)) {
HXLINE(  75)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  75)															_hx_tmp = false;
            														}
HXDLIN(  75)														if (_hx_tmp) {
HXLINE(  75)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  75)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  75)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  75)													int index;
HXDLIN(  75)													if (undoImage2->useVirtualPos) {
HXLINE(  75)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  75)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  75)													int value;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  75)														value = c;
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((index >= 0)) {
HXLINE(  75)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  75)												if (forceClear) {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage2->image;
HXDLIN(  75)													int x = (dx - rectLeft);
HXDLIN(  75)													int y = (dy - rectTop);
HXDLIN(  75)													int index;
HXDLIN(  75)													if (undoImage2->useVirtualPos) {
HXLINE(  75)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage2->virtualY) * ( (Float)(undoImage2->width) )) + x) - undoImage2->virtualX));
            													}
            													else {
HXLINE(  75)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage2->width) + x)) ));
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((index >= 0)) {
HXLINE(  75)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  75)					bool found2 = false;
HXDLIN(  75)					Float min2 = ( (Float)(0) );
HXDLIN(  75)					Float max2 = ( (Float)(0) );
HXDLIN(  75)					int a2 = 0;
HXDLIN(  75)					int r2 = 0;
HXDLIN(  75)					int g2 = 0;
HXDLIN(  75)					int b2 = 0;
HXDLIN(  75)					{
HXLINE(  75)						int _g_min2 = xIter32->start;
HXDLIN(  75)						int _g_max2 = xIter32->max;
HXDLIN(  75)						while((_g_min2 < _g_max2)){
HXLINE(  75)							_g_min2 = (_g_min2 + 1);
HXDLIN(  75)							int px = (_g_min2 - 1);
HXDLIN(  75)							Float pcx = (( (Float)(px) ) - dx);
HXLINE( 813)							found2 = false;
HXLINE(  75)							{
HXLINE(  75)								int _g_min = yIter32->start;
HXDLIN(  75)								int _g_max = yIter32->max;
HXDLIN(  75)								while((_g_min < _g_max)){
HXLINE(  75)									_g_min = (_g_min + 1);
HXDLIN(  75)									int py = (_g_min - 1);
HXDLIN(  75)									Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  75)									Float dot31 = ((pcx * bcx2) + (pcy * bcy2));
HXDLIN(  75)									Float dot32 = ((pcx * acx2) + (pcy * acy2));
HXDLIN(  75)									Float ratioA = (((dot222 * dot31) - (dot122 * dot32)) * denom12);
HXDLIN(  75)									Float ratioB = (((dot112 * dot32) - (dot122 * dot31)) * denom12);
HXDLIN(  75)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  75)									bool _hx_tmp;
HXDLIN(  75)									bool _hx_tmp1;
HXDLIN(  75)									if ((ratioA >= 0)) {
HXLINE(  75)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  75)										_hx_tmp1 = false;
            									}
HXDLIN(  75)									if (_hx_tmp1) {
HXLINE(  75)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  75)										_hx_tmp = false;
            									}
HXDLIN(  75)									if (_hx_tmp) {
HXLINE(  75)										int i = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  75)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  75)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  75)										int this1 = i;
HXLINE( 822)										r2 = this1;
HXLINE(  75)										int i1 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  75)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  75)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  75)										int this2 = i1;
HXLINE( 823)										g2 = this2;
HXLINE(  75)										int i2 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  75)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  75)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  75)										int this3 = i2;
HXLINE( 824)										b2 = this3;
HXLINE(  75)										{
HXLINE(  75)											if ((ratioA < ratioC)) {
HXLINE(  75)												min2 = ratioA;
            											}
            											else {
HXLINE(  75)												min2 = ratioC;
            											}
HXDLIN(  75)											if ((ratioA > ratioB)) {
HXLINE(  75)												max2 = ratioA;
            											}
            											else {
HXLINE(  75)												max2 = ratioB;
            											}
HXDLIN(  75)											if (!((max2 > ratioC))) {
HXLINE(  75)												max2 = ratioC;
            											}
HXLINE( 830)											max2 = ((( (Float)(1) ) - max2) / ( (Float)(2) ));
HXLINE(  75)											if (!((min2 < max2))) {
HXLINE(  75)												min2 = ((max2 + min2) / ( (Float)(2) ));
            											}
HXDLIN(  75)											int i3 = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min2));
HXDLIN(  75)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  75)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  75)											int this4 = i3;
HXLINE( 833)											a2 = this4;
HXLINE(  75)											{
HXLINE(  75)												int location;
HXDLIN(  75)												if (pixelShape->useVirtualPos) {
HXLINE(  75)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  75)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            												}
HXDLIN(  75)												bool _hx_tmp;
HXDLIN(  75)												if (pixelShape->transparent) {
HXLINE(  75)													_hx_tmp = (a2 < 254);
            												}
            												else {
HXLINE(  75)													_hx_tmp = false;
            												}
HXDLIN(  75)												if (_hx_tmp) {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)													int this3 = this2;
HXDLIN(  75)													int old;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  75)														old = this3;
            													}
HXDLIN(  75)													int rhs = ((((a2 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
HXDLIN(  75)													Float a1;
HXDLIN(  75)													int this4 = ((old >> 24) & 255);
HXDLIN(  75)													if ((this4 == 0)) {
HXLINE(  75)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r1;
HXDLIN(  75)													int this5 = ((old >> 16) & 255);
HXDLIN(  75)													if ((this5 == 0)) {
HXLINE(  75)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g1;
HXDLIN(  75)													int this6 = ((old >> 8) & 255);
HXDLIN(  75)													if ((this6 == 0)) {
HXLINE(  75)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b1;
HXDLIN(  75)													int this7 = (old & 255);
HXDLIN(  75)													if ((this7 == 0)) {
HXLINE(  75)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a21;
HXDLIN(  75)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  75)													if ((this8 == 0)) {
HXLINE(  75)														a21 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a21 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r21;
HXDLIN(  75)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  75)													if ((this9 == 0)) {
HXLINE(  75)														r21 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r21 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g21;
HXDLIN(  75)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  75)													if ((this10 == 0)) {
HXLINE(  75)														g21 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g21 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b21;
HXDLIN(  75)													int this11 = (rhs & 255);
HXDLIN(  75)													if ((this11 == 0)) {
HXLINE(  75)														b21 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b21 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a3 = (a1 * (( (Float)(1) ) - a21));
HXDLIN(  75)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r21 * a21))));
HXDLIN(  75)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g21 * a21))));
HXDLIN(  75)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b21 * a21))));
HXDLIN(  75)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a21)));
HXDLIN(  75)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)													{
HXLINE(  75)														::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  75)														int value;
HXDLIN(  75)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  75)															value = blended;
            														}
HXDLIN(  75)														bool _hx_tmp;
HXDLIN(  75)														if ((location >= 0)) {
HXLINE(  75)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  75)															_hx_tmp = false;
            														}
HXDLIN(  75)														if (_hx_tmp) {
HXLINE(  75)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  75)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  75)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)													int value;
HXDLIN(  75)													if (pixelShape->isLittle) {
HXLINE(  75)														value = ((((a2 << 24) | (b2 << 16)) | (g2 << 8)) | r2);
            													}
            													else {
HXLINE(  75)														value = ((((a2 << 24) | (r2 << 16)) | (g2 << 8)) | b2);
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((location >= 0)) {
HXLINE(  75)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
HXLINE( 851)										found2 = true;
            									}
            									else {
HXLINE(  75)										if (found2) {
HXLINE(  75)											goto _hx_goto_22;
            										}
            									}
            								}
            								_hx_goto_22:;
            							}
            						}
            					}
HXDLIN(  75)					if ((hasHit == false)) {
HXLINE(  75)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  75)						if (hasUndo2) {
HXLINE(  75)							v->undoImage = undoImage2;
HXDLIN(  75)							v->undoX = xIter32->start;
HXDLIN(  75)							v->undoY = yIter32->start;
            						}
            					}
            				}
HXDLIN(  75)				{
HXLINE(  75)					bool hasUndo3 = true;
HXDLIN(  75)					int aA3 = ((color >> 24) & 255);
HXDLIN(  75)					int rA3 = ((color >> 16) & 255);
HXDLIN(  75)					int gA3 = ((color >> 8) & 255);
HXDLIN(  75)					int bA3 = (color & 255);
HXDLIN(  75)					Float bcx3 = (cx - dx);
HXDLIN(  75)					Float bcy3 = (cy - dy);
HXDLIN(  75)					Float acx3 = (bx - dx);
HXDLIN(  75)					Float acy3 = (by - dy);
HXDLIN(  75)					Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  75)					Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  75)					Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  75)					Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  75)					::pixelimage::iter::IntIterStart xIter33;
HXDLIN(  75)					if ((bx > cx)) {
HXLINE(  75)						if ((bx > dx)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((cx > dx)) {
HXLINE(  75)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::floor(cx);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter33 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(cx);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter33 = this1;
            						}
            					}
            					else {
HXLINE(  75)						if ((cx > dx)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((bx > dx)) {
HXLINE(  75)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::ceil(bx);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter33 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(bx);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							xIter33 = this1;
            						}
            					}
HXDLIN(  75)					::pixelimage::iter::IntIterStart yIter33;
HXDLIN(  75)					if ((by > cy)) {
HXLINE(  75)						if ((by > dy)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((cy > dy)) {
HXLINE(  75)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::floor(cy);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(by);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter33 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(cy);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter33 = this1;
            						}
            					}
            					else {
HXLINE(  75)						if ((cy > dy)) {
HXLINE(  75)							int min;
HXDLIN(  75)							if ((by > dy)) {
HXLINE(  75)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE(  75)								min = ::Math_obj::ceil(by);
            							}
HXDLIN(  75)							int ii_min = min;
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter33 = this1;
            						}
            						else {
HXLINE(  75)							int ii_min = ::Math_obj::floor(by);
HXDLIN(  75)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  75)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  75)							yIter33 = this1;
            						}
            					}
HXDLIN(  75)					::pixelimage::ImageStruct undoImage3 = null();
HXDLIN(  75)					if (hasUndo3) {
HXLINE(  75)						int w = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  75)						int h = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  75)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  75)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  75)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  75)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  75)						undoImage3 = this3;
HXDLIN(  75)						{
HXLINE(  75)							int rectLeft = xIter33->start;
HXDLIN(  75)							int rectTop = yIter33->start;
HXDLIN(  75)							int rectRight = xIter33->max;
HXDLIN(  75)							bool forceClear = false;
HXDLIN(  75)							{
HXLINE(  75)								int _g = rectTop;
HXDLIN(  75)								int _g1 = yIter33->max;
HXDLIN(  75)								while((_g < _g1)){
HXLINE(  75)									_g = (_g + 1);
HXDLIN(  75)									int dy = (_g - 1);
HXDLIN(  75)									{
HXLINE(  75)										int _g1 = rectLeft;
HXDLIN(  75)										int _g2 = rectRight;
HXDLIN(  75)										while((_g1 < _g2)){
HXLINE(  75)											_g1 = (_g1 + 1);
HXDLIN(  75)											int dx = (_g1 - 1);
HXDLIN(  75)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)											int index;
HXDLIN(  75)											if (pixelShape->useVirtualPos) {
HXLINE(  75)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  75)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  75)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)											int col;
HXDLIN(  75)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  75)												col = c;
            											}
HXDLIN(  75)											bool _hx_tmp;
HXDLIN(  75)											if (pixelShape->useMask) {
HXLINE(  75)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  75)												_hx_tmp = false;
            											}
HXDLIN(  75)											if (_hx_tmp) {
HXLINE(  75)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  75)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  75)												int index;
HXDLIN(  75)												if (this1->useVirtualPos) {
HXLINE(  75)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  75)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  75)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  75)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  75)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)												int v;
HXDLIN(  75)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  75)													v = c;
            												}
HXDLIN(  75)												int this3 = v;
HXDLIN(  75)												int maskPixel = this3;
HXDLIN(  75)												int this4 = col;
HXDLIN(  75)												int this5 = this4;
HXDLIN(  75)												if ((maskPixel == 0)) {
HXLINE(  75)													int this1 = this5;
HXDLIN(  75)													col = this1;
            												}
            												else {
HXLINE(  75)													Float m0;
HXDLIN(  75)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  75)													if ((this1 == 0)) {
HXLINE(  75)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m1;
HXDLIN(  75)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  75)													if ((this2 == 0)) {
HXLINE(  75)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m2;
HXDLIN(  75)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  75)													if ((this3 == 0)) {
HXLINE(  75)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float m3;
HXDLIN(  75)													int this4 = (maskPixel & 255);
HXDLIN(  75)													if ((this4 == 0)) {
HXLINE(  75)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  75)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  75)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  75)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  75)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  75)											if ((col != 0)) {
HXLINE(  75)												int x = (dx - rectLeft);
HXDLIN(  75)												int y = (dy - rectTop);
HXDLIN(  75)												int this1 = col;
HXDLIN(  75)												int c = this1;
HXDLIN(  75)												bool _hx_tmp;
HXDLIN(  75)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  75)													_hx_tmp = undoImage3->transparent;
            												}
            												else {
HXLINE(  75)													_hx_tmp = false;
            												}
HXDLIN(  75)												if (_hx_tmp) {
HXLINE(  75)													int location;
HXDLIN(  75)													if (undoImage3->useVirtualPos) {
HXLINE(  75)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  75)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  75)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)													int this3 = this2;
HXDLIN(  75)													int this4;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  75)														this4 = this3;
            													}
HXDLIN(  75)													Float a1;
HXDLIN(  75)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  75)													if ((this5 == 0)) {
HXLINE(  75)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r1;
HXDLIN(  75)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  75)													if ((this6 == 0)) {
HXLINE(  75)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g1;
HXDLIN(  75)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  75)													if ((this7 == 0)) {
HXLINE(  75)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b1;
HXDLIN(  75)													int this8 = (this4 & 255);
HXDLIN(  75)													if ((this8 == 0)) {
HXLINE(  75)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a2;
HXDLIN(  75)													int this9 = ((col >> 24) & 255);
HXDLIN(  75)													if ((this9 == 0)) {
HXLINE(  75)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r2;
HXDLIN(  75)													int this10 = ((col >> 16) & 255);
HXDLIN(  75)													if ((this10 == 0)) {
HXLINE(  75)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g2;
HXDLIN(  75)													int this11 = ((col >> 8) & 255);
HXDLIN(  75)													if ((this11 == 0)) {
HXLINE(  75)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b2;
HXDLIN(  75)													int this12 = (col & 255);
HXDLIN(  75)													if ((this12 == 0)) {
HXLINE(  75)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  75)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  75)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  75)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  75)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  75)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)													{
HXLINE(  75)														::haxe::io::ArrayBufferViewImpl this13 = undoImage3->image;
HXDLIN(  75)														int value;
HXDLIN(  75)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  75)															value = blended;
            														}
HXDLIN(  75)														bool _hx_tmp;
HXDLIN(  75)														if ((location >= 0)) {
HXLINE(  75)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  75)															_hx_tmp = false;
            														}
HXDLIN(  75)														if (_hx_tmp) {
HXLINE(  75)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  75)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  75)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  75)													int index;
HXDLIN(  75)													if (undoImage3->useVirtualPos) {
HXLINE(  75)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  75)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  75)													int value;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  75)														value = c;
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((index >= 0)) {
HXLINE(  75)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  75)												if (forceClear) {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = undoImage3->image;
HXDLIN(  75)													int x = (dx - rectLeft);
HXDLIN(  75)													int y = (dy - rectTop);
HXDLIN(  75)													int index;
HXDLIN(  75)													if (undoImage3->useVirtualPos) {
HXLINE(  75)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  75)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage3->width) + x)) ));
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((index >= 0)) {
HXLINE(  75)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  75)					bool found3 = false;
HXDLIN(  75)					Float min3 = ( (Float)(0) );
HXDLIN(  75)					Float max3 = ( (Float)(0) );
HXDLIN(  75)					int a3 = 0;
HXDLIN(  75)					int r3 = 0;
HXDLIN(  75)					int g3 = 0;
HXDLIN(  75)					int b3 = 0;
HXDLIN(  75)					{
HXLINE(  75)						int _g_min3 = xIter33->start;
HXDLIN(  75)						int _g_max3 = xIter33->max;
HXDLIN(  75)						while((_g_min3 < _g_max3)){
HXLINE(  75)							_g_min3 = (_g_min3 + 1);
HXDLIN(  75)							int px = (_g_min3 - 1);
HXDLIN(  75)							Float pcx = (( (Float)(px) ) - dx);
HXLINE( 813)							found3 = false;
HXLINE(  75)							{
HXLINE(  75)								int _g_min = yIter33->start;
HXDLIN(  75)								int _g_max = yIter33->max;
HXDLIN(  75)								while((_g_min < _g_max)){
HXLINE(  75)									_g_min = (_g_min + 1);
HXDLIN(  75)									int py = (_g_min - 1);
HXDLIN(  75)									Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  75)									Float dot31 = ((pcx * bcx3) + (pcy * bcy3));
HXDLIN(  75)									Float dot32 = ((pcx * acx3) + (pcy * acy3));
HXDLIN(  75)									Float ratioA = (((dot223 * dot31) - (dot123 * dot32)) * denom13);
HXDLIN(  75)									Float ratioB = (((dot113 * dot32) - (dot123 * dot31)) * denom13);
HXDLIN(  75)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  75)									bool _hx_tmp;
HXDLIN(  75)									bool _hx_tmp1;
HXDLIN(  75)									if ((ratioA >= 0)) {
HXLINE(  75)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  75)										_hx_tmp1 = false;
            									}
HXDLIN(  75)									if (_hx_tmp1) {
HXLINE(  75)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  75)										_hx_tmp = false;
            									}
HXDLIN(  75)									if (_hx_tmp) {
HXLINE(  75)										int i = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN(  75)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  75)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  75)										int this1 = i;
HXLINE( 822)										r3 = this1;
HXLINE(  75)										int i1 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN(  75)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  75)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  75)										int this2 = i1;
HXLINE( 823)										g3 = this2;
HXLINE(  75)										int i2 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN(  75)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  75)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  75)										int this3 = i2;
HXLINE( 824)										b3 = this3;
HXLINE(  75)										{
HXLINE(  75)											if ((ratioB < ratioC)) {
HXLINE(  75)												min3 = ratioB;
            											}
            											else {
HXLINE(  75)												min3 = ratioC;
            											}
HXDLIN(  75)											if ((ratioA > ratioB)) {
HXLINE(  75)												max3 = ratioA;
            											}
            											else {
HXLINE(  75)												max3 = ratioB;
            											}
HXDLIN(  75)											if (!((max3 > ratioC))) {
HXLINE(  75)												max3 = ratioC;
            											}
HXLINE( 843)											max3 = ((( (Float)(1) ) - max3) / ( (Float)(2) ));
HXLINE(  75)											if (!((min3 < max3))) {
HXLINE(  75)												min3 = ((max3 + min3) / ( (Float)(2) ));
            											}
HXDLIN(  75)											int i3 = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft) * min3));
HXDLIN(  75)											if ((i3 > 255)) {
HXLINE(  24)												i3 = 255;
            											}
HXLINE(  75)											if ((i3 < 0)) {
HXLINE(  25)												i3 = 0;
            											}
HXLINE(  75)											int this4 = i3;
HXLINE( 846)											a3 = this4;
HXLINE(  75)											{
HXLINE(  75)												int location;
HXDLIN(  75)												if (pixelShape->useVirtualPos) {
HXLINE(  75)													location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            												}
            												else {
HXLINE(  75)													location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            												}
HXDLIN(  75)												bool _hx_tmp;
HXDLIN(  75)												if (pixelShape->transparent) {
HXLINE(  75)													_hx_tmp = (a3 < 254);
            												}
            												else {
HXLINE(  75)													_hx_tmp = false;
            												}
HXDLIN(  75)												if (_hx_tmp) {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  75)													int this3 = this2;
HXDLIN(  75)													int old;
HXDLIN(  75)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)														old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  75)														old = this3;
            													}
HXDLIN(  75)													int rhs = ((((a3 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  75)													Float a1;
HXDLIN(  75)													int this4 = ((old >> 24) & 255);
HXDLIN(  75)													if ((this4 == 0)) {
HXLINE(  75)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r1;
HXDLIN(  75)													int this5 = ((old >> 16) & 255);
HXDLIN(  75)													if ((this5 == 0)) {
HXLINE(  75)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g1;
HXDLIN(  75)													int this6 = ((old >> 8) & 255);
HXDLIN(  75)													if ((this6 == 0)) {
HXLINE(  75)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b1;
HXDLIN(  75)													int this7 = (old & 255);
HXDLIN(  75)													if ((this7 == 0)) {
HXLINE(  75)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a2;
HXDLIN(  75)													int this8 = ((rhs >> 24) & 255);
HXDLIN(  75)													if ((this8 == 0)) {
HXLINE(  75)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float r2;
HXDLIN(  75)													int this9 = ((rhs >> 16) & 255);
HXDLIN(  75)													if ((this9 == 0)) {
HXLINE(  75)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float g2;
HXDLIN(  75)													int this10 = ((rhs >> 8) & 255);
HXDLIN(  75)													if ((this10 == 0)) {
HXLINE(  75)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float b2;
HXDLIN(  75)													int this11 = (rhs & 255);
HXDLIN(  75)													if ((this11 == 0)) {
HXLINE(  75)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  75)														b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  75)													Float a31 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  75)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a31) + (r2 * a2))));
HXDLIN(  75)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a31) + (g2 * a2))));
HXDLIN(  75)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a31) + (b2 * a2))));
HXDLIN(  75)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a2)));
HXDLIN(  75)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  75)													{
HXLINE(  75)														::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  75)														int value;
HXDLIN(  75)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  75)															value = blended;
            														}
HXDLIN(  75)														bool _hx_tmp;
HXDLIN(  75)														if ((location >= 0)) {
HXLINE(  75)															_hx_tmp = (location < (this12->byteLength >> 2));
            														}
            														else {
HXLINE(  75)															_hx_tmp = false;
            														}
HXDLIN(  75)														if (_hx_tmp) {
HXLINE(  75)															::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  75)															int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  75)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  75)													::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  75)													int value;
HXDLIN(  75)													if (pixelShape->isLittle) {
HXLINE(  75)														value = ((((a3 << 24) | (b3 << 16)) | (g3 << 8)) | r3);
            													}
            													else {
HXLINE(  75)														value = ((((a3 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
            													}
HXDLIN(  75)													bool _hx_tmp;
HXDLIN(  75)													if ((location >= 0)) {
HXLINE(  75)														_hx_tmp = (location < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  75)														_hx_tmp = false;
            													}
HXDLIN(  75)													if (_hx_tmp) {
HXLINE(  75)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  75)														int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  75)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  75)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  75)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  75)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            										}
HXLINE( 851)										found3 = true;
            									}
            									else {
HXLINE(  75)										if (found3) {
HXLINE(  75)											goto _hx_goto_26;
            										}
            									}
            								}
            								_hx_goto_26:;
            							}
            						}
            					}
HXDLIN(  75)					if ((hasHit == false)) {
HXLINE(  75)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  75)						if (hasUndo3) {
HXLINE(  75)							v->undoImage = undoImage3;
HXDLIN(  75)							v->undoX = xIter33->start;
HXDLIN(  75)							v->undoY = yIter33->start;
            						}
            					}
            				}
HXDLIN(  75)				if ((hasHit == true)) {
HXLINE(  75)					::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE(  71)					_hx_tmp = v;
            				}
            				else {
HXLINE(  71)					_hx_tmp = null();
            				}
            			}
            			else {
HXLINE(  77)				Float ax = (this->aX + this->offX);
HXDLIN(  77)				Float ay = (this->aY + this->offY);
HXDLIN(  77)				Float bx = (this->bX + this->offX);
HXDLIN(  77)				Float by = (this->bY + this->offY);
HXDLIN(  77)				Float cx = (this->cX + this->offX);
HXDLIN(  77)				Float cy = (this->cY + this->offY);
HXDLIN(  77)				Float dx = (this->dX + this->offX);
HXDLIN(  77)				Float dy = (this->dY + this->offY);
HXDLIN(  77)				int color = this->strokeColor;
HXDLIN(  77)				Float soft = this->soft;
HXDLIN(  77)				bool hasHit = false;
HXDLIN(  77)				{
HXLINE(  77)					bool hasUndo = true;
HXDLIN(  77)					int aA = ((color >> 24) & 255);
HXDLIN(  77)					int rA = ((color >> 16) & 255);
HXDLIN(  77)					int gA = ((color >> 8) & 255);
HXDLIN(  77)					int bA = (color & 255);
HXDLIN(  77)					Float bcx = (bx - dx);
HXDLIN(  77)					Float bcy = (by - dy);
HXDLIN(  77)					Float acx = (ax - dx);
HXDLIN(  77)					Float acy = (ay - dy);
HXDLIN(  77)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  77)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  77)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  77)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  77)					::pixelimage::iter::IntIterStart xIter3;
HXDLIN(  77)					if ((ax > bx)) {
HXLINE(  77)						if ((ax > dx)) {
HXLINE(  77)							int min;
HXDLIN(  77)							if ((bx > dx)) {
HXLINE(  77)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE(  77)								min = ::Math_obj::floor(bx);
            							}
HXDLIN(  77)							int ii_min = min;
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							xIter3 = this1;
            						}
            						else {
HXLINE(  77)							int ii_min = ::Math_obj::floor(bx);
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							xIter3 = this1;
            						}
            					}
            					else {
HXLINE(  77)						if ((bx > dx)) {
HXLINE(  77)							int min;
HXDLIN(  77)							if ((ax > dx)) {
HXLINE(  77)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE(  77)								min = ::Math_obj::ceil(ax);
            							}
HXDLIN(  77)							int ii_min = min;
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							xIter3 = this1;
            						}
            						else {
HXLINE(  77)							int ii_min = ::Math_obj::floor(ax);
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							xIter3 = this1;
            						}
            					}
HXDLIN(  77)					::pixelimage::iter::IntIterStart yIter3;
HXDLIN(  77)					if ((ay > by)) {
HXLINE(  77)						if ((ay > dy)) {
HXLINE(  77)							int min;
HXDLIN(  77)							if ((by > dy)) {
HXLINE(  77)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE(  77)								min = ::Math_obj::floor(by);
            							}
HXDLIN(  77)							int ii_min = min;
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(ay);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							yIter3 = this1;
            						}
            						else {
HXLINE(  77)							int ii_min = ::Math_obj::floor(by);
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							yIter3 = this1;
            						}
            					}
            					else {
HXLINE(  77)						if ((by > dy)) {
HXLINE(  77)							int min;
HXDLIN(  77)							if ((ay > dy)) {
HXLINE(  77)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE(  77)								min = ::Math_obj::ceil(ay);
            							}
HXDLIN(  77)							int ii_min = min;
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(by);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							yIter3 = this1;
            						}
            						else {
HXLINE(  77)							int ii_min = ::Math_obj::floor(ay);
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							yIter3 = this1;
            						}
            					}
HXDLIN(  77)					::pixelimage::ImageStruct undoImage = null();
HXDLIN(  77)					if (hasUndo) {
HXLINE(  77)						int w = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  77)						int h = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  77)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  77)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  77)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  77)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  77)						undoImage = this3;
HXDLIN(  77)						{
HXLINE(  77)							int rectLeft = xIter3->start;
HXDLIN(  77)							int rectTop = yIter3->start;
HXDLIN(  77)							int rectRight = xIter3->max;
HXDLIN(  77)							bool forceClear = false;
HXDLIN(  77)							{
HXLINE(  77)								int _g = rectTop;
HXDLIN(  77)								int _g1 = yIter3->max;
HXDLIN(  77)								while((_g < _g1)){
HXLINE(  77)									_g = (_g + 1);
HXDLIN(  77)									int dy = (_g - 1);
HXDLIN(  77)									{
HXLINE(  77)										int _g1 = rectLeft;
HXDLIN(  77)										int _g2 = rectRight;
HXDLIN(  77)										while((_g1 < _g2)){
HXLINE(  77)											_g1 = (_g1 + 1);
HXDLIN(  77)											int dx = (_g1 - 1);
HXDLIN(  77)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)											int index;
HXDLIN(  77)											if (pixelShape->useVirtualPos) {
HXLINE(  77)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  77)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  77)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)											int col;
HXDLIN(  77)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  77)												col = c;
            											}
HXDLIN(  77)											bool _hx_tmp;
HXDLIN(  77)											if (pixelShape->useMask) {
HXLINE(  77)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  77)												_hx_tmp = false;
            											}
HXDLIN(  77)											if (_hx_tmp) {
HXLINE(  77)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  77)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  77)												int index;
HXDLIN(  77)												if (this1->useVirtualPos) {
HXLINE(  77)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  77)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  77)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  77)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  77)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)												int v;
HXDLIN(  77)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  77)													v = c;
            												}
HXDLIN(  77)												int this3 = v;
HXDLIN(  77)												int maskPixel = this3;
HXDLIN(  77)												int this4 = col;
HXDLIN(  77)												int this5 = this4;
HXDLIN(  77)												if ((maskPixel == 0)) {
HXLINE(  77)													int this1 = this5;
HXDLIN(  77)													col = this1;
            												}
            												else {
HXLINE(  77)													Float m0;
HXDLIN(  77)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  77)													if ((this1 == 0)) {
HXLINE(  77)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float m1;
HXDLIN(  77)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  77)													if ((this2 == 0)) {
HXLINE(  77)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float m2;
HXDLIN(  77)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  77)													if ((this3 == 0)) {
HXLINE(  77)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float m3;
HXDLIN(  77)													int this4 = (maskPixel & 255);
HXDLIN(  77)													if ((this4 == 0)) {
HXLINE(  77)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  77)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  77)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  77)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  77)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  77)											if ((col != 0)) {
HXLINE(  77)												int x = (dx - rectLeft);
HXDLIN(  77)												int y = (dy - rectTop);
HXDLIN(  77)												int this1 = col;
HXDLIN(  77)												int c = this1;
HXDLIN(  77)												bool _hx_tmp;
HXDLIN(  77)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  77)													_hx_tmp = undoImage->transparent;
            												}
            												else {
HXLINE(  77)													_hx_tmp = false;
            												}
HXDLIN(  77)												if (_hx_tmp) {
HXLINE(  77)													int location;
HXDLIN(  77)													if (undoImage->useVirtualPos) {
HXLINE(  77)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  77)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  77)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  77)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  77)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)													int this3 = this2;
HXDLIN(  77)													int this4;
HXDLIN(  77)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  77)														this4 = this3;
            													}
HXDLIN(  77)													Float a1;
HXDLIN(  77)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  77)													if ((this5 == 0)) {
HXLINE(  77)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float r1;
HXDLIN(  77)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  77)													if ((this6 == 0)) {
HXLINE(  77)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float g1;
HXDLIN(  77)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  77)													if ((this7 == 0)) {
HXLINE(  77)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float b1;
HXDLIN(  77)													int this8 = (this4 & 255);
HXDLIN(  77)													if ((this8 == 0)) {
HXLINE(  77)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float a2;
HXDLIN(  77)													int this9 = ((col >> 24) & 255);
HXDLIN(  77)													if ((this9 == 0)) {
HXLINE(  77)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float r2;
HXDLIN(  77)													int this10 = ((col >> 16) & 255);
HXDLIN(  77)													if ((this10 == 0)) {
HXLINE(  77)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float g2;
HXDLIN(  77)													int this11 = ((col >> 8) & 255);
HXDLIN(  77)													if ((this11 == 0)) {
HXLINE(  77)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float b2;
HXDLIN(  77)													int this12 = (col & 255);
HXDLIN(  77)													if ((this12 == 0)) {
HXLINE(  77)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  77)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  77)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  77)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  77)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  77)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  77)													{
HXLINE(  77)														::haxe::io::ArrayBufferViewImpl this13 = undoImage->image;
HXDLIN(  77)														int value;
HXDLIN(  77)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  77)															value = blended;
            														}
HXDLIN(  77)														bool _hx_tmp;
HXDLIN(  77)														if ((location >= 0)) {
HXLINE(  77)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  77)															_hx_tmp = false;
            														}
HXDLIN(  77)														if (_hx_tmp) {
HXLINE(  77)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  77)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  77)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  77)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  77)													int index;
HXDLIN(  77)													if (undoImage->useVirtualPos) {
HXLINE(  77)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  77)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  77)													int value;
HXDLIN(  77)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  77)														value = c;
            													}
HXDLIN(  77)													bool _hx_tmp;
HXDLIN(  77)													if ((index >= 0)) {
HXLINE(  77)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  77)														_hx_tmp = false;
            													}
HXDLIN(  77)													if (_hx_tmp) {
HXLINE(  77)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  77)												if (forceClear) {
HXLINE(  77)													::haxe::io::ArrayBufferViewImpl this1 = undoImage->image;
HXDLIN(  77)													int x = (dx - rectLeft);
HXDLIN(  77)													int y = (dy - rectTop);
HXDLIN(  77)													int index;
HXDLIN(  77)													if (undoImage->useVirtualPos) {
HXLINE(  77)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x) - undoImage->virtualX));
            													}
            													else {
HXLINE(  77)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage->width) + x)) ));
            													}
HXDLIN(  77)													bool _hx_tmp;
HXDLIN(  77)													if ((index >= 0)) {
HXLINE(  77)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  77)														_hx_tmp = false;
            													}
HXDLIN(  77)													if (_hx_tmp) {
HXLINE(  77)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  77)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  77)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  77)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  77)					bool found = false;
HXDLIN(  77)					Float min = ( (Float)(0) );
HXDLIN(  77)					Float max = ( (Float)(0) );
HXDLIN(  77)					int a = 0;
HXDLIN(  77)					int r = 0;
HXDLIN(  77)					int g = 0;
HXDLIN(  77)					int b = 0;
HXDLIN(  77)					{
HXLINE(  77)						int _g_min = xIter3->start;
HXDLIN(  77)						int _g_max = xIter3->max;
HXDLIN(  77)						while((_g_min < _g_max)){
HXLINE(  77)							_g_min = (_g_min + 1);
HXDLIN(  77)							int px = (_g_min - 1);
HXDLIN(  77)							Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)							found = false;
HXLINE(  77)							{
HXLINE(  77)								int _g_min1 = yIter3->start;
HXDLIN(  77)								int _g_max = yIter3->max;
HXDLIN(  77)								while((_g_min1 < _g_max)){
HXLINE(  77)									_g_min1 = (_g_min1 + 1);
HXDLIN(  77)									int py = (_g_min1 - 1);
HXDLIN(  77)									Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  77)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  77)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  77)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  77)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  77)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  77)									bool _hx_tmp;
HXDLIN(  77)									bool _hx_tmp1;
HXDLIN(  77)									if ((ratioA >= 0)) {
HXLINE(  77)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  77)										_hx_tmp1 = false;
            									}
HXDLIN(  77)									if (_hx_tmp1) {
HXLINE(  77)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  77)										_hx_tmp = false;
            									}
HXDLIN(  77)									if (_hx_tmp) {
HXLINE(  77)										if ((ratioA < ratioC)) {
HXLINE(  77)											min = ratioA;
            										}
            										else {
HXLINE(  77)											min = ratioC;
            										}
HXDLIN(  77)										if ((ratioA > ratioB)) {
HXLINE(  77)											max = ratioA;
            										}
            										else {
HXLINE(  77)											max = ratioB;
            										}
HXDLIN(  77)										if (!((max > ratioC))) {
HXLINE(  77)											max = ratioC;
            										}
HXLINE( 729)										max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  77)										if (!((min < max))) {
HXLINE(  77)											min = ((max + min) / ( (Float)(2) ));
            										}
HXDLIN(  77)										int i = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min));
HXDLIN(  77)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  77)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  77)										int this1 = i;
HXDLIN(  77)										a = this1;
HXDLIN(  77)										int i1 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  77)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  77)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  77)										int this2 = i1;
HXLINE( 748)										r = this2;
HXLINE(  77)										int i2 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  77)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  77)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  77)										int this3 = i2;
HXLINE( 749)										g = this3;
HXLINE(  77)										int i3 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  77)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  77)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  77)										int this4 = i3;
HXLINE( 750)										b = this4;
HXLINE(  77)										{
HXLINE(  77)											int location;
HXDLIN(  77)											if (pixelShape->useVirtualPos) {
HXLINE(  77)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  77)												location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            											}
HXDLIN(  77)											bool _hx_tmp;
HXDLIN(  77)											if (pixelShape->transparent) {
HXLINE(  77)												_hx_tmp = (a < 254);
            											}
            											else {
HXLINE(  77)												_hx_tmp = false;
            											}
HXDLIN(  77)											if (_hx_tmp) {
HXLINE(  77)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  77)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)												int this3 = this2;
HXDLIN(  77)												int old;
HXDLIN(  77)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  77)													old = this3;
            												}
HXDLIN(  77)												int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  77)												Float a1;
HXDLIN(  77)												int this4 = ((old >> 24) & 255);
HXDLIN(  77)												if ((this4 == 0)) {
HXLINE(  77)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float r1;
HXDLIN(  77)												int this5 = ((old >> 16) & 255);
HXDLIN(  77)												if ((this5 == 0)) {
HXLINE(  77)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float g1;
HXDLIN(  77)												int this6 = ((old >> 8) & 255);
HXDLIN(  77)												if ((this6 == 0)) {
HXLINE(  77)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float b1;
HXDLIN(  77)												int this7 = (old & 255);
HXDLIN(  77)												if ((this7 == 0)) {
HXLINE(  77)													b1 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float a2;
HXDLIN(  77)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  77)												if ((this8 == 0)) {
HXLINE(  77)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float r2;
HXDLIN(  77)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  77)												if ((this9 == 0)) {
HXLINE(  77)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float g2;
HXDLIN(  77)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  77)												if ((this10 == 0)) {
HXLINE(  77)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float b2;
HXDLIN(  77)												int this11 = (rhs & 255);
HXDLIN(  77)												if ((this11 == 0)) {
HXLINE(  77)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  77)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  77)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  77)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  77)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  77)												int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  77)												{
HXLINE(  77)													::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  77)													int value;
HXDLIN(  77)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  77)														value = blended;
            													}
HXDLIN(  77)													bool _hx_tmp;
HXDLIN(  77)													if ((location >= 0)) {
HXLINE(  77)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  77)														_hx_tmp = false;
            													}
HXDLIN(  77)													if (_hx_tmp) {
HXLINE(  77)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  77)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  77)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  77)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)												int value;
HXDLIN(  77)												if (pixelShape->isLittle) {
HXLINE(  77)													value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            												}
            												else {
HXLINE(  77)													value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            												}
HXDLIN(  77)												bool _hx_tmp;
HXDLIN(  77)												if ((location >= 0)) {
HXLINE(  77)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  77)													_hx_tmp = false;
            												}
HXDLIN(  77)												if (_hx_tmp) {
HXLINE(  77)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  77)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
HXLINE( 752)										found = true;
            									}
            									else {
HXLINE(  77)										if (found) {
HXLINE(  77)											goto _hx_goto_30;
            										}
            									}
            								}
            								_hx_goto_30:;
            							}
            						}
            					}
HXDLIN(  77)					if ((hasHit == false)) {
HXLINE(  77)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  77)						if (hasUndo) {
HXLINE(  77)							v->undoImage = undoImage;
HXDLIN(  77)							v->undoX = xIter3->start;
HXDLIN(  77)							v->undoY = yIter3->start;
            						}
            					}
            				}
HXDLIN(  77)				{
HXLINE(  77)					bool hasUndo1 = true;
HXDLIN(  77)					int aA1 = ((color >> 24) & 255);
HXDLIN(  77)					int rA1 = ((color >> 16) & 255);
HXDLIN(  77)					int gA1 = ((color >> 8) & 255);
HXDLIN(  77)					int bA1 = (color & 255);
HXDLIN(  77)					Float bcx1 = (cx - dx);
HXDLIN(  77)					Float bcy1 = (cy - dy);
HXDLIN(  77)					Float acx1 = (bx - dx);
HXDLIN(  77)					Float acy1 = (by - dy);
HXDLIN(  77)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  77)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  77)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  77)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  77)					::pixelimage::iter::IntIterStart xIter31;
HXDLIN(  77)					if ((bx > cx)) {
HXLINE(  77)						if ((bx > dx)) {
HXLINE(  77)							int min;
HXDLIN(  77)							if ((cx > dx)) {
HXLINE(  77)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE(  77)								min = ::Math_obj::floor(cx);
            							}
HXDLIN(  77)							int ii_min = min;
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(bx);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							xIter31 = this1;
            						}
            						else {
HXLINE(  77)							int ii_min = ::Math_obj::floor(cx);
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							xIter31 = this1;
            						}
            					}
            					else {
HXLINE(  77)						if ((cx > dx)) {
HXLINE(  77)							int min;
HXDLIN(  77)							if ((bx > dx)) {
HXLINE(  77)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXLINE(  77)								min = ::Math_obj::ceil(bx);
            							}
HXDLIN(  77)							int ii_min = min;
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							xIter31 = this1;
            						}
            						else {
HXLINE(  77)							int ii_min = ::Math_obj::floor(bx);
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(dx);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							xIter31 = this1;
            						}
            					}
HXDLIN(  77)					::pixelimage::iter::IntIterStart yIter31;
HXDLIN(  77)					if ((by > cy)) {
HXLINE(  77)						if ((by > dy)) {
HXLINE(  77)							int min;
HXDLIN(  77)							if ((cy > dy)) {
HXLINE(  77)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE(  77)								min = ::Math_obj::floor(cy);
            							}
HXDLIN(  77)							int ii_min = min;
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(by);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							yIter31 = this1;
            						}
            						else {
HXLINE(  77)							int ii_min = ::Math_obj::floor(cy);
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							yIter31 = this1;
            						}
            					}
            					else {
HXLINE(  77)						if ((cy > dy)) {
HXLINE(  77)							int min;
HXDLIN(  77)							if ((by > dy)) {
HXLINE(  77)								min = ::Math_obj::floor(dy);
            							}
            							else {
HXLINE(  77)								min = ::Math_obj::ceil(by);
            							}
HXDLIN(  77)							int ii_min = min;
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(cy);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							yIter31 = this1;
            						}
            						else {
HXLINE(  77)							int ii_min = ::Math_obj::floor(by);
HXDLIN(  77)							int ii_max = ::Math_obj::ceil(dy);
HXDLIN(  77)							::pixelimage::iter::IntIterStart this1 = ::pixelimage::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  77)							yIter31 = this1;
            						}
            					}
HXDLIN(  77)					::pixelimage::ImageStruct undoImage1 = null();
HXDLIN(  77)					if (hasUndo1) {
HXLINE(  77)						int w = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  77)						int h = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  77)						int size = (::Std_obj::_hx_int(( (Float)((w * h)) )) * 4);
HXDLIN(  77)						::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  77)						::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  77)						::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,w,h,this2);
HXDLIN(  77)						undoImage1 = this3;
HXDLIN(  77)						{
HXLINE(  77)							int rectLeft = xIter31->start;
HXDLIN(  77)							int rectTop = yIter31->start;
HXDLIN(  77)							int rectRight = xIter31->max;
HXDLIN(  77)							bool forceClear = false;
HXDLIN(  77)							{
HXLINE(  77)								int _g = rectTop;
HXDLIN(  77)								int _g1 = yIter31->max;
HXDLIN(  77)								while((_g < _g1)){
HXLINE(  77)									_g = (_g + 1);
HXDLIN(  77)									int dy = (_g - 1);
HXDLIN(  77)									{
HXLINE(  77)										int _g1 = rectLeft;
HXDLIN(  77)										int _g2 = rectRight;
HXDLIN(  77)										while((_g1 < _g2)){
HXLINE(  77)											_g1 = (_g1 + 1);
HXDLIN(  77)											int dx = (_g1 - 1);
HXDLIN(  77)											::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)											int index;
HXDLIN(  77)											if (pixelShape->useVirtualPos) {
HXLINE(  77)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + dx) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  77)												index = ::Std_obj::_hx_int(( (Float)(((dy * pixelShape->width) + dx)) ));
            											}
HXDLIN(  77)											::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)											int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)											int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)											int col;
HXDLIN(  77)											if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  77)												col = c;
            											}
HXDLIN(  77)											bool _hx_tmp;
HXDLIN(  77)											if (pixelShape->useMask) {
HXLINE(  77)												_hx_tmp = ::hx::IsNotNull( pixelShape->mask );
            											}
            											else {
HXLINE(  77)												_hx_tmp = false;
            											}
HXDLIN(  77)											if (_hx_tmp) {
HXLINE(  77)												::pixelimage::ImageStruct this1 = pixelShape->mask;
HXDLIN(  77)												::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  77)												int index;
HXDLIN(  77)												if (this1->useVirtualPos) {
HXLINE(  77)													index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            												}
            												else {
HXLINE(  77)													index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            												}
HXDLIN(  77)												::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  77)												int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  77)												int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)												int v;
HXDLIN(  77)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)													v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  77)													v = c;
            												}
HXDLIN(  77)												int this3 = v;
HXDLIN(  77)												int maskPixel = this3;
HXDLIN(  77)												int this4 = col;
HXDLIN(  77)												int this5 = this4;
HXDLIN(  77)												if ((maskPixel == 0)) {
HXLINE(  77)													int this1 = this5;
HXDLIN(  77)													col = this1;
            												}
            												else {
HXLINE(  77)													Float m0;
HXDLIN(  77)													int this1 = ((maskPixel >> 24) & 255);
HXDLIN(  77)													if ((this1 == 0)) {
HXLINE(  77)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														m0 = (( (Float)(this1) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float m1;
HXDLIN(  77)													int this2 = ((maskPixel >> 16) & 255);
HXDLIN(  77)													if ((this2 == 0)) {
HXLINE(  77)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														m1 = (( (Float)(this2) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float m2;
HXDLIN(  77)													int this3 = ((maskPixel >> 8) & 255);
HXDLIN(  77)													if ((this3 == 0)) {
HXLINE(  77)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														m2 = (( (Float)(this3) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float m3;
HXDLIN(  77)													int this4 = (maskPixel & 255);
HXDLIN(  77)													if ((this4 == 0)) {
HXLINE(  77)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														m3 = (( (Float)(this4) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN(  77)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN(  77)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN(  77)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN(  77)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  77)											if ((col != 0)) {
HXLINE(  77)												int x = (dx - rectLeft);
HXDLIN(  77)												int y = (dy - rectTop);
HXDLIN(  77)												int this1 = col;
HXDLIN(  77)												int c = this1;
HXDLIN(  77)												bool _hx_tmp;
HXDLIN(  77)												if ((((c >> 24) & 255) < 254)) {
HXLINE(  77)													_hx_tmp = undoImage1->transparent;
            												}
            												else {
HXLINE(  77)													_hx_tmp = false;
            												}
HXDLIN(  77)												if (_hx_tmp) {
HXLINE(  77)													int location;
HXDLIN(  77)													if (undoImage1->useVirtualPos) {
HXLINE(  77)														location = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  77)														location = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  77)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  77)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  77)													int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)													int this3 = this2;
HXDLIN(  77)													int this4;
HXDLIN(  77)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)														this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            													}
            													else {
HXLINE(  77)														this4 = this3;
            													}
HXDLIN(  77)													Float a1;
HXDLIN(  77)													int this5 = ((this4 >> 24) & 255);
HXDLIN(  77)													if ((this5 == 0)) {
HXLINE(  77)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float r1;
HXDLIN(  77)													int this6 = ((this4 >> 16) & 255);
HXDLIN(  77)													if ((this6 == 0)) {
HXLINE(  77)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float g1;
HXDLIN(  77)													int this7 = ((this4 >> 8) & 255);
HXDLIN(  77)													if ((this7 == 0)) {
HXLINE(  77)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float b1;
HXDLIN(  77)													int this8 = (this4 & 255);
HXDLIN(  77)													if ((this8 == 0)) {
HXLINE(  77)														b1 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float a2;
HXDLIN(  77)													int this9 = ((col >> 24) & 255);
HXDLIN(  77)													if ((this9 == 0)) {
HXLINE(  77)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float r2;
HXDLIN(  77)													int this10 = ((col >> 16) & 255);
HXDLIN(  77)													if ((this10 == 0)) {
HXLINE(  77)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float g2;
HXDLIN(  77)													int this11 = ((col >> 8) & 255);
HXDLIN(  77)													if ((this11 == 0)) {
HXLINE(  77)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float b2;
HXDLIN(  77)													int this12 = (col & 255);
HXDLIN(  77)													if ((this12 == 0)) {
HXLINE(  77)														b2 = ((Float)0.);
            													}
            													else {
HXLINE(  77)														b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            													}
HXDLIN(  77)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  77)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  77)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  77)													int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  77)													int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  77)													int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  77)													{
HXLINE(  77)														::haxe::io::ArrayBufferViewImpl this13 = undoImage1->image;
HXDLIN(  77)														int value;
HXDLIN(  77)														if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)															value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  77)															value = blended;
            														}
HXDLIN(  77)														bool _hx_tmp;
HXDLIN(  77)														if ((location >= 0)) {
HXLINE(  77)															_hx_tmp = (location < (this13->byteLength >> 2));
            														}
            														else {
HXLINE(  77)															_hx_tmp = false;
            														}
HXDLIN(  77)														if (_hx_tmp) {
HXLINE(  77)															::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  77)															int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  77)															_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)															_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)															_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)															_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            														}
            													}
            												}
            												else {
HXLINE(  77)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  77)													int index;
HXDLIN(  77)													if (undoImage1->useVirtualPos) {
HXLINE(  77)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  77)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  77)													int value;
HXDLIN(  77)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)														value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXLINE(  77)														value = c;
            													}
HXDLIN(  77)													bool _hx_tmp;
HXDLIN(  77)													if ((index >= 0)) {
HXLINE(  77)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  77)														_hx_tmp = false;
            													}
HXDLIN(  77)													if (_hx_tmp) {
HXLINE(  77)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  77)												if (forceClear) {
HXLINE(  77)													::haxe::io::ArrayBufferViewImpl this1 = undoImage1->image;
HXDLIN(  77)													int x = (dx - rectLeft);
HXDLIN(  77)													int y = (dy - rectTop);
HXDLIN(  77)													int index;
HXDLIN(  77)													if (undoImage1->useVirtualPos) {
HXLINE(  77)														index = ::Std_obj::_hx_int(((((( (Float)(y) ) - undoImage1->virtualY) * ( (Float)(undoImage1->width) )) + x) - undoImage1->virtualX));
            													}
            													else {
HXLINE(  77)														index = ::Std_obj::_hx_int(( (Float)(((y * undoImage1->width) + x)) ));
            													}
HXDLIN(  77)													bool _hx_tmp;
HXDLIN(  77)													if ((index >= 0)) {
HXLINE(  77)														_hx_tmp = (index < (this1->byteLength >> 2));
            													}
            													else {
HXLINE(  77)														_hx_tmp = false;
            													}
HXDLIN(  77)													if (_hx_tmp) {
HXLINE(  77)														::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)														int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  77)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  77)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  77)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  77)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  77)					bool found1 = false;
HXDLIN(  77)					Float min1 = ( (Float)(0) );
HXDLIN(  77)					Float max1 = ( (Float)(0) );
HXDLIN(  77)					int a1 = 0;
HXDLIN(  77)					int r1 = 0;
HXDLIN(  77)					int g1 = 0;
HXDLIN(  77)					int b1 = 0;
HXDLIN(  77)					{
HXLINE(  77)						int _g_min1 = xIter31->start;
HXDLIN(  77)						int _g_max1 = xIter31->max;
HXDLIN(  77)						while((_g_min1 < _g_max1)){
HXLINE(  77)							_g_min1 = (_g_min1 + 1);
HXDLIN(  77)							int px = (_g_min1 - 1);
HXDLIN(  77)							Float pcx = (( (Float)(px) ) - dx);
HXLINE( 696)							found1 = false;
HXLINE(  77)							{
HXLINE(  77)								int _g_min = yIter31->start;
HXDLIN(  77)								int _g_max = yIter31->max;
HXDLIN(  77)								while((_g_min < _g_max)){
HXLINE(  77)									_g_min = (_g_min + 1);
HXDLIN(  77)									int py = (_g_min - 1);
HXDLIN(  77)									Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  77)									Float dot31 = ((pcx * bcx1) + (pcy * bcy1));
HXDLIN(  77)									Float dot32 = ((pcx * acx1) + (pcy * acy1));
HXDLIN(  77)									Float ratioA = (((dot221 * dot31) - (dot121 * dot32)) * denom11);
HXDLIN(  77)									Float ratioB = (((dot111 * dot32) - (dot121 * dot31)) * denom11);
HXDLIN(  77)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  77)									bool _hx_tmp;
HXDLIN(  77)									bool _hx_tmp1;
HXDLIN(  77)									if ((ratioA >= 0)) {
HXLINE(  77)										_hx_tmp1 = (ratioB >= 0);
            									}
            									else {
HXLINE(  77)										_hx_tmp1 = false;
            									}
HXDLIN(  77)									if (_hx_tmp1) {
HXLINE(  77)										_hx_tmp = (ratioC >= 0);
            									}
            									else {
HXLINE(  77)										_hx_tmp = false;
            									}
HXDLIN(  77)									if (_hx_tmp) {
HXLINE(  77)										if ((ratioB < ratioC)) {
HXLINE(  77)											min1 = ratioB;
            										}
            										else {
HXLINE(  77)											min1 = ratioC;
            										}
HXDLIN(  77)										if ((ratioA > ratioB)) {
HXLINE(  77)											max1 = ratioA;
            										}
            										else {
HXLINE(  77)											max1 = ratioB;
            										}
HXDLIN(  77)										if (!((max1 > ratioC))) {
HXLINE(  77)											max1 = ratioC;
            										}
HXLINE( 736)										max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  77)										if (!((min1 < max1))) {
HXLINE(  77)											min1 = ((max1 + min1) / ( (Float)(2) ));
            										}
HXDLIN(  77)										int i = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min1));
HXDLIN(  77)										if ((i > 255)) {
HXLINE(  24)											i = 255;
            										}
HXLINE(  77)										if ((i < 0)) {
HXLINE(  25)											i = 0;
            										}
HXLINE(  77)										int this1 = i;
HXDLIN(  77)										a1 = this1;
HXDLIN(  77)										int i1 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  77)										if ((i1 > 255)) {
HXLINE(  24)											i1 = 255;
            										}
HXLINE(  77)										if ((i1 < 0)) {
HXLINE(  25)											i1 = 0;
            										}
HXLINE(  77)										int this2 = i1;
HXLINE( 748)										r1 = this2;
HXLINE(  77)										int i2 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  77)										if ((i2 > 255)) {
HXLINE(  24)											i2 = 255;
            										}
HXLINE(  77)										if ((i2 < 0)) {
HXLINE(  25)											i2 = 0;
            										}
HXLINE(  77)										int this3 = i2;
HXLINE( 749)										g1 = this3;
HXLINE(  77)										int i3 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  77)										if ((i3 > 255)) {
HXLINE(  24)											i3 = 255;
            										}
HXLINE(  77)										if ((i3 < 0)) {
HXLINE(  25)											i3 = 0;
            										}
HXLINE(  77)										int this4 = i3;
HXLINE( 750)										b1 = this4;
HXLINE(  77)										{
HXLINE(  77)											int location;
HXDLIN(  77)											if (pixelShape->useVirtualPos) {
HXLINE(  77)												location = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + px) - pixelShape->virtualX));
            											}
            											else {
HXLINE(  77)												location = ::Std_obj::_hx_int(( (Float)(((py * pixelShape->width) + px)) ));
            											}
HXDLIN(  77)											bool _hx_tmp;
HXDLIN(  77)											if (pixelShape->transparent) {
HXLINE(  77)												_hx_tmp = (a1 < 254);
            											}
            											else {
HXLINE(  77)												_hx_tmp = false;
            											}
HXDLIN(  77)											if (_hx_tmp) {
HXLINE(  77)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)												::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)												int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  77)												int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  77)												int this3 = this2;
HXDLIN(  77)												int old;
HXDLIN(  77)												if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)													old = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            												}
            												else {
HXLINE(  77)													old = this3;
            												}
HXDLIN(  77)												int rhs = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
HXDLIN(  77)												Float a11;
HXDLIN(  77)												int this4 = ((old >> 24) & 255);
HXDLIN(  77)												if ((this4 == 0)) {
HXLINE(  77)													a11 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													a11 = (( (Float)(this4) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float r11;
HXDLIN(  77)												int this5 = ((old >> 16) & 255);
HXDLIN(  77)												if ((this5 == 0)) {
HXLINE(  77)													r11 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													r11 = (( (Float)(this5) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float g11;
HXDLIN(  77)												int this6 = ((old >> 8) & 255);
HXDLIN(  77)												if ((this6 == 0)) {
HXLINE(  77)													g11 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													g11 = (( (Float)(this6) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float b11;
HXDLIN(  77)												int this7 = (old & 255);
HXDLIN(  77)												if ((this7 == 0)) {
HXLINE(  77)													b11 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													b11 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float a2;
HXDLIN(  77)												int this8 = ((rhs >> 24) & 255);
HXDLIN(  77)												if ((this8 == 0)) {
HXLINE(  77)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float r2;
HXDLIN(  77)												int this9 = ((rhs >> 16) & 255);
HXDLIN(  77)												if ((this9 == 0)) {
HXLINE(  77)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float g2;
HXDLIN(  77)												int this10 = ((rhs >> 8) & 255);
HXDLIN(  77)												if ((this10 == 0)) {
HXLINE(  77)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float b2;
HXDLIN(  77)												int this11 = (rhs & 255);
HXDLIN(  77)												if ((this11 == 0)) {
HXLINE(  77)													b2 = ((Float)0.);
            												}
            												else {
HXLINE(  77)													b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  77)												Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  77)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a3) + (r2 * a2))));
HXDLIN(  77)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a3) + (g2 * a2))));
HXDLIN(  77)												int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b2 * a2))));
HXDLIN(  77)												int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  77)												int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  77)												{
HXLINE(  77)													::haxe::io::ArrayBufferViewImpl this12 = pixelShape->image;
HXDLIN(  77)													int value;
HXDLIN(  77)													if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  77)														value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  77)														value = blended;
            													}
HXDLIN(  77)													bool _hx_tmp;
HXDLIN(  77)													if ((location >= 0)) {
HXLINE(  77)														_hx_tmp = (location < (this12->byteLength >> 2));
            													}
            													else {
HXLINE(  77)														_hx_tmp = false;
            													}
HXDLIN(  77)													if (_hx_tmp) {
HXLINE(  77)														::haxe::io::Bytes _this = this12->bytes;
HXDLIN(  77)														int pos = ((location << 2) + this12->byteOffset);
HXDLIN(  77)														_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)														_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)														_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)														_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            													}
            												}
            											}
            											else {
HXLINE(  77)												::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  77)												int value;
HXDLIN(  77)												if (pixelShape->isLittle) {
HXLINE(  77)													value = ((((a1 << 24) | (b1 << 16)) | (g1 << 8)) | r1);
            												}
            												else {
HXLINE(  77)													value = ((((a1 << 24) | (r1 << 16)) | (g1 << 8)) | b1);
            												}
HXDLIN(  77)												bool _hx_tmp;
HXDLIN(  77)												if ((location >= 0)) {
HXLINE(  77)													_hx_tmp = (location < (this1->byteLength >> 2));
            												}
            												else {
HXLINE(  77)													_hx_tmp = false;
            												}
HXDLIN(  77)												if (_hx_tmp) {
HXLINE(  77)													::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  77)													int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  77)													_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  77)													_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  77)													_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  77)													_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            												}
            											}
            										}
HXLINE( 752)										found1 = true;
            									}
            									else {
HXLINE(  77)										if (found1) {
HXLINE(  77)											goto _hx_goto_34;
            										}
            									}
            								}
            								_hx_goto_34:;
            							}
            						}
            					}
HXDLIN(  77)					if ((hasHit == false)) {
HXLINE(  77)						::pixelimage::algo::HitTri v = ::pixelimage::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  77)						if (hasUndo1) {
HXLINE(  77)							v->undoImage = undoImage1;
HXDLIN(  77)							v->undoX = xIter31->start;
HXDLIN(  77)							v->undoY = yIter31->start;
            						}
            					}
            				}
HXDLIN(  77)				if ((hasHit == true)) {
HXLINE(  77)					::pixelimage::algo::HitQuad v = ::pixelimage::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE(  71)					_hx_tmp = v;
            				}
            				else {
HXLINE(  71)					_hx_tmp = null();
            				}
            			}
            		}
HXDLIN(  71)		this->hitObj = _hx_tmp;
HXLINE(  81)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< QuadShape_obj > QuadShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_aX,::hx::Null< Float >  __o_aY,::hx::Null< Float >  __o_bX,::hx::Null< Float >  __o_bY,::hx::Null< Float >  __o_cX,::hx::Null< Float >  __o_cY,::hx::Null< Float >  __o_dX,::hx::Null< Float >  __o_dY,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_luxury) {
	::hx::ObjectPtr< QuadShape_obj > __this = new QuadShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_aX,__o_aY,__o_bX,__o_bY,__o_cX,__o_cY,__o_dX,__o_dY,__o_soft,__o_luxury);
	return __this;
}

::hx::ObjectPtr< QuadShape_obj > QuadShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_aX,::hx::Null< Float >  __o_aY,::hx::Null< Float >  __o_bX,::hx::Null< Float >  __o_bY,::hx::Null< Float >  __o_cX,::hx::Null< Float >  __o_cY,::hx::Null< Float >  __o_dX,::hx::Null< Float >  __o_dY,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_luxury) {
	QuadShape_obj *__this = (QuadShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(QuadShape_obj), true, "pixelimage.triangleGML.contour.QuadShape"));
	*(void **)__this = QuadShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_aX,__o_aY,__o_bX,__o_bY,__o_cX,__o_cY,__o_dX,__o_dY,__o_soft,__o_luxury);
	return __this;
}

QuadShape_obj::QuadShape_obj()
{
}

::hx::Val QuadShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"aX") ) { return ::hx::Val( aX ); }
		if (HX_FIELD_EQ(inName,"aY") ) { return ::hx::Val( aY ); }
		if (HX_FIELD_EQ(inName,"bX") ) { return ::hx::Val( bX ); }
		if (HX_FIELD_EQ(inName,"bY") ) { return ::hx::Val( bY ); }
		if (HX_FIELD_EQ(inName,"cX") ) { return ::hx::Val( cX ); }
		if (HX_FIELD_EQ(inName,"cY") ) { return ::hx::Val( cY ); }
		if (HX_FIELD_EQ(inName,"dX") ) { return ::hx::Val( dX ); }
		if (HX_FIELD_EQ(inName,"dY") ) { return ::hx::Val( dY ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"soft") ) { return ::hx::Val( soft ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"luxury") ) { return ::hx::Val( luxury ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val QuadShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"aX") ) { aX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"aY") ) { aY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bX") ) { bX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bY") ) { bY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cX") ) { cX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cY") ) { cY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dX") ) { dX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dY") ) { dY=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"soft") ) { soft=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"luxury") ) { luxury=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void QuadShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("aX",d7,54,00,00));
	outFields->push(HX_("aY",d8,54,00,00));
	outFields->push(HX_("bX",b6,55,00,00));
	outFields->push(HX_("bY",b7,55,00,00));
	outFields->push(HX_("cX",95,56,00,00));
	outFields->push(HX_("cY",96,56,00,00));
	outFields->push(HX_("dX",74,57,00,00));
	outFields->push(HX_("dY",75,57,00,00));
	outFields->push(HX_("soft",ea,1c,58,4c));
	outFields->push(HX_("luxury",0d,9d,17,dc));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo QuadShape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,aX),HX_("aX",d7,54,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,aY),HX_("aY",d8,54,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,bX),HX_("bX",b6,55,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,bY),HX_("bY",b7,55,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,cX),HX_("cX",95,56,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,cY),HX_("cY",96,56,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,dX),HX_("dX",74,57,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,dY),HX_("dY",75,57,00,00)},
	{::hx::fsFloat,(int)offsetof(QuadShape_obj,soft),HX_("soft",ea,1c,58,4c)},
	{::hx::fsBool,(int)offsetof(QuadShape_obj,luxury),HX_("luxury",0d,9d,17,dc)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *QuadShape_obj_sStaticStorageInfo = 0;
#endif

static ::String QuadShape_obj_sMemberFields[] = {
	HX_("aX",d7,54,00,00),
	HX_("aY",d8,54,00,00),
	HX_("bX",b6,55,00,00),
	HX_("bY",b7,55,00,00),
	HX_("cX",95,56,00,00),
	HX_("cY",96,56,00,00),
	HX_("dX",74,57,00,00),
	HX_("dY",75,57,00,00),
	HX_("soft",ea,1c,58,4c),
	HX_("luxury",0d,9d,17,dc),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class QuadShape_obj::__mClass;

void QuadShape_obj::__register()
{
	QuadShape_obj _hx_dummy;
	QuadShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.contour.QuadShape",3d,55,c8,02);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(QuadShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< QuadShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = QuadShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = QuadShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace contour
