// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_contour_LineGridShape
#include <pixelimage/triangleGML/contour/LineGridShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_BasicShape
#include <pixelimage/triangleGML/coreShape/BasicShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_GroupShape
#include <pixelimage/triangleGML/coreShape/GroupShape.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_ShapeInterface
#include <pixelimage/triangleGML/coreShape/ShapeInterface.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0ab80190315aeee2_27_new,"pixelimage.triangleGML.contour.LineGridShape","new",0x6bd87fbc,"pixelimage.triangleGML.contour.LineGridShape.new","pixelimage/triangleGML/contour/LineGridShape.hx",27,0xb06d10b7)
HX_LOCAL_STACK_FRAME(_hx_pos_0ab80190315aeee2_37_setParameter,"pixelimage.triangleGML.contour.LineGridShape","setParameter",0x73b07acb,"pixelimage.triangleGML.contour.LineGridShape.setParameter","pixelimage/triangleGML/contour/LineGridShape.hx",37,0xb06d10b7)
HX_LOCAL_STACK_FRAME(_hx_pos_0ab80190315aeee2_54_render,"pixelimage.triangleGML.contour.LineGridShape","render",0x8d4bbd7a,"pixelimage.triangleGML.contour.LineGridShape.render","pixelimage/triangleGML/contour/LineGridShape.hx",54,0xb06d10b7)
namespace pixelimage{
namespace triangleGML{
namespace contour{

void LineGridShape_obj::__construct(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_delta,::hx::Null< Float >  __o_deltaH){
            		Float opacity = __o_opacity.Default(((Float)1.));
            		bool visibility = __o_visibility.Default(true);
            		int strokeColor = __o_strokeColor.Default(-1048576);
            		Float strokeWidth = __o_strokeWidth.Default(((Float)1.));
            		Float left = __o_left.Default(((Float)0.));
            		Float top = __o_top.Default(((Float)0.));
            		Float width = __o_width.Default(((Float)1.));
            		Float height = __o_height.Default(((Float)1.));
            		Float delta = __o_delta.Default(((Float)1.));
            		Float deltaH = __o_deltaH.Default(((Float)0.));
            	HX_STACKFRAME(&_hx_pos_0ab80190315aeee2_27_new)
HXLINE(  28)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
HXLINE(  29)		this->left = left;
HXLINE(  30)		this->top = top;
HXLINE(  31)		this->width = width;
HXLINE(  32)		this->height = height;
HXLINE(  33)		this->delta = delta;
HXLINE(  34)		this->deltaH = deltaH;
            	}

Dynamic LineGridShape_obj::__CreateEmpty() { return new LineGridShape_obj; }

void *LineGridShape_obj::_hx_vtable = 0;

Dynamic LineGridShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LineGridShape_obj > _hx_result = new LineGridShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10]);
	return _hx_result;
}

bool LineGridShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x24e92cfb) {
		if (inClassId<=(int)0x2091632c) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2091632c;
		} else {
			return inClassId==(int)0x24e92cfb;
		}
	} else {
		return inClassId==(int)0x693fee16;
	}
}

void LineGridShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_0ab80190315aeee2_37_setParameter)
HXDLIN(  37)		::String _hx_switch_0 = name;
            		if (  (_hx_switch_0==HX_("delta",f8,e7,26,d7)) ){
HXLINE(  47)			this->delta = ::Std_obj::parseFloat(value);
HXDLIN(  47)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("deltaH",50,11,e4,6a)) ){
HXLINE(  49)			this->deltaH = ::Std_obj::parseFloat(value);
HXDLIN(  49)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("height",e7,07,4c,02)) ){
HXLINE(  45)			this->height = ::Std_obj::parseFloat(value);
HXDLIN(  45)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("left",07,08,b0,47)) ){
HXLINE(  39)			this->left = ::Std_obj::parseFloat(value);
HXDLIN(  39)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("top",95,66,58,00)) ){
HXLINE(  41)			this->top = ::Std_obj::parseFloat(value);
HXDLIN(  41)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("width",06,b6,62,ca)) ){
HXLINE(  43)			this->width = ::Std_obj::parseFloat(value);
HXDLIN(  43)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE(  51)			this->super::setParameter(name,value);
            		}
            		_hx_goto_1:;
            	}


::pixelimage::ImageStruct LineGridShape_obj::render(::pixelimage::ImageStruct pixelShape){
            	HX_STACKFRAME(&_hx_pos_0ab80190315aeee2_54_render)
HXLINE(  55)		if ((this->deltaH != ((Float)0.))) {
HXLINE(  56)			Float x = (this->left + this->offX);
HXDLIN(  56)			Float y = (this->top + this->offY);
HXDLIN(  56)			Float w = this->width;
HXDLIN(  56)			Float h = this->height;
HXDLIN(  56)			Float deltaW = this->delta;
HXDLIN(  56)			Float deltaH = this->deltaH;
HXDLIN(  56)			Float thick = this->strokeWidth;
HXDLIN(  56)			int color = this->strokeColor;
HXDLIN(  56)			Float h_ = (( (Float)(::Math_obj::floor((h / deltaH))) ) * deltaH);
HXDLIN(  56)			Float w_ = (( (Float)(::Math_obj::floor((w / deltaW))) ) * deltaW);
HXDLIN(  56)			{
HXLINE(  56)				int _g = 0;
HXDLIN(  56)				int _g1 = (::Math_obj::floor((w / deltaW)) + 1);
HXDLIN(  56)				while((_g < _g1)){
HXLINE(  56)					_g = (_g + 1);
HXDLIN(  56)					int i = (_g - 1);
HXDLIN(  56)					{
HXLINE(  56)						Float x1 = ((x + (( (Float)(i) ) * deltaW)) - (thick / ( (Float)(2) )));
HXDLIN(  56)						int p = ::Std_obj::_hx_int(x1);
HXDLIN(  56)						int xx = p;
HXDLIN(  56)						int q = ::Std_obj::_hx_int(y);
HXDLIN(  56)						int maxX = ::Std_obj::_hx_int((x1 + thick));
HXDLIN(  56)						int maxY = ::Std_obj::_hx_int((y + h_));
HXDLIN(  56)						while(true){
HXLINE(  56)							{
HXLINE(  56)								p = (p + 1);
HXDLIN(  56)								int x = (p - 1);
HXDLIN(  56)								int this1 = color;
HXDLIN(  56)								int c = this1;
HXDLIN(  56)								bool _hx_tmp;
HXDLIN(  56)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  56)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  56)									_hx_tmp = false;
            								}
HXDLIN(  56)								if (_hx_tmp) {
HXLINE(  56)									int location;
HXDLIN(  56)									if (pixelShape->useVirtualPos) {
HXLINE(  56)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  56)										location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  56)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  56)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  56)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  56)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  56)									int this3 = this2;
HXDLIN(  56)									int this4;
HXDLIN(  56)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  56)										this4 = this3;
            									}
HXDLIN(  56)									Float a1;
HXDLIN(  56)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  56)									if ((this5 == 0)) {
HXLINE(  56)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float r1;
HXDLIN(  56)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  56)									if ((this6 == 0)) {
HXLINE(  56)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float g1;
HXDLIN(  56)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  56)									if ((this7 == 0)) {
HXLINE(  56)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float b1;
HXDLIN(  56)									int this8 = (this4 & 255);
HXDLIN(  56)									if ((this8 == 0)) {
HXLINE(  56)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float a2;
HXDLIN(  56)									int this9 = ((color >> 24) & 255);
HXDLIN(  56)									if ((this9 == 0)) {
HXLINE(  56)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float r2;
HXDLIN(  56)									int this10 = ((color >> 16) & 255);
HXDLIN(  56)									if ((this10 == 0)) {
HXLINE(  56)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float g2;
HXDLIN(  56)									int this11 = ((color >> 8) & 255);
HXDLIN(  56)									if ((this11 == 0)) {
HXLINE(  56)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float b2;
HXDLIN(  56)									int this12 = (color & 255);
HXDLIN(  56)									if ((this12 == 0)) {
HXLINE(  56)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  56)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  56)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  56)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  56)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  56)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  56)									{
HXLINE(  56)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  56)										int value;
HXDLIN(  56)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  56)											value = blended;
            										}
HXDLIN(  56)										bool _hx_tmp;
HXDLIN(  56)										if ((location >= 0)) {
HXLINE(  56)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  56)											_hx_tmp = false;
            										}
HXDLIN(  56)										if (_hx_tmp) {
HXLINE(  56)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  56)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  56)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  56)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  56)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  56)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  56)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  56)									int index;
HXDLIN(  56)									if (pixelShape->useVirtualPos) {
HXLINE(  56)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  56)										index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  56)									int value;
HXDLIN(  56)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  56)										value = c;
            									}
HXDLIN(  56)									bool _hx_tmp;
HXDLIN(  56)									if ((index >= 0)) {
HXLINE(  56)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  56)										_hx_tmp = false;
            									}
HXDLIN(  56)									if (_hx_tmp) {
HXLINE(  56)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  56)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  56)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  56)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  56)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  56)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  56)							if ((p > maxX)) {
HXLINE(  56)								p = xx;
HXDLIN(  56)								q = (q + 1);
            							}
HXDLIN(  56)							if ((q > maxY)) {
HXLINE(  56)								goto _hx_goto_4;
            							}
            						}
            						_hx_goto_4:;
            					}
            				}
            			}
HXDLIN(  56)			{
HXLINE(  56)				int _g2 = 0;
HXDLIN(  56)				int _g3 = (::Math_obj::floor((h / deltaH)) + 1);
HXDLIN(  56)				while((_g2 < _g3)){
HXLINE(  56)					_g2 = (_g2 + 1);
HXDLIN(  56)					int i = (_g2 - 1);
HXDLIN(  56)					{
HXLINE(  56)						Float y1 = ((y + (( (Float)(i) ) * deltaH)) - (thick / ( (Float)(2) )));
HXDLIN(  56)						int p = ::Std_obj::_hx_int(x);
HXDLIN(  56)						int xx = p;
HXDLIN(  56)						int q = ::Std_obj::_hx_int(y1);
HXDLIN(  56)						int maxX = ::Std_obj::_hx_int((x + w_));
HXDLIN(  56)						int maxY = ::Std_obj::_hx_int((y1 + thick));
HXDLIN(  56)						while(true){
HXLINE(  56)							{
HXLINE(  56)								p = (p + 1);
HXDLIN(  56)								int x = (p - 1);
HXDLIN(  56)								int this1 = color;
HXDLIN(  56)								int c = this1;
HXDLIN(  56)								bool _hx_tmp;
HXDLIN(  56)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  56)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  56)									_hx_tmp = false;
            								}
HXDLIN(  56)								if (_hx_tmp) {
HXLINE(  56)									int location;
HXDLIN(  56)									if (pixelShape->useVirtualPos) {
HXLINE(  56)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  56)										location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  56)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  56)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  56)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  56)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  56)									int this3 = this2;
HXDLIN(  56)									int this4;
HXDLIN(  56)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  56)										this4 = this3;
            									}
HXDLIN(  56)									Float a1;
HXDLIN(  56)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  56)									if ((this5 == 0)) {
HXLINE(  56)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float r1;
HXDLIN(  56)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  56)									if ((this6 == 0)) {
HXLINE(  56)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float g1;
HXDLIN(  56)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  56)									if ((this7 == 0)) {
HXLINE(  56)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float b1;
HXDLIN(  56)									int this8 = (this4 & 255);
HXDLIN(  56)									if ((this8 == 0)) {
HXLINE(  56)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float a2;
HXDLIN(  56)									int this9 = ((color >> 24) & 255);
HXDLIN(  56)									if ((this9 == 0)) {
HXLINE(  56)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float r2;
HXDLIN(  56)									int this10 = ((color >> 16) & 255);
HXDLIN(  56)									if ((this10 == 0)) {
HXLINE(  56)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float g2;
HXDLIN(  56)									int this11 = ((color >> 8) & 255);
HXDLIN(  56)									if ((this11 == 0)) {
HXLINE(  56)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float b2;
HXDLIN(  56)									int this12 = (color & 255);
HXDLIN(  56)									if ((this12 == 0)) {
HXLINE(  56)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  56)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  56)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  56)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  56)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  56)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  56)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  56)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  56)									{
HXLINE(  56)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  56)										int value;
HXDLIN(  56)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  56)											value = blended;
            										}
HXDLIN(  56)										bool _hx_tmp;
HXDLIN(  56)										if ((location >= 0)) {
HXLINE(  56)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  56)											_hx_tmp = false;
            										}
HXDLIN(  56)										if (_hx_tmp) {
HXLINE(  56)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  56)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  56)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  56)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  56)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  56)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  56)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  56)									int index;
HXDLIN(  56)									if (pixelShape->useVirtualPos) {
HXLINE(  56)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  56)										index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  56)									int value;
HXDLIN(  56)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  56)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  56)										value = c;
            									}
HXDLIN(  56)									bool _hx_tmp;
HXDLIN(  56)									if ((index >= 0)) {
HXLINE(  56)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  56)										_hx_tmp = false;
            									}
HXDLIN(  56)									if (_hx_tmp) {
HXLINE(  56)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  56)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  56)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  56)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  56)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  56)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  56)							if ((p > maxX)) {
HXLINE(  56)								p = xx;
HXDLIN(  56)								q = (q + 1);
            							}
HXDLIN(  56)							if ((q > maxY)) {
HXLINE(  56)								goto _hx_goto_6;
            							}
            						}
            						_hx_goto_6:;
            					}
            				}
            			}
            		}
            		else {
HXLINE(  58)			Float x = (this->left + this->offX);
HXDLIN(  58)			Float y = (this->top + this->offY);
HXDLIN(  58)			Float w = this->width;
HXDLIN(  58)			Float h = this->height;
HXDLIN(  58)			Float delta = this->delta;
HXDLIN(  58)			Float thick = this->strokeWidth;
HXDLIN(  58)			int color = this->strokeColor;
HXDLIN(  58)			Float h_ = (( (Float)(::Math_obj::floor((h / delta))) ) * delta);
HXDLIN(  58)			Float w_ = (( (Float)(::Math_obj::floor((w / delta))) ) * delta);
HXDLIN(  58)			{
HXLINE(  58)				int _g = 0;
HXDLIN(  58)				int _g1 = (::Math_obj::floor((w / delta)) + 1);
HXDLIN(  58)				while((_g < _g1)){
HXLINE(  58)					_g = (_g + 1);
HXDLIN(  58)					int i = (_g - 1);
HXDLIN(  58)					{
HXLINE(  58)						Float x1 = ((x + (( (Float)(i) ) * delta)) - (thick / ( (Float)(2) )));
HXDLIN(  58)						int p = ::Std_obj::_hx_int(x1);
HXDLIN(  58)						int xx = p;
HXDLIN(  58)						int q = ::Std_obj::_hx_int(y);
HXDLIN(  58)						int maxX = ::Std_obj::_hx_int((x1 + thick));
HXDLIN(  58)						int maxY = ::Std_obj::_hx_int((y + h_));
HXDLIN(  58)						while(true){
HXLINE(  58)							{
HXLINE(  58)								p = (p + 1);
HXDLIN(  58)								int x = (p - 1);
HXDLIN(  58)								int this1 = color;
HXDLIN(  58)								int c = this1;
HXDLIN(  58)								bool _hx_tmp;
HXDLIN(  58)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  58)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  58)									_hx_tmp = false;
            								}
HXDLIN(  58)								if (_hx_tmp) {
HXLINE(  58)									int location;
HXDLIN(  58)									if (pixelShape->useVirtualPos) {
HXLINE(  58)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  58)										location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  58)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  58)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  58)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  58)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  58)									int this3 = this2;
HXDLIN(  58)									int this4;
HXDLIN(  58)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  58)										this4 = this3;
            									}
HXDLIN(  58)									Float a1;
HXDLIN(  58)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  58)									if ((this5 == 0)) {
HXLINE(  58)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float r1;
HXDLIN(  58)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  58)									if ((this6 == 0)) {
HXLINE(  58)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float g1;
HXDLIN(  58)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  58)									if ((this7 == 0)) {
HXLINE(  58)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float b1;
HXDLIN(  58)									int this8 = (this4 & 255);
HXDLIN(  58)									if ((this8 == 0)) {
HXLINE(  58)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float a2;
HXDLIN(  58)									int this9 = ((color >> 24) & 255);
HXDLIN(  58)									if ((this9 == 0)) {
HXLINE(  58)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float r2;
HXDLIN(  58)									int this10 = ((color >> 16) & 255);
HXDLIN(  58)									if ((this10 == 0)) {
HXLINE(  58)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float g2;
HXDLIN(  58)									int this11 = ((color >> 8) & 255);
HXDLIN(  58)									if ((this11 == 0)) {
HXLINE(  58)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float b2;
HXDLIN(  58)									int this12 = (color & 255);
HXDLIN(  58)									if ((this12 == 0)) {
HXLINE(  58)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  58)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  58)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  58)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  58)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  58)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  58)									{
HXLINE(  58)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  58)										int value;
HXDLIN(  58)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  58)											value = blended;
            										}
HXDLIN(  58)										bool _hx_tmp;
HXDLIN(  58)										if ((location >= 0)) {
HXLINE(  58)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  58)											_hx_tmp = false;
            										}
HXDLIN(  58)										if (_hx_tmp) {
HXLINE(  58)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  58)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  58)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  58)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  58)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  58)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  58)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  58)									int index;
HXDLIN(  58)									if (pixelShape->useVirtualPos) {
HXLINE(  58)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  58)										index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  58)									int value;
HXDLIN(  58)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  58)										value = c;
            									}
HXDLIN(  58)									bool _hx_tmp;
HXDLIN(  58)									if ((index >= 0)) {
HXLINE(  58)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  58)										_hx_tmp = false;
            									}
HXDLIN(  58)									if (_hx_tmp) {
HXLINE(  58)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  58)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  58)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  58)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  58)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  58)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  58)							if ((p > maxX)) {
HXLINE(  58)								p = xx;
HXDLIN(  58)								q = (q + 1);
            							}
HXDLIN(  58)							if ((q > maxY)) {
HXLINE(  58)								goto _hx_goto_8;
            							}
            						}
            						_hx_goto_8:;
            					}
            				}
            			}
HXDLIN(  58)			{
HXLINE(  58)				int _g2 = 0;
HXDLIN(  58)				int _g3 = (::Math_obj::floor((h / delta)) + 1);
HXDLIN(  58)				while((_g2 < _g3)){
HXLINE(  58)					_g2 = (_g2 + 1);
HXDLIN(  58)					int i = (_g2 - 1);
HXDLIN(  58)					{
HXLINE(  58)						Float y1 = ((y + (( (Float)(i) ) * delta)) - (thick / ( (Float)(2) )));
HXDLIN(  58)						int p = ::Std_obj::_hx_int(x);
HXDLIN(  58)						int xx = p;
HXDLIN(  58)						int q = ::Std_obj::_hx_int(y1);
HXDLIN(  58)						int maxX = ::Std_obj::_hx_int((x + w_));
HXDLIN(  58)						int maxY = ::Std_obj::_hx_int((y1 + thick));
HXDLIN(  58)						while(true){
HXLINE(  58)							{
HXLINE(  58)								p = (p + 1);
HXDLIN(  58)								int x = (p - 1);
HXDLIN(  58)								int this1 = color;
HXDLIN(  58)								int c = this1;
HXDLIN(  58)								bool _hx_tmp;
HXDLIN(  58)								if ((((c >> 24) & 255) < 254)) {
HXLINE(  58)									_hx_tmp = pixelShape->transparent;
            								}
            								else {
HXLINE(  58)									_hx_tmp = false;
            								}
HXDLIN(  58)								if (_hx_tmp) {
HXLINE(  58)									int location;
HXDLIN(  58)									if (pixelShape->useVirtualPos) {
HXLINE(  58)										location = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  58)										location = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  58)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  58)									::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  58)									int pos = ((location << 2) + this1->byteOffset);
HXDLIN(  58)									int this2 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  58)									int this3 = this2;
HXDLIN(  58)									int this4;
HXDLIN(  58)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)										this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            									}
            									else {
HXLINE(  58)										this4 = this3;
            									}
HXDLIN(  58)									Float a1;
HXDLIN(  58)									int this5 = ((this4 >> 24) & 255);
HXDLIN(  58)									if ((this5 == 0)) {
HXLINE(  58)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float r1;
HXDLIN(  58)									int this6 = ((this4 >> 16) & 255);
HXDLIN(  58)									if ((this6 == 0)) {
HXLINE(  58)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float g1;
HXDLIN(  58)									int this7 = ((this4 >> 8) & 255);
HXDLIN(  58)									if ((this7 == 0)) {
HXLINE(  58)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float b1;
HXDLIN(  58)									int this8 = (this4 & 255);
HXDLIN(  58)									if ((this8 == 0)) {
HXLINE(  58)										b1 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float a2;
HXDLIN(  58)									int this9 = ((color >> 24) & 255);
HXDLIN(  58)									if ((this9 == 0)) {
HXLINE(  58)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float r2;
HXDLIN(  58)									int this10 = ((color >> 16) & 255);
HXDLIN(  58)									if ((this10 == 0)) {
HXLINE(  58)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float g2;
HXDLIN(  58)									int this11 = ((color >> 8) & 255);
HXDLIN(  58)									if ((this11 == 0)) {
HXLINE(  58)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float b2;
HXDLIN(  58)									int this12 = (color & 255);
HXDLIN(  58)									if ((this12 == 0)) {
HXLINE(  58)										b2 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  58)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  58)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  58)									int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  58)									int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  58)									int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  58)									{
HXLINE(  58)										::haxe::io::ArrayBufferViewImpl this13 = pixelShape->image;
HXDLIN(  58)										int value;
HXDLIN(  58)										if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)											value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  58)											value = blended;
            										}
HXDLIN(  58)										bool _hx_tmp;
HXDLIN(  58)										if ((location >= 0)) {
HXLINE(  58)											_hx_tmp = (location < (this13->byteLength >> 2));
            										}
            										else {
HXLINE(  58)											_hx_tmp = false;
            										}
HXDLIN(  58)										if (_hx_tmp) {
HXLINE(  58)											::haxe::io::Bytes _this = this13->bytes;
HXDLIN(  58)											int pos = ((location << 2) + this13->byteOffset);
HXDLIN(  58)											_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  58)											_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  58)											_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  58)											_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            										}
            									}
            								}
            								else {
HXLINE(  58)									::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  58)									int index;
HXDLIN(  58)									if (pixelShape->useVirtualPos) {
HXLINE(  58)										index = ::Std_obj::_hx_int(((((( (Float)(q) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            									}
            									else {
HXLINE(  58)										index = ::Std_obj::_hx_int(( (Float)(((q * pixelShape->width) + x)) ));
            									}
HXDLIN(  58)									int value;
HXDLIN(  58)									if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)										value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  58)										value = c;
            									}
HXDLIN(  58)									bool _hx_tmp;
HXDLIN(  58)									if ((index >= 0)) {
HXLINE(  58)										_hx_tmp = (index < (this1->byteLength >> 2));
            									}
            									else {
HXLINE(  58)										_hx_tmp = false;
            									}
HXDLIN(  58)									if (_hx_tmp) {
HXLINE(  58)										::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  58)										int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  58)										_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  58)										_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  58)										_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  58)										_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            									}
            								}
            							}
HXDLIN(  58)							if ((p > maxX)) {
HXLINE(  58)								p = xx;
HXDLIN(  58)								q = (q + 1);
            							}
HXDLIN(  58)							if ((q > maxY)) {
HXLINE(  58)								goto _hx_goto_10;
            							}
            						}
            						_hx_goto_10:;
            					}
            				}
            			}
            		}
HXLINE(  60)		return this->super::render(pixelShape);
            	}



::hx::ObjectPtr< LineGridShape_obj > LineGridShape_obj::__new(::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_delta,::hx::Null< Float >  __o_deltaH) {
	::hx::ObjectPtr< LineGridShape_obj > __this = new LineGridShape_obj();
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_left,__o_top,__o_width,__o_height,__o_delta,__o_deltaH);
	return __this;
}

::hx::ObjectPtr< LineGridShape_obj > LineGridShape_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_opacity,::hx::Null< bool >  __o_visibility,::hx::Null< int >  __o_strokeColor,::hx::Null< Float >  __o_strokeWidth,::Array< ::String > strokeDashGapArray,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height,::hx::Null< Float >  __o_delta,::hx::Null< Float >  __o_deltaH) {
	LineGridShape_obj *__this = (LineGridShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(LineGridShape_obj), true, "pixelimage.triangleGML.contour.LineGridShape"));
	*(void **)__this = LineGridShape_obj::_hx_vtable;
	__this->__construct(__o_opacity,__o_visibility,__o_strokeColor,__o_strokeWidth,strokeDashGapArray,__o_left,__o_top,__o_width,__o_height,__o_delta,__o_deltaH);
	return __this;
}

LineGridShape_obj::LineGridShape_obj()
{
}

::hx::Val LineGridShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { return ::hx::Val( top ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { return ::hx::Val( left ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"delta") ) { return ::hx::Val( delta ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"deltaH") ) { return ::hx::Val( deltaH ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val LineGridShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { top=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { left=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"delta") ) { delta=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"deltaH") ) { deltaH=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void LineGridShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("left",07,08,b0,47));
	outFields->push(HX_("top",95,66,58,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("delta",f8,e7,26,d7));
	outFields->push(HX_("deltaH",50,11,e4,6a));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo LineGridShape_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(LineGridShape_obj,left),HX_("left",07,08,b0,47)},
	{::hx::fsFloat,(int)offsetof(LineGridShape_obj,top),HX_("top",95,66,58,00)},
	{::hx::fsFloat,(int)offsetof(LineGridShape_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsFloat,(int)offsetof(LineGridShape_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsFloat,(int)offsetof(LineGridShape_obj,delta),HX_("delta",f8,e7,26,d7)},
	{::hx::fsFloat,(int)offsetof(LineGridShape_obj,deltaH),HX_("deltaH",50,11,e4,6a)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *LineGridShape_obj_sStaticStorageInfo = 0;
#endif

static ::String LineGridShape_obj_sMemberFields[] = {
	HX_("left",07,08,b0,47),
	HX_("top",95,66,58,00),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("delta",f8,e7,26,d7),
	HX_("deltaH",50,11,e4,6a),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class LineGridShape_obj::__mClass;

void LineGridShape_obj::__register()
{
	LineGridShape_obj _hx_dummy;
	LineGridShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage.triangleGML.contour.LineGridShape",ca,31,3f,d0);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(LineGridShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< LineGridShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LineGridShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LineGridShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage
} // end namespace triangleGML
} // end namespace contour
