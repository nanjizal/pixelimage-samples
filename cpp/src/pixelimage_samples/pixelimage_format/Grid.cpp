// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED_format_png_Chunk
#include <format/png/Chunk.h>
#endif
#ifndef INCLUDED_format_png_Color
#include <format/png/Color.h>
#endif
#ifndef INCLUDED_format_png_Writer
#include <format/png/Writer.h>
#endif
#ifndef INCLUDED_format_tools_Deflate
#include <format/tools/Deflate.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_List
#include <haxe/ds/List.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Output
#include <haxe/io/Output.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_pixelimage_ImageStruct
#include <pixelimage/ImageStruct.h>
#endif
#ifndef INCLUDED_pixelimage__Endian_Endian_Fields_
#include <pixelimage/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pixelimage_triangleGML_coreShape_TriangleGML
#include <pixelimage/triangleGML/coreShape/TriangleGML.h>
#endif
#ifndef INCLUDED_pixelimage_samples_pixelimage_format_Grid
#include <pixelimage_samples/pixelimage_format/Grid.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif
#ifndef INCLUDED_sys_io_FileOutput
#include <sys/io/FileOutput.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_cb4ec6acc24a4683_14_new,"pixelimage_samples.pixelimage_format.Grid","new",0xaa1729f4,"pixelimage_samples.pixelimage_format.Grid.new","pixelimage_samples/pixelimage_format/Grid.hx",14,0x655227fa)
HX_LOCAL_STACK_FRAME(_hx_pos_cb4ec6acc24a4683_42_begin,"pixelimage_samples.pixelimage_format.Grid","begin",0xd4d1d0bd,"pixelimage_samples.pixelimage_format.Grid.begin","pixelimage_samples/pixelimage_format/Grid.hx",42,0x655227fa)
HX_LOCAL_STACK_FRAME(_hx_pos_cb4ec6acc24a4683_48_end,"pixelimage_samples.pixelimage_format.Grid","end",0xaa105d6f,"pixelimage_samples.pixelimage_format.Grid.end","pixelimage_samples/pixelimage_format/Grid.hx",48,0x655227fa)
namespace pixelimage_samples{
namespace pixelimage_format{

void Grid_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_cb4ec6acc24a4683_14_new)
HXLINE( 170)		this->vePathElementShape = HX_("<VePathElementShape\n                        pathData=\"M200,300 Q400,50 600,300 T1000,300,L50,50 L20,20 L100,200 C100,100 250,100 250,200S400,300 400,200\" \n                        translateX=\"0\"\n                        translateY=\"0\"\n                        strokeWidths=\"[ 10, 20, 30, 40, 50, 60, 70 ]\" \n                        strokeColors=\"[ 0xFF9400D3, 0xFF4b0082, 0xFF0000FF, 0xFF00ff00, 0xFFFFFF00, 0xFFFF7F00, 0xFFFF0000 ]\" \n                        fill=\"0xff0000ff\">\n                    </VePathElementShape>",d4,b6,c8,1d);
HXLINE( 158)		this->quadShapeLuxury = HX_("<QuadShape \n                    aX=\"500\" aY=\"300\" \n                    bX=\"530\" bY=\"220\"\n                    cX=\"700\" cY=\"120\"\n                    dX=\"900\" dY=\"500\" \n                    soft=\"90\"\n                    luxury=\"true\"\n                    strokeColor=\"0xFFFF0000\" strokeWidth=\"1\"> \n                    </QuadShape>",f9,69,0f,ac);
HXLINE( 150)		this->quadShape = HX_("<QuadShape \n                    aX=\"500\" aY=\"300\" \n                    bX=\"530\" bY=\"220\"\n                    cX=\"700\" cY=\"120\"\n                    dX=\"900\" dY=\"500\" \n                    strokeColor=\"0xFFFF0000\" strokeWidth=\"1\">\n                    </QuadShape>",f3,22,a5,3f);
HXLINE( 142)		this->quadShapeSoft = HX_("<QuadShape \n                    aX=\"500\" aY=\"300\" \n                    bX=\"530\" bY=\"220\"\n                    cX=\"700\" cY=\"120\"\n                    dX=\"900\" dY=\"500\" \n                    soft=\"90\"\n                    strokeColor=\"0xFFFF0000\" strokeWidth=\"1\"> \n                    </QuadShape>",81,e2,6d,bc);
HXLINE( 133)		this->arcChord2 = HX_("<ArcShape \n                        left=\"100\"  top=\"100\" \n                        width=\"500\" height=\"480\" \n                        strokeColor=\"0xFFFF7700\" strokeWidth=\"12\" \n                        fill=\"0xFF00A6FF\" \n                        startAngle=\"190\" sweepAngle=\"90\"\n                        arcType=\"chord\">\n                    </ArcShape>",24,49,df,bd);
HXLINE( 123)		this->arcEllipse2 = HX_("<ArcShape \n                        left=\"100\"  top=\"100\" \n                        width=\"500\" height=\"480\" \n                        strokeColor=\"0xFF0000FF\" strokeWidth=\"12\" \n                        fill=\"0xFFFF00EE\" \n                        startAngle=\"-43\" sweepAngle=\"108\"\n                        arcType=\"ellipse\">\n                    </ArcShape>",41,e3,03,aa);
HXLINE( 113)		this->arcPie2 = HX_("<ArcShape \n                        left=\"100\"  top=\"100\" \n                        width=\"500\" height=\"480\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"12\" \n                        fill=\"0xFF00FF00\" \n                        startAngle=\"120\" sweepAngle=\"70\"\n                        arcType=\"pie\">\n                    </ArcShape>",48,ea,84,5a);
HXLINE( 103)		this->arcChord = HX_("<ArcShape \n                        left=\"100\"  top=\"100\" \n                        width=\"500\" height=\"480\" \n                        strokeColor=\"0xFFFF7700\" strokeWidth=\"12\" \n                        fill=\"0xFF00A6FF\" \n                        startAngle=\"0\" sweepAngle=\"240\"\n                        arcType=\"chord\">\n                    </ArcShape>",bb,e2,46,5e);
HXLINE(  93)		this->arcEllipse = HX_("<ArcShape \n                        left=\"100\"  top=\"100\" \n                        width=\"500\" height=\"480\" \n                        strokeColor=\"0xFF0000FF\" strokeWidth=\"12\" \n                        fill=\"0xFFFF00EE\" \n                        startAngle=\"0\" sweepAngle=\"240\"\n                        arcType=\"ellipse\">\n                    </ArcShape>",f2,f7,81,23);
HXLINE(  83)		this->arcPie = HX_("<ArcShape \n                        left=\"100\"  top=\"100\" \n                        width=\"500\" height=\"480\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"12\" \n                        fill=\"0xFF00FF00\" \n                        startAngle=\"0\" sweepAngle=\"240\"\n                        arcType=\"pie\">\n                    </ArcShape>",40,b2,e5,6c);
HXLINE(  75)		this->softEllipseTest = HX_("<SoftEllipseShape \n                        left=\"500\" top=\"500\" \n                        width=\"400\" \n                        height=\"400\" \n                        strokeColor=\"0xFFFF0000\"\n                        softC=\"10\">\n                    </SoftEllipseShape>",17,98,c0,a3);
HXLINE(  68)		this->circleTest = HX_("<CircleShape \n                        left=\"200\" top=\"200\" \n                        diameter=\"300\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"10\" \n                        fill=\"0xFF00FF00\">\n                    </CircleShape>",e8,cd,e6,d8);
HXLINE(  60)		this->ellipseTest = HX_("<EllipseShape \n                        top=\"100\" \n                        width=\"200\" \n                        height=\"50\" \n                        strokeColor=\"0xFF0000\" strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\">\n                    </EllipseShape>",2e,be,26,f1);
HXLINE(  52)		this->lineGridShape = HX_("<LineGridShape\n                        left = \"100\"  top = \"100\"\n                        width = \"2048\" height = \"1536\"\n                        delta = \"100\" deltaH = \"100\"\n                        strokeColor=\"0xfF003300\" strokeWidth=\"3\">\n                    </LineGridShape>",35,a9,d8,cd);
HXLINE(  20)		this->begin();
HXLINE(  21)		::pixelimage::ImageStruct pixelShape = this->pixelImage;
HXLINE(  23)		{
HXLINE(  23)			::pixelimage::ImageStruct this1 = this->pixelImage;
HXDLIN(  23)			Float h = ( (Float)(this->pixelImage->height) );
HXDLIN(  23)			int p = 0;
HXDLIN(  23)			int xx = p;
HXDLIN(  23)			int q = 0;
HXDLIN(  23)			int maxX = ::Std_obj::_hx_int(( (Float)(this->pixelImage->width) ));
HXDLIN(  23)			int maxY = ::Std_obj::_hx_int(h);
HXDLIN(  23)			while(true){
HXLINE(  23)				{
HXLINE(  23)					p = (p + 1);
HXDLIN(  23)					int x = (p - 1);
HXDLIN(  23)					int this2 = -16777216;
HXDLIN(  23)					int c = this2;
HXDLIN(  23)					bool _hx_tmp;
HXDLIN(  23)					if ((((c >> 24) & 255) < 254)) {
HXLINE(  23)						_hx_tmp = this1->transparent;
            					}
            					else {
HXLINE(  23)						_hx_tmp = false;
            					}
HXDLIN(  23)					if (_hx_tmp) {
HXLINE(  23)						int location;
HXDLIN(  23)						if (this1->useVirtualPos) {
HXLINE(  23)							location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            						}
            						else {
HXLINE(  23)							location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            						}
HXDLIN(  23)						::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  23)						::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  23)						int pos = ((location << 2) + this2->byteOffset);
HXDLIN(  23)						int this3 = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  23)						int this4 = this3;
HXDLIN(  23)						int this5;
HXDLIN(  23)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)							this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            						}
            						else {
HXLINE(  23)							this5 = this4;
            						}
HXDLIN(  23)						Float a1;
HXDLIN(  23)						int this6 = ((this5 >> 24) & 255);
HXDLIN(  23)						if ((this6 == 0)) {
HXLINE(  23)							a1 = ((Float)0.);
            						}
            						else {
HXLINE(  23)							a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN(  23)						Float r1;
HXDLIN(  23)						int this7 = ((this5 >> 16) & 255);
HXDLIN(  23)						if ((this7 == 0)) {
HXLINE(  23)							r1 = ((Float)0.);
            						}
            						else {
HXLINE(  23)							r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN(  23)						Float g1;
HXDLIN(  23)						int this8 = ((this5 >> 8) & 255);
HXDLIN(  23)						if ((this8 == 0)) {
HXLINE(  23)							g1 = ((Float)0.);
            						}
            						else {
HXLINE(  23)							g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN(  23)						Float b1;
HXDLIN(  23)						int this9 = (this5 & 255);
HXDLIN(  23)						if ((this9 == 0)) {
HXLINE(  23)							b1 = ((Float)0.);
            						}
            						else {
HXLINE(  23)							b1 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN(  23)						Float a2;
HXDLIN(  23)						int this10 = ((-16777216 >> 24) & 255);
HXDLIN(  23)						if ((this10 == 0)) {
HXLINE(  23)							a2 = ((Float)0.);
            						}
            						else {
HXLINE(  23)							a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN(  23)						Float r2;
HXDLIN(  23)						int this11 = ((-16777216 >> 16) & 255);
HXDLIN(  23)						if ((this11 == 0)) {
HXLINE(  23)							r2 = ((Float)0.);
            						}
            						else {
HXLINE(  23)							r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN(  23)						Float g2;
HXDLIN(  23)						int this12 = ((-16777216 >> 8) & 255);
HXDLIN(  23)						if ((this12 == 0)) {
HXLINE(  23)							g2 = ((Float)0.);
            						}
            						else {
HXLINE(  23)							g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN(  23)						Float b2;
HXDLIN(  23)						int this13 = (-16777216 & 255);
HXDLIN(  23)						if ((this13 == 0)) {
HXLINE(  23)							b2 = ((Float)0.);
            						}
            						else {
HXLINE(  23)							b2 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN(  23)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  23)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  23)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  23)						int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  23)						int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  23)						int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  23)						{
HXLINE(  23)							::haxe::io::ArrayBufferViewImpl this14 = this1->image;
HXDLIN(  23)							int value;
HXDLIN(  23)							if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)								value = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE(  23)								value = blended;
            							}
HXDLIN(  23)							bool _hx_tmp;
HXDLIN(  23)							if ((location >= 0)) {
HXLINE(  23)								_hx_tmp = (location < (this14->byteLength >> 2));
            							}
            							else {
HXLINE(  23)								_hx_tmp = false;
            							}
HXDLIN(  23)							if (_hx_tmp) {
HXLINE(  23)								::haxe::io::Bytes _this = this14->bytes;
HXDLIN(  23)								int pos = ((location << 2) + this14->byteOffset);
HXDLIN(  23)								_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  23)								_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  23)								_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  23)								_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            							}
            						}
            					}
            					else {
HXLINE(  23)						::haxe::io::ArrayBufferViewImpl this2 = this1->image;
HXDLIN(  23)						int index;
HXDLIN(  23)						if (this1->useVirtualPos) {
HXLINE(  23)							index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            						}
            						else {
HXLINE(  23)							index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x)) ));
            						}
HXDLIN(  23)						int value;
HXDLIN(  23)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)							value = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            						}
            						else {
HXLINE(  23)							value = c;
            						}
HXDLIN(  23)						bool _hx_tmp;
HXDLIN(  23)						if ((index >= 0)) {
HXLINE(  23)							_hx_tmp = (index < (this2->byteLength >> 2));
            						}
            						else {
HXLINE(  23)							_hx_tmp = false;
            						}
HXDLIN(  23)						if (_hx_tmp) {
HXLINE(  23)							::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  23)							int pos = ((index << 2) + this2->byteOffset);
HXDLIN(  23)							_this->b[pos] = ( (unsigned char)(value) );
HXDLIN(  23)							_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN(  23)							_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN(  23)							_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            						}
            					}
            				}
HXDLIN(  23)				if ((p > maxX)) {
HXLINE(  23)					p = xx;
HXDLIN(  23)					q = (q + 1);
            				}
HXDLIN(  23)				if ((q > maxY)) {
HXLINE(  23)					goto _hx_goto_0;
            				}
            			}
            			_hx_goto_0:;
            		}
HXLINE(  24)		{
HXLINE(  24)			::pixelimage::ImageStruct pixelShape1 = this->pixelImage;
HXDLIN(  24)			::String str = this->lineGridShape;
HXDLIN(  24)			::haxe::Log_obj::trace(str,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  24)			::Xml xml = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  24)			::haxe::Log_obj::trace(xml,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  24)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape1,xml,((Float)0.),((Float)0.));
            		}
HXLINE(  25)		{
HXLINE(  25)			::String str1 = this->arcPie;
HXDLIN(  25)			::haxe::Log_obj::trace(str1,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  25)			::Xml xml1 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str1) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  25)			::haxe::Log_obj::trace(xml1,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  25)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape,xml1,10,0);
            		}
HXLINE(  26)		{
HXLINE(  26)			::String str2 = this->arcEllipse;
HXDLIN(  26)			::haxe::Log_obj::trace(str2,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  26)			::Xml xml2 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str2) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  26)			::haxe::Log_obj::trace(xml2,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  26)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape,xml2,10,500);
            		}
HXLINE(  27)		{
HXLINE(  27)			::String str3 = this->arcChord;
HXDLIN(  27)			::haxe::Log_obj::trace(str3,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  27)			::Xml xml3 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str3) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  27)			::haxe::Log_obj::trace(xml3,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  27)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape,xml3,10,1000);
            		}
HXLINE(  28)		{
HXLINE(  28)			::String str4 = this->arcPie2;
HXDLIN(  28)			::haxe::Log_obj::trace(str4,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  28)			::Xml xml4 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str4) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  28)			::haxe::Log_obj::trace(xml4,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  28)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape,xml4,1210,0);
            		}
HXLINE(  29)		{
HXLINE(  29)			::String str5 = this->arcEllipse2;
HXDLIN(  29)			::haxe::Log_obj::trace(str5,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  29)			::Xml xml5 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str5) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  29)			::haxe::Log_obj::trace(xml5,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  29)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape,xml5,1210,500);
            		}
HXLINE(  30)		{
HXLINE(  30)			::String str6 = this->arcChord2;
HXDLIN(  30)			::haxe::Log_obj::trace(str6,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  30)			::Xml xml6 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str6) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  30)			::haxe::Log_obj::trace(xml6,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  30)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape,xml6,1210,1000);
            		}
HXLINE(  31)		{
HXLINE(  31)			::pixelimage::ImageStruct pixelShape2 = this->pixelImage;
HXDLIN(  31)			::String str7 = this->ellipseTest;
HXDLIN(  31)			::haxe::Log_obj::trace(str7,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  31)			::Xml xml7 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str7) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  31)			::haxe::Log_obj::trace(xml7,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  31)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape2,xml7,((Float)0.),((Float)0.));
            		}
HXLINE(  32)		{
HXLINE(  32)			::pixelimage::ImageStruct pixelShape3 = this->pixelImage;
HXDLIN(  32)			::String str8 = this->circleTest;
HXDLIN(  32)			::haxe::Log_obj::trace(str8,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  32)			::Xml xml8 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str8) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  32)			::haxe::Log_obj::trace(xml8,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  32)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape3,xml8,((Float)0.),((Float)0.));
            		}
HXLINE(  33)		{
HXLINE(  33)			::pixelimage::ImageStruct pixelShape4 = this->pixelImage;
HXDLIN(  33)			::String str9 = this->softEllipseTest;
HXDLIN(  33)			::haxe::Log_obj::trace(str9,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  33)			::Xml xml9 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str9) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  33)			::haxe::Log_obj::trace(xml9,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  33)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape4,xml9,((Float)0.),((Float)0.));
            		}
HXLINE(  34)		{
HXLINE(  34)			::pixelimage::ImageStruct pixelShape5 = this->pixelImage;
HXDLIN(  34)			::String str10 = this->quadShape;
HXDLIN(  34)			::haxe::Log_obj::trace(str10,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  34)			::Xml xml10 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str10) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  34)			::haxe::Log_obj::trace(xml10,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  34)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape5,xml10,((Float)0.),((Float)0.));
            		}
HXLINE(  35)		::pixelimage::ImageStruct pixelShape6 = this->pixelImage;
HXDLIN(  35)		::String str11 = this->quadShapeSoft;
HXDLIN(  35)		::haxe::Log_obj::trace(str11,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  35)		::Xml xml11 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str11) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  35)		::haxe::Log_obj::trace(xml11,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  35)		::pixelimage::triangleGML::coreShape::TriangleGML trigml = ::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape6,xml11,340,5);
HXLINE(  36)		{
HXLINE(  36)			::pixelimage::ImageStruct pixelShape7 = this->pixelImage;
HXDLIN(  36)			::String str12 = this->quadShapeLuxury;
HXDLIN(  36)			::haxe::Log_obj::trace(str12,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  36)			::Xml xml12 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str12) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  36)			::haxe::Log_obj::trace(xml12,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  36)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape7,xml12,340,500);
            		}
HXLINE(  37)		{
HXLINE(  37)			::pixelimage::ImageStruct pixelShape8 = this->pixelImage;
HXDLIN(  37)			::String str13 = this->vePathElementShape;
HXDLIN(  37)			::haxe::Log_obj::trace(str13,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),39,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  37)			::Xml xml13 = ::Xml_obj::parse(((HX_("<node>",40,5e,28,9d) + str13) + HX_("</node>",a9,82,8c,29)))->firstElement();
HXDLIN(  37)			::haxe::Log_obj::trace(xml13,::hx::SourceInfo(HX_("pixelimage/triangleGML/coreShape/TriangleGML.hx",b8,1d,5b,c6),41,HX_("pixelimage.triangleGML.coreShape.TriangleGML",e9,4f,fd,9f),HX_("withString",77,5b,fa,fc)));
HXDLIN(  37)			::pixelimage::triangleGML::coreShape::TriangleGML_obj::__alloc( HX_CTX ,pixelShape8,xml13,((Float)0.),((Float)0.));
            		}
HXLINE(  38)		this->end();
            	}

Dynamic Grid_obj::__CreateEmpty() { return new Grid_obj; }

void *Grid_obj::_hx_vtable = 0;

Dynamic Grid_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Grid_obj > _hx_result = new Grid_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Grid_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6549c0c8;
}

void Grid_obj::begin(){
            	HX_GC_STACKFRAME(&_hx_pos_cb4ec6acc24a4683_42_begin)
HXLINE(  43)		int size = 50331648;
HXDLIN(  43)		::haxe::io::ArrayBufferViewImpl this1 = ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  43)		::haxe::io::ArrayBufferViewImpl this2 = this1;
HXDLIN(  43)		::pixelimage::ImageStruct this3 = ::pixelimage::ImageStruct_obj::__alloc( HX_CTX ,4096,3072,this2);
HXDLIN(  43)		::pixelimage::ImageStruct this4 = this3;
HXDLIN(  43)		this->pixelImage = this4;
HXLINE(  44)		this->pixelImage->transparent = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Grid_obj,begin,(void))

void Grid_obj::end(){
            	HX_GC_STACKFRAME(&_hx_pos_cb4ec6acc24a4683_48_end)
HXDLIN(  48)		::pixelimage::ImageStruct pixelShape = this->pixelImage;
HXDLIN(  48)		int level = 9;
HXDLIN(  48)		int lh = pixelShape->height;
HXDLIN(  48)		int lw = pixelShape->width;
HXDLIN(  48)		::haxe::io::Bytes rgba = ::haxe::io::Bytes_obj::alloc((((lw * lh) * 4) + lh));
HXDLIN(  48)		int w = 0;
HXDLIN(  48)		{
HXDLIN(  48)			int _g = 0;
HXDLIN(  48)			int _g1 = lh;
HXDLIN(  48)			while((_g < _g1)){
HXDLIN(  48)				_g = (_g + 1);
HXDLIN(  48)				int y = (_g - 1);
HXDLIN(  48)				{
HXDLIN(  48)					w = (w + 1);
HXDLIN(  48)					rgba->b[(w - 1)] = ( (unsigned char)(0) );
            				}
HXDLIN(  48)				{
HXDLIN(  48)					int _g1 = 0;
HXDLIN(  48)					int _g2 = lw;
HXDLIN(  48)					while((_g1 < _g2)){
HXDLIN(  48)						_g1 = (_g1 + 1);
HXDLIN(  48)						int x = (_g1 - 1);
HXDLIN(  48)						::haxe::io::ArrayBufferViewImpl this1 = pixelShape->image;
HXDLIN(  48)						int index;
HXDLIN(  48)						if (pixelShape->useVirtualPos) {
HXDLIN(  48)							index = ::Std_obj::_hx_int(((((( (Float)(y) ) - pixelShape->virtualY) * ( (Float)(pixelShape->width) )) + x) - pixelShape->virtualX));
            						}
            						else {
HXDLIN(  48)							index = ::Std_obj::_hx_int(( (Float)(((y * pixelShape->width) + x)) ));
            						}
HXDLIN(  48)						::haxe::io::Bytes _this = this1->bytes;
HXDLIN(  48)						int pos = ((index << 2) + this1->byteOffset);
HXDLIN(  48)						int c = (((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24));
HXDLIN(  48)						int v;
HXDLIN(  48)						if (::pixelimage::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  48)							v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            						}
            						else {
HXDLIN(  48)							v = c;
            						}
HXDLIN(  48)						int this2 = v;
HXDLIN(  48)						int col = this2;
HXDLIN(  48)						int a = ((col >> 24) & 255);
HXDLIN(  48)						int r = ((col >> 16) & 255);
HXDLIN(  48)						int g = ((col >> 8) & 255);
HXDLIN(  48)						int b = (col & 255);
HXDLIN(  48)						{
HXDLIN(  48)							w = (w + 1);
HXDLIN(  48)							rgba->b[(w - 1)] = ( (unsigned char)(r) );
            						}
HXDLIN(  48)						{
HXDLIN(  48)							w = (w + 1);
HXDLIN(  48)							rgba->b[(w - 1)] = ( (unsigned char)(g) );
            						}
HXDLIN(  48)						{
HXDLIN(  48)							w = (w + 1);
HXDLIN(  48)							rgba->b[(w - 1)] = ( (unsigned char)(b) );
            						}
HXDLIN(  48)						{
HXDLIN(  48)							w = (w + 1);
HXDLIN(  48)							rgba->b[(w - 1)] = ( (unsigned char)(a) );
            						}
HXDLIN(  48)						r = (r + 4);
            					}
            				}
            			}
            		}
HXDLIN(  48)		::haxe::ds::List l = ::haxe::ds::List_obj::__alloc( HX_CTX );
HXDLIN(  48)		l->add(::format::png::Chunk_obj::CHeader( ::Dynamic(::hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("width",06,b6,62,ca),pixelShape->width)
            			->setFixed(1,HX_("interlaced",91,cb,78,d9),false)
            			->setFixed(2,HX_("colbits",46,9b,c7,e6),8)
            			->setFixed(3,HX_("height",e7,07,4c,02),pixelShape->height)
            			->setFixed(4,HX_("color",63,71,5c,4a),::format::png::Color_obj::ColTrue(true)))));
HXDLIN(  48)		l->add(::format::png::Chunk_obj::CData(::format::tools::Deflate_obj::run(rgba,level)));
HXDLIN(  48)		l->add(::format::png::Chunk_obj::CEnd_dyn());
HXDLIN(  48)		::haxe::Log_obj::trace(HX_("create writer",57,5f,86,cb),::hx::SourceInfo(HX_("pixelimage/formats/Format.hx",5a,75,38,68),56,HX_("pixelimage.formats._Format.Format_Fields_",01,34,ca,a3),HX_("toPNG",ee,f1,16,14)));
HXDLIN(  48)		::String dir = ::haxe::io::Path_obj::directory(::Sys_obj::programPath());
HXDLIN(  48)		::format::png::Writer writer = ::format::png::Writer_obj::__alloc( HX_CTX ,::sys::io::File_obj::write(::haxe::io::Path_obj::join(::Array_obj< ::String >::__new(2)->init(0,dir)->init(1,(HX_("gridTest",38,a6,38,4f) + HX_(".png",3b,2d,bd,1e)))),true));
HXDLIN(  48)		writer->write(l);
HXDLIN(  48)		::haxe::Log_obj::trace(HX_("written",d7,5c,41,ab),::hx::SourceInfo(HX_("pixelimage/formats/Format.hx",5a,75,38,68),63,HX_("pixelimage.formats._Format.Format_Fields_",01,34,ca,a3),HX_("toPNG",ee,f1,16,14)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Grid_obj,end,(void))


::hx::ObjectPtr< Grid_obj > Grid_obj::__new() {
	::hx::ObjectPtr< Grid_obj > __this = new Grid_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Grid_obj > Grid_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Grid_obj *__this = (Grid_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Grid_obj), true, "pixelimage_samples.pixelimage_format.Grid"));
	*(void **)__this = Grid_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Grid_obj::Grid_obj()
{
}

void Grid_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Grid);
	HX_MARK_MEMBER_NAME(pixelImage,"pixelImage");
	HX_MARK_MEMBER_NAME(lineGridShape,"lineGridShape");
	HX_MARK_MEMBER_NAME(ellipseTest,"ellipseTest");
	HX_MARK_MEMBER_NAME(circleTest,"circleTest");
	HX_MARK_MEMBER_NAME(softEllipseTest,"softEllipseTest");
	HX_MARK_MEMBER_NAME(arcPie,"arcPie");
	HX_MARK_MEMBER_NAME(arcEllipse,"arcEllipse");
	HX_MARK_MEMBER_NAME(arcChord,"arcChord");
	HX_MARK_MEMBER_NAME(arcPie2,"arcPie2");
	HX_MARK_MEMBER_NAME(arcEllipse2,"arcEllipse2");
	HX_MARK_MEMBER_NAME(arcChord2,"arcChord2");
	HX_MARK_MEMBER_NAME(quadShapeSoft,"quadShapeSoft");
	HX_MARK_MEMBER_NAME(quadShape,"quadShape");
	HX_MARK_MEMBER_NAME(quadShapeLuxury,"quadShapeLuxury");
	HX_MARK_MEMBER_NAME(vePathElementShape,"vePathElementShape");
	HX_MARK_END_CLASS();
}

void Grid_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(pixelImage,"pixelImage");
	HX_VISIT_MEMBER_NAME(lineGridShape,"lineGridShape");
	HX_VISIT_MEMBER_NAME(ellipseTest,"ellipseTest");
	HX_VISIT_MEMBER_NAME(circleTest,"circleTest");
	HX_VISIT_MEMBER_NAME(softEllipseTest,"softEllipseTest");
	HX_VISIT_MEMBER_NAME(arcPie,"arcPie");
	HX_VISIT_MEMBER_NAME(arcEllipse,"arcEllipse");
	HX_VISIT_MEMBER_NAME(arcChord,"arcChord");
	HX_VISIT_MEMBER_NAME(arcPie2,"arcPie2");
	HX_VISIT_MEMBER_NAME(arcEllipse2,"arcEllipse2");
	HX_VISIT_MEMBER_NAME(arcChord2,"arcChord2");
	HX_VISIT_MEMBER_NAME(quadShapeSoft,"quadShapeSoft");
	HX_VISIT_MEMBER_NAME(quadShape,"quadShape");
	HX_VISIT_MEMBER_NAME(quadShapeLuxury,"quadShapeLuxury");
	HX_VISIT_MEMBER_NAME(vePathElementShape,"vePathElementShape");
}

::hx::Val Grid_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { return ::hx::Val( end_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"begin") ) { return ::hx::Val( begin_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"arcPie") ) { return ::hx::Val( arcPie ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"arcPie2") ) { return ::hx::Val( arcPie2 ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"arcChord") ) { return ::hx::Val( arcChord ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"arcChord2") ) { return ::hx::Val( arcChord2 ); }
		if (HX_FIELD_EQ(inName,"quadShape") ) { return ::hx::Val( quadShape ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"pixelImage") ) { return ::hx::Val( pixelImage ); }
		if (HX_FIELD_EQ(inName,"circleTest") ) { return ::hx::Val( circleTest ); }
		if (HX_FIELD_EQ(inName,"arcEllipse") ) { return ::hx::Val( arcEllipse ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"ellipseTest") ) { return ::hx::Val( ellipseTest ); }
		if (HX_FIELD_EQ(inName,"arcEllipse2") ) { return ::hx::Val( arcEllipse2 ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"lineGridShape") ) { return ::hx::Val( lineGridShape ); }
		if (HX_FIELD_EQ(inName,"quadShapeSoft") ) { return ::hx::Val( quadShapeSoft ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"softEllipseTest") ) { return ::hx::Val( softEllipseTest ); }
		if (HX_FIELD_EQ(inName,"quadShapeLuxury") ) { return ::hx::Val( quadShapeLuxury ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"vePathElementShape") ) { return ::hx::Val( vePathElementShape ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Grid_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"arcPie") ) { arcPie=inValue.Cast< ::String >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"arcPie2") ) { arcPie2=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"arcChord") ) { arcChord=inValue.Cast< ::String >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"arcChord2") ) { arcChord2=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"quadShape") ) { quadShape=inValue.Cast< ::String >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"pixelImage") ) { pixelImage=inValue.Cast< ::pixelimage::ImageStruct >(); return inValue; }
		if (HX_FIELD_EQ(inName,"circleTest") ) { circleTest=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"arcEllipse") ) { arcEllipse=inValue.Cast< ::String >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"ellipseTest") ) { ellipseTest=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"arcEllipse2") ) { arcEllipse2=inValue.Cast< ::String >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"lineGridShape") ) { lineGridShape=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"quadShapeSoft") ) { quadShapeSoft=inValue.Cast< ::String >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"softEllipseTest") ) { softEllipseTest=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"quadShapeLuxury") ) { quadShapeLuxury=inValue.Cast< ::String >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"vePathElementShape") ) { vePathElementShape=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Grid_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("pixelImage",f5,62,57,5c));
	outFields->push(HX_("lineGridShape",e7,57,5f,b4));
	outFields->push(HX_("ellipseTest",50,fc,6d,f6));
	outFields->push(HX_("circleTest",82,ae,ea,fc));
	outFields->push(HX_("softEllipseTest",86,2b,40,c6));
	outFields->push(HX_("arcPie",1a,51,f9,ad));
	outFields->push(HX_("arcEllipse",ac,b8,11,c3));
	outFields->push(HX_("arcChord",aa,84,ec,9e));
	outFields->push(HX_("arcPie2",d8,a5,2d,8c));
	outFields->push(HX_("arcEllipse2",06,de,6f,ec));
	outFields->push(HX_("arcChord2",48,90,07,70));
	outFields->push(HX_("quadShapeSoft",e4,a6,d9,50));
	outFields->push(HX_("quadShape",da,e8,39,0d));
	outFields->push(HX_("quadShapeLuxury",87,19,8b,2b));
	outFields->push(HX_("vePathElementShape",59,21,cc,07));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Grid_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::pixelimage::ImageStruct */ ,(int)offsetof(Grid_obj,pixelImage),HX_("pixelImage",f5,62,57,5c)},
	{::hx::fsString,(int)offsetof(Grid_obj,lineGridShape),HX_("lineGridShape",e7,57,5f,b4)},
	{::hx::fsString,(int)offsetof(Grid_obj,ellipseTest),HX_("ellipseTest",50,fc,6d,f6)},
	{::hx::fsString,(int)offsetof(Grid_obj,circleTest),HX_("circleTest",82,ae,ea,fc)},
	{::hx::fsString,(int)offsetof(Grid_obj,softEllipseTest),HX_("softEllipseTest",86,2b,40,c6)},
	{::hx::fsString,(int)offsetof(Grid_obj,arcPie),HX_("arcPie",1a,51,f9,ad)},
	{::hx::fsString,(int)offsetof(Grid_obj,arcEllipse),HX_("arcEllipse",ac,b8,11,c3)},
	{::hx::fsString,(int)offsetof(Grid_obj,arcChord),HX_("arcChord",aa,84,ec,9e)},
	{::hx::fsString,(int)offsetof(Grid_obj,arcPie2),HX_("arcPie2",d8,a5,2d,8c)},
	{::hx::fsString,(int)offsetof(Grid_obj,arcEllipse2),HX_("arcEllipse2",06,de,6f,ec)},
	{::hx::fsString,(int)offsetof(Grid_obj,arcChord2),HX_("arcChord2",48,90,07,70)},
	{::hx::fsString,(int)offsetof(Grid_obj,quadShapeSoft),HX_("quadShapeSoft",e4,a6,d9,50)},
	{::hx::fsString,(int)offsetof(Grid_obj,quadShape),HX_("quadShape",da,e8,39,0d)},
	{::hx::fsString,(int)offsetof(Grid_obj,quadShapeLuxury),HX_("quadShapeLuxury",87,19,8b,2b)},
	{::hx::fsString,(int)offsetof(Grid_obj,vePathElementShape),HX_("vePathElementShape",59,21,cc,07)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Grid_obj_sStaticStorageInfo = 0;
#endif

static ::String Grid_obj_sMemberFields[] = {
	HX_("pixelImage",f5,62,57,5c),
	HX_("begin",29,ea,55,b0),
	HX_("end",db,03,4d,00),
	HX_("lineGridShape",e7,57,5f,b4),
	HX_("ellipseTest",50,fc,6d,f6),
	HX_("circleTest",82,ae,ea,fc),
	HX_("softEllipseTest",86,2b,40,c6),
	HX_("arcPie",1a,51,f9,ad),
	HX_("arcEllipse",ac,b8,11,c3),
	HX_("arcChord",aa,84,ec,9e),
	HX_("arcPie2",d8,a5,2d,8c),
	HX_("arcEllipse2",06,de,6f,ec),
	HX_("arcChord2",48,90,07,70),
	HX_("quadShapeSoft",e4,a6,d9,50),
	HX_("quadShape",da,e8,39,0d),
	HX_("quadShapeLuxury",87,19,8b,2b),
	HX_("vePathElementShape",59,21,cc,07),
	::String(null()) };

::hx::Class Grid_obj::__mClass;

void Grid_obj::__register()
{
	Grid_obj _hx_dummy;
	Grid_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pixelimage_samples.pixelimage_format.Grid",02,60,de,a5);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Grid_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Grid_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Grid_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Grid_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pixelimage_samples
} // end namespace pixelimage_format
