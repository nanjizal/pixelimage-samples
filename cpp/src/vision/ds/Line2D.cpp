// Generated by Haxe 4.3.0-rc.1+
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_vision_ds_Line2D
#include <vision/ds/Line2D.h>
#endif
#ifndef INCLUDED_vision_ds_Point2D
#include <vision/ds/Point2D.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_8_new,"vision.ds.Line2D","new",0x658a4851,"vision.ds.Line2D.new","vision/ds/Line2D.hx",8,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_67_toString,"vision.ds.Line2D","toString",0x036aef1b,"vision.ds.Line2D.toString","vision/ds/Line2D.hx",67,0xa053e19f)
namespace vision{
namespace ds{

void Line2D_obj::__construct(::vision::ds::Point2D start,::vision::ds::Point2D end){
            	HX_GC_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_8_new)
HXLINE(  38)		this->end = ::vision::ds::Point2D_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ));
HXLINE(  33)		this->start = ::vision::ds::Point2D_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ));
HXLINE(  49)		this->start->x = start->x;
HXLINE(  50)		this->start->y = start->y;
HXLINE(  51)		this->end->x = end->x;
HXLINE(  52)		this->end->y = end->y;
HXLINE(  53)		Float x = (end->x - start->x);
HXDLIN(  53)		Float y = (end->y - start->y);
HXDLIN(  53)		this->radians = ::Math_obj::atan2(x,y);
HXLINE(  54)		this->slope = ::Math_obj::tan(this->radians);
HXLINE(  55)		this->degrees = ((this->radians * ( (Float)(180) )) / ::Math_obj::PI);
            	}

Dynamic Line2D_obj::__CreateEmpty() { return new Line2D_obj; }

void *Line2D_obj::_hx_vtable = 0;

Dynamic Line2D_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Line2D_obj > _hx_result = new Line2D_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Line2D_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6048be01;
}

::String Line2D_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_67_toString)
HXDLIN(  67)		::String _hx_tmp = ((HX_("\n (",92,b2,07,00) + ::Std_obj::string(this->start)) + HX_(".x, ",7e,05,c3,1e));
HXDLIN(  67)		::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string(this->start)) + HX_(".y) --> (",04,3c,8a,6b));
HXDLIN(  67)		::String _hx_tmp2 = ((_hx_tmp1 + ::Std_obj::string(this->end)) + HX_(".x, ",7e,05,c3,1e));
HXDLIN(  67)		return ((_hx_tmp2 + ::Std_obj::string(this->end)) + HX_(".y)",3e,51,23,00));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Line2D_obj,toString,return )


::hx::ObjectPtr< Line2D_obj > Line2D_obj::__new(::vision::ds::Point2D start,::vision::ds::Point2D end) {
	::hx::ObjectPtr< Line2D_obj > __this = new Line2D_obj();
	__this->__construct(start,end);
	return __this;
}

::hx::ObjectPtr< Line2D_obj > Line2D_obj::__alloc(::hx::Ctx *_hx_ctx,::vision::ds::Point2D start,::vision::ds::Point2D end) {
	Line2D_obj *__this = (Line2D_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Line2D_obj), true, "vision.ds.Line2D"));
	*(void **)__this = Line2D_obj::_hx_vtable;
	__this->__construct(start,end);
	return __this;
}

Line2D_obj::Line2D_obj()
{
}

void Line2D_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Line2D);
	HX_MARK_MEMBER_NAME(slope,"slope");
	HX_MARK_MEMBER_NAME(degrees,"degrees");
	HX_MARK_MEMBER_NAME(radians,"radians");
	HX_MARK_MEMBER_NAME(start,"start");
	HX_MARK_MEMBER_NAME(end,"end");
	HX_MARK_END_CLASS();
}

void Line2D_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(slope,"slope");
	HX_VISIT_MEMBER_NAME(degrees,"degrees");
	HX_VISIT_MEMBER_NAME(radians,"radians");
	HX_VISIT_MEMBER_NAME(start,"start");
	HX_VISIT_MEMBER_NAME(end,"end");
}

::hx::Val Line2D_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { return ::hx::Val( end ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"slope") ) { return ::hx::Val( slope ); }
		if (HX_FIELD_EQ(inName,"start") ) { return ::hx::Val( start ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"degrees") ) { return ::hx::Val( degrees ); }
		if (HX_FIELD_EQ(inName,"radians") ) { return ::hx::Val( radians ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"toString") ) { return ::hx::Val( toString_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Line2D_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { end=inValue.Cast< ::vision::ds::Point2D >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"slope") ) { slope=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"start") ) { start=inValue.Cast< ::vision::ds::Point2D >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"degrees") ) { degrees=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"radians") ) { radians=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Line2D_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("slope",2b,5d,cc,7e));
	outFields->push(HX_("degrees",a7,e3,5a,3a));
	outFields->push(HX_("radians",72,46,f0,26));
	outFields->push(HX_("start",62,74,0b,84));
	outFields->push(HX_("end",db,03,4d,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Line2D_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Line2D_obj,slope),HX_("slope",2b,5d,cc,7e)},
	{::hx::fsFloat,(int)offsetof(Line2D_obj,degrees),HX_("degrees",a7,e3,5a,3a)},
	{::hx::fsFloat,(int)offsetof(Line2D_obj,radians),HX_("radians",72,46,f0,26)},
	{::hx::fsObject /* ::vision::ds::Point2D */ ,(int)offsetof(Line2D_obj,start),HX_("start",62,74,0b,84)},
	{::hx::fsObject /* ::vision::ds::Point2D */ ,(int)offsetof(Line2D_obj,end),HX_("end",db,03,4d,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Line2D_obj_sStaticStorageInfo = 0;
#endif

static ::String Line2D_obj_sMemberFields[] = {
	HX_("slope",2b,5d,cc,7e),
	HX_("degrees",a7,e3,5a,3a),
	HX_("radians",72,46,f0,26),
	HX_("start",62,74,0b,84),
	HX_("end",db,03,4d,00),
	HX_("toString",ac,d0,6e,38),
	::String(null()) };

::hx::Class Line2D_obj::__mClass;

void Line2D_obj::__register()
{
	Line2D_obj _hx_dummy;
	Line2D_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("vision.ds.Line2D",df,cb,31,1c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Line2D_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Line2D_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Line2D_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Line2D_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace vision
} // end namespace ds
