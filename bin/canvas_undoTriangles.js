// Generated by Haxe 4.3.0-rc.1+
(function ($global) { "use strict";
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var htmlHelper_canvas_CanvasSetup = function() {
	this.factor = 4.;
	this.divertTrace = new htmlHelper_tools_DivertTrace();
	var e = null;
	var this1;
	if(e == null) {
		var canvas = window.document.createElement("canvas");
		var dom = canvas;
		var style = dom.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = "0px";
		style.top = "0px";
		style.position = "absolute";
		this1 = canvas;
	} else {
		this1 = e;
	}
	this.canvasWrapper = this1;
	this.canvasWrapper.width = 1024;
	this.canvasWrapper.height = 768;
	var dom = this.canvasWrapper;
	var style = dom.style;
	style.background = "black";
	window.document.body.appendChild(this.canvasWrapper);
	var this1 = new htmlHelper_canvas_CanvasPlus(this.canvasWrapper.getContext("2d",null),10,10);
	this1.me.lineWidth = 1;
	var tmp = StringTools.hex(16744272,6);
	this1.me.strokeStyle = "#" + tmp;
	this.surface = this1;
	this.overSampleCanvas();
};
htmlHelper_canvas_CanvasSetup.__name__ = true;
htmlHelper_canvas_CanvasSetup.prototype = {
	overSampleCanvas: function() {
		var ctx = this.surface.me;
		var canvas = this.canvasWrapper;
		var width = canvas.width;
		var height = canvas.height;
		canvas.width = 0 | (width * this.factor | 0);
		canvas.height = 0 | (height * this.factor | 0);
		var dom = this.canvasWrapper;
		var style = dom.style;
		style.width = width + "px";
		style.height = height + "px";
		ctx.scale(this.factor,this.factor);
	}
};
var htmlHelper_canvas_CanvasPlus = function(me,x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
	this.me = me;
};
htmlHelper_canvas_CanvasPlus.__name__ = true;
var htmlHelper_tools_DivertTrace = function(left,d) {
	if(left == null) {
		left = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	this.divertTrace(left,d);
};
htmlHelper_tools_DivertTrace.__name__ = true;
htmlHelper_tools_DivertTrace.prototype = {
	divertTrace: function(left,d) {
		if(d == null) {
			var doc = window.document;
			this.traceDiv = doc.createElement("div");
			doc.body.appendChild(this.traceDiv);
			var dom = this.traceDiv;
			var style = dom.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = (left == null ? "null" : "" + left) + "px";
			style.height = "500px";
			style.width = "500px";
			style.zIndex = "99";
			style.overflow = "auto";
		} else {
			this.traceDiv = d;
		}
		haxe_Log.trace = $bind(this,this.myTrace);
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var pixelimage_ImageStruct = function(width,height,image) {
	this.useMask = false;
	this.useVirtualPos = false;
	this.virtualY = 0;
	this.virtualX = 0;
	this.transparent = false;
	this.width = width;
	this.height = height;
	this.image = image;
	this.isLittle = pixelimage_Endian_isLittleEndian;
	this.transparent = false;
};
pixelimage_ImageStruct.__name__ = true;
var pixelimage_algo_HitTri = function(ax,ay,bx,by,cx,cy,preCalculated) {
	if(preCalculated == null) {
		preCalculated = true;
	}
	this.undoImage = null;
	var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	this.ax = ax;
	this.ay = ay;
	this.bx = bx;
	this.by = by;
	this.cx = cx;
	this.cy = cy;
	this.preCalculated = preCalculated;
	if(preCalculated) {
		this.s0 = this.ay * this.cx - this.ax * this.cy;
		this.sx = this.cy - this.ay;
		this.sy = this.ax - this.cx;
		this.t0 = this.ax * this.by - this.ay * this.bx;
		this.tx = this.ay - this.by;
		this.ty = this.bx - this.ax;
		this.A = -this.by * this.cx + this.ay * (-this.bx + this.cx) + this.ax * (this.by - this.cy) + this.bx * this.cy;
		var a = this.ax;
		var b = this.bx;
		var c = this.cx;
		var tmp;
		if(a > b) {
			if(a > c) {
				var ii_min = b > c ? Math.floor(c) : Math.floor(b);
				var ii_max = Math.ceil(a);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			} else {
				var ii_min = Math.floor(b);
				var ii_max = Math.ceil(c);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			}
		} else if(b > c) {
			var ii_min = a > c ? Math.floor(c) : Math.ceil(a);
			var ii_max = Math.ceil(b);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		} else {
			var ii_min = Math.floor(a);
			var ii_max = Math.ceil(c);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		}
		this.xIter3 = tmp;
		var a = this.ay;
		var b = this.by;
		var c = this.cy;
		var tmp;
		if(a > b) {
			if(a > c) {
				var ii_min = b > c ? Math.floor(c) : Math.floor(b);
				var ii_max = Math.ceil(a);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			} else {
				var ii_min = Math.floor(b);
				var ii_max = Math.ceil(c);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			}
		} else if(b > c) {
			var ii_min = a > c ? Math.floor(c) : Math.ceil(a);
			var ii_max = Math.ceil(b);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		} else {
			var ii_min = Math.floor(a);
			var ii_max = Math.ceil(c);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		}
		this.yIter3 = tmp;
	}
};
pixelimage_algo_HitTri.__name__ = true;
var pixelimage_iter_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
pixelimage_iter_IntIterStart.__name__ = true;
var pixelimage_$samples_pixelimage_$canvas_UndoTriangles = function() {
	this.canvasSetup = new htmlHelper_canvas_CanvasSetup();
	this.begin();
	this.drawGrid();
	var hits = this.drawAlphaTrianglePink(this.pixelImage);
	var hit4 = hits[4];
	var hit3 = hits[3];
	this.pixelImage.transparent = false;
	var _g = 0;
	var _g1 = hit3.undoImage.height;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g3 = hit3.undoImage.width;
		while(_g2 < _g3) {
			var x = _g2++;
			var x1 = x + hit3.undoX;
			var y1 = y + hit3.undoY;
			var tmp;
			var tmp1;
			var this1 = hit3.xIter3;
			if(x1 > this1.start - 1 && x1 < this1.max + 1) {
				var this2 = hit3.yIter3;
				tmp1 = y1 > this2.start - 1 && y1 < this2.max + 1;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var s = hit3.s0 + hit3.sx * x1 + hit3.sy * y1;
				var t = hit3.t0 + hit3.tx * x1 + hit3.ty * y1;
				tmp = s <= 0 || t <= 0 ? false : s + t < hit3.A;
			} else {
				tmp = false;
			}
			if(tmp) {
				var this3 = hit3.undoImage;
				var c = this3.image[this3.useVirtualPos ? (y - this3.virtualY) * this3.width + x - this3.virtualX | 0 : y * this3.width + x | 0];
				var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(col != 0) {
					var this4 = this.pixelImage;
					var x2 = x + hit3.undoX;
					var y2 = y + hit3.undoY;
					var this5 = col;
					var c1 = this5;
					if((c1 >> 24 & 255) < 254 && this4.transparent) {
						var location = this4.useVirtualPos ? (y2 - this4.virtualY) * this4.width + x2 - this4.virtualX | 0 : y2 * this4.width + x2 | 0;
						var this6 = this4.image[location];
						var this7 = this6;
						var this8 = pixelimage_Endian_isLittleEndian ? (this7 >> 24 & 255) << 24 | (this7 & 255) << 16 | (this7 >> 8 & 255) << 8 | this7 >> 16 & 255 : this7;
						var this9 = this8 >> 24 & 255;
						var a1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = this8 >> 16 & 255;
						var r1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = this8 >> 8 & 255;
						var g1 = this11 == 0 ? 0. : this11 / 255;
						var this12 = this8 & 255;
						var b1 = this12 == 0 ? 0. : this12 / 255;
						var this13 = col >> 24 & 255;
						var a2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = col >> 16 & 255;
						var r2 = this14 == 0 ? 0. : this14 / 255;
						var this15 = col >> 8 & 255;
						var g2 = this15 == 0 ? 0. : this15 / 255;
						var this16 = col & 255;
						var b2 = this16 == 0 ? 0. : this16 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						this4.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						this4.image[this4.useVirtualPos ? (y2 - this4.virtualY) * this4.width + x2 - this4.virtualX | 0 : y2 * this4.width + x2 | 0] = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					}
					this.pixelImage.transparent = true;
					var x3 = x + hit3.undoX;
					var y3 = y + hit3.undoY;
					var tmp2;
					var tmp3;
					var this17 = hit4.xIter3;
					if(x3 > this17.start - 1 && x3 < this17.max + 1) {
						var this18 = hit4.yIter3;
						tmp3 = y3 > this18.start - 1 && y3 < this18.max + 1;
					} else {
						tmp3 = false;
					}
					if(tmp3) {
						var s1 = hit4.s0 + hit4.sx * x3 + hit4.sy * y3;
						var t1 = hit4.t0 + hit4.tx * x3 + hit4.ty * y3;
						tmp2 = s1 <= 0 || t1 <= 0 ? false : s1 + t1 < hit4.A;
					} else {
						tmp2 = false;
					}
					if(tmp2) {
						var this19 = this.pixelImage;
						var x4 = x + hit3.undoX;
						var y4 = y + hit3.undoY;
						var this20 = -286261056;
						var c2 = this20;
						if((c2 >> 24 & 255) < 254 && this19.transparent) {
							var location1 = this19.useVirtualPos ? (y4 - this19.virtualY) * this19.width + x4 - this19.virtualX | 0 : y4 * this19.width + x4 | 0;
							var this21 = this19.image[location1];
							var this22 = this21;
							var this23 = pixelimage_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
							var this24 = this23 >> 24 & 255;
							var a11 = this24 == 0 ? 0. : this24 / 255;
							var this25 = this23 >> 16 & 255;
							var r11 = this25 == 0 ? 0. : this25 / 255;
							var this26 = this23 >> 8 & 255;
							var g11 = this26 == 0 ? 0. : this26 / 255;
							var this27 = this23 & 255;
							var b11 = this27 == 0 ? 0. : this27 / 255;
							var this28 = 238;
							var a21 = this28 == 0 ? 0. : this28 / 255;
							var this29 = 240;
							var r21 = this29 == 0 ? 0. : this29 / 255;
							var this30 = 0;
							var g21 = this30 == 0 ? 0. : this30 / 255;
							var this31 = 192;
							var b21 = this31 == 0 ? 0. : this31 / 255;
							var a31 = a11 * (1 - a21);
							var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
							var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
							var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
							var a4 = 255 * (a31 + a21) | 0;
							var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							this19.image[location1] = pixelimage_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
						} else {
							this19.image[this19.useVirtualPos ? (y4 - this19.virtualY) * this19.width + x4 - this19.virtualX | 0 : y4 * this19.width + x4 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
					this.pixelImage.transparent = false;
				} else {
					var this32 = this.pixelImage;
					var x5 = x + hit3.undoX;
					var y5 = y + hit3.undoY;
					this32.image[this32.useVirtualPos ? (y5 - this32.virtualY) * this32.width + x5 - this32.virtualX | 0 : y5 * this32.width + x5 | 0] = 0;
					this.pixelImage.transparent = true;
					var x6 = x + hit3.undoX;
					var y6 = y + hit3.undoY;
					var tmp4;
					var tmp5;
					var this33 = hit4.xIter3;
					if(x6 > this33.start - 1 && x6 < this33.max + 1) {
						var this34 = hit4.yIter3;
						tmp5 = y6 > this34.start - 1 && y6 < this34.max + 1;
					} else {
						tmp5 = false;
					}
					if(tmp5) {
						var s2 = hit4.s0 + hit4.sx * x6 + hit4.sy * y6;
						var t2 = hit4.t0 + hit4.tx * x6 + hit4.ty * y6;
						tmp4 = s2 <= 0 || t2 <= 0 ? false : s2 + t2 < hit4.A;
					} else {
						tmp4 = false;
					}
					if(tmp4) {
						var this35 = this.pixelImage;
						var x7 = x + hit3.undoX;
						var y7 = y + hit3.undoY;
						var this36 = -286261056;
						var c3 = this36;
						if((c3 >> 24 & 255) < 254 && this35.transparent) {
							var location2 = this35.useVirtualPos ? (y7 - this35.virtualY) * this35.width + x7 - this35.virtualX | 0 : y7 * this35.width + x7 | 0;
							var this37 = this35.image[location2];
							var this38 = this37;
							var this39 = pixelimage_Endian_isLittleEndian ? (this38 >> 24 & 255) << 24 | (this38 & 255) << 16 | (this38 >> 8 & 255) << 8 | this38 >> 16 & 255 : this38;
							var this40 = this39 >> 24 & 255;
							var a12 = this40 == 0 ? 0. : this40 / 255;
							var this41 = this39 >> 16 & 255;
							var r12 = this41 == 0 ? 0. : this41 / 255;
							var this42 = this39 >> 8 & 255;
							var g12 = this42 == 0 ? 0. : this42 / 255;
							var this43 = this39 & 255;
							var b12 = this43 == 0 ? 0. : this43 / 255;
							var this44 = 238;
							var a22 = this44 == 0 ? 0. : this44 / 255;
							var this45 = 240;
							var r22 = this45 == 0 ? 0. : this45 / 255;
							var this46 = 0;
							var g22 = this46 == 0 ? 0. : this46 / 255;
							var this47 = 192;
							var b22 = this47 == 0 ? 0. : this47 / 255;
							var a32 = a12 * (1 - a22);
							var r4 = 255 * (r12 * a32 + r22 * a22) | 0;
							var g4 = 255 * (g12 * a32 + g22 * a22) | 0;
							var b4 = 255 * (b12 * a32 + b22 * a22) | 0;
							var a5 = 255 * (a32 + a22) | 0;
							var blended2 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
							this35.image[location2] = pixelimage_Endian_isLittleEndian ? (blended2 >> 24 & 255) << 24 | (blended2 & 255) << 16 | (blended2 >> 8 & 255) << 8 | blended2 >> 16 & 255 : blended2;
						} else {
							this35.image[this35.useVirtualPos ? (y7 - this35.virtualY) * this35.width + x7 - this35.virtualX | 0 : y7 * this35.width + x7 | 0] = pixelimage_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
						}
					}
					this.pixelImage.transparent = false;
				}
			}
		}
	}
	this.pixelImage.transparent = true;
	var hits = this.drawAlphaTriangleCyan(this.pixelImage);
	var hit4 = hits[4];
	var hit3 = hits[3];
	this.pixelImage.transparent = false;
	var this1 = this.pixelImage;
	var pixelImage = hit4.undoImage;
	var x = hit4.undoX;
	var y = hit4.undoY;
	var useAvaliableMask = false;
	var forceClear = true;
	if(forceClear == null) {
		forceClear = false;
	}
	if(useAvaliableMask == null) {
		useAvaliableMask = true;
	}
	var _g = 0;
	var _g1 = pixelImage.height;
	while(_g < _g1) {
		var dy = _g++;
		var _g2 = 0;
		var _g3 = pixelImage.width;
		while(_g2 < _g3) {
			var dx = _g2++;
			var c = pixelImage.image[pixelImage.useVirtualPos ? (dy - pixelImage.virtualY) * pixelImage.width + dx - pixelImage.virtualX | 0 : dy * pixelImage.width + dx | 0];
			var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
			if(pixelImage.useMask && useAvaliableMask && pixelImage.mask != null) {
				var this2 = pixelImage.mask;
				var c1 = this2.image[this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0];
				var this3 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
				var maskPixel = this3;
				var this4 = col;
				var this5 = this4;
				if(maskPixel == 0) {
					var this6 = this5;
					col = this6;
				} else {
					var this7 = maskPixel >> 24 & 255;
					var m0 = this7 == 0 ? 0. : this7 / 255;
					var this8 = maskPixel >> 16 & 255;
					var m1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = maskPixel >> 8 & 255;
					var m2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = maskPixel & 255;
					var m3 = this10 == 0 ? 0. : this10 / 255;
					var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
					var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
					var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
					var ch3 = (1. - m3) * (this5 & 255) | 0;
					col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
				}
			}
			if(col != 0) {
				var x1 = x + dx;
				var y1 = y + dy;
				var this11 = col;
				var c2 = this11;
				if((c2 >> 24 & 255) < 254 && this1.transparent) {
					var location = this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0;
					var this12 = this1.image[location];
					var this13 = this12;
					var this14 = pixelimage_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
					var this15 = this14 >> 24 & 255;
					var a1 = this15 == 0 ? 0. : this15 / 255;
					var this16 = this14 >> 16 & 255;
					var r1 = this16 == 0 ? 0. : this16 / 255;
					var this17 = this14 >> 8 & 255;
					var g1 = this17 == 0 ? 0. : this17 / 255;
					var this18 = this14 & 255;
					var b1 = this18 == 0 ? 0. : this18 / 255;
					var this19 = col >> 24 & 255;
					var a2 = this19 == 0 ? 0. : this19 / 255;
					var this20 = col >> 16 & 255;
					var r2 = this20 == 0 ? 0. : this20 / 255;
					var this21 = col >> 8 & 255;
					var g2 = this21 == 0 ? 0. : this21 / 255;
					var this22 = col & 255;
					var b2 = this22 == 0 ? 0. : this22 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this1.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					this1.image[this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				}
			} else if(forceClear) {
				var x2 = x + dx;
				var y2 = y + dy;
				this1.image[this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : y2 * this1.width + x2 | 0] = 0;
			}
		}
	}
	var this1 = this.pixelImage;
	var pixelImage = hit3.undoImage;
	var x = hit3.undoX;
	var y = hit3.undoY;
	var useAvaliableMask = false;
	var forceClear = true;
	if(forceClear == null) {
		forceClear = false;
	}
	if(useAvaliableMask == null) {
		useAvaliableMask = true;
	}
	var _g = 0;
	var _g1 = pixelImage.height;
	while(_g < _g1) {
		var dy = _g++;
		var _g2 = 0;
		var _g3 = pixelImage.width;
		while(_g2 < _g3) {
			var dx = _g2++;
			var c = pixelImage.image[pixelImage.useVirtualPos ? (dy - pixelImage.virtualY) * pixelImage.width + dx - pixelImage.virtualX | 0 : dy * pixelImage.width + dx | 0];
			var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
			if(pixelImage.useMask && useAvaliableMask && pixelImage.mask != null) {
				var this2 = pixelImage.mask;
				var c1 = this2.image[this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0];
				var this3 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
				var maskPixel = this3;
				var this4 = col;
				var this5 = this4;
				if(maskPixel == 0) {
					var this6 = this5;
					col = this6;
				} else {
					var this7 = maskPixel >> 24 & 255;
					var m0 = this7 == 0 ? 0. : this7 / 255;
					var this8 = maskPixel >> 16 & 255;
					var m1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = maskPixel >> 8 & 255;
					var m2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = maskPixel & 255;
					var m3 = this10 == 0 ? 0. : this10 / 255;
					var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
					var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
					var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
					var ch3 = (1. - m3) * (this5 & 255) | 0;
					col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
				}
			}
			if(col != 0) {
				var x1 = x + dx;
				var y1 = y + dy;
				var this11 = col;
				var c2 = this11;
				if((c2 >> 24 & 255) < 254 && this1.transparent) {
					var location = this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0;
					var this12 = this1.image[location];
					var this13 = this12;
					var this14 = pixelimage_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
					var this15 = this14 >> 24 & 255;
					var a1 = this15 == 0 ? 0. : this15 / 255;
					var this16 = this14 >> 16 & 255;
					var r1 = this16 == 0 ? 0. : this16 / 255;
					var this17 = this14 >> 8 & 255;
					var g1 = this17 == 0 ? 0. : this17 / 255;
					var this18 = this14 & 255;
					var b1 = this18 == 0 ? 0. : this18 / 255;
					var this19 = col >> 24 & 255;
					var a2 = this19 == 0 ? 0. : this19 / 255;
					var this20 = col >> 16 & 255;
					var r2 = this20 == 0 ? 0. : this20 / 255;
					var this21 = col >> 8 & 255;
					var g2 = this21 == 0 ? 0. : this21 / 255;
					var this22 = col & 255;
					var b2 = this22 == 0 ? 0. : this22 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this1.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					this1.image[this1.useVirtualPos ? (y1 - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : y1 * this1.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				}
			} else if(forceClear) {
				var x2 = x + dx;
				var y2 = y + dy;
				this1.image[this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : y2 * this1.width + x2 | 0] = 0;
			}
		}
	}
	this.pixelImage.transparent = true;
	var gap = 800;
	var this1 = this.pixelImage;
	var ax = 100 + gap;
	var hasHit = true;
	var hasUndo = true;
	if(hasUndo == null) {
		hasUndo = false;
	}
	if(hasHit == null) {
		hasHit = false;
	}
	var bx = 300 + gap;
	var by = 800;
	var cx = 500 + gap;
	var cy = 600;
	var hasHit1 = hasHit;
	var hasUndo1 = hasUndo;
	if(hasUndo1 == null) {
		hasUndo1 = false;
	}
	if(hasHit1 == null) {
		hasHit1 = false;
	}
	var adjustWinding = ax * by - bx * 500 + (bx * cy - cx * by) + (cx * 500 - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	var hasHit = hasHit1;
	var hasUndo = hasUndo1;
	if(hasUndo == null) {
		hasUndo = false;
	}
	if(hasHit == null) {
		hasHit = false;
	}
	var s0 = 500 * cx - ax * cy;
	var sx = cy - 500;
	var sy = ax - cx;
	var t0 = ax * by - 500 * bx;
	var tx = 500 - by;
	var ty = bx - ax;
	var A = -by * cx + 500 * (-bx + cx) + ax * (by - cy) + bx * cy;
	var xIter3;
	if(ax > bx) {
		if(ax > cx) {
			var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
			var ii_max = Math.ceil(ax);
			var this2 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		} else {
			var ii_min = Math.floor(bx);
			var ii_max = Math.ceil(cx);
			var this2 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this2;
		}
	} else if(bx > cx) {
		var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
		var ii_max = Math.ceil(bx);
		var this2 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
		xIter3 = this2;
	} else {
		var ii_min = Math.floor(ax);
		var ii_max = Math.ceil(cx);
		var this2 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
		xIter3 = this2;
	}
	var yIter3;
	if(500 > by) {
		if(500 > cy) {
			var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
			var ii_max = Math.ceil(500);
			var this2 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		} else {
			var ii_min = Math.floor(by);
			var ii_max = Math.ceil(cy);
			var this2 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this2;
		}
	} else if(by > cy) {
		var ii_min = 500 > cy ? Math.floor(cy) : Math.ceil(500);
		var ii_max = Math.ceil(by);
		var this2 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
		yIter3 = this2;
	} else {
		var ii_min = Math.floor(500);
		var ii_max = Math.ceil(cy);
		var this2 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
		yIter3 = this2;
	}
	var undoImage = null;
	if(hasUndo) {
		var w = xIter3.max - xIter3.start + 1;
		var h = yIter3.max - yIter3.start + 1;
		var this2 = new Uint32Array(w * h | 0);
		var this3 = new pixelimage_ImageStruct(w,h,this2);
		undoImage = this3;
		var rectLeft = xIter3.start;
		var rectTop = yIter3.start;
		var rectRight = xIter3.max;
		var _g = rectTop;
		var _g1 = yIter3.max;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = rectLeft;
			var _g3 = rectRight;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
				var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(this1.useMask && this1.mask != null) {
					var this2 = this1.mask;
					var c1 = this2.image[this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0];
					var this3 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this3;
					var this4 = col;
					var this5 = this4;
					if(maskPixel == 0) {
						var this6 = this5;
						col = this6;
					} else {
						var this7 = maskPixel >> 24 & 255;
						var m0 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 16 & 255;
						var m1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel >> 8 & 255;
						var m2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = maskPixel & 255;
						var m3 = this10 == 0 ? 0. : this10 / 255;
						var ch0 = (1. - m0) * (this5 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this5 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this5 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this5 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x = dx - rectLeft;
					var y = dy - rectTop;
					var this11 = col;
					var c2 = this11;
					if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
						var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
						var this12 = undoImage.image[location];
						var this13 = this12;
						var this14 = pixelimage_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
						var this15 = this14 >> 24 & 255;
						var a1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this14 >> 16 & 255;
						var r1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this14 >> 8 & 255;
						var g1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = this14 & 255;
						var b1 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 24 & 255;
						var a2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 16 & 255;
						var r2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col >> 8 & 255;
						var g2 = this21 == 0 ? 0. : this21 / 255;
						var this22 = col & 255;
						var b2 = this22 == 0 ? 0. : this22 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
				}
			}
		}
	}
	var found = false;
	var s = 0.;
	var t = 0.;
	var sxx = 0.;
	var txx = 0.;
	var _g_min = xIter3.start;
	var _g_max = xIter3.max;
	while(_g_min < _g_max) {
		var x = _g_min++;
		sxx = sx * x;
		txx = tx * x;
		found = false;
		var _g_min1 = yIter3.start;
		var _g_max1 = yIter3.max;
		while(_g_min1 < _g_max1) {
			var y = _g_min1++;
			s = s0 + sxx + sy * y;
			t = t0 + txx + ty * y;
			if(s <= 0 || t <= 0) {
				if(found) {
					break;
				}
			} else if(s + t < A) {
				var this2 = -301940496;
				var c = this2;
				if((c >> 24 & 255) < 254 && this1.transparent) {
					var location = this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0;
					var this3 = this1.image[location];
					var this4 = this3;
					var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
					var this6 = this5 >> 24 & 255;
					var a1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this5 >> 16 & 255;
					var r1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this5 >> 8 & 255;
					var g1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this5 & 255;
					var b1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 238;
					var a2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var r2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 192;
					var g2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 240;
					var b2 = this13 == 0 ? 0. : this13 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this1.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					this1.image[this1.useVirtualPos ? (y - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y * this1.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				found = true;
			} else if(found) {
				break;
			}
		}
	}
	if(hasHit == true) {
		var v = new pixelimage_algo_HitTri(ax,500,bx,by,cx,cy,true);
		if(hasUndo) {
			v.undoImage = undoImage;
			v.undoX = xIter3.start;
			v.undoY = yIter3.start;
		}
	}
	this.end();
};
pixelimage_$samples_pixelimage_$canvas_UndoTriangles.__name__ = true;
pixelimage_$samples_pixelimage_$canvas_UndoTriangles.prototype = {
	begin: function() {
		this.surface = this.canvasSetup.surface;
		var this1 = new Uint32Array(12582912);
		var this2 = new pixelimage_ImageStruct(4096,3072,this1);
		var this1 = this2;
		this.pixelImage = this1;
		this.pixelImage.transparent = true;
	}
	,end: function() {
		var this1 = this.pixelImage;
		var ctx = this.surface.me;
		if(this1.useMask && this1.mask != null) {
			var w = this1.width;
			var h = this1.height;
			var this2 = new Uint32Array(w * h | 0);
			var this3 = new pixelimage_ImageStruct(w,h,this2);
			var temp = this3;
			var _g = 0;
			var _g1 = this1.image.length;
			while(_g < _g1) {
				var i = _g++;
				var this2 = this1.image[i];
				var p0 = this2;
				var this3 = this1.mask.image[i];
				var m1 = this3;
				var value;
				if(m1 == 0) {
					var this4 = p0;
					value = this4;
				} else {
					var this5 = m1 >> 24 & 255;
					var m0 = this5 == 0 ? 0. : this5 / 255;
					var this6 = m1 >> 16 & 255;
					var m11 = this6 == 0 ? 0. : this6 / 255;
					var this7 = m1 >> 8 & 255;
					var m2 = this7 == 0 ? 0. : this7 / 255;
					var this8 = m1 & 255;
					var m3 = this8 == 0 ? 0. : this8 / 255;
					var ch0 = (1. - m0) * (p0 >> 24 & 255) | 0;
					var ch1 = (1. - m11) * (p0 >> 16 & 255) | 0;
					var ch2 = (1. - m2) * (p0 >> 8 & 255) | 0;
					var ch3 = (1. - m3) * (p0 & 255) | 0;
					value = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
				}
				temp.image[i] = value;
			}
			var dataimg = temp.image;
			var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
			var imageData = new ImageData(data,this1.width,this1.height);
			if(this1.useVirtualPos) {
				ctx.putImageData(imageData,0 - this1.virtualX,0 - this1.virtualY);
			} else {
				ctx.putImageData(imageData,0,0);
			}
		} else {
			var dataimg = this1.image;
			var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
			var imageData = new ImageData(data,this1.width,this1.height);
			if(this1.useVirtualPos) {
				ctx.putImageData(imageData,0 - this1.virtualX,0 - this1.virtualY);
			} else {
				ctx.putImageData(imageData,0,0);
			}
		}
	}
	,drawGrid: function() {
		var this1 = this.pixelImage;
		var h_ = 2300;
		var w_ = 3000;
		var _g = 0;
		var _g1 = 31;
		while(_g < _g1) {
			var i = _g++;
			var x = 100 + i * 100 - 1.25;
			var p = x | 0;
			var xx = p;
			var q = 100;
			var maxX = x + 2.5 | 0;
			var maxY = 100 + h_ | 0;
			while(true) {
				var x1 = p++;
				var this2 = -16764160;
				var c = this2;
				if((c >> 24 & 255) < 254 && this1.transparent) {
					var location = this1.useVirtualPos ? (q - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : q * this1.width + x1 | 0;
					var this3 = this1.image[location];
					var this4 = this3;
					var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
					var this6 = this5 >> 24 & 255;
					var a1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this5 >> 16 & 255;
					var r1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this5 >> 8 & 255;
					var g1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this5 & 255;
					var b1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 255;
					var a2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var r2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 51;
					var g2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var b2 = this13 == 0 ? 0. : this13 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this1.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					this1.image[this1.useVirtualPos ? (q - this1.virtualY) * this1.width + x1 - this1.virtualX | 0 : q * this1.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
		var _g = 0;
		var _g1 = 24;
		while(_g < _g1) {
			var i = _g++;
			var y = 100 + i * 100 - 1.25;
			var p = 100;
			var xx = p;
			var q = y | 0;
			var maxX = 100 + w_ | 0;
			var maxY = y + 2.5 | 0;
			while(true) {
				var x = p++;
				var this2 = -16764160;
				var c = this2;
				if((c >> 24 & 255) < 254 && this1.transparent) {
					var location = this1.useVirtualPos ? (q - this1.virtualY) * this1.width + x - this1.virtualX | 0 : q * this1.width + x | 0;
					var this3 = this1.image[location];
					var this4 = this3;
					var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
					var this6 = this5 >> 24 & 255;
					var a1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this5 >> 16 & 255;
					var r1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this5 >> 8 & 255;
					var g1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = this5 & 255;
					var b1 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 255;
					var a2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var r2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 51;
					var g2 = this12 == 0 ? 0. : this12 / 255;
					var this13 = 0;
					var b2 = this13 == 0 ? 0. : this13 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					this1.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					this1.image[this1.useVirtualPos ? (q - this1.virtualY) * this1.width + x - this1.virtualX | 0 : q * this1.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
	}
	,drawAlphaTrianglePink: function(p) {
		var a_0 = 871366848;
		var a_1 = -1712324416;
		var a_2 = -1427111744;
		var a_3 = -856686400;
		var a_4 = -286261056;
		var gap = 200;
		var out = [];
		var ax = 100 + 0 * gap;
		var color = a_0;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + 0 * gap;
		var by = 1200;
		var cx = 500 + 0 * gap;
		var cy = 1000;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 900 * cx - ax * cy;
		var sx = cy - 900;
		var sy = ax - cx;
		var t0 = ax * by - 900 * bx;
		var tx = 900 - by;
		var ty = bx - ax;
		var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(900 > by) {
			if(900 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(900);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 900 > cy ? Math.floor(cy) : Math.ceil(900);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(900);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,900,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		var ax = 100 + gap;
		var color = a_1;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + gap;
		var by = 1200;
		var cx = 500 + gap;
		var cy = 1000;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 900 * cx - ax * cy;
		var sx = cy - 900;
		var sy = ax - cx;
		var t0 = ax * by - 900 * bx;
		var tx = 900 - by;
		var ty = bx - ax;
		var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(900 > by) {
			if(900 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(900);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 900 > cy ? Math.floor(cy) : Math.ceil(900);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(900);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,900,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		var ax = 100 + 2 * gap;
		var color = a_2;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + 2 * gap;
		var by = 1200;
		var cx = 500 + 2 * gap;
		var cy = 1000;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 900 * cx - ax * cy;
		var sx = cy - 900;
		var sy = ax - cx;
		var t0 = ax * by - 900 * bx;
		var tx = 900 - by;
		var ty = bx - ax;
		var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(900 > by) {
			if(900 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(900);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 900 > cy ? Math.floor(cy) : Math.ceil(900);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(900);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,900,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		var ax = 100 + 3 * gap;
		var color = a_3;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + 3 * gap;
		var by = 1200;
		var cx = 500 + 3 * gap;
		var cy = 1000;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 900 * cx - ax * cy;
		var sx = cy - 900;
		var sy = ax - cx;
		var t0 = ax * by - 900 * bx;
		var tx = 900 - by;
		var ty = bx - ax;
		var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(900 > by) {
			if(900 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(900);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 900 > cy ? Math.floor(cy) : Math.ceil(900);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(900);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,900,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		var ax = 100 + 4 * gap;
		var color = a_4;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + 4 * gap;
		var by = 1200;
		var cx = 500 + 4 * gap;
		var cy = 1000;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 900 + (bx * cy - cx * by) + (cx * 900 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 900 * cx - ax * cy;
		var sx = cy - 900;
		var sy = ax - cx;
		var t0 = ax * by - 900 * bx;
		var tx = 900 - by;
		var ty = bx - ax;
		var A = -by * cx + 900 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(900 > by) {
			if(900 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(900);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 900 > cy ? Math.floor(cy) : Math.ceil(900);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(900);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,900,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		return out;
	}
	,drawAlphaTriangleCyan: function(p) {
		var a_0 = 855687408;
		var a_1 = -1728003856;
		var a_2 = -1442791184;
		var a_3 = -872365840;
		var a_4 = -301940496;
		var gap = 200;
		var out = [];
		var ax = 100 + 0 * gap;
		var color = a_0;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + 0 * gap;
		var by = 800;
		var cx = 500 + 0 * gap;
		var cy = 600;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 500 + (bx * cy - cx * by) + (cx * 500 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 500 * cx - ax * cy;
		var sx = cy - 500;
		var sy = ax - cx;
		var t0 = ax * by - 500 * bx;
		var tx = 500 - by;
		var ty = bx - ax;
		var A = -by * cx + 500 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(500 > by) {
			if(500 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(500);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 500 > cy ? Math.floor(cy) : Math.ceil(500);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(500);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,500,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		var ax = 100 + gap;
		var color = a_1;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + gap;
		var by = 800;
		var cx = 500 + gap;
		var cy = 600;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 500 + (bx * cy - cx * by) + (cx * 500 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 500 * cx - ax * cy;
		var sx = cy - 500;
		var sy = ax - cx;
		var t0 = ax * by - 500 * bx;
		var tx = 500 - by;
		var ty = bx - ax;
		var A = -by * cx + 500 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(500 > by) {
			if(500 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(500);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 500 > cy ? Math.floor(cy) : Math.ceil(500);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(500);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,500,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		var ax = 100 + 2 * gap;
		var color = a_2;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + 2 * gap;
		var by = 800;
		var cx = 500 + 2 * gap;
		var cy = 600;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 500 + (bx * cy - cx * by) + (cx * 500 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 500 * cx - ax * cy;
		var sx = cy - 500;
		var sy = ax - cx;
		var t0 = ax * by - 500 * bx;
		var tx = 500 - by;
		var ty = bx - ax;
		var A = -by * cx + 500 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(500 > by) {
			if(500 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(500);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 500 > cy ? Math.floor(cy) : Math.ceil(500);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(500);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,500,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		var ax = 100 + 3 * gap;
		var color = a_3;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + 3 * gap;
		var by = 800;
		var cx = 500 + 3 * gap;
		var cy = 600;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 500 + (bx * cy - cx * by) + (cx * 500 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 500 * cx - ax * cy;
		var sx = cy - 500;
		var sy = ax - cx;
		var t0 = ax * by - 500 * bx;
		var tx = 500 - by;
		var ty = bx - ax;
		var A = -by * cx + 500 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(500 > by) {
			if(500 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(500);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 500 > cy ? Math.floor(cy) : Math.ceil(500);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(500);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,500,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		var ax = 100 + 4 * gap;
		var color = a_4;
		var hasHit = true;
		var hasUndo = true;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var bx = 300 + 4 * gap;
		var by = 800;
		var cx = 500 + 4 * gap;
		var cy = 600;
		var hasHit1 = hasHit;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by - bx * 500 + (bx * cy - cx * by) + (cx * 500 - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var hasHit = hasHit1;
		var hasUndo = hasUndo1;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = 500 * cx - ax * cy;
		var sx = cy - 500;
		var sy = ax - cx;
		var t0 = ax * by - 500 * bx;
		var tx = 500 - by;
		var ty = bx - ax;
		var A = -by * cx + 500 * (-bx + cx) + ax * (by - cy) + bx * cy;
		var xIter3;
		if(ax > bx) {
			if(ax > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx > cx) {
			var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
			var ii_max = Math.ceil(bx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(500 > by) {
			if(500 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
				var ii_max = Math.ceil(500);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by > cy) {
			var ii_min = 500 > cy ? Math.floor(cy) : Math.ceil(500);
			var ii_max = Math.ceil(by);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(500);
			var ii_max = Math.ceil(cy);
			var this1 = new pixelimage_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = p.image[p.useVirtualPos ? (dy - p.virtualY) * p.width + dx - p.virtualX | 0 : dy * p.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(p.useMask && p.mask != null) {
						var this1 = p.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && p.transparent) {
						var location = p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0;
						var this2 = p.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						p.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						p.image[p.useVirtualPos ? (y - p.virtualY) * p.width + x - p.virtualX | 0 : y * p.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var tmp;
		if(hasHit == true) {
			var v = new pixelimage_algo_HitTri(ax,500,bx,by,cx,cy,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			tmp = v;
		} else {
			tmp = null;
		}
		out.push(tmp);
		return out;
	}
};
function pixelimage_$samples_pixelimage_$canvas_UndoTriangles_main() {
	new pixelimage_$samples_pixelimage_$canvas_UndoTriangles();
}
var vision_ds_Line2D = function(start,end) {
	this.end = new vision_ds_Point2D(0,0);
	this.start = new vision_ds_Point2D(0,0);
	this.start.x = start.x;
	this.start.y = start.y;
	this.end.x = end.x;
	this.end.y = end.y;
	var x = end.x - start.x;
	var y = end.y - start.y;
	this.radians = Math.atan2(x,y);
	this.slope = Math.tan(this.radians);
	this.degrees = this.radians * 180 / Math.PI;
};
vision_ds_Line2D.__name__ = true;
vision_ds_Line2D.prototype = {
	toString: function() {
		return "\n (" + Std.string(this.start) + ".x, " + Std.string(this.start) + ".y) --> (" + Std.string(this.end) + ".x, " + Std.string(this.end) + ".y)";
	}
};
var vision_ds_Point2D = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
vision_ds_Point2D.__name__ = true;
vision_ds_Point2D.prototype = {
	toString: function() {
		return "(" + this.x + ", " + this.y + ")";
	}
};
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
var pixelimage_Endian_isLittleEndian = (function($this) {
	var $r;
	var a8 = new Uint8Array(4);
	var a32 = new Uint32Array(a8.buffer)[0] = -3407855;
	$r = a8[0] != 255;
	return $r;
}(this));
pixelimage_$samples_pixelimage_$canvas_UndoTriangles_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
